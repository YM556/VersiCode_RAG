{
    "data": [
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-04-09",
            "description": "The code is used to preprocess and augment a training dataset by converting images to floating point, flipping them horizontally, adjusting the contrast randomly, shuffling the dataset, creating batches of 64 samples, and repeating the process.",
            "code": "train = train.map(\n    lambda image, label: (tf.image.convert_image_dtype(image, tf.float32), label)\n).cache().map(\n    lambda image, label: (tf.image.random_flip_left_right(image), label)\n).map(\n    lambda image, label: (tf.image.random_contrast(image, lower=0.0, upper=1.0), label)\n).shuffle(\n    100\n).batch(\n    64\n).repeat()",
            "masked_code": "train = train.map(\n    lambda image, label: (tf.image.convert_image_dtype(image, tf.float32), label)\n).cache().map(\n    lambda image, label: (tf.image.random_flip_left_right(image), label)\n).map(\n    <line_mask>\n).shuffle(\n    100\n).batch(\n    64\n).repeat()",
            "masked_line": "lambda image, label: (tf.image.random_contrast(image, lower=0.0, upper=1.0), label)",
            "answer": "image",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1",
            "model_output": "['<start>lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)<end>', '<start>lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)<end>', '<start>lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)<end>', '<start>lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)<end>', '<start>lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)<end>', '<start>lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)<end>']",
            "model_output_token_clear": "['lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)', 'lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)', 'lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)', 'lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)', 'lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)', 'lambda image, label: (tf.image.random_contrast(image, lower=0.6, upper=1.4), label)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-04-09",
            "description": "The code doubles the \"element\" and creates a list of images containing the first image from each element. It then checks if the first two images are the same using TensorFlow operations.",
            "code": "element = element.repeat(2)\n# You can iterate through tf.data.Dataset now, finally...\nimages = [image[0] for image in element]\nprint(f\"Are the same: {tf.reduce_all(tf.equal(images[0], images[1]))}\")",
            "masked_code": "element = element.repeat(2)\n# You can iterate through tf.data.Dataset now, finally...\nimages = [image[0] for image in element]\n<line_mask>",
            "masked_line": "print(f\"Are the same: {tf.reduce_all(tf.equal(images[0], images[1]))}\")",
            "answer": "reduce_all",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_2",
            "model_output": "['<start>images = [image[0].numpy() for image in element]<end>', '<start>images = [image[0].numpy() for image in element]<end>', '<start>images = [image[0].numpy() for image in element]<end>', '<start>images = [tf.equal(images[0], image) for image in images] <end>', '<start>images = [tf.equal(images[0], image)[0] for image in images[1:]]<end>', '<start>images = tf.stack([image[0] for image in element])<end>']",
            "model_output_token_clear": "['images = [image[0].numpy() for image in element]', 'images = [image[0].numpy() for image in element]', 'images = [image[0].numpy() for image in element]', 'images = [tf.equal(images[0], image) for image in images] ', 'images = [tf.equal(images[0], image)[0] for image in images[1:]]', 'images = tf.stack([image[0] for image in element])']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-10-30",
            "description": "The code initializes a TensorFlow session in compatibility mode.",
            "code": "import tensorflow as tf\n\ntf.compat.v1.Session()",
            "masked_code": "import tensorflow as tf\n\n<line_mask>",
            "masked_line": "tf.compat.v1.Session()",
            "answer": "compat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_3",
            "model_output": "['<start>sess = tf.compat.v1.Session()<end>', '<start>tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>']",
            "model_output_token_clear": "['sess = tf.compat.v1.Session()', 'tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-04-18",
            "description": "The code defines a class \"ExampleAugmentation\" that takes in parameters such as log directory, maximum number of images, and a name. The class has a method \"__call__\" that applies random flip left-right and up-down augmentation to an input image and writes the augmented image to a TensorBoard file. The method also increments a counter for each augmentation applied and returns the augmented image along with the label.",
            "code": "import tensorflow as tf\n\nclass ExampleAugmentation:\n    def __init__(self, logdir: str, max_images: int, name: str):\n        self.file_writer = tf.summary.create_file_writer(logdir)\n        self.max_images: int = max_images\n        self.name: str = name\n        self._counter: int = 0\n\n    def __call__(self, image, label):\n        augmented_image = tf.image.random_flip_left_right(\n            tf.image.random_flip_up_down(image)\n        )\n        with self.file_writer.as_default():\n            tf.summary.image(\n                self.name,\n                augmented_image,\n                step=self._counter,\n                max_outputs=self.max_images,\n            )\n\n        self._counter += 1\n        return augmented_image, label",
            "masked_code": "import tensorflow as tf\n\nclass ExampleAugmentation:\n    def __init__(self, logdir: str, max_images: int, name: str):\n        self.file_writer = tf.summary.create_file_writer(logdir)\n        self.max_images: int = max_images\n        self.name: str = name\n        self._counter: int = 0\n\n    def __call__(self, image, label):\n        augmented_image = tf.image.random_flip_left_right(\n            tf.image.random_flip_up_down(image)\n        )\n        <line_mask>\n            tf.summary.image(\n                self.name,\n                augmented_image,\n                step=self._counter,\n                max_outputs=self.max_images,\n            )\n\n        self._counter += 1\n        return augmented_image, label",
            "masked_line": "with self.file_writer.as_default():",
            "answer": "file_writer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_4",
            "model_output": "['<start>aumented_image = tf.cast(augmented_image, tf.uint8)<end>', '<start>tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images)<end>', '<start>tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images,)<end>', '<start>tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images)<end>', '<start>aumented_image = tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images,)<end>', '<start>augmented_image = tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images)<end>']",
            "model_output_token_clear": "['aumented_image = tf.cast(augmented_image, tf.uint8)', 'tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images)', 'tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images,)', 'tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images)', 'aumented_image = tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images,)', 'augmented_image = tf.summary.image(self.name, augmented_image, step=self._counter, max_outputs=self.max_images)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-04-18",
            "description": "The code preprocesses and augments a dataset of images by converting the image data type to float32, batching the data, applying data augmentation, and repeating the process for a specified number of epochs.",
            "code": "dataset = (\n    dataset.map(\n        lambda image, label: (\n            tf.image.convert_image_dtype(image, dtype=tf.float32),\n            label,\n        )\n    )\n    .batch(BATCH_SIZE)\n    .map(AUGMENTATION)\n    .repeat(EPOCHS)\n)",
            "masked_code": "dataset = (\n    dataset.map(\n        lambda image, label: (\n            <line_mask>\n            label,\n        )\n    )\n    .batch(BATCH_SIZE)\n    .map(AUGMENTATION)\n    .repeat(EPOCHS)\n)",
            "masked_line": "tf.image.convert_image_dtype(image, dtype=tf.float32),",
            "answer": "convert_image_dtype",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_5",
            "model_output": "['<start>tf.io.read_file(image), tf.io.read_file(label)<end>', '<start>tf.cast(image / 255., tf.float32),<end>', '<start>tf.cast(image / 255., dtype=tf.float32),<end>', '<start>tf.cast(image / 255.0, dtype=tf.float32),<end>', '<start>tf.io.read_file(image), tf.io.read_file(label)<end>', '<start>tf.cast(image / 255., dtype=tf.float32),<end>']",
            "model_output_token_clear": "['tf.io.read_file(image), tf.io.read_file(label)', 'tf.cast(image / 255., tf.float32),', 'tf.cast(image / 255., dtype=tf.float32),', 'tf.cast(image / 255.0, dtype=tf.float32),', 'tf.io.read_file(image), tf.io.read_file(label)', 'tf.cast(image / 255., dtype=tf.float32),']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-30",
            "description": "This code defines a class `manyVariables` that creates and manages multiple TensorFlow variables. It generates a list of 100 variables with normal random values, another list of 10 variables with normal random values, and creates a TensorFlow checkpoint. The class also includes methods to save the variables to a checkpoint file and restore variables from a checkpoint file. Finally, the code demonstrates creating instances of the `manyVariables` class, assigning values to the variables, saving the variables to a file, and restoring them from the file.",
            "code": "import tensorflow as tf\n\nclass manyVariables:\n    def __init__(self):\n        self.initList = [None]*100\n        for i in range(100):\n            self.initList[i] = tf.Variable(tf.random.normal([5,5]))\n        self.makeSomeMoreVariables()\n        self.ckpt = self.makeCheckpoint()\n\n    def makeSomeMoreVariables(self):\n        self.moreList = [None]*10\n        for i in range(10):\n            self.moreList[i] = tf.Variable(tf.random.normal([3,3]))\n\n    def makeCheckpoint(self):\n        return tf.train.Checkpoint(\n            init3=self.initList[3], init55=self.initList[55],\n            init60=self.initList[60], more4=self.moreList[4])\n\n    def saveVariables(self):\n        self.ckpt.save('./ckpt')\n\n    def restoreVariables(self):\n        status = self.ckpt.restore(tf.train.latest_checkpoint('.'))\n        status.assert_consumed()  # Optional check\n\n# Create variables\nv1 = manyVariables()\n# Assigned fixed values\nfor i, v in enumerate(v1.initList):\n    v.assign(i * tf.ones_like(v))\nfor i, v in enumerate(v1.moreList):\n    v.assign(100 + i * tf.ones_like(v))\n# Save them\nv1.saveVariables()\n\n# Create new variables\nv2 = manyVariables()\n# Check initial values\nprint(v2.initList[2].numpy())\n# [[-1.9110833   0.05956204 -1.1753829  -0.3572553  -0.95049495]\n#  [ 0.31409055  1.1262076   0.47890127 -0.1699607   0.4409122 ]\n#  [-0.75385517 -0.13847834  0.97012395  0.42515194 -1.4371008 ]\n#  [ 0.44205236  0.86158335  0.6919655  -2.5156968   0.16496429]\n#  [-1.241602   -0.15177743  0.5603795  -0.3560254  -0.18536267]]\nprint(v2.initList[3].numpy())\n# [[-3.3441594  -0.18425298 -0.4898144  -1.2330629   0.08798431]\n#  [ 1.5002227   0.99475247  0.7817361   0.3849587  -0.59548247]\n#  [-0.57121766 -1.277224    0.6957546  -0.67618763  0.0510064 ]\n#  [ 0.85491985  0.13310803 -0.93152267  0.10205163  0.57520276]\n#  [-1.0606447  -0.16966362 -1.0448577   0.56799036 -0.90726566]]\n\n# Restore them\nv2.restoreVariables()\n# Check values after restoring\nprint(v2.initList[2].numpy())\n# [[-1.9110833   0.05956204 -1.1753829  -0.3572553  -0.95049495]\n#  [ 0.31409055  1.1262076   0.47890127 -0.1699607   0.4409122 ]\n#  [-0.75385517 -0.13847834  0.97012395  0.42515194 -1.4371008 ]\n#  [ 0.44205236  0.86158335  0.6919655  -2.5156968   0.16496429]\n#  [-1.241602   -0.15177743  0.5603795  -0.3560254  -0.18536267]]\nprint(v2.initList[3].numpy())\n# [[3. 3. 3. 3. 3.]\n#  [3. 3. 3. 3. 3.]\n#  [3. 3. 3. 3. 3.]\n#  [3. 3. 3. 3. 3.]\n#  [3. 3. 3. 3. 3.]]",
            "masked_code": "import tensorflow as tf\n\nclass manyVariables:\n    def __init__(self):\n        self.initList = [None]*100\n        for i in range(100):\n            <line_mask>\n        self.makeSomeMoreVariables()\n        self.ckpt = self.makeCheckpoint()\n\n    def makeSomeMoreVariables(self):\n        self.moreList = [None]*10\n        for i in range(10):\n            self.moreList[i] = tf.Variable(tf.random.normal([3,3]))\n\n    def makeCheckpoint(self):\n        return tf.train.Checkpoint(\n            init3=self.initList[3], init55=self.initList[55],\n            init60=self.initList[60], more4=self.moreList[4])\n\n    def saveVariables(self):\n        self.ckpt.save('./ckpt')\n\n    def restoreVariables(self):\n        status = self.ckpt.restore(tf.train.latest_checkpoint('.'))\n        status.assert_consumed()  # Optional check\n\n# Create variables\nv1 = manyVariables()\n# Assigned fixed values\nfor i, v in enumerate(v1.initList):\n    v.assign(i * tf.ones_like(v))\nfor i, v in enumerate(v1.moreList):\n    v.assign(100 + i * tf.ones_like(v))\n# Save them\nv1.saveVariables()\n\n# Create new variables\nv2 = manyVariables()\n# Check initial values\nprint(v2.initList[2].numpy())\n# [[-1.9110833   0.05956204 -1.1753829  -0.3572553  -0.95049495]\n#  [ 0.31409055  1.1262076   0.47890127 -0.1699607   0.4409122 ]\n#  [-0.75385517 -0.13847834  0.97012395  0.42515194 -1.4371008 ]\n#  [ 0.44205236  0.86158335  0.6919655  -2.5156968   0.16496429]\n#  [-1.241602   -0.15177743  0.5603795  -0.3560254  -0.18536267]]\nprint(v2.initList[3].numpy())\n# [[-3.3441594  -0.18425298 -0.4898144  -1.2330629   0.08798431]\n#  [ 1.5002227   0.99475247  0.7817361   0.3849587  -0.59548247]\n#  [-0.57121766 -1.277224    0.6957546  -0.67618763  0.0510064 ]\n#  [ 0.85491985  0.13310803 -0.93152267  0.10205163  0.57520276]\n#  [-1.0606447  -0.16966362 -1.0448577   0.56799036 -0.90726566]]\n\n# Restore them\nv2.restoreVariables()\n# Check values after restoring\nprint(v2.initList[2].numpy())\n# [[-1.9110833   0.05956204 -1.1753829  -0.3572553  -0.95049495]\n#  [ 0.31409055  1.1262076   0.47890127 -0.1699607   0.4409122 ]\n#  [-0.75385517 -0.13847834  0.97012395  0.42515194 -1.4371008 ]\n#  [ 0.44205236  0.86158335  0.6919655  -2.5156968   0.16496429]\n#  [-1.241602   -0.15177743  0.5603795  -0.3560254  -0.18536267]]\nprint(v2.initList[3].numpy())\n# [[3. 3. 3. 3. 3.]\n#  [3. 3. 3. 3. 3.]\n#  [3. 3. 3. 3. 3.]\n#  [3. 3. 3. 3. 3.]\n#  [3. 3. 3. 3. 3.]]",
            "masked_line": "self.initList[i] = tf.Variable(tf.random.normal([5,5]))",
            "answer": "normal",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_6",
            "model_output": "['<start>self.initList[i] = tf.Variable(tf.random.normal([5,5]))<end>', '<start>self.initList[i] = tf.Variable(tf.random.normal([5,5]))<end>', '<start>self.initList[i] = tf.Variable(tf.random.normal([5,5]))<end>', '<start>self.initList[i] = tf.Variable(tf.random.normal([5,5]))<end>', '<start>self.initList[i] = tf.Variable(tf.random.normal([5,5]))<end>', '<start>self.initList[i] = tf.Variable(tf.random.normal([5,5]))<end>']",
            "model_output_token_clear": "['self.initList[i] = tf.Variable(tf.random.normal([5,5]))', 'self.initList[i] = tf.Variable(tf.random.normal([5,5]))', 'self.initList[i] = tf.Variable(tf.random.normal([5,5]))', 'self.initList[i] = tf.Variable(tf.random.normal([5,5]))', 'self.initList[i] = tf.Variable(tf.random.normal([5,5]))', 'self.initList[i] = tf.Variable(tf.random.normal([5,5]))']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-30",
            "description": "The function creates a TensorFlow checkpoint object with initialized variables from initList and additional variables from moreList.",
            "code": "def makeCheckpoint(self):\n    return tf.train.Checkpoint(\n        **{f'init{i}': v for i, v in enumerate(self.initList)},\n        **{f'more{i}': v for i, v in enumerate(self.moreList)})",
            "masked_code": "def makeCheckpoint(self):\n    <line_mask>\n        **{f'init{i}': v for i, v in enumerate(self.initList)},\n        **{f'more{i}': v for i, v in enumerate(self.moreList)})",
            "masked_line": "return tf.train.Checkpoint(",
            "answer": "train",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_7",
            "model_output": "[\"<start>self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})<end>\", \"<start>self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})<end>\", \"<start>self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})<end>\", \"<start>self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})<end>\", \"<start>self.checkpoint = tf.train.Checkpoint(init=tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}), more=tf.train.Checkpoint(**{f'more{i}': v for i, v in enumerate(self.moreList)}))<end>\", \"<start>self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})<end>\"]",
            "model_output_token_clear": "[\"self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})\", \"self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})\", \"self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})\", \"self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})\", \"self.checkpoint = tf.train.Checkpoint(init=tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}), more=tf.train.Checkpoint(**{f'more{i}': v for i, v in enumerate(self.moreList)}))\", \"self.checkpoint = tf.train.Checkpoint(**{f'init{i}': v for i, v in enumerate(self.initList)}, **{f'more{i}': v for i, v in enumerate(self.moreList)})\"]"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-30",
            "description": "This function creates a TensorFlow checkpoint object with variables from a provided list, where each variable is assigned a name in the format 'item{i}'.",
            "code": "def listCheckpoint(varList):\n    # Use 'item{}'.format(i) if using Python <3.6\n    return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})",
            "masked_code": "def listCheckpoint(varList):\n    # Use 'item{}'.format(i) if using Python <3.6\n    <line_mask>",
            "masked_line": "return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})",
            "answer": "Checkpoint",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_8",
            "model_output": "[\"<start>return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})<end>\", \"<start>return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})<end>\", \"<start>return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})<end>\", \"<start>return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})<end>\", \"<start>return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})<end>\", \"<start>return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})<end>\"]",
            "model_output_token_clear": "[\"return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})\", \"return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})\", \"return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})\", \"return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})\", \"return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})\", \"return tf.train.Checkpoint(**{f'item{i}': v for i, v in enumerate(varList)})\"]"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-30",
            "description": "This code defines a method called \"makeCheckpoint\" that creates a TensorFlow checkpoint with two lists as initializers (\"initList\" and \"moreList\").",
            "code": "def makeCheckpoint(self):\n    return tf.train.Checkpoint(init=listCheckpoint(self.initList),\n                               more=listCheckpoint(self.moreList))",
            "masked_code": "def makeCheckpoint(self):\n    <line_mask>\n                               more=listCheckpoint(self.moreList))",
            "masked_line": "return tf.train.Checkpoint(init=listCheckpoint(self.initList),",
            "answer": "Checkpoint",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_9",
            "model_output": "['<start>ckpt = tf.train.Checkpoint(step=tf.Variable(1), initList=tf.Variable(self.initList), more=moreList)<end>', '<start>ckpt = tf.train.Checkpoint(step=tf.Variable(1), initList=tf.Variable(self.initList), more=listCheckpoint(self.moreList))<end>', '<start>ckpt = tf.train.Checkpoint(step=tf.Variable(1), initList=tf.Variable(self.initList), moreList=tf.Variable(self.moreList))<end>', '<start>ckpt = tf.train.Checkpoint(step=tf.Variable(1), optimizer=optimizer, initList=tf.Variable(self.initList), more=moreList)<end>', '<start>ckpt = tf.train.Checkpoint(step=tf.Variable(1), initList=tf.Variable(self.initList), more=moreList)<end>', '<start>ckpt = tf.train.Checkpoint(step=tf.Variable(1),initList=tf.Variable(self.initList),more=moreList)<end>']",
            "model_output_token_clear": "['ckpt = tf.train.Checkpoint(step=tf.Variable(1), initList=tf.Variable(self.initList), more=moreList)', 'ckpt = tf.train.Checkpoint(step=tf.Variable(1), initList=tf.Variable(self.initList), more=listCheckpoint(self.moreList))', 'ckpt = tf.train.Checkpoint(step=tf.Variable(1), initList=tf.Variable(self.initList), moreList=tf.Variable(self.moreList))', 'ckpt = tf.train.Checkpoint(step=tf.Variable(1), optimizer=optimizer, initList=tf.Variable(self.initList), more=moreList)', 'ckpt = tf.train.Checkpoint(step=tf.Variable(1), initList=tf.Variable(self.initList), more=moreList)', 'ckpt = tf.train.Checkpoint(step=tf.Variable(1),initList=tf.Variable(self.initList),more=moreList)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-19",
            "description": "The code creates a TensorFlow session using the tf.compat.v1.Session() function.",
            "code": "sess = tf.compat.v1.Session()",
            "masked_code": "<line_mask>",
            "masked_line": "sess = tf.compat.v1.Session()",
            "answer": "Session",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_10",
            "model_output": "['<start>sess = tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>', '<start>sess = tf.compat.v1.Session()<end>']",
            "model_output_token_clear": "['sess = tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()', 'sess = tf.compat.v1.Session()']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-19",
            "description": "The code defines a TensorFlow function named f1 that takes two input parameters x1 and y1, and returns their sum using the TensorFlow mathematical add function. It then calls this function with two constant tensors (3.0 and 4.5), and prints the result of adding these two values.",
            "code": "@tf.function\ndef f1(x1, y1):\n    return tf.math.add(x1, y1)\n\nprint(f1(tf.constant(3.0), tf.constant(4.5)))",
            "masked_code": "<line_mask>\ndef f1(x1, y1):\n    return tf.math.add(x1, y1)\n\nprint(f1(tf.constant(3.0), tf.constant(4.5)))",
            "masked_line": "@tf.function",
            "answer": "function",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_11",
            "model_output": "['<start>@tf.function<end>', '<start>@tf.function<end>', '<start>@tf.function def f1(x1, y1):<end>', '<start>@tf.function<end>', '<start>@tf.function def f1(x1, y1):<end>', '<start>@tf.function def f1(x1, y1):<end>']",
            "model_output_token_clear": "['@tf.function', '@tf.function', '@tf.function def f1(x1, y1):', '@tf.function', '@tf.function def f1(x1, y1):', '@tf.function def f1(x1, y1):']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-08-30",
            "description": "The code disables eager execution in TensorFlow.",
            "code": "tf.compat.v1.disable_eager_execution()",
            "masked_code": "<line_mask>",
            "masked_line": "tf.compat.v1.disable_eager_execution()",
            "answer": "disable_eager_execution",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_12",
            "model_output": "['<start>tf.compat.v1.disable_eager_execution()<end>', '<start>tf.compat.v1.disable_eager_execution()<end>', '<start>tf.compat.v1.disable_eager_execution()<end>', '<start>tf.compat.v1.disable_eager_execution()<end>', '<start>tf.compat.v1.disable_eager_execution()<end>', '<start>tf.compat.v1.disable_eager_execution()<end>']",
            "model_output_token_clear": "['tf.compat.v1.disable_eager_execution()', 'tf.compat.v1.disable_eager_execution()', 'tf.compat.v1.disable_eager_execution()', 'tf.compat.v1.disable_eager_execution()', 'tf.compat.v1.disable_eager_execution()', 'tf.compat.v1.disable_eager_execution()']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-08-30",
            "description": "The code loads a machine learning model trained in TensorFlow to classify images into z-pattern and non z-pattern categories. It then loads an image, preprocesses it, and feeds it into the model to make a prediction. Finally, it checks the model's prediction confidence to determine if it is a z-pattern or not and prints out the result along with the time taken for the entire process.",
            "code": "import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nimport matplotlib.pyplot as plt\nimport numpy as np \nfrom tensorflow.keras.preprocessing import image\nimport time\n\ntstart = time.time()\nreconstructed_model = keras.models.load_model(\"my_model2\")\n\ntf.compat.v1.disable_eager_execution()\nimage = image.load_img(\"testimages/1404.jpg\", target_size = (28, 28))\n# image.show()\ninput_arr = keras.preprocessing.image.img_to_array(image)\ninput_arr = np.array([input_arr])  # Convert single image to a batch.\nresult = reconstructed_model.predict(input_arr)\n\nprint(result)\nprint(result[0][0])\nprint(result[0][1])\n# training_set.class_indices\nif result[0][1] > 0.9:\n    prediction = 'This is a z-pattern'\nelse:\n    prediction = 'This is not a z-pattern'\nprint(prediction)\nprint ('display FPS:' , (time.time()-tstart)*1000 , \"msec\")",
            "masked_code": "import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\nimport matplotlib.pyplot as plt\nimport numpy as np \nfrom tensorflow.keras.preprocessing import image\nimport time\n\ntstart = time.time()\nreconstructed_model = keras.models.load_model(\"my_model2\")\n\n<line_mask>\nimage = image.load_img(\"testimages/1404.jpg\", target_size = (28, 28))\n# image.show()\ninput_arr = keras.preprocessing.image.img_to_array(image)\ninput_arr = np.array([input_arr])  # Convert single image to a batch.\nresult = reconstructed_model.predict(input_arr)\n\nprint(result)\nprint(result[0][0])\nprint(result[0][1])\n# training_set.class_indices\nif result[0][1] > 0.9:\n    prediction = 'This is a z-pattern'\nelse:\n    prediction = 'This is not a z-pattern'\nprint(prediction)\nprint ('display FPS:' , (time.time()-tstart)*1000 , \"msec\")",
            "masked_line": "tf.compat.v1.disable_eager_execution()",
            "answer": "v1",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_13",
            "model_output": "['<start>reconstructed_model.summary()<end>', '<start>reconstructed_model.summary()<end>', '<start>reconstructed_model.summary()<end>', '<start>reconstructed_model.summary()<end>', '<start>reconstructed_model.make_predict_function()<end>', '<start>reconstructed_model.make_predict_function()<end>']",
            "model_output_token_clear": "['reconstructed_model.summary()', 'reconstructed_model.summary()', 'reconstructed_model.summary()', 'reconstructed_model.summary()', 'reconstructed_model.make_predict_function()', 'reconstructed_model.make_predict_function()']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2021-08-26",
            "description": "The code creates a sparse tensor with negative infinity values at specified indices and then converts it to a dense tensor.",
            "code": "import tensorflow as tf\n\n#there are same values in the tensor\nskip_ids = tf.constant([[0], [0]], dtype=tf.int64)\n\nsparse_mask = tf.SparseTensor(\n    # Put a -inf at each bad index.\n    values=[-float('inf')] * len(skip_ids),\n    indices=skip_ids,\n    # Match the shape to the vocabulary\n    dense_shape=[76])\nprint(sparse_mask)\n\nprediction_mask = tf.sparse.to_dense(sparse_mask)",
            "masked_code": "import tensorflow as tf\n\n#there are same values in the tensor\nskip_ids = tf.constant([[0], [0]], dtype=tf.int64)\n\nsparse_mask = tf.SparseTensor(\n    # Put a -inf at each bad index.\n    values=[-float('inf')] * len(skip_ids),\n    indices=skip_ids,\n    # Match the shape to the vocabulary\n    dense_shape=[76])\nprint(sparse_mask)\n\n<line_mask>",
            "masked_line": "prediction_mask = tf.sparse.to_dense(sparse_mask)",
            "answer": "sparse",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_14",
            "model_output": "['<start>dense_mask = tf.sparse.to_dense(sparse_mask)<end>', '<start>dense_mask = tf.sparse.to_dense(sparse_mask)<end>', '<start>dense_mask = tf.sparse.to_dense(sparse_mask)<end>', '<start>dense_mask = tf.sparse.to_dense(sparse_mask)<end>', '<start>mask_dense = tf.sparse.to_dense(sparse_mask)<end>', '<start>dense_mask = tf.sparse.to_dense(sparse_mask)<end>']",
            "model_output_token_clear": "['dense_mask = tf.sparse.to_dense(sparse_mask)', 'dense_mask = tf.sparse.to_dense(sparse_mask)', 'dense_mask = tf.sparse.to_dense(sparse_mask)', 'dense_mask = tf.sparse.to_dense(sparse_mask)', 'mask_dense = tf.sparse.to_dense(sparse_mask)', 'dense_mask = tf.sparse.to_dense(sparse_mask)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2021-08-26",
            "description": "The code creates a sparse mask for a given set of unique indices by putting -inf at each index and then converts the sparse mask into a dense prediction mask.",
            "code": "import tensorflow as tf\n\nskip_ids = tf.constant([[0], [0]], dtype=tf.int64)\n\n# get unique indices\ntmp1 = tf.reshape(skip_ids, shape=(-1,))\nuniques, idx, counts = tf.unique_with_counts(tmp1)\nuniques_ids = tf.expand_dims(uniques, axis=1)\n\n\nsparse_mask = tf.SparseTensor(\n    # Put a -inf at each bad index.\n    values=[-float('inf')] * len(uniques_ids),\n    indices=uniques_ids,\n    # Match the shape to the vocabulary\n    dense_shape=[76])\nprint(sparse_mask)\n\nprediction_mask = tf.sparse.to_dense(sparse_mask)\n\nprint(prediction_mask)",
            "masked_code": "import tensorflow as tf\n\nskip_ids = tf.constant([[0], [0]], dtype=tf.int64)\n\n# get unique indices\ntmp1 = tf.reshape(skip_ids, shape=(-1,))\nuniques, idx, counts = tf.unique_with_counts(tmp1)\n<line_mask>\n\n\nsparse_mask = tf.SparseTensor(\n    # Put a -inf at each bad index.\n    values=[-float('inf')] * len(uniques_ids),\n    indices=uniques_ids,\n    # Match the shape to the vocabulary\n    dense_shape=[76])\nprint(sparse_mask)\n\nprediction_mask = tf.sparse.to_dense(sparse_mask)\n\nprint(prediction_mask)",
            "masked_line": "uniques_ids = tf.expand_dims(uniques, axis=1)",
            "answer": "expand_dims",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_15",
            "model_output": "['<start>uniques_ids = uniques<end>', '<start>uniques_ids = uniques<end>', '<start>uniques_ids = uniques<end>', '<start>uniques_ids = uniques<end>', '<start>uniques_ids = uniques<end>', '<start>uniques_ids = uniques<end>']",
            "model_output_token_clear": "['uniques_ids = uniques', 'uniques_ids = uniques', 'uniques_ids = uniques', 'uniques_ids = uniques', 'uniques_ids = uniques', 'uniques_ids = uniques']"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.1",
            "time": "2022-12-03",
            "description": "This code creates a pandas DataFrame with a MultiIndex containing hex_name and leaf_name levels. It then inserts a NaN value into the DataFrame at the specified task_path_str location.",
            "code": "import pandas as pd\nimport numpy as np\nhex_name = '123456abc'\nmulti_sub_dir_id_list = [hex_name, hex_name, hex_name]\nmulti_leaf_node_dirs = ['one', 'two', 'three'] \nx_dir_multi_index = pd.MultiIndex.from_arrays ([multi_sub_dir_id_list, multi_leaf_node_dirs], names = ['hex_name', 'leaf_name'])\nleaf_name = 'one'\ndirpath = '/a/string/path'\ntask_path_str = 'thepath'\nmulti_exec_df = pd.DataFrame (data = None, columns = x_dir_multi_index)\nmulti_exec_df.loc[task_path_str] = np.nan",
            "masked_code": "import pandas as pd\nimport numpy as np\nhex_name = '123456abc'\nmulti_sub_dir_id_list = [hex_name, hex_name, hex_name]\nmulti_leaf_node_dirs = ['one', 'two', 'three'] \nx_dir_multi_index = pd.MultiIndex.from_arrays ([multi_sub_dir_id_list, multi_leaf_node_dirs], names = ['hex_name', 'leaf_name'])\nleaf_name = 'one'\ndirpath = '/a/string/path'\ntask_path_str = 'thepath'\n<line_mask>\nmulti_exec_df.loc[task_path_str] = np.nan",
            "masked_line": "multi_exec_df = pd.DataFrame (data = None, columns = x_dir_multi_index)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_16",
            "model_output": "['<start>multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath<end>', '<start>multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath<end>', '<start>multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath<end>', '<start>multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath<end>', '<start>multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath<end>', '<start>multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath<end>']",
            "model_output_token_clear": "['multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath', 'multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath', 'multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath', 'multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath', 'multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath', 'multi_exec_df.loc[task_path_str, (hex_name, leaf_name)] = dirpath']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-12",
            "description": "The code creates a boolean array 'y' with the same shape as 'all_bools', then finds the index of the maximum value along axis 1 for each row in array 'x', and assigns these values from 'x' to the corresponding indices in 'y'.",
            "code": "y = np.zeros_like(all_bools, dtype=bool)\nidx = np.arange(len(x)), x.argmax(axis=1)\ny[idx] = x[idx]\n\ny\narray([[False,  True, False],\n       [ True, False, False],\n       [False, False,  True],\n       [False, False, False]])",
            "masked_code": "y = np.zeros_like(all_bools, dtype=bool)\n<line_mask>\ny[idx] = x[idx]\n\ny\narray([[False,  True, False],\n       [ True, False, False],\n       [False, False,  True],\n       [False, False, False]])",
            "masked_line": "idx = np.arange(len(x)), x.argmax(axis=1)",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_17",
            "model_output": "['<start>idx = np.argmax(x, axis=1)<end>', '<start>idx = np.argmax(x, axis=1); y[np.arange(len(idx))[:,None], idx] = x[np.arange(len(idx))[:,None], idx]<end>', '<start>idx = np.argmax(x, axis=1); y[np.arange(len(x))[:,None], idx] = x[np.arange(len(x))[:,None], idx]<end>', '<start>idx = np.argmax(x, axis=1); y[np.arange(len(x))[:, None], idx] = True<end>', '<start>idx = np.argmax(x, axis=1); y[np.arange(len(x))[:,None], idx] = x[np.arange(len(x))[:,None], idx]<end>', '<start>idx = np.argmax(x, axis=1); y[np.arange(len(x))[:,None], idx] = True<end>']",
            "model_output_token_clear": "['idx = np.argmax(x, axis=1)', 'idx = np.argmax(x, axis=1); y[np.arange(len(idx))[:,None], idx] = x[np.arange(len(idx))[:,None], idx]', 'idx = np.argmax(x, axis=1); y[np.arange(len(x))[:,None], idx] = x[np.arange(len(x))[:,None], idx]', 'idx = np.argmax(x, axis=1); y[np.arange(len(x))[:, None], idx] = True', 'idx = np.argmax(x, axis=1); y[np.arange(len(x))[:,None], idx] = x[np.arange(len(x))[:,None], idx]', 'idx = np.argmax(x, axis=1); y[np.arange(len(x))[:,None], idx] = True']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-12",
            "description": "The code compares three different algorithms for boolean indexing in a numpy array. The three functions (cs1, cs2, and a_guest) perform boolean operations on the input array x and return the result. The perfplot.show function is used to plot the performance of these functions for varying sizes of the input array.",
            "code": "import numpy as np\nimport perfplot\n\ndef cs1(x):\n    return  x.cumsum(axis=1).cumsum(axis=1) == 1 \n\ndef cs2(x):\n    y = np.zeros_like(x, dtype=bool)\n    idx = np.arange(len(x)), x.argmax(axis=1)\n    y[idx] = x[idx]\n    return y\n\ndef a_guest(x):\n    b = np.zeros_like(x, dtype=bool)\n    i = np.argmax(x, axis=1)\n    b[np.arange(i.size), i] = np.logical_or.reduce(x, axis=1)\n    return b\n\nperfplot.show(\n    setup=lambda n: np.random.randint(0, 2, size=(n, n)).astype(bool),\n    kernels=[cs1, cs2, a_guest],\n    labels=['cs1', 'cs2', 'a_guest'],\n    n_range=[2**k for k in range(1, 8)],\n    xlabel='N'\n)",
            "masked_code": "import numpy as np\nimport perfplot\n\ndef cs1(x):\n    return  x.cumsum(axis=1).cumsum(axis=1) == 1 \n\ndef cs2(x):\n    y = np.zeros_like(x, dtype=bool)\n    idx = np.arange(len(x)), x.argmax(axis=1)\n    y[idx] = x[idx]\n    return y\n\ndef a_guest(x):\n    <line_mask>\n    i = np.argmax(x, axis=1)\n    b[np.arange(i.size), i] = np.logical_or.reduce(x, axis=1)\n    return b\n\nperfplot.show(\n    setup=lambda n: np.random.randint(0, 2, size=(n, n)).astype(bool),\n    kernels=[cs1, cs2, a_guest],\n    labels=['cs1', 'cs2', 'a_guest'],\n    n_range=[2**k for k in range(1, 8)],\n    xlabel='N'\n)",
            "masked_line": "b = np.zeros_like(x, dtype=bool)",
            "answer": "zeros_like",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_18",
            "model_output": "['<start>b = np.zeros_like(x, dtype=bool)<end>', '<start>b = np.zeros_like(x)<end>', '<start>b = np.zeros_like(x, dtype=bool)<end>', '<start>b = np.zeros_like(x, dtype=bool)<end>', '<start>b = np.zeros_like(x, dtype=bool)<end>', '<start>b = np.zeros_like(x)<end>']",
            "model_output_token_clear": "['b = np.zeros_like(x, dtype=bool)', 'b = np.zeros_like(x)', 'b = np.zeros_like(x, dtype=bool)', 'b = np.zeros_like(x, dtype=bool)', 'b = np.zeros_like(x, dtype=bool)', 'b = np.zeros_like(x)']"
        },
        {
            "dependency": "pyarrow",
            "version": "==4.0.1",
            "time": "2021-07-16",
            "description": "The code reads a pandas DataFrame, converts it to a PyArrow Table, and then writes the Table to an ORC file format at the specified location '/tmp/your_df.orc'.",
            "code": "import pandas as pd\nimport pyarrow as pa\nimport pyarrow.orc as orc\n\n# Here prepare your pandas df.\n\ntable = pa.Table.from_pandas(df, preserve_index=False)\norc.write_table(table, '/tmp/your_df.orc')",
            "masked_code": "import pandas as pd\nimport pyarrow as pa\nimport pyarrow.orc as orc\n\n# Here prepare your pandas df.\n\n<line_mask>\norc.write_table(table, '/tmp/your_df.orc')",
            "masked_line": "table = pa.Table.from_pandas(df, preserve_index=False)",
            "answer": "Table",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_19",
            "model_output": "['<start>table = pa.Table.from_pandas(df, preserve_index=False)<end>', '<start>table = pa.Table.from_pandas(df, preserve_index=False)<end>', '<start>table = pa.Table.from_pandas(df, preserve_index=False)<end>', '<start>table = pa.Table.from_pandas(df, preserve_index=False)<end>', '<start>table = pa.Table.from_pandas(df, preserve_index=False)<end>', '<start>table = pa.Table.from_pandas(df, preserve_index=False)<end>']",
            "model_output_token_clear": "['table = pa.Table.from_pandas(df, preserve_index=False)', 'table = pa.Table.from_pandas(df, preserve_index=False)', 'table = pa.Table.from_pandas(df, preserve_index=False)', 'table = pa.Table.from_pandas(df, preserve_index=False)', 'table = pa.Table.from_pandas(df, preserve_index=False)', 'table = pa.Table.from_pandas(df, preserve_index=False)']"
        },
        {
            "dependency": "pytest",
            "version": "==4.1.1",
            "time": "2019-01-29",
            "description": "The code defines two fixture functions, input1 and input2, that retrieve the values of command-line options input1 and input2 for pytest tests.",
            "code": "import pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\"--input1\", action=\"store\", default=\"default input1\")\n    parser.addoption(\"--input2\", action=\"store\", default=\"default input2\")\n\n\n\n@pytest.fixture\ndef input1(request):\n    return request.config.getoption(\"--input1\")\n\n\n@pytest.fixture\ndef input2(request):\n    return request.config.getoption(\"--input2\")",
            "masked_code": "import pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\"--input1\", action=\"store\", default=\"default input1\")\n    parser.addoption(\"--input2\", action=\"store\", default=\"default input2\")\n\n\n\n<line_mask>\ndef input1(request):\n    return request.config.getoption(\"--input1\")\n\n\n@pytest.fixture\ndef input2(request):\n    return request.config.getoption(\"--input2\")",
            "masked_line": "@pytest.fixture",
            "answer": "fixture",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_20",
            "model_output": "['<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>']",
            "model_output_token_clear": "['@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture']"
        },
        {
            "dependency": "pytest",
            "version": "==4.1.1",
            "time": "2019-01-29",
            "description": "This code defines a test named \"test_print_name\" with two input parameters. It prints the values of the two input parameters to the console.",
            "code": "import pytest\n\n@pytest.mark.unit\ndef test_print_name(input1, input2):\n    print (\"Displaying input1: %s\" % input1)\n    print(\"Displaying input2: %s\" % input2)",
            "masked_code": "import pytest\n\n<line_mask>\ndef test_print_name(input1, input2):\n    print (\"Displaying input1: %s\" % input1)\n    print(\"Displaying input2: %s\" % input2)",
            "masked_line": "@pytest.mark.unit",
            "answer": "mark",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_21",
            "model_output": "['<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>']",
            "model_output_token_clear": "['@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture']"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-05-22",
            "description": "This code retrieves information about hospitals and schools in Port-au-Prince, Haiti within a certain distance. It then plots the locations of these amenities on a map using Bokeh, with hospitals marked in red and schools marked in blue, and allows the user to toggle the visibility of the legend by clicking on it.",
            "code": "from bokeh.models import ColumnDataSource\nfrom bokeh.plotting import figure, show\nfrom bokeh.tile_providers import CARTODBPOSITRON_RETINA\nimport osmnx as ox\n\namenities = ['hospital', 'school']\nfor i, amenity in enumerate(amenities):\n    buildings = ox.pois_from_address(\"Port-au-Prince, Haiti\", amenities = [amenity], distance = 3500)[['geometry', 'name', 'element_type']]\n    for item in ['way', 'relation']:\n        buildings.loc[buildings.element_type == item, 'geometry'] = buildings[buildings.element_type == item]['geometry'].map(lambda x: x.centroid)\n        buildings.name.fillna('Hospital' if i == 0 else 'School', inplace = True)\n        amenities[i] = buildings.to_crs(epsg = 3857)\n\np = figure(title = \"Port-au-Prince, Haiti\", tools = \"pan,wheel_zoom,hover,reset\", x_range = (-8057000, -8048500), y_range = (2098000, 2106000), \n           tooltips = [('Name', '@name'), (\"(Long, Lat)\", \"($x, $y)\")], x_axis_location = None, y_axis_location = None, active_scroll = 'wheel_zoom')\np.add_tile(CARTODBPOSITRON_RETINA)\np.grid.grid_line_color = None\n\nfor i, b in enumerate(amenities):\n    source = ColumnDataSource(data = dict(x = b.geometry.x, y = b.geometry.y, name = b.name.values))\n    p.circle('x', 'y', color = 'red' if i == 0 else 'blue', source = source, legend = 'Hospital' if i == 0 else 'School')\n\np.legend.click_policy = 'hide' \n\nshow(p)",
            "masked_code": "from bokeh.models import ColumnDataSource\nfrom bokeh.plotting import figure, show\nfrom bokeh.tile_providers import CARTODBPOSITRON_RETINA\nimport osmnx as ox\n\namenities = ['hospital', 'school']\nfor i, amenity in enumerate(amenities):\n    buildings = ox.pois_from_address(\"Port-au-Prince, Haiti\", amenities = [amenity], distance = 3500)[['geometry', 'name', 'element_type']]\n    for item in ['way', 'relation']:\n        buildings.loc[buildings.element_type == item, 'geometry'] = buildings[buildings.element_type == item]['geometry'].map(lambda x: x.centroid)\n        buildings.name.fillna('Hospital' if i == 0 else 'School', inplace = True)\n        amenities[i] = buildings.to_crs(epsg = 3857)\n\np = figure(title = \"Port-au-Prince, Haiti\", tools = \"pan,wheel_zoom,hover,reset\", x_range = (-8057000, -8048500), y_range = (2098000, 2106000), \n           tooltips = [('Name', '@name'), (\"(Long, Lat)\", \"($x, $y)\")], x_axis_location = None, y_axis_location = None, active_scroll = 'wheel_zoom')\n<line_mask>\np.grid.grid_line_color = None\n\nfor i, b in enumerate(amenities):\n    source = ColumnDataSource(data = dict(x = b.geometry.x, y = b.geometry.y, name = b.name.values))\n    p.circle('x', 'y', color = 'red' if i == 0 else 'blue', source = source, legend = 'Hospital' if i == 0 else 'School')\n\np.legend.click_policy = 'hide' \n\nshow(p)",
            "masked_line": "p.add_tile(CARTODBPOSITRON_RETINA)",
            "answer": "add_tile",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_22",
            "model_output": "['<start>p.add_tile(CARTODBPOSITRON_RETINA)<end>', '<start>p.add_tile(CARTODBPOSITRON_RETINA)<end>', '<start>p.add_tile(CARTODBPOSITRON_RETINA)<end>', '<start>p.add_tile(CARTODBPOSITRON_RETINA)<end>', '<start>p.add_tile(CARTODBPOSITRON_RETINA)<end>', '<start>p.add_tile(CARTODBPOSITRON_RETINA)<end>']",
            "model_output_token_clear": "['p.add_tile(CARTODBPOSITRON_RETINA)', 'p.add_tile(CARTODBPOSITRON_RETINA)', 'p.add_tile(CARTODBPOSITRON_RETINA)', 'p.add_tile(CARTODBPOSITRON_RETINA)', 'p.add_tile(CARTODBPOSITRON_RETINA)', 'p.add_tile(CARTODBPOSITRON_RETINA)']"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-05-22",
            "description": "The code is creating a visualization using Bokeh library to display hospitals and schools in Port-au-Prince, Haiti. It fetches the location data of hospitals and schools, processes the data to plot them on a map, and creates a selection dropdown menu to switch between viewing hospitals and schools on the map.",
            "code": "from bokeh.models import ColumnDataSource, Column, Select, CustomJS\nfrom bokeh.plotting import figure, show\nfrom bokeh.tile_providers import CARTODBPOSITRON_RETINA\nimport osmnx as ox\n\namenities = ['hospital', 'school']\nfor i, amenity in enumerate(amenities):\n    buildings = ox.pois_from_address(\"Port-au-Prince, Haiti\", amenities = [amenity], distance = 3500)[['geometry', 'name', 'element_type']]\n    for item in ['way', 'relation']:\n        buildings.loc[buildings.element_type == item, 'geometry'] = buildings[buildings.element_type == item]['geometry'].map(lambda x: x.centroid)\n        buildings.name.fillna('Hospital' if i == 0 else 'School', inplace = True)\n        buildings = buildings.to_crs(epsg = 3857)      \n    amenities[i] = dict(x = list(buildings.geometry.x), y = list(buildings.geometry.y), name = list(buildings.name.values), color = (['red'] if i == 0 else ['blue']) * len(buildings.name.values))\n\nsource = ColumnDataSource(amenities[0])\np = figure(title = \"Hospitals\", tools = \"pan,wheel_zoom,hover,reset\", x_range = (-8057000, -8048500), y_range = (2098000, 2106000), \n           tooltips = [('Name', '@name'), (\"(Long, Lat)\", \"($x, $y)\")], x_axis_location = None, y_axis_location = None, active_scroll = 'wheel_zoom')\np.add_tile(CARTODBPOSITRON_RETINA)\np.circle(x = 'x', y = 'y', color = 'color', source = source)\np.grid.grid_line_color = None\n\ncode = '''  source.data = (cb_obj.value == 'Hospitals' ? data[0] : data[1]); p.title.text =  cb_obj.value; '''\nselect = Select(options = ['Hospitals', 'Schools'], callback = CustomJS(args=dict(p = p, source = source, data = amenities), code = code))\n\nshow(Column(p, select))",
            "masked_code": "<line_mask>\nfrom bokeh.plotting import figure, show\nfrom bokeh.tile_providers import CARTODBPOSITRON_RETINA\nimport osmnx as ox\n\namenities = ['hospital', 'school']\nfor i, amenity in enumerate(amenities):\n    buildings = ox.pois_from_address(\"Port-au-Prince, Haiti\", amenities = [amenity], distance = 3500)[['geometry', 'name', 'element_type']]\n    for item in ['way', 'relation']:\n        buildings.loc[buildings.element_type == item, 'geometry'] = buildings[buildings.element_type == item]['geometry'].map(lambda x: x.centroid)\n        buildings.name.fillna('Hospital' if i == 0 else 'School', inplace = True)\n        buildings = buildings.to_crs(epsg = 3857)      \n    amenities[i] = dict(x = list(buildings.geometry.x), y = list(buildings.geometry.y), name = list(buildings.name.values), color = (['red'] if i == 0 else ['blue']) * len(buildings.name.values))\n\nsource = ColumnDataSource(amenities[0])\np = figure(title = \"Hospitals\", tools = \"pan,wheel_zoom,hover,reset\", x_range = (-8057000, -8048500), y_range = (2098000, 2106000), \n           tooltips = [('Name', '@name'), (\"(Long, Lat)\", \"($x, $y)\")], x_axis_location = None, y_axis_location = None, active_scroll = 'wheel_zoom')\np.add_tile(CARTODBPOSITRON_RETINA)\np.circle(x = 'x', y = 'y', color = 'color', source = source)\np.grid.grid_line_color = None\n\ncode = '''  source.data = (cb_obj.value == 'Hospitals' ? data[0] : data[1]); p.title.text =  cb_obj.value; '''\nselect = Select(options = ['Hospitals', 'Schools'], callback = CustomJS(args=dict(p = p, source = source, data = amenities), code = code))\n\nshow(Column(p, select))",
            "masked_line": "from bokeh.models import ColumnDataSource, Column, Select, CustomJS",
            "answer": "ColumnDataSource",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_23",
            "model_output": "[\"<start>data[0] if cb_obj.value == 'Hospitals' else data[1]<end>\", \"<start>data[0] if cb_obj.value == 'Hospitals' else data[1]<end>\", \"<start>data[0] if cb_obj.value == 'Hospitals' else data[1]<end>\", \"<start>data[i] = dict(x=list(buildings.geometry.x), y=list(buildings.geometry.y), name=list(buildings.name.values), color=(['red'] if i == 0 else ['blue'])*len(buildings.name.values))<end>\", \"<start>data[0] if cb_obj.value == 'Hospitals' else data[1]<end>\", \"<start>data[0] if cb_obj.value == 'Hospitals' else data[1]<end>\"]",
            "model_output_token_clear": "[\"data[0] if cb_obj.value == 'Hospitals' else data[1]\", \"data[0] if cb_obj.value == 'Hospitals' else data[1]\", \"data[0] if cb_obj.value == 'Hospitals' else data[1]\", \"data[i] = dict(x=list(buildings.geometry.x), y=list(buildings.geometry.y), name=list(buildings.name.values), color=(['red'] if i == 0 else ['blue'])*len(buildings.name.values))\", \"data[0] if cb_obj.value == 'Hospitals' else data[1]\", \"data[0] if cb_obj.value == 'Hospitals' else data[1]\"]"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-11-07",
            "description": "The code loads an image from a specified file path, encodes the image as a JPEG, prepares the image bytes for inference, loads a TensorFlow saved model from a directory, performs inference using the loaded model on the prepared image bytes, and returns the output.",
            "code": "import cv2\ncv2.imread(filepath)\nflag, bts = cv.imencode('.jpg', img)\ninp = [bts[:,0].tobytes()]\nsaved_model_dir = '.'\nloaded = tf.saved_model.load(export_dir=saved_model_dir)\ninfer = loaded.signatures[\"serving_default\"]\nout = infer(key=tf.constant('something_unique'), image_bytes=tf.constant(inp))",
            "masked_code": "import cv2\ncv2.imread(filepath)\nflag, bts = cv.imencode('.jpg', img)\ninp = [bts[:,0].tobytes()]\nsaved_model_dir = '.'\n<line_mask>\ninfer = loaded.signatures[\"serving_default\"]\nout = infer(key=tf.constant('something_unique'), image_bytes=tf.constant(inp))",
            "masked_line": "loaded = tf.saved_model.load(export_dir=saved_model_dir)",
            "answer": "saved_model",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_24",
            "model_output": "['<start>loaded = tf.saved_model.load(saved_model_dir)<end>', '<start>loaded = tf.saved_model.load(saved_model_dir)<end>', '<start>loaded = tf.saved_model.load(saved_model_dir)<end>', '<start>loaded = tf.saved_model.load(saved_model_dir)<end>', '<start>loaded = tf.saved_model.load(saved_model_dir)<end>', '<start>loaded = tf.saved_model.load(saved_model_dir)<end>']",
            "model_output_token_clear": "['loaded = tf.saved_model.load(saved_model_dir)', 'loaded = tf.saved_model.load(saved_model_dir)', 'loaded = tf.saved_model.load(saved_model_dir)', 'loaded = tf.saved_model.load(saved_model_dir)', 'loaded = tf.saved_model.load(saved_model_dir)', 'loaded = tf.saved_model.load(saved_model_dir)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-07",
            "description": "The code sorts the elements of the array \"startRavel\" in ascending order and creates a new array \"s_startRavel\" with the sorted elements.",
            "code": "ix = np.argsort(startRavel)\ns_startRavel = startRavel[ix]",
            "masked_code": "<line_mask>\ns_startRavel = startRavel[ix]",
            "masked_line": "ix = np.argsort(startRavel)",
            "answer": "argsort",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_25",
            "model_output": "['<start>s_startRavel = startRavel[np.argsort(startRavel[:, ix])]<end>', '<start>s_startRavel = startRavel[np.argsort(startRavel[:, ix])]<end>', '<start>s_startRavel = startRavel[np.argsort(startRavel)[ix]]<end>', '<start>s_startRavel = startRavel[np.argsort(startRavel[:,ix][:,0] if ix==0 else -startRavel[:,ix][:,0])]<end>', '<start>s_startRavel = startRavel[np.argsort(startRavel[:,ix])]<end>', '<start>s_startRavel = startRavel[np.argsort(startRavel[:, ix])] if ix == 0 else startRavel[np.argsort(-startRavel[:, ix])]<end>']",
            "model_output_token_clear": "['s_startRavel = startRavel[np.argsort(startRavel[:, ix])]', 's_startRavel = startRavel[np.argsort(startRavel[:, ix])]', 's_startRavel = startRavel[np.argsort(startRavel)[ix]]', 's_startRavel = startRavel[np.argsort(startRavel[:,ix][:,0] if ix==0 else -startRavel[:,ix][:,0])]', 's_startRavel = startRavel[np.argsort(startRavel[:,ix])]', 's_startRavel = startRavel[np.argsort(startRavel[:, ix])] if ix == 0 else startRavel[np.argsort(-startRavel[:, ix])]']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-07",
            "description": "This code snippet uses NumPy to find the indices where the elements in the array unique_policies would be inserted in a sorted array s_startRavel.",
            "code": "s_ix = np.searchsorted(s_startRavel, unique_policies)\n# array([0, 1, 4])",
            "masked_code": "<line_mask>\n# array([0, 1, 4])",
            "masked_line": "s_ix = np.searchsorted(s_startRavel, unique_policies)",
            "answer": "searchsorted",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_26",
            "model_output": "['<start>s_ix = np.searchsorted(s_startRavel, unique_policies)<end>', '<start>s_ix = np.searchsorted(s_startRavel, unique_policies)<end>', '<start>s_ix = np.searchsorted(s_startRavel, unique_policies)<end>', '<start>s_ix = np.searchsorted(s_startRavel, unique_policies)<end>', '<start>s_ix = np.searchsorted(s_startRavel, unique_policies)<end>', '<start>s_ix = np.searchsorted(s_startRavel, unique_policies)<end>']",
            "model_output_token_clear": "['s_ix = np.searchsorted(s_startRavel, unique_policies)', 's_ix = np.searchsorted(s_startRavel, unique_policies)', 's_ix = np.searchsorted(s_startRavel, unique_policies)', 's_ix = np.searchsorted(s_startRavel, unique_policies)', 's_ix = np.searchsorted(s_startRavel, unique_policies)', 's_ix = np.searchsorted(s_startRavel, unique_policies)']"
        },
        {
            "dependency": "PyQt5",
            "version": "==5.12.1",
            "time": "2019-03-23",
            "description": "This code defines a custom model (DataFrameModel) for Qt Quick applications to display pandas DataFrame in QML. The model includes methods to set and get the DataFrame, retrieve header data, row and column count, and display data values based on specified roles. It also sets up roles for data display, data type, and value. Finally, the code integrates the model with a QML interface for displaying the DataFrame in a Qt Quick application.",
            "code": "from PyQt5 import QtCore, QtGui, QtQml\nimport numpy as np\nimport pandas as pd\n\nclass DataFrameModel(QtCore.QAbstractTableModel):\n    DtypeRole = QtCore.Qt.UserRole + 1000\n    ValueRole = QtCore.Qt.UserRole + 1001\n\n    def __init__(self, df=pd.DataFrame(), parent=None):\n        super(DataFrameModel, self).__init__(parent)\n        self._dataframe = df\n\n    def setDataFrame(self, dataframe):\n        self.beginResetModel()\n        self._dataframe = dataframe.copy()\n        self.endResetModel()\n\n    def dataFrame(self):\n        return self._dataframe\n\n    dataFrame = QtCore.pyqtProperty(pd.DataFrame, fget=dataFrame, fset=setDataFrame)\n\n    @QtCore.pyqtSlot(int, QtCore.Qt.Orientation, result=str)\n    def headerData(self, section: int, orientation: QtCore.Qt.Orientation, role: int = QtCore.Qt.DisplayRole):\n        if role == QtCore.Qt.DisplayRole:\n            if orientation == QtCore.Qt.Horizontal:\n                return self._dataframe.columns[section]\n            else:\n                return str(self._dataframe.index[section])\n        return QtCore.QVariant()\n\n    def rowCount(self, parent=QtCore.QModelIndex()):\n        if parent.isValid():\n            return 0\n        return len(self._dataframe.index)\n\n    def columnCount(self, parent=QtCore.QModelIndex()):\n        if parent.isValid():\n            return 0\n        return self._dataframe.columns.size\n\n    def data(self, index, role=QtCore.Qt.DisplayRole):\n        if not index.isValid() or not (0 <= index.row() < self.rowCount() \\\n            and 0 <= index.column() < self.columnCount()):\n            return QtCore.QVariant()\n        row = self._dataframe.index[index.row()]\n        col = self._dataframe.columns[index.column()]\n        dt = self._dataframe[col].dtype\n\n        val = self._dataframe.iloc[row][col]\n        if role == QtCore.Qt.DisplayRole:\n            return str(val)\n        elif role == DataFrameModel.ValueRole:\n            return val\n        if role == DataFrameModel.DtypeRole:\n            return dt\n        return QtCore.QVariant()\n\n    def roleNames(self):\n        roles = {\n            QtCore.Qt.DisplayRole: b'display',\n            DataFrameModel.DtypeRole: b'dtype',\n            DataFrameModel.ValueRole: b'value'\n        }\n        return roles\n\nif __name__ == \"__main__\":\n    import os\n    import sys\n\n    app = QtGui.QGuiApplication(sys.argv)\n    df = pd.DataFrame(np.random.randint(0, 100, size=(6, 7)), columns=list('ABCDEFG'))\n    print(df)\n    model = DataFrameModel(df)\n    engine = QtQml.QQmlApplicationEngine()\n    engine.rootContext().setContextProperty(\"table_model\", model)\n    qml_path = os.path.join(os.path.dirname(__file__), \"main.qml\")\n    engine.load(QtCore.QUrl.fromLocalFile(qml_path))\n    if not engine.rootObjects():\n        sys.exit(-1)\n    engine.quit.connect(app.quit)\n    sys.exit(app.exec_())",
            "masked_code": "from PyQt5 import QtCore, QtGui, QtQml\nimport numpy as np\nimport pandas as pd\n\nclass DataFrameModel(QtCore.QAbstractTableModel):\n    DtypeRole = QtCore.Qt.UserRole + 1000\n    ValueRole = QtCore.Qt.UserRole + 1001\n\n    def __init__(self, df=pd.DataFrame(), parent=None):\n        super(DataFrameModel, self).__init__(parent)\n        self._dataframe = df\n\n    def setDataFrame(self, dataframe):\n        self.beginResetModel()\n        self._dataframe = dataframe.copy()\n        self.endResetModel()\n\n    def dataFrame(self):\n        return self._dataframe\n\n    dataFrame = QtCore.pyqtProperty(pd.DataFrame, fget=dataFrame, fset=setDataFrame)\n\n    @QtCore.pyqtSlot(int, QtCore.Qt.Orientation, result=str)\n    def headerData(self, section: int, orientation: QtCore.Qt.Orientation, role: int = QtCore.Qt.DisplayRole):\n        if role == QtCore.Qt.DisplayRole:\n            if orientation == QtCore.Qt.Horizontal:\n                return self._dataframe.columns[section]\n            else:\n                return str(self._dataframe.index[section])\n        return QtCore.QVariant()\n\n    def rowCount(self, parent=QtCore.QModelIndex()):\n        if parent.isValid():\n            return 0\n        return len(self._dataframe.index)\n\n    def columnCount(self, parent=QtCore.QModelIndex()):\n        if parent.isValid():\n            return 0\n        return self._dataframe.columns.size\n\n    def data(self, index, role=QtCore.Qt.DisplayRole):\n        if not index.isValid() or not (0 <= index.row() < self.rowCount() \\\n            and 0 <= index.column() < self.columnCount()):\n            return QtCore.QVariant()\n        row = self._dataframe.index[index.row()]\n        col = self._dataframe.columns[index.column()]\n        dt = self._dataframe[col].dtype\n\n        val = self._dataframe.iloc[row][col]\n        if role == QtCore.Qt.DisplayRole:\n            return str(val)\n        elif role == DataFrameModel.ValueRole:\n            return val\n        if role == DataFrameModel.DtypeRole:\n            return dt\n        return QtCore.QVariant()\n\n    def roleNames(self):\n        roles = {\n            QtCore.Qt.DisplayRole: b'display',\n            DataFrameModel.DtypeRole: b'dtype',\n            DataFrameModel.ValueRole: b'value'\n        }\n        return roles\n\nif __name__ == \"__main__\":\n    import os\n    import sys\n\n    <line_mask>\n    df = pd.DataFrame(np.random.randint(0, 100, size=(6, 7)), columns=list('ABCDEFG'))\n    print(df)\n    model = DataFrameModel(df)\n    engine = QtQml.QQmlApplicationEngine()\n    engine.rootContext().setContextProperty(\"table_model\", model)\n    qml_path = os.path.join(os.path.dirname(__file__), \"main.qml\")\n    engine.load(QtCore.QUrl.fromLocalFile(qml_path))\n    if not engine.rootObjects():\n        sys.exit(-1)\n    engine.quit.connect(app.quit)\n    sys.exit(app.exec_())",
            "masked_line": "app = QtGui.QGuiApplication(sys.argv)",
            "answer": "QGuiApplication",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_27",
            "model_output": "['<start>app = QtGui.QGuiApplication(sys.argv)<end>', '<start>app = QtGui.QGuiApplication(sys.argv)<end>', '<start>app = QtGui.QGuiApplication(sys.argv)<end>', '<start>app = QtGui.QGuiApplication(sys.argv)<end>', '<start>os.environ[\"QT_QPA_PLATFORM_PLUGIN_PATH\"] = os.path.dirname(QtCore.__file__) + \"/plugins\"; app = QtGui.QGuiApplication(sys.argv)<end>', '<start>app = QtGui.QGuiApplication(sys.argv)<end>']",
            "model_output_token_clear": "['app = QtGui.QGuiApplication(sys.argv)', 'app = QtGui.QGuiApplication(sys.argv)', 'app = QtGui.QGuiApplication(sys.argv)', 'app = QtGui.QGuiApplication(sys.argv)', 'os.environ[\"QT_QPA_PLATFORM_PLUGIN_PATH\"] = os.path.dirname(QtCore.__file__) + \"/plugins\"; app = QtGui.QGuiApplication(sys.argv)', 'app = QtGui.QGuiApplication(sys.argv)']"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.1",
            "time": "2019-03-23",
            "description": "This Python code defines a custom model class (DataFrameModel) that extends QAbstractTableModel from PyQt5. The model is designed to work with pandas DataFrame objects and provides methods to set and retrieve the data frame, as well as to access data, row count, column count, and header data. The model also defines custom roles (DtypeRole and ValueRole) for data types and values in the data frame. The code also includes a main block that creates a random DataFrame, initializes the custom model with the DataFrame, and connects the model to a QML view for display.",
            "code": "from PyQt5 import QtCore, QtGui, QtQml\nimport numpy as np\nimport pandas as pd\n\nclass DataFrameModel(QtCore.QAbstractTableModel):\n    DtypeRole = QtCore.Qt.UserRole + 1000\n    ValueRole = QtCore.Qt.UserRole + 1001\n\n    def __init__(self, df=pd.DataFrame(), parent=None):\n        super(DataFrameModel, self).__init__(parent)\n        self._dataframe = df\n\n    def setDataFrame(self, dataframe):\n        self.beginResetModel()\n        self._dataframe = dataframe.copy()\n        self.endResetModel()\n\n    def dataFrame(self):\n        return self._dataframe\n\n    dataFrame = QtCore.pyqtProperty(pd.DataFrame, fget=dataFrame, fset=setDataFrame)\n\n    @QtCore.pyqtSlot(int, QtCore.Qt.Orientation, result=str)\n    def headerData(self, section: int, orientation: QtCore.Qt.Orientation, role: int = QtCore.Qt.DisplayRole):\n        if role == QtCore.Qt.DisplayRole:\n            if orientation == QtCore.Qt.Horizontal:\n                return self._dataframe.columns[section]\n            else:\n                return str(self._dataframe.index[section])\n        return QtCore.QVariant()\n\n    def rowCount(self, parent=QtCore.QModelIndex()):\n        if parent.isValid():\n            return 0\n        return len(self._dataframe.index)\n\n    def columnCount(self, parent=QtCore.QModelIndex()):\n        if parent.isValid():\n            return 0\n        return self._dataframe.columns.size\n\n    def data(self, index, role=QtCore.Qt.DisplayRole):\n        if not index.isValid() or not (0 <= index.row() < self.rowCount() \\\n            and 0 <= index.column() < self.columnCount()):\n            return QtCore.QVariant()\n        row = self._dataframe.index[index.row()]\n        col = self._dataframe.columns[index.column()]\n        dt = self._dataframe[col].dtype\n\n        val = self._dataframe.iloc[row][col]\n        if role == QtCore.Qt.DisplayRole:\n            return str(val)\n        elif role == DataFrameModel.ValueRole:\n            return val\n        if role == DataFrameModel.DtypeRole:\n            return dt\n        return QtCore.QVariant()\n\n    def roleNames(self):\n        roles = {\n            QtCore.Qt.DisplayRole: b'display',\n            DataFrameModel.DtypeRole: b'dtype',\n            DataFrameModel.ValueRole: b'value'\n        }\n        return roles\n\nif __name__ == \"__main__\":\n    import os\n    import sys\n\n    app = QtGui.QGuiApplication(sys.argv)\n    df = pd.DataFrame(np.random.randint(0, 100, size=(6, 7)), columns=list('ABCDEFG'))\n    print(df)\n    model = DataFrameModel(df)\n    engine = QtQml.QQmlApplicationEngine()\n    engine.rootContext().setContextProperty(\"table_model\", model)\n    qml_path = os.path.join(os.path.dirname(__file__), \"main.qml\")\n    engine.load(QtCore.QUrl.fromLocalFile(qml_path))\n    if not engine.rootObjects():\n        sys.exit(-1)\n    engine.quit.connect(app.quit)\n    sys.exit(app.exec_())",
            "masked_code": "from PyQt5 import QtCore, QtGui, QtQml\nimport numpy as np\nimport pandas as pd\n\nclass DataFrameModel(QtCore.QAbstractTableModel):\n    DtypeRole = QtCore.Qt.UserRole + 1000\n    ValueRole = QtCore.Qt.UserRole + 1001\n\n    def __init__(self, df=pd.DataFrame(), parent=None):\n        super(DataFrameModel, self).__init__(parent)\n        self._dataframe = df\n\n    def setDataFrame(self, dataframe):\n        self.beginResetModel()\n        self._dataframe = dataframe.copy()\n        self.endResetModel()\n\n    def dataFrame(self):\n        return self._dataframe\n\n    dataFrame = QtCore.pyqtProperty(pd.DataFrame, fget=dataFrame, fset=setDataFrame)\n\n    @QtCore.pyqtSlot(int, QtCore.Qt.Orientation, result=str)\n    def headerData(self, section: int, orientation: QtCore.Qt.Orientation, role: int = QtCore.Qt.DisplayRole):\n        if role == QtCore.Qt.DisplayRole:\n            if orientation == QtCore.Qt.Horizontal:\n                return self._dataframe.columns[section]\n            else:\n                return str(self._dataframe.index[section])\n        return QtCore.QVariant()\n\n    def rowCount(self, parent=QtCore.QModelIndex()):\n        if parent.isValid():\n            return 0\n        return len(self._dataframe.index)\n\n    def columnCount(self, parent=QtCore.QModelIndex()):\n        if parent.isValid():\n            return 0\n        return self._dataframe.columns.size\n\n    def data(self, index, role=QtCore.Qt.DisplayRole):\n        if not index.isValid() or not (0 <= index.row() < self.rowCount() \\\n            and 0 <= index.column() < self.columnCount()):\n            return QtCore.QVariant()\n        row = self._dataframe.index[index.row()]\n        col = self._dataframe.columns[index.column()]\n        dt = self._dataframe[col].dtype\n\n        val = self._dataframe.iloc[row][col]\n        if role == QtCore.Qt.DisplayRole:\n            return str(val)\n        elif role == DataFrameModel.ValueRole:\n            return val\n        if role == DataFrameModel.DtypeRole:\n            return dt\n        return QtCore.QVariant()\n\n    def roleNames(self):\n        roles = {\n            QtCore.Qt.DisplayRole: b'display',\n            DataFrameModel.DtypeRole: b'dtype',\n            DataFrameModel.ValueRole: b'value'\n        }\n        return roles\n\nif __name__ == \"__main__\":\n    import os\n    import sys\n\n    app = QtGui.QGuiApplication(sys.argv)\n    <line_mask>\n    print(df)\n    model = DataFrameModel(df)\n    engine = QtQml.QQmlApplicationEngine()\n    engine.rootContext().setContextProperty(\"table_model\", model)\n    qml_path = os.path.join(os.path.dirname(__file__), \"main.qml\")\n    engine.load(QtCore.QUrl.fromLocalFile(qml_path))\n    if not engine.rootObjects():\n        sys.exit(-1)\n    engine.quit.connect(app.quit)\n    sys.exit(app.exec_())",
            "masked_line": "df = pd.DataFrame(np.random.randint(0, 100, size=(6, 7)), columns=list('ABCDEFG'))",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_28",
            "model_output": "['<start>df = pd.DataFrame(np.random.rand(10, 5))<end>', \"<start>df = pd.DataFrame(np.random.randint(0,100,size=(10, 4)), columns=list('ABCD'))<end>\", '<start>df = pd.DataFrame(np.random.rand(10, 10))<end>', \"<start>df = pd.DataFrame(np.random.randint(0,100,size=(10, 4)), columns=list('ABCD'))<end>\", \"<start>df = pd.DataFrame(np.random.randn(5, 3), columns=['A', 'B', 'C'])<end>\", '<start>df = pd.DataFrame(np.random.rand(10, 5))<end>']",
            "model_output_token_clear": "['df = pd.DataFrame(np.random.rand(10, 5))', \"df = pd.DataFrame(np.random.randint(0,100,size=(10, 4)), columns=list('ABCD'))\", 'df = pd.DataFrame(np.random.rand(10, 10))', \"df = pd.DataFrame(np.random.randint(0,100,size=(10, 4)), columns=list('ABCD'))\", \"df = pd.DataFrame(np.random.randn(5, 3), columns=['A', 'B', 'C'])\", 'df = pd.DataFrame(np.random.rand(10, 5))']"
        },
        {
            "dependency": "pandas",
            "version": "<0.25",
            "time": "2019-08-08",
            "description": "The code segment takes a dictionary data structure containing information about individuals, such as their names, company IDs, and education levels, and converts it into a structured DataFrame using the Pandas library in Python. It then manipulates the DataFrame by expanding the 'names' and 'education' columns into separate columns, removing unnecessary columns, and sorting the data by 'company_id' and 'names'. Finally, it renames the columns and prints the resulting DataFrame.",
            "code": "import pandas as pd\n\ntest = {\n    'abc': {\n        'company_id': '123c',\n        'names': ['Oscar', 'John Smith', 'Smith, John'],\n        'education': ['MS', 'BS']\n    },\n    'DEF': {\n        'company_id': '124b',\n        'names': ['Matt B.'],\n        'education': ['']\n    }\n}\n\nframe = pd.DataFrame(test).T\n\nnames = frame.names.apply(pd.Series)\nframe = frame.merge(\n    names, left_index=True, right_index=True).drop('names', axis=1)\nframe = frame.reset_index().melt(\n    id_vars=['index', 'company_id', 'education'],\n    value_name='names').drop('variable', axis=1).dropna()\n\neducation = frame.education.apply(pd.Series)\nframe = frame.merge(\n    education, left_index=True, right_index=True).drop('education', axis=1)\nframe = frame.melt(\n    id_vars=['index', 'company_id', 'names'],\n    value_name='education').drop(\n    'variable', axis=1).dropna().sort_values(by=['company_id', 'names'])\n\nframe.columns = ['set_name', 'company_id', 'names', 'education']\n\nprint(frame)",
            "masked_code": "import pandas as pd\n\ntest = {\n    'abc': {\n        'company_id': '123c',\n        'names': ['Oscar', 'John Smith', 'Smith, John'],\n        'education': ['MS', 'BS']\n    },\n    'DEF': {\n        'company_id': '124b',\n        'names': ['Matt B.'],\n        'education': ['']\n    }\n}\n\n<line_mask>\n\nnames = frame.names.apply(pd.Series)\nframe = frame.merge(\n    names, left_index=True, right_index=True).drop('names', axis=1)\nframe = frame.reset_index().melt(\n    id_vars=['index', 'company_id', 'education'],\n    value_name='names').drop('variable', axis=1).dropna()\n\neducation = frame.education.apply(pd.Series)\nframe = frame.merge(\n    education, left_index=True, right_index=True).drop('education', axis=1)\nframe = frame.melt(\n    id_vars=['index', 'company_id', 'names'],\n    value_name='education').drop(\n    'variable', axis=1).dropna().sort_values(by=['company_id', 'names'])\n\nframe.columns = ['set_name', 'company_id', 'names', 'education']\n\nprint(frame)",
            "masked_line": "frame = pd.DataFrame(test).T",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_29",
            "model_output": "['<start>frame = pd.DataFrame(test).T.reset_index(drop=True)<end>', '<start>frame = pd.DataFrame(test).T.reset_index()<end>', \"<start>frame = pd.DataFrame(test).stack().reset_index(name='value').loc[:, ['level_0', 'level_1', 'value']].rename(columns={'level_0': 'set_name', 'level_1': 'category'})<end>\", '<start>frame = pd.DataFrame(test).T.reset_index(drop=True)<end>', '<start>frame = pd.DataFrame(test).T.reset_index(drop=True)<end>', \"<start>frame = pd.DataFrame(test).stack().reset_index(name='value').loc[:, ['level_1', 'value']]<end>\"]",
            "model_output_token_clear": "['frame = pd.DataFrame(test).T.reset_index(drop=True)', 'frame = pd.DataFrame(test).T.reset_index()', \"frame = pd.DataFrame(test).stack().reset_index(name='value').loc[:, ['level_0', 'level_1', 'value']].rename(columns={'level_0': 'set_name', 'level_1': 'category'})\", 'frame = pd.DataFrame(test).T.reset_index(drop=True)', 'frame = pd.DataFrame(test).T.reset_index(drop=True)', \"frame = pd.DataFrame(test).stack().reset_index(name='value').loc[:, ['level_1', 'value']]\"]"
        },
        {
            "dependency": "numpy",
            "version": "==1.16.2",
            "time": "2019-07-09",
            "description": "This code calculates the sum of elements in 'a' array for every 'interval' number of elements.",
            "code": "import numpy as np\n\ninterval = 3\na = [1, 7, 4, 7, 4, 8, 5, 2, 17, 8, 3, 12, 9, 6, 28]\nl = max(a) // interval + 1\nb = np.bincount(a, minlength=l*interval).reshape((l,interval)).sum(axis=1)",
            "masked_code": "import numpy as np\n\ninterval = 3\na = [1, 7, 4, 7, 4, 8, 5, 2, 17, 8, 3, 12, 9, 6, 28]\nl = max(a) // interval + 1\n<line_mask>",
            "masked_line": "b = np.bincount(a, minlength=l*interval).reshape((l,interval)).sum(axis=1)",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_30",
            "model_output": "['<start>buckets = [[] for _ in range(l)]<end>', '<start>buckets = [[] for _ in range(l)]<end>', '<start>bins = [[] for _ in range(l)]<end>', '<start>bins = [a[i:i+l] for i in range(0,len(a),l)]<end>', '<start>binned_a = [sum(a[i:i+interval]) for i in range(0,l*interval,interval)]<end>', '<start>binned_a = np.array([a[i:i+l] for i in range(0, len(a), interval)])<end>']",
            "model_output_token_clear": "['buckets = [[] for _ in range(l)]', 'buckets = [[] for _ in range(l)]', 'bins = [[] for _ in range(l)]', 'bins = [a[i:i+l] for i in range(0,len(a),l)]', 'binned_a = [sum(a[i:i+interval]) for i in range(0,l*interval,interval)]', 'binned_a = np.array([a[i:i+l] for i in range(0, len(a), interval)])']"
        },
        {
            "dependency": "numpy",
            "version": "==1.16.1",
            "time": "2019-10-01",
            "description": "The function saves an array to a file named 'postCodeArray' using the numpy library in Python.",
            "code": "def saveArray(array):\n\n    import numpy as np\n    np.save('postCodeArray', array, allow_pickle=True)",
            "masked_code": "def saveArray(array):\n\n    import numpy as np\n    <line_mask>",
            "masked_line": "np.save('postCodeArray', array, allow_pickle=True)",
            "answer": "save",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_31",
            "model_output": "[\"<start>np.savetxt('postCodeArray.txt', array, delimiter=';')<end>\", \"<start>np.save('postCodeArray', array)<end>\", \"<start>np.savetxt('postCodeArray.txt', array, delimiter=';')<end>\", \"<start>np.savetxt('postCodeArray.txt', array)<end>\", \"<start>np.savetxt('postCodeArray.txt', array)<end>\", \"<start>np.savetxt('postCodeArray.txt', array, delimiter=';')<end>\"]",
            "model_output_token_clear": "[\"np.savetxt('postCodeArray.txt', array, delimiter=';')\", \"np.save('postCodeArray', array)\", \"np.savetxt('postCodeArray.txt', array, delimiter=';')\", \"np.savetxt('postCodeArray.txt', array)\", \"np.savetxt('postCodeArray.txt', array)\", \"np.savetxt('postCodeArray.txt', array, delimiter=';')\"]"
        },
        {
            "dependency": "numpy",
            "version": "==1.16.1",
            "time": "2019-10-01",
            "description": "This code loads a numpy array from a saved file called 'postCodeArray.npy' and then prints the contents of the array.",
            "code": "def callFunction():\n\n    import numpy as np\n    array = np.load('postCodeArray.npy', allow_pickle=True)  \n    print(array)",
            "masked_code": "def callFunction():\n\n    import numpy as np\n    <line_mask>\n    print(array)",
            "masked_line": "array = np.load('postCodeArray.npy', allow_pickle=True)",
            "answer": "load",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_32",
            "model_output": "[\"<start>array = np.load('postCodeArray.npy')<end>\", \"<start>array = np.load('postCodeArray.npy')<end>\", \"<start>array = np.load('postCodeArray.npy')<end>\", \"<start>array = np.load('postCodeArray.npy')<end>\", \"<start>array = np.load('postCodeArray.npy')<end>\", \"<start>array = np.load('postCodeArray.npy')<end>\"]",
            "model_output_token_clear": "[\"array = np.load('postCodeArray.npy')\", \"array = np.load('postCodeArray.npy')\", \"array = np.load('postCodeArray.npy')\", \"array = np.load('postCodeArray.npy')\", \"array = np.load('postCodeArray.npy')\", \"array = np.load('postCodeArray.npy')\"]"
        },
        {
            "dependency": "sklearn",
            "version": "==0.20",
            "time": "2020-06-16",
            "description": "The code defines a custom transformer class called FeatureSelector that selects specific columns from a dataset. It then creates a pipeline with the FeatureSelector as one of the steps and fits and transforms a DataFrame using the pipeline, returning the first 5 rows of the transformed DataFrame.",
            "code": "from sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.pipeline import Pipeline\n\nclass FeatureSelector(BaseEstimator, TransformerMixin):\n    def __init__(self, columns):\n        self.columns = columns\n\n    def fit(self, X, y=None):\n        return self\n\n    def transform(self, X, y=None):\n        return X[self.columns]\n\n\npipeline = Pipeline([('selector', FeatureSelector(columns=mycols))\n                     ])\n\npipeline.fit_transform(df)[:5]",
            "masked_code": "from sklearn.base import BaseEstimator, TransformerMixin\n<line_mask>\n\nclass FeatureSelector(BaseEstimator, TransformerMixin):\n    def __init__(self, columns):\n        self.columns = columns\n\n    def fit(self, X, y=None):\n        return self\n\n    def transform(self, X, y=None):\n        return X[self.columns]\n\n\npipeline = Pipeline([('selector', FeatureSelector(columns=mycols))\n                     ])\n\npipeline.fit_transform(df)[:5]",
            "masked_line": "from sklearn.pipeline import Pipeline",
            "answer": "Pipeline",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_33",
            "model_output": "['<start>class FeatureSelector(BaseEstimator, TransformerMixin):<end>', '<start>class FeatureSelector(BaseEstimator, TransformerMixin):<end>', '<start>class FeatureSelector(BaseEstimator, TransformerMixin):<end>', '<start>class FeatureSelector(BaseEstimator, TransformerMixin):<end>', '<start>class FeatureSelector(BaseEstimator, TransformerMixin):<end>', '<start>class FeatureSelector(BaseEstimator, TransformerMixin):<end>']",
            "model_output_token_clear": "['class FeatureSelector(BaseEstimator, TransformerMixin):', 'class FeatureSelector(BaseEstimator, TransformerMixin):', 'class FeatureSelector(BaseEstimator, TransformerMixin):', 'class FeatureSelector(BaseEstimator, TransformerMixin):', 'class FeatureSelector(BaseEstimator, TransformerMixin):', 'class FeatureSelector(BaseEstimator, TransformerMixin):']"
        },
        {
            "dependency": "django",
            "version": ">=3.0",
            "time": "2020-09-04",
            "description": "This code defines a Django model called SomeModel with a field named enum_field, which is a CharField with choices specified by the SomeEnum TextChoices class. The enum_field field defaults to Option A (represented by \"A\") from the SomeEnum choices.",
            "code": "from django.db import models\n\nclass SomeModel(models.Model):\n\n    class SomeEnum(models.TextChoices):\n\n        A = \"A\", _(\"Option A\")\n        B = \"B\", _(\"Option B\")\n\n    enum_field = models.CharField(\n        max_length=1,\n        choices=SomeEnum.choices,\n        default=SomeEnum.A,\n    )",
            "masked_code": "from django.db import models\n\nclass SomeModel(models.Model):\n\n    class SomeEnum(models.TextChoices):\n\n        A = \"A\", _(\"Option A\")\n        B = \"B\", _(\"Option B\")\n\n    <line_mask>\n        max_length=1,\n        choices=SomeEnum.choices,\n        default=SomeEnum.A,\n    )",
            "masked_line": "enum_field = models.CharField(",
            "answer": "CharField",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_34",
            "model_output": "['<start>enum_field = models.CharField<end>', '<start>enum_field = models.CharField<end>', '<start>enum_field = models.CharField<end>', '<start>enum_field = models.CharField<end>', '<start>enum_field = models.CharField<end>', '<start>enum_field = models.CharField<end>']",
            "model_output_token_clear": "['enum_field = models.CharField', 'enum_field = models.CharField', 'enum_field = models.CharField', 'enum_field = models.CharField', 'enum_field = models.CharField', 'enum_field = models.CharField']"
        },
        {
            "dependency": "discord.py",
            "version": "==1.0",
            "time": "2020-09-11",
            "description": "This code sets up a Discord bot using the discord.ext library in Python. The bot is set to send a message to a specific channel at 7:00 am every day. It continuously checks the time and sends the message only once when the time is 7:00 am.",
            "code": "from discord.ext import commands\nimport datetime\nimport asyncio\n\ntime = datetime.datetime.now\n\nbot = commands.Bot(command_prefix='!')\n\nasync def timer():\n    await bot.wait_until_ready()\n    channel = bot.get_channel(123456789) # replace with channel ID that you want to send to\n    msg_sent = False\n\n    while True:\n        if time().hour == 7 and time().minute == 0:\n            if not msg_sent:\n                await channel.send('Its 7 am')\n                msg_sent = True\n        else:\n            msg_sent = False\n\n    await asyncio.sleep(1)\n\nbot.loop.create_task(timer())\nbot.run('TOKEN')",
            "masked_code": "from discord.ext import commands\nimport datetime\nimport asyncio\n\ntime = datetime.datetime.now\n\nbot = commands.Bot(command_prefix='!')\n\nasync def timer():\n    await bot.wait_until_ready()\n    channel = bot.get_channel(123456789) # replace with channel ID that you want to send to\n    msg_sent = False\n\n    while True:\n        if time().hour == 7 and time().minute == 0:\n            if not msg_sent:\n                await channel.send('Its 7 am')\n                msg_sent = True\n        else:\n            msg_sent = False\n\n    await asyncio.sleep(1)\n\n<line_mask>\nbot.run('TOKEN')",
            "masked_line": "bot.loop.create_task(timer())",
            "answer": "create_task",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_35",
            "model_output": "['<start>bot.loop.create_task(timer())<end>', '<start>bot.loop.create_task(timer())<end>', '<start>bot.loop.create_task(timer())<end>', '<start>bot.loop.create_task(timer())<end>', '<start>bot.loop.create_task(timer())<end>', '<start>bot.loop.create_task(timer())<end>']",
            "model_output_token_clear": "['bot.loop.create_task(timer())', 'bot.loop.create_task(timer())', 'bot.loop.create_task(timer())', 'bot.loop.create_task(timer())', 'bot.loop.create_task(timer())', 'bot.loop.create_task(timer())']"
        },
        {
            "dependency": "pillow",
            "version": "==8.0.0",
            "time": "2020-12-29",
            "description": "This code generates an image with the text \"Hello World\" centered within a specified width and height. It calculates the appropriate font size to fit the text within the given dimensions by testing different font sizes. It then positions the text in the center of the image and displays the resulting image.",
            "code": "from PIL import Image, ImageDraw, ImageFont\n\nwidth = 300\nheight = 100\n\ntext = \"Hello World\"\n\nfont_name = 'Ubuntu-M'\n\n# --- create image for text ---\n\nimg = Image.new('RGB', (width, height), (255, 255, 255))\ndraw = ImageDraw.Draw(img)\n\n# --- calculate font size, box ---\n\n# default values at start\nfont_size = None   # for font size\nfont = None        # for object truetype with correct font size\nbox = None         # for version 8.0.0\n\n# test for different font sizes\nfor size in range(1, 500):\n\n    # create new font\n    new_font = ImageFont.truetype(font_name, size)\n    \n    # calculate bbox for version 8.0.0\n    new_box = draw.textbbox((0, 0), text, new_font)  # need 8.0.0\n    \n    # `bbox` may have top/left margin so calculate real width/height\n    new_w = new_box[2] - new_box[0]  # bottom-top\n    new_h = new_box[3] - new_box[1]  # right-left\n    #print(size, '|', new_w, new_h, '|', new_box)\n\n    # if too big then exit with previous values\n    if new_w > width or new_h > height:\n        break\n        \n    # set new current values as current values\n    font_size = size\n    font = new_font\n    box = new_box\n    w = new_w\n    h = new_h\n    \n# --- use it ---\n    \nprint('font size:', font_size)\nprint('box:', box)\n\nprint('w <= width :', w, '<=', width)\nprint('h <= height:', h, '<=', height)\n\n# calculate position (minus margins in box)\nx = (width - w)//2 - box[0]   # minus left margin\ny = (height - h)//2 - box[3]  # minus top margin\nprint('w,h (without margins):', w, h)\nprint('x,y (without margins):', x, y)\n\n# draw it \ndraw.text((x, y), text, (0, 0, 0), font)\n\n# display result\nimg.show()\n\nimg.save('result-textbbox.png', 'png')",
            "masked_code": "from PIL import Image, ImageDraw, ImageFont\n\nwidth = 300\nheight = 100\n\ntext = \"Hello World\"\n\nfont_name = 'Ubuntu-M'\n\n# --- create image for text ---\n\n<line_mask>\ndraw = ImageDraw.Draw(img)\n\n# --- calculate font size, box ---\n\n# default values at start\nfont_size = None   # for font size\nfont = None        # for object truetype with correct font size\nbox = None         # for version 8.0.0\n\n# test for different font sizes\nfor size in range(1, 500):\n\n    # create new font\n    new_font = ImageFont.truetype(font_name, size)\n    \n    # calculate bbox for version 8.0.0\n    new_box = draw.textbbox((0, 0), text, new_font)  # need 8.0.0\n    \n    # `bbox` may have top/left margin so calculate real width/height\n    new_w = new_box[2] - new_box[0]  # bottom-top\n    new_h = new_box[3] - new_box[1]  # right-left\n    #print(size, '|', new_w, new_h, '|', new_box)\n\n    # if too big then exit with previous values\n    if new_w > width or new_h > height:\n        break\n        \n    # set new current values as current values\n    font_size = size\n    font = new_font\n    box = new_box\n    w = new_w\n    h = new_h\n    \n# --- use it ---\n    \nprint('font size:', font_size)\nprint('box:', box)\n\nprint('w <= width :', w, '<=', width)\nprint('h <= height:', h, '<=', height)\n\n# calculate position (minus margins in box)\nx = (width - w)//2 - box[0]   # minus left margin\ny = (height - h)//2 - box[3]  # minus top margin\nprint('w,h (without margins):', w, h)\nprint('x,y (without margins):', x, y)\n\n# draw it \ndraw.text((x, y), text, (0, 0, 0), font)\n\n# display result\nimg.show()\n\nimg.save('result-textbbox.png', 'png')",
            "masked_line": "img = Image.new('RGB', (width, height), (255, 255, 255))",
            "answer": "new",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_36",
            "model_output": "[\"<start>img = Image.new('RGB', (width, height), color='white')<end>\", \"<start>img = Image.new('RGB', (width, height), color='white')<end>\", \"<start>img = Image.new('RGB', (width, height), color='white')<end>\", \"<start>img = Image.new('RGB', (width, height), color='white')<end>\", \"<start>img = Image.new('RGB', (width, height), color='white')<end>\", \"<start>img = Image.new('RGB', (width, height), color='white')<end>\"]",
            "model_output_token_clear": "[\"img = Image.new('RGB', (width, height), color='white')\", \"img = Image.new('RGB', (width, height), color='white')\", \"img = Image.new('RGB', (width, height), color='white')\", \"img = Image.new('RGB', (width, height), color='white')\", \"img = Image.new('RGB', (width, height), color='white')\", \"img = Image.new('RGB', (width, height), color='white')\"]"
        },
        {
            "dependency": "networkx",
            "version": "==1.3",
            "time": "2020-05-20",
            "description": "Find the bidirectional shortest path in a graph from coordinate 1 to coordinate 2, where the coordinates are represented as tuples and the path is returned as a list of coordinates.",
            "code": "coor1 = (0, 2) # seen as 2 in the arr array\ncoor2 = (2, 1) # seen as 7 in the arr array\n\nnx.bidirectional_shortest_path(G, source=coor1, target=coor2)\n# [(0, 2), (1, 2), (2, 2), (2, 1)]",
            "masked_code": "coor1 = (0, 2) # seen as 2 in the arr array\ncoor2 = (2, 1) # seen as 7 in the arr array\n\n<line_mask>\n# [(0, 2), (1, 2), (2, 2), (2, 1)]",
            "masked_line": "nx.bidirectional_shortest_path(G, source=coor1, target=coor2)",
            "answer": "bidirectional_shortest_path",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_37",
            "model_output": "['<start>G = nx.Graph(); G.add_nodes_from(coordinates); for ind, coord in enumerate(coordinates): for other_coord in coordinates[ind+1:]: if abs((coord[0] - other_coord[0])) <= 1 or abs((coord[1] - other_coord[1])) <= 1: G.add_edge(coord, other_coord)<end>', '<start>G = nx.Graph(); G.add_nodes_from(coordinates); for coord in coordinates: for other_coord in coordinates: if abs((coord[0] - other_coord[0])) <= 1 or abs((coord[1] - other_coord[1])) <= 1: G.add_edge(coord, other_coord); shortest_path = nx.bidirectional_shortest_path(G, coor1, coor2)<end>', '<start>G = nx.Graph(); G.add_edges_from([(coor1, coor) for coor in coordinates if abs(coor[0] - coor1[0]) <= 1 or abs(coor[1] - coor1[1]) <= 1] + [(coor2, coor) for coor in coordinates if abs(coor[0] - coor2[0]) <= 1 or abs(coor[1] - coor2[1]) <= 1]); shortest_path = nx.bidirectional_shortest_path(G, coor1, coor2)<end', '<start>G = nx.Graph(); G.add_edges_from([(coor1, coord) for coord in coordinates if abs(coor1[0] - coord[0]) <= 1 or abs(coor1[1] - coord[1]) <= 1]); path = nx.bidirectional_shortest_path(G, coor1, coor2)<end>', '<start>path = nx.bidirectional_shortest_path(G=adjacency_lists, source=coor1, target=coor2)<end>', '<start>G = nx.Graph(); G.add_nodes_from(coordinates); for coord in coordinates: for other_coord in coordinates: if abs((coord[0] - other_coord[0])) <= 1 or abs((coord[1] - other_coord[1])) <= 1: G.add_edge(coord, other_coord); shortest_path = nx.bidirectional_shortest_path(G, coor1, coor2)<end>']",
            "model_output_token_clear": "['G = nx.Graph(); G.add_nodes_from(coordinates); for ind, coord in enumerate(coordinates): for other_coord in coordinates[ind+1:]: if abs((coord[0] - other_coord[0])) <= 1 or abs((coord[1] - other_coord[1])) <= 1: G.add_edge(coord, other_coord)', 'G = nx.Graph(); G.add_nodes_from(coordinates); for coord in coordinates: for other_coord in coordinates: if abs((coord[0] - other_coord[0])) <= 1 or abs((coord[1] - other_coord[1])) <= 1: G.add_edge(coord, other_coord); shortest_path = nx.bidirectional_shortest_path(G, coor1, coor2)', 'no_answer', 'G = nx.Graph(); G.add_edges_from([(coor1, coord) for coord in coordinates if abs(coor1[0] - coord[0]) <= 1 or abs(coor1[1] - coord[1]) <= 1]); path = nx.bidirectional_shortest_path(G, coor1, coor2)', 'path = nx.bidirectional_shortest_path(G=adjacency_lists, source=coor1, target=coor2)', 'G = nx.Graph(); G.add_nodes_from(coordinates); for coord in coordinates: for other_coord in coordinates: if abs((coord[0] - other_coord[0])) <= 1 or abs((coord[1] - other_coord[1])) <= 1: G.add_edge(coord, other_coord); shortest_path = nx.bidirectional_shortest_path(G, coor1, coor2)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2020-02-10",
            "description": "The code concatenates four images together horizontally and then vertically to create a single large image.",
            "code": "concatenate1 = np.concatenate((image1, image2), axis=1)\nconcatenate2 = np.concatenate((image3, image4), axis=1)\nconcatenate_result = np.concatenate((concatenate1, concatenate2), axis=0)",
            "masked_code": "<line_mask>\nconcatenate2 = np.concatenate((image3, image4), axis=1)\nconcatenate_result = np.concatenate((concatenate1, concatenate2), axis=0)",
            "masked_line": "concatenate1 = np.concatenate((image1, image2), axis=1)",
            "answer": "concatenate",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_38",
            "model_output": "['<start>concatenate1 = np.concatenate((image1, image2), axis=1)<end>', '<start>concatenate1 = np.concatenate((image1, image2), axis=1)<end>', '<start>concatenate1 = np.concatenate((image1, image2), axis=1)<end>', '<start>concatenate1 = np.concatenate((image1, image2), axis=1)<end>', '<start>concatenate1 = np.concatenate((image1, image2), axis=1)<end>', '<start>concatenate1 = np.concatenate((image1, image2), axis=1)<end>']",
            "model_output_token_clear": "['concatenate1 = np.concatenate((image1, image2), axis=1)', 'concatenate1 = np.concatenate((image1, image2), axis=1)', 'concatenate1 = np.concatenate((image1, image2), axis=1)', 'concatenate1 = np.concatenate((image1, image2), axis=1)', 'concatenate1 = np.concatenate((image1, image2), axis=1)', 'concatenate1 = np.concatenate((image1, image2), axis=1)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-04-08",
            "description": "This code snippet creates an LSTM cell with 10 units using Glorot uniform initialization in TensorFlow 2.x.",
            "code": "import tensorflow.compat.v1 as tf1\ntf1.disable_v2_behavior() \nimport tensorflow as tf2 #Tensorflow 2.x\n\ntf2.compat.v1.nn.rnn_cell.LSTMCell(num_units=10,\n                            state_is_tuple=True,\n                            initializer= tf2.initializers.GlorotUniform()\n                           )",
            "masked_code": "import tensorflow.compat.v1 as tf1\ntf1.disable_v2_behavior() \nimport tensorflow as tf2 #Tensorflow 2.x\n\n<line_mask>\n                            state_is_tuple=True,\n                            initializer= tf2.initializers.GlorotUniform()\n                           )",
            "masked_line": "tf2.compat.v1.nn.rnn_cell.LSTMCell(num_units=10,",
            "answer": "nn",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_39",
            "model_output": "['<start>lstm_cell = tf2.keras.layers.LSTMCell(10,<end>', '<start>lstm_cell = tf2.keras.layers.LSTMCell(10,<end>', '<start>lstm_cell = tf2.nn.rnn_cell.LSTMCell(num_units=10,<end>', '<start>lstm_cell = tf2.keras.layers.LSTMCell(10,<end>', '<start>lstm_cell = tf2.keras.layers.LSTMCell(10,<end>', '<start{lstm_cell = tf2.keras.layers.LSTMCell(10, state_is_tuple=True, initializer= tf2.initializers.GlorotUniform())}<end>']",
            "model_output_token_clear": "['lstm_cell = tf2.keras.layers.LSTMCell(10,', 'lstm_cell = tf2.keras.layers.LSTMCell(10,', 'lstm_cell = tf2.nn.rnn_cell.LSTMCell(num_units=10,', 'lstm_cell = tf2.keras.layers.LSTMCell(10,', 'lstm_cell = tf2.keras.layers.LSTMCell(10,', 'no_answer']"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.4",
            "time": "2020-08-31",
            "description": "The code generates a list of 8 strings, each containing 3 randomly selected uppercase letters.",
            "code": "from itertools import combinations_with_replacement\nupperletters = map(chr, range(65, 91))\nprint(np.random.choice(list(map(''.join, \n                                combinations_with_replacement(upperletters, 3))), \n                       size=8, replace=False))\n#['JPZ' 'SSU' 'AQW' 'GKQ' 'AIZ' 'UYY' 'IJS' 'AOR']",
            "masked_code": "from itertools import combinations_with_replacement\nupperletters = map(chr, range(65, 91))\n<line_mask>\n                                combinations_with_replacement(upperletters, 3))), \n                       size=8, replace=False))\n#['JPZ' 'SSU' 'AQW' 'GKQ' 'AIZ' 'UYY' 'IJS' 'AOR']",
            "masked_line": "print(np.random.choice(list(map(''.join,",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_40",
            "model_output": "['<start>upperletters_list = list(upperletters)<end>', '<start>upperletters = list(upperletters)<end>', '<start>lowerletters = map(chr, range(97, 123)); upperletters = list(upperletters); random.sample(list(combinations_with_replacement(upperletters, 3))), <end>', \"<start>lowerletters = map(chr, range(97, 123)); upperletters_with_three = list(map(''.join, combinations_with_replacement(upperletters, 3)))<end>\", '<start>upperletters_combinations = list(combinations_with_replacement(upperletters, 3))<end>', '<start>upperletters = list(upperletters)<end>']",
            "model_output_token_clear": "['upperletters_list = list(upperletters)', 'upperletters = list(upperletters)', 'lowerletters = map(chr, range(97, 123)); upperletters = list(upperletters); random.sample(list(combinations_with_replacement(upperletters, 3))), ', \"lowerletters = map(chr, range(97, 123)); upperletters_with_three = list(map(''.join, combinations_with_replacement(upperletters, 3)))\", 'upperletters_combinations = list(combinations_with_replacement(upperletters, 3))', 'upperletters = list(upperletters)']"
        },
        {
            "dependency": "networkx",
            "version": "==1.9.1",
            "time": "2021-09-24",
            "description": "The code identifies the connected components in the graph G.",
            "code": "list(nx.connected_components(G))",
            "masked_code": "<line_mask>",
            "masked_line": "list(nx.connected_components(G))",
            "answer": "connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_41",
            "model_output": "['<start>comp, hist = label_components(g)<end>', '<start>ccs = list(nx.connected_components(G))<end>', '<start>ccs = list(nx.connected_components(G))<end>', '<start>connected_components = list(nx.connected_components(G))<end>', '<start>comp, hist = label_components(g)<end>', '<start>comp, hist = label_components(g)<end>']",
            "model_output_token_clear": "['comp, hist = label_components(g)', 'ccs = list(nx.connected_components(G))', 'ccs = list(nx.connected_components(G))', 'connected_components = list(nx.connected_components(G))', 'comp, hist = label_components(g)', 'comp, hist = label_components(g)']"
        },
        {
            "dependency": "networkx",
            "version": "==1.9.1",
            "time": "2021-09-24",
            "description": "This code filters out connected components in graph G with a length less than the threshold value of 6.",
            "code": "threshold = 6\n[c for c in nx.connected_components(G) if len(c) < threshold]",
            "masked_code": "threshold = 6\n<line_mask>",
            "masked_line": "[c for c in nx.connected_components(G) if len(c) < threshold]",
            "answer": "connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_42",
            "model_output": "['<start>components = list(nx.connected_components(G))<end>', '<start>G.remove_nodes_from(GC)<end>', '<start>components = list(nx.connected_components(G))<end>', '<start>components = list(nx.connected_components(G))<end>', '<start>components = list(nx.connected_components(G))<end>', '<start>components = list(nx.connected_components(G))<end>']",
            "model_output_token_clear": "['components = list(nx.connected_components(G))', 'G.remove_nodes_from(GC)', 'components = list(nx.connected_components(G))', 'components = list(nx.connected_components(G))', 'components = list(nx.connected_components(G))', 'components = list(nx.connected_components(G))']"
        },
        {
            "dependency": "bokeh",
            "version": ">=3.2.0",
            "time": "2021-02-17",
            "description": "This code generates a candlestick chart with volume for the Microsoft (MSFT) stock data provided in the Bokeh sample data. The chart displays candlesticks representing open, high, low, and close prices for the stock, as well as a volume bar chart. The chart includes interactive tools such as pan, zoom, and reset.",
            "code": "import pandas as pd\nimport numpy as np\nfrom bokeh.plotting import figure, output_notebook, show\nfrom bokeh.sampledata.stocks import MSFT\nfrom bokeh.models import LinearAxis, Range1d, Segment, Legend\noutput_notebook()\n\ndf = pd.DataFrame(MSFT)[:50]\ndf[\"date\"] = pd.to_datetime(df[\"date\"])\ninc = df.close > df.open\ndec = df.open > df.close\nw = 12*60*60*1000 # half day in ms\n\nTOOLS = \"pan,wheel_zoom,box_zoom,reset,save\"\np = figure(\n    x_axis_type=\"datetime\",\n    tools=TOOLS,\n    width=700,\n    height=300,\n    title = \"MSFT Candlestick with Volume\"\n)\np.add_layout(Legend(click_policy=\"hide\", orientation='horizontal', spacing=20), 'below')\n# left y axis\nlow, high  = df[['open', 'close']].min().min(), df[['open', 'close']].max().max()\ndiff = high-low\np.y_range = Range1d(low-0.1*diff, high+0.1*diff)\np.yaxis.axis_label = 'Price'\np.segment(df.date, df.high, df.date, df.low, color=\"black\", legend_label='Candlestick')\np.vbar(df.date[inc], w, df.open[inc], df.close[inc], \n       fill_color=\"#D5E1DD\", line_color=\"black\", legend_label='Candlestick')\np.vbar(df.date[dec], w, df.open[dec], df.close[dec], \n       fill_color=\"#F2583E\", line_color=\"black\", legend_label='Candlestick')\n# right y axis\np.extra_y_ranges.update({'two':  Range1d(0, 1.1*df.volume.max())})\np.add_layout(LinearAxis(y_range_name='two', axis_label='Volume' ), 'right')\np.vbar(df.date, w, df.volume, [0]*df.shape[0], alpha=0.5, level='underlay', \n       legend_label='Volume', y_range_name='two')\nwheel_zoom = p.toolbar.tools[1]\nwheel_zoom.zoom_together='none' # can be 'none', 'cross', 'all'\np.toolbar.active_scroll = wheel_zoom\nshow(p)",
            "masked_code": "import pandas as pd\nimport numpy as np\nfrom bokeh.plotting import figure, output_notebook, show\nfrom bokeh.sampledata.stocks import MSFT\nfrom bokeh.models import LinearAxis, Range1d, Segment, Legend\noutput_notebook()\n\ndf = pd.DataFrame(MSFT)[:50]\ndf[\"date\"] = pd.to_datetime(df[\"date\"])\ninc = df.close > df.open\ndec = df.open > df.close\nw = 12*60*60*1000 # half day in ms\n\nTOOLS = \"pan,wheel_zoom,box_zoom,reset,save\"\np = figure(\n    x_axis_type=\"datetime\",\n    tools=TOOLS,\n    width=700,\n    height=300,\n    title = \"MSFT Candlestick with Volume\"\n)\np.add_layout(Legend(click_policy=\"hide\", orientation='horizontal', spacing=20), 'below')\n# left y axis\nlow, high  = df[['open', 'close']].min().min(), df[['open', 'close']].max().max()\ndiff = high-low\np.y_range = Range1d(low-0.1*diff, high+0.1*diff)\np.yaxis.axis_label = 'Price'\np.segment(df.date, df.high, df.date, df.low, color=\"black\", legend_label='Candlestick')\np.vbar(df.date[inc], w, df.open[inc], df.close[inc], \n       fill_color=\"#D5E1DD\", line_color=\"black\", legend_label='Candlestick')\np.vbar(df.date[dec], w, df.open[dec], df.close[dec], \n       fill_color=\"#F2583E\", line_color=\"black\", legend_label='Candlestick')\n# right y axis\np.extra_y_ranges.update({'two':  Range1d(0, 1.1*df.volume.max())})\n<line_mask>\np.vbar(df.date, w, df.volume, [0]*df.shape[0], alpha=0.5, level='underlay', \n       legend_label='Volume', y_range_name='two')\nwheel_zoom = p.toolbar.tools[1]\nwheel_zoom.zoom_together='none' # can be 'none', 'cross', 'all'\np.toolbar.active_scroll = wheel_zoom\nshow(p)",
            "masked_line": "p.add_layout(LinearAxis(y_range_name='two', axis_label='Volume' ), 'right')",
            "answer": "add_layout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_43",
            "model_output": "[\"<start>p.extra_y_ranges['two'] = Range1d(0, 1.1*df.volume.max())<end>\", \"<start>p.extra_y_ranges.update({'two':  Range1d(start=0, end=1.1*df.volume.max())})<end>\", \"<start>p.extra_y_ranges['two'] = Range1d(0, 1.1*df.volume.max())<end>\", \"<start>p.add_layout(LinearAxis(y_range_name='two', axis_label='Volume'), 'right')<end>\", \"<start>p.extra_y_ranges['two'] = Range1d(0, 1.1*df.volume.max())<end>\", \"<start>p.extra_y_ranges.update({'two':  Range1d(start=0, end=1.1*df.volume.max())})<end>\"]",
            "model_output_token_clear": "[\"p.extra_y_ranges['two'] = Range1d(0, 1.1*df.volume.max())\", \"p.extra_y_ranges.update({'two':  Range1d(start=0, end=1.1*df.volume.max())})\", \"p.extra_y_ranges['two'] = Range1d(0, 1.1*df.volume.max())\", \"p.add_layout(LinearAxis(y_range_name='two', axis_label='Volume'), 'right')\", \"p.extra_y_ranges['two'] = Range1d(0, 1.1*df.volume.max())\", \"p.extra_y_ranges.update({'two':  Range1d(start=0, end=1.1*df.volume.max())})\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-02",
            "description": "The code generates subplots displaying monthly consumption data. Each subplot represents a month, with consumption data plotted and weekends highlighted. The x-axis tick labels are formatted, and each subplot includes a title specifying the year and frequency of the data being displayed. Additionally, the space between subplots is adjusted for better visualization.",
            "code": "# Draw and format subplots by looping through months and flattened array of axes\nfig, axs = plt.subplots(4, 3, figsize=(10, 9), sharey=True)\nfor month, ax in zip(df.index.month.unique(), axs.flat):\n    # Select monthly data and plot it\n    df_month = df[df.index.month == month]\n    ax.plot(df_month.index, df_month['consumption'])\n    ax.set_ylim(0, 2500) # set limit similar to plot shown in question\n    \n    # Draw vertical spans for weekends: computing the timedelta and adding it\n    # to the date solves the problem of exceeding the df_month.index\n    timedelta = pd.to_timedelta(df_month.index.freq)\n    weekends = df_month.index[df_month.index.weekday>=5].to_series()\n    for date in weekends:\n        ax.axvspan(date, date+timedelta, facecolor='k', edgecolor=None, alpha=.1)\n    \n    # Format tick labels\n    ax.set_xticks(ax.get_xticks())\n    tk_labels = [pd.to_datetime(tk, unit='D').strftime('%d') for tk in ax.get_xticks()]\n    ax.set_xticklabels(tk_labels, rotation=0, ha='center')\n    \n    # Add x labels for months\n    ax.set_xlabel(df_month.index[0].month_name().upper(), labelpad=5)\n    ax.xaxis.set_label_position('top')\n\n# Add title and edit spaces between subplots\nyear = df.index[0].year\nfreq = df_month.index.freqstr\ntitle = f'{year} consumption displayed for each month with a {freq} frequency'\nfig.suptitle(title.upper(), y=0.95, fontsize=12)\nfig.subplots_adjust(wspace=0.1, hspace=0.5)\n\nfig.text(0.5, 0.99, 'Weekends are highlighted by using the DatetimeIndex',\n         ha='center', fontsize=14, weight='semibold');",
            "masked_code": "# Draw and format subplots by looping through months and flattened array of axes\nfig, axs = plt.subplots(4, 3, figsize=(10, 9), sharey=True)\nfor month, ax in zip(df.index.month.unique(), axs.flat):\n    # Select monthly data and plot it\n    df_month = df[df.index.month == month]\n    ax.plot(df_month.index, df_month['consumption'])\n    ax.set_ylim(0, 2500) # set limit similar to plot shown in question\n    \n    # Draw vertical spans for weekends: computing the timedelta and adding it\n    # to the date solves the problem of exceeding the df_month.index\n    timedelta = pd.to_timedelta(df_month.index.freq)\n    weekends = df_month.index[df_month.index.weekday>=5].to_series()\n    for date in weekends:\n        ax.axvspan(date, date+timedelta, facecolor='k', edgecolor=None, alpha=.1)\n    \n    # Format tick labels\n    ax.set_xticks(ax.get_xticks())\n    tk_labels = [pd.to_datetime(tk, unit='D').strftime('%d') for tk in ax.get_xticks()]\n    ax.set_xticklabels(tk_labels, rotation=0, ha='center')\n    \n    # Add x labels for months\n    ax.set_xlabel(df_month.index[0].month_name().upper(), labelpad=5)\n    ax.xaxis.set_label_position('top')\n\n# Add title and edit spaces between subplots\nyear = df.index[0].year\nfreq = df_month.index.freqstr\ntitle = f'{year} consumption displayed for each month with a {freq} frequency'\n<line_mask>\nfig.subplots_adjust(wspace=0.1, hspace=0.5)\n\nfig.text(0.5, 0.99, 'Weekends are highlighted by using the DatetimeIndex',\n         ha='center', fontsize=14, weight='semibold');",
            "masked_line": "fig.suptitle(title.upper(), y=0.95, fontsize=12)",
            "answer": "suptitle",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_44",
            "model_output": "['<start>fig.suptitle(title)<end>', '<start>fig.suptitle(title, fontsize=16, y=1.02)<end>', '<start>fig.tight_layout()<end>', '<start>fig.suptitle(title, fontsize=16)<end>', '<start>fig.suptitle(title, fontsize=16)<end>', '<start>fig.suptitle(title)<end>']",
            "model_output_token_clear": "['fig.suptitle(title)', 'fig.suptitle(title, fontsize=16, y=1.02)', 'fig.tight_layout()', 'fig.suptitle(title, fontsize=16)', 'fig.suptitle(title, fontsize=16)', 'fig.suptitle(title)']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-02",
            "description": "This code generates subplots for each month of data, plots monthly consumption data, sets y-axis limits, highlights weekends on the plot, creates appropriate date ticks, adds x labels for months, and displays a title with consumption data for each month.",
            "code": "# Draw and format subplots by looping through months and flattened array of axes\nfig, axs = plt.subplots(4, 3, figsize=(10, 9), sharey=True)\nfor month, ax in zip(df.index.month.unique(), axs.flat):\n    # Select monthly data and plot it\n    df_month = df[df.index.month == month]\n    ax.plot(df_month.index, df_month['consumption'])\n    ax.set_ylim(0, 2500) # set limit like plot shown in question, or use next line\n#     ax.set_ylim(*ax.get_ylim())\n    \n    # Highlight weekends based on the x-axis units, regardless of the DatetimeIndex\n    xmin, xmax = ax.get_xlim()\n    days = np.arange(np.floor(xmin), np.ceil(xmax)+2)\n    weekends = [(dt.weekday()>=5)|(dt.weekday()==0) for dt in mdates.num2date(days)]\n    ax.fill_between(days, *ax.get_ylim(), where=weekends, facecolor='k', alpha=.1)\n    ax.set_xlim(xmin, xmax) # set limits back to default values\n     \n    # Create appropriate ticks with matplotlib date tick locator and formatter\n    tick_loc = mdates.MonthLocator(bymonthday=np.arange(1, 31, step=5))\n    ax.xaxis.set_major_locator(tick_loc)\n    tick_fmt = mdates.DateFormatter('%d')\n    ax.xaxis.set_major_formatter(tick_fmt)\n    \n    # Add x labels for months\n    ax.set_xlabel(df_month.index[0].month_name().upper(), labelpad=5)\n    ax.xaxis.set_label_position('top')\n\n# Add title and edit spaces between subplots\nyear = df.index[0].year\nfreq = df_month.index.freqstr\ntitle = f'{year} consumption displayed for each month with a {freq} frequency'\nfig.suptitle(title.upper(), y=0.95, fontsize=12)\nfig.subplots_adjust(wspace=0.1, hspace=0.5)\nfig.text(0.5, 0.99, 'Weekends are highlighted by using the x-axis units',\n         ha='center', fontsize=14, weight='semibold');",
            "masked_code": "# Draw and format subplots by looping through months and flattened array of axes\nfig, axs = plt.subplots(4, 3, figsize=(10, 9), sharey=True)\nfor month, ax in zip(df.index.month.unique(), axs.flat):\n    # Select monthly data and plot it\n    df_month = df[df.index.month == month]\n    ax.plot(df_month.index, df_month['consumption'])\n    ax.set_ylim(0, 2500) # set limit like plot shown in question, or use next line\n#     ax.set_ylim(*ax.get_ylim())\n    \n    # Highlight weekends based on the x-axis units, regardless of the DatetimeIndex\n    xmin, xmax = ax.get_xlim()\n    days = np.arange(np.floor(xmin), np.ceil(xmax)+2)\n    weekends = [(dt.weekday()>=5)|(dt.weekday()==0) for dt in mdates.num2date(days)]\n    ax.fill_between(days, *ax.get_ylim(), where=weekends, facecolor='k', alpha=.1)\n    ax.set_xlim(xmin, xmax) # set limits back to default values\n     \n    # Create appropriate ticks with matplotlib date tick locator and formatter\n    tick_loc = mdates.MonthLocator(bymonthday=np.arange(1, 31, step=5))\n    ax.xaxis.set_major_locator(tick_loc)\n    tick_fmt = mdates.DateFormatter('%d')\n    ax.xaxis.set_major_formatter(tick_fmt)\n    \n    # Add x labels for months\n    ax.set_xlabel(df_month.index[0].month_name().upper(), labelpad=5)\n    ax.xaxis.set_label_position('top')\n\n# Add title and edit spaces between subplots\nyear = df.index[0].year\nfreq = df_month.index.freqstr\ntitle = f'{year} consumption displayed for each month with a {freq} frequency'\n<line_mask>\nfig.subplots_adjust(wspace=0.1, hspace=0.5)\nfig.text(0.5, 0.99, 'Weekends are highlighted by using the x-axis units',\n         ha='center', fontsize=14, weight='semibold');",
            "masked_line": "fig.suptitle(title.upper(), y=0.95, fontsize=12)",
            "answer": "suptitle",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_45",
            "model_output": "['<start>fig.suptitle(title)<end>', '<start>fig.suptitle(title)<end>', '<start>fig.suptitle(title)<end>', '<start>fig.suptitle(title)<end>', '<start>fig.suptitle(title)<end>', '<start>fig.suptitle(title)<end>']",
            "model_output_token_clear": "['fig.suptitle(title)', 'fig.suptitle(title)', 'fig.suptitle(title)', 'fig.suptitle(title)', 'fig.suptitle(title)', 'fig.suptitle(title)']"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.1",
            "time": "2022-02-25",
            "description": "The code creates a pandas DataFrame with columns 'A' and 'B' containing the values [1, 2] and [3, 4] respectively. It then uses a generator function to iterate over the records of the DataFrame and print each record. Additionally, it compares the output of the generator function with the to_dict method of the DataFrame when 'orient' parameter is set to 'records'.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({\n    'A': [1, 2],\n    'B': [3, 4]\n})\n\n# Using Generator\nfor row in dataframe_records_gen(df):\n    print(row)\n\n# For Comparison with to_dict function\nprint(\"to_dict\", df.to_dict(orient='records'))",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame({\n    'A': [1, 2],\n    'B': [3, 4]\n})\n\n# Using Generator\nfor row in dataframe_records_gen(df):\n    print(row)\n\n# For Comparison with to_dict function\n<line_mask>",
            "masked_line": "print(\"to_dict\", df.to_dict(orient='records'))",
            "answer": "to_dict",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_46",
            "model_output": "[\"<start>print(df.to_dict('records'))<end>\", \"<start>print(df.to_dict('records'))<end>\", \"<start>print(df.to_dict('records'))<end>\", \"<start>print(df.to_dict('records'))<end>\", '<start>df = df.from_records(row) or df = df.append(row) or df = df.append(dict(row), ignore_index=True)<end>', '<start>df = df.from_records(row) or df = df.append(row)<end>']",
            "model_output_token_clear": "[\"print(df.to_dict('records'))\", \"print(df.to_dict('records'))\", \"print(df.to_dict('records'))\", \"print(df.to_dict('records'))\", 'df = df.from_records(row) or df = df.append(row) or df = df.append(dict(row), ignore_index=True)', 'df = df.from_records(row) or df = df.append(row)']"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.1",
            "time": "2022-02-25",
            "description": "This code creates a DataFrame with columns 'A' and 'B' and then loops through the DataFrame rows using a custom generator method 'records' and prints each row. It also compares this custom generator method output with the 'to_dict' function output using the 'orient' parameter set to 'records'.",
            "code": "df = pd.DataFrame({\n        'A': [1, 2],\n        'B': [3, 4]\n    })\n\n# Using Generator through registered custom accessor\nfor row in df.gen.records():\n    print(row)\n\n# For Comparison with to_dict function\nprint(\"to_dict\", df.to_dict(orient='records'))",
            "masked_code": "df = pd.DataFrame({\n        'A': [1, 2],\n        'B': [3, 4]\n    })\n\n# Using Generator through registered custom accessor\n<line_mask>\n    print(row)\n\n# For Comparison with to_dict function\nprint(\"to_dict\", df.to_dict(orient='records'))",
            "masked_line": "for row in df.gen.records():",
            "answer": "gen",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_47",
            "model_output": "['<start>for index, row in df.iterrows():<end>', '<start>df.apply(lambda row: dict(row), axis=1)<end>', '<start>df.iterrows().records()<end>', '<start>for row in df.itertuples(index=False):<end>', '<start>for index, row in df.iterrows():<end>', '<start>df.records = df.apply(lambda row: dict(row), axis=1)<end>']",
            "model_output_token_clear": "['for index, row in df.iterrows():', 'df.apply(lambda row: dict(row), axis=1)', 'df.iterrows().records()', 'for row in df.itertuples(index=False):', 'for index, row in df.iterrows():', 'df.records = df.apply(lambda row: dict(row), axis=1)']"
        },
        {
            "dependency": "cartopy",
            "version": "==0.19.0",
            "time": "2022-08-24",
            "description": "The code generates a polar stereographic map centered around the North Pole with coastlines, oceans, and land features displayed. It sets specific longitude and latitude extents for the map, adds gridlines with labeled coordinates, and includes a text annotation indicating the data source.",
            "code": "import matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport numpy as np\nimport matplotlib.ticker as mticker\nfrom matplotlib.offsetbox import AnchoredText\n\nfig = plt.figure(figsize=(5,5))\n\nprojection = ccrs.NorthPolarStereo(central_longitude=-100)\n\nax = plt.subplot(projection=projection)\nax.set_extent([-180, 179.9, 65, 90], ccrs.PlateCarree())\n#ax.set_extent([0, 360, 65, 90], crs=ccrs.PlateCarree())\n\nax.add_feature(cfeature.COASTLINE, color=\"gray\", lw=0.75)\nax.add_feature(cfeature.OCEAN)\nax.add_feature(cfeature.LAND)\n\nxticks = np.arange(-180, 181, 30)\nyticks = np.arange(70, 91, 10)\n\ngl = ax.gridlines(crs=ccrs.PlateCarree(), \n                  color='gray', \n                  draw_labels=True, \n                  dms=True, \n                  x_inline=False, \n                  y_inline=True)\n\ngl.ylocator = mticker.FixedLocator(yticks)\ngl.xlocator = mticker.FixedLocator(xticks)\ngl.xlabel_style = {'rotation':0}\n\ntext = AnchoredText(' Natural Earth; license: public domain',\n                    loc=4, prop={'size': 10}, frameon=True)\n\nax.add_artist(text)\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nimport numpy as np\nimport matplotlib.ticker as mticker\nfrom matplotlib.offsetbox import AnchoredText\n\nfig = plt.figure(figsize=(5,5))\n\nprojection = ccrs.NorthPolarStereo(central_longitude=-100)\n\nax = plt.subplot(projection=projection)\n<line_mask>\n#ax.set_extent([0, 360, 65, 90], crs=ccrs.PlateCarree())\n\nax.add_feature(cfeature.COASTLINE, color=\"gray\", lw=0.75)\nax.add_feature(cfeature.OCEAN)\nax.add_feature(cfeature.LAND)\n\nxticks = np.arange(-180, 181, 30)\nyticks = np.arange(70, 91, 10)\n\ngl = ax.gridlines(crs=ccrs.PlateCarree(), \n                  color='gray', \n                  draw_labels=True, \n                  dms=True, \n                  x_inline=False, \n                  y_inline=True)\n\ngl.ylocator = mticker.FixedLocator(yticks)\ngl.xlocator = mticker.FixedLocator(xticks)\ngl.xlabel_style = {'rotation':0}\n\ntext = AnchoredText(' Natural Earth; license: public domain',\n                    loc=4, prop={'size': 10}, frameon=True)\n\nax.add_artist(text)\n\nplt.show()",
            "masked_line": "ax.set_extent([-180, 179.9, 65, 90], ccrs.PlateCarree())",
            "answer": "PlateCarree",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_48",
            "model_output": "['<start>ax.set_extent([-100, 40, 65, 90], crs=ccrs.PlateCarree())<end>', '<start>ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)<end>', '<start>ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)<end>', '<start>ax.set_extent([-100, 40, 65, 90], crs=ccrs.PlateCarree())<end>', '<start>ax.set_extent([-100, 60, 65, 90], crs=ccrs.PlateCarree())<end>', '<start>ax.set_extent([-100, 40, 65, 90], crs=ccrs.PlateCarree())<end>']",
            "model_output_token_clear": "['ax.set_extent([-100, 40, 65, 90], crs=ccrs.PlateCarree())', 'ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)', 'ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True)', 'ax.set_extent([-100, 40, 65, 90], crs=ccrs.PlateCarree())', 'ax.set_extent([-100, 60, 65, 90], crs=ccrs.PlateCarree())', 'ax.set_extent([-100, 40, 65, 90], crs=ccrs.PlateCarree())']"
        },
        {
            "dependency": "pandas",
            "version": ">=1.5.0",
            "time": "2022-12-24",
            "description": "The code separates the genre information from the dataset and renames the genre column to \"Genre\", then concatenates the genre information with the review scores.",
            "code": "import pandas as pd\n\ngenre = pd.from_dummies(df.drop(columns=\"review_score\"))\npd.concat([genre[\"\"].rename(\"Genre\"), df[\"review_score\"]], axis=1)",
            "masked_code": "import pandas as pd\n\ngenre = pd.from_dummies(df.drop(columns=\"review_score\"))\n<line_mask>",
            "masked_line": "pd.concat([genre[\"\"].rename(\"Genre\"), df[\"review_score\"]], axis=1)",
            "answer": "rename",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_49",
            "model_output": "[\"<start>genre = df.dot(df.columns + ' ')<end>\", \"<start>genre = df.dot(df.columns + ', ').str.rstrip(', ')<end>\", \"<start>genre = df.dot(df.columns + ' ')<end>\", \"<start>genre = df.dot(df.columns + ' ')<end>\", \"<start>genre = df.dot(df.columns + ' ').str.rstrip(' ')<end>\", \"<start>genre = df.dot(df.columns + ' ')<end>\"]",
            "model_output_token_clear": "[\"genre = df.dot(df.columns + ' ')\", \"genre = df.dot(df.columns + ', ').str.rstrip(', ')\", \"genre = df.dot(df.columns + ' ')\", \"genre = df.dot(df.columns + ' ')\", \"genre = df.dot(df.columns + ' ').str.rstrip(' ')\", \"genre = df.dot(df.columns + ' ')\"]"
        },
        {
            "dependency": "gspread",
            "version": "==5.7.0",
            "time": "2022-12-06",
            "description": "This code opens a Google Sheets document titled \"Sheet1\" and selects the first worksheet from that document.",
            "code": "import gspread\ngc = gspread.service_account()\nworksheet = gc.open(\"Sheet1\").sheet1",
            "masked_code": "import gspread\ngc = gspread.service_account()\n<line_mask>",
            "masked_line": "worksheet = gc.open(\"Sheet1\").sheet1",
            "answer": "open",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_50",
            "model_output": "['<start>sh = gc.open(\"Sheet1\").sheet1<end>', '<start>sh = gc.open(\"Sheet1\").sheet1<end>', '<start>sh = gc.open(\"Sheet1\").sheet1<end>', '<start>sh = gc.open(\"Sheet1\").sheet1<end>', '<start>sh = gc.open(\"Sheet1\").sheet1<end>', '<start>sh = gc.open(\"Sheet1\").sheet1<end>']",
            "model_output_token_clear": "['sh = gc.open(\"Sheet1\").sheet1', 'sh = gc.open(\"Sheet1\").sheet1', 'sh = gc.open(\"Sheet1\").sheet1', 'sh = gc.open(\"Sheet1\").sheet1', 'sh = gc.open(\"Sheet1\").sheet1', 'sh = gc.open(\"Sheet1\").sheet1']"
        },
        {
            "dependency": "tweepy",
            "version": "==4.x.x",
            "time": "2022-08-11",
            "description": "This code is for unfollowing users on Twitter who are not following you back. It retrieves the IDs of your followers and friends, checks for users you are following who are not following you back, and unfollows them. Finally, it prints the number of users you are currently following.",
            "code": "import tweepy\nfrom cred import *\n\nauth = tweepy.OAuthHandler(consumer_key, consumer_secret)\nauth.set_access_token(access_token, access_token_secret)\n\napi = tweepy.API(auth, wait_on_rate_limit=True)\n\n\ndef unfollower():\n\n    followers = api.get_follower_ids(screen_name=api.verify_credentials().screen_name)\n    friends = api.get_friend_ids(screen_name=api.verify_credentials().screen_name)\n    print(\"You follow:\", len(friends))    \n    \n    for friend in friends[::-1]:\n        if friend not in followers:\n            api.destroy_friendship(user_id = friend)\n        else:\n            pass\n        \n    friends = api.friends_ids(screen_name=api.me().screen_name)\n    print(\"Now you're following:\", len(friends))\n\nunfollower()",
            "masked_code": "import tweepy\nfrom cred import *\n\nauth = tweepy.OAuthHandler(consumer_key, consumer_secret)\nauth.set_access_token(access_token, access_token_secret)\n\napi = tweepy.API(auth, wait_on_rate_limit=True)\n\n\ndef unfollower():\n\n    followers = api.get_follower_ids(screen_name=api.verify_credentials().screen_name)\n    friends = api.get_friend_ids(screen_name=api.verify_credentials().screen_name)\n    print(\"You follow:\", len(friends))    \n    \n    for friend in friends[::-1]:\n        if friend not in followers:\n            api.destroy_friendship(user_id = friend)\n        else:\n            pass\n        \n    <line_mask>\n    print(\"Now you're following:\", len(friends))\n\nunfollower()",
            "masked_line": "friends = api.friends_ids(screen_name=api.me().screen_name)",
            "answer": "me",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_51",
            "model_output": "['<start>friends = api.get_friend_ids(screen_name=api.me().screen_name)<end>', '<start>friends = api.get_friend_ids(screen_name=api.me().screen_name)<end>', '<start>friends = api.get_friend_ids(screen_name=api.me().screen_name)<end>', '<start>friends = api.get_friend_ids(screen_name=api.verify_credentials().screen_name)<end>', '<start>friends = api.get_friend_ids(screen_name=api.verify_credentials().screen_name)<end>', '<start>friends = api.get_friend_ids(screen_name=api.me().screen_name)<end>']",
            "model_output_token_clear": "['friends = api.get_friend_ids(screen_name=api.me().screen_name)', 'friends = api.get_friend_ids(screen_name=api.me().screen_name)', 'friends = api.get_friend_ids(screen_name=api.me().screen_name)', 'friends = api.get_friend_ids(screen_name=api.verify_credentials().screen_name)', 'friends = api.get_friend_ids(screen_name=api.verify_credentials().screen_name)', 'friends = api.get_friend_ids(screen_name=api.me().screen_name)']"
        },
        {
            "dependency": "selenium",
            "version": "==4.1.0",
            "time": "2022-01-17",
            "description": "The code initializes a Selenium Edge webdriver with logging capabilities and retrieves and prints the browser logs.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities\n\nd = DesiredCapabilities.EDGE\nd['ms:loggingPrefs'] = { 'browser':'ALL' }\n\ndriver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\Users\\Administrator\\Desktop\\msedgedriver.exe\")\ndriver.get('')\n\nentry = driver.get_log(\"browser\")\nprint(entry)",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities\n\nd = DesiredCapabilities.EDGE\nd['ms:loggingPrefs'] = { 'browser':'ALL' }\n\n<line_mask>\ndriver.get('')\n\nentry = driver.get_log(\"browser\")\nprint(entry)",
            "masked_line": "driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\Users\\Administrator\\Desktop\\msedgedriver.exe\")",
            "answer": "Edge",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_52",
            "model_output": "['<start>driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\msedgedriver.exe\")<end>', '<start>driver = webdriver.Edge(capabilities=d, executable_path=r\"path_to_your_edgedriver\")<end>', '<start>driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\msedgedriver.exe\")<end>', '<start>driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\msedgedriver.exe\")<end>', '<start>driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\\\\\Users\\\\\\\\myuser\\\\\\\\Documents\\\\\\\\edgedriver_win64\\\\\\\\msedgedriver.exe\")<end>', '<start>driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\\\\\Users\\\\\\\\myuser\\\\\\\\Documents\\\\\\\\edgedriver_win64\\\\\\\\msedgedriver.exe\")<end>']",
            "model_output_token_clear": "['driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\msedgedriver.exe\")', 'driver = webdriver.Edge(capabilities=d, executable_path=r\"path_to_your_edgedriver\")', 'driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\msedgedriver.exe\")', 'driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\msedgedriver.exe\")', 'driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\\\\\Users\\\\\\\\myuser\\\\\\\\Documents\\\\\\\\edgedriver_win64\\\\\\\\msedgedriver.exe\")', 'driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\\\\\\\Users\\\\\\\\myuser\\\\\\\\Documents\\\\\\\\edgedriver_win64\\\\\\\\msedgedriver.exe\")']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.6.0",
            "time": "2022-10-09",
            "description": "This code creates a GUI window using tkinter library with two sine wave plots generated randomly with different scales every time the \"Draw\" button is pressed. The plots are displayed using matplotlib library within the GUI window, and the window can be resized to adjust the plot size.",
            "code": "import tkinter as tk\n\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\nfrom matplotlib.figure import Figure\nimport numpy as np\n\n# --- functions ---\n\ndef draw_plots():\n    x = np.arange(0, 3.01, .01)\n\n    scale = np.random.randint(1, 10)\n    y1 = scale * np.sin(scale * np.pi * x)\n    \n    scale = np.random.randint(1, 10)\n    y2 = scale * np.sin(scale * np.pi * x)\n\n    ax.clear()   # remove previous plots\n    #ax.grid(True)\n\n    ax.plot(x, y1)\n    ax.plot(x, y2)\n    \n    canvas.draw()  # refresh window\n    \n# --- main ---\n\nroot = tk.Tk()\n\nfig = Figure()  # Figure(figsize=(5, 4), dpi=100)\ncanvas = FigureCanvasTkAgg(fig, master=root)\ncanvas.get_tk_widget().pack(fill='both', expand=True)  # resize plot when window is resized\n\nax = fig.add_subplot(111)\n#ax.grid(True)\n\nbutton = tk.Button(root, text='Draw', command=draw_plots)\nbutton.pack()\n\ntk.mainloop()",
            "masked_code": "import tkinter as tk\n\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\nfrom matplotlib.figure import Figure\nimport numpy as np\n\n# --- functions ---\n\ndef draw_plots():\n    x = np.arange(0, 3.01, .01)\n\n    scale = np.random.randint(1, 10)\n    y1 = scale * np.sin(scale * np.pi * x)\n    \n    scale = np.random.randint(1, 10)\n    y2 = scale * np.sin(scale * np.pi * x)\n\n    ax.clear()   # remove previous plots\n    #ax.grid(True)\n\n    ax.plot(x, y1)\n    ax.plot(x, y2)\n    \n    <line_mask>\n    \n# --- main ---\n\nroot = tk.Tk()\n\nfig = Figure()  # Figure(figsize=(5, 4), dpi=100)\ncanvas = FigureCanvasTkAgg(fig, master=root)\ncanvas.get_tk_widget().pack(fill='both', expand=True)  # resize plot when window is resized\n\nax = fig.add_subplot(111)\n#ax.grid(True)\n\nbutton = tk.Button(root, text='Draw', command=draw_plots)\nbutton.pack()\n\ntk.mainloop()",
            "masked_line": "canvas.draw()  # refresh window",
            "answer": "draw",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_53",
            "model_output": "['<start>canvas.draw()<end>', '<start>canvas.draw()<end>', '<start>canvas.draw()<end>', '<start>canvas.draw()<end>', '<start>canvas.draw()<end>', '<start>canvas.draw()<end>']",
            "model_output_token_clear": "['canvas.draw()', 'canvas.draw()', 'canvas.draw()', 'canvas.draw()', 'canvas.draw()', 'canvas.draw()']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.6.0",
            "time": "2022-10-09",
            "description": "This code creates a Tkinter GUI window with two subplots displaying sinusoidal plots of random amplitudes when a 'Draw' button is clicked. The plots are updated with new random data each time the button is clicked.",
            "code": "# author: Bartlomiej \"furas\" Burek (https://blog.furas.pl)\n# date: 2022.10.09\n# [python - Plots in Tkinter - Stack Overflow](https://stackoverflow.com/questions/73997593/plots-in-tkinter/)\n\n# [Embedding in Tk  Matplotlib 3.6.0 documentation](https://matplotlib.org/stable/gallery/user_interfaces/embedding_in_tk_sgskip.html)\n\nimport tkinter as tk\n\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\nfrom matplotlib.figure import Figure\nimport numpy as np\n\n# --- functions ---\n\ndef draw_plots():\n    x = np.arange(0, 3.01, .01)\n\n    scale = np.random.randint(1, 10)\n    y1 = scale * np.sin(scale * np.pi * x)\n    \n    scale = np.random.randint(1, 10)\n    y2 = scale * np.sin(scale * np.pi * x)\n\n    ax1.clear()   # remove previous plots\n    ax2.clear()   # remove previous plots\n    #ax1.grid(True)\n    #ax2.grid(True)    \n    \n    ax1.plot(x, y1)\n    ax2.plot(x, y2)\n    \n    canvas.draw()  # refresh window\n    \n# --- main ---\n\nroot = tk.Tk()\n\nfig = Figure()  # Figure(figsize=(5, 4), dpi=100)\ncanvas = FigureCanvasTkAgg(fig, master=root)\ncanvas.get_tk_widget().pack(fill='both', expand=True)  # resize plot when window is resized\n\nax1 = fig.add_subplot(211)\nax2 = fig.add_subplot(212)\n#ax1.grid(True)\n#ax2.grid(True)\n\nbutton = tk.Button(root, text='Draw', command=draw_plots)\nbutton.pack()\n\ntk.mainloop()",
            "masked_code": "# author: Bartlomiej \"furas\" Burek (https://blog.furas.pl)\n# date: 2022.10.09\n# [python - Plots in Tkinter - Stack Overflow](https://stackoverflow.com/questions/73997593/plots-in-tkinter/)\n\n# [Embedding in Tk  Matplotlib 3.6.0 documentation](https://matplotlib.org/stable/gallery/user_interfaces/embedding_in_tk_sgskip.html)\n\nimport tkinter as tk\n\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\nfrom matplotlib.figure import Figure\nimport numpy as np\n\n# --- functions ---\n\ndef draw_plots():\n    x = np.arange(0, 3.01, .01)\n\n    scale = np.random.randint(1, 10)\n    y1 = scale * np.sin(scale * np.pi * x)\n    \n    scale = np.random.randint(1, 10)\n    y2 = scale * np.sin(scale * np.pi * x)\n\n    ax1.clear()   # remove previous plots\n    <line_mask>\n    #ax1.grid(True)\n    #ax2.grid(True)    \n    \n    ax1.plot(x, y1)\n    ax2.plot(x, y2)\n    \n    canvas.draw()  # refresh window\n    \n# --- main ---\n\nroot = tk.Tk()\n\nfig = Figure()  # Figure(figsize=(5, 4), dpi=100)\ncanvas = FigureCanvasTkAgg(fig, master=root)\ncanvas.get_tk_widget().pack(fill='both', expand=True)  # resize plot when window is resized\n\nax1 = fig.add_subplot(211)\nax2 = fig.add_subplot(212)\n#ax1.grid(True)\n#ax2.grid(True)\n\nbutton = tk.Button(root, text='Draw', command=draw_plots)\nbutton.pack()\n\ntk.mainloop()",
            "masked_line": "ax2.clear()   # remove previous plots",
            "answer": "clear",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_54",
            "model_output": "['<start>ax1.plot(x, y1); ax2.plot(x, y2)<end>', '<start>ax1.plot(x, y1); ax2.plot(x, y2)<end>', '<start>ax1.plot(x, y1); ax2.plot(x, y2)<end>', '<start>ax1.plot(x, y1); ax2.plot(x, y2)<end>', '<start>ax1.plot(x, y1); ax2.plot(x, y2)<end>', '<start>ax1.plot(x, y1); ax2.plot(x, y2)<end>']",
            "model_output_token_clear": "['ax1.plot(x, y1); ax2.plot(x, y2)', 'ax1.plot(x, y1); ax2.plot(x, y2)', 'ax1.plot(x, y1); ax2.plot(x, y2)', 'ax1.plot(x, y1); ax2.plot(x, y2)', 'ax1.plot(x, y1); ax2.plot(x, y2)', 'ax1.plot(x, y1); ax2.plot(x, y2)']"
        },
        {
            "dependency": "APScheduler",
            "version": "==4.0.01a",
            "time": "2022-08-16",
            "description": "The code sets up two periodic tasks: one for extracting URLs every 15 minutes and another for checking URLs every 5 minutes. The tasks are scheduled to run asynchronously using the apscheduler library. The start times of the tasks are based on the current time and a predefined initial time.",
            "code": "from asyncio import run\nfrom datetime import datetime, timedelta\nfrom apscheduler.schedulers.async_ import AsyncScheduler\nfrom apscheduler.triggers.interval import IntervalTrigger\n\nfirst_run_time = datetime.now()\n\n\ndef periodic_extract_urls():\n    print(f'Extraction time: {datetime.now()}')\n    print(datetime.now() - first_run_time)\n    print('\\n')\n\n\ndef periodic_check_urls():\n    print(f'Checking time: {datetime.now()}')\n    print(datetime.now() - first_run_time)\n    print('\\n')\n\n\nasync def jobs():\n    async with AsyncScheduler() as scheduler:\n        await scheduler.add_schedule(func_or_task_id=periodic_extract_urls,\n                                     trigger=IntervalTrigger(minutes=15, start_time=first_run_time),\n                                     id=\"extract_urls\"\n                                     )\n\n        await scheduler.add_schedule(func_or_task_id=periodic_check_urls,\n                                     trigger=IntervalTrigger(minutes=5,\n                                                             start_time=first_run_time + timedelta(seconds=300)),\n                                     id=\"check_urls\"\n                                     )\n\n        await scheduler.wait_until_stopped()\n\n\nrun(jobs())",
            "masked_code": "from asyncio import run\nfrom datetime import datetime, timedelta\nfrom apscheduler.schedulers.async_ import AsyncScheduler\nfrom apscheduler.triggers.interval import IntervalTrigger\n\nfirst_run_time = datetime.now()\n\n\ndef periodic_extract_urls():\n    print(f'Extraction time: {datetime.now()}')\n    print(datetime.now() - first_run_time)\n    print('\\n')\n\n\ndef periodic_check_urls():\n    print(f'Checking time: {datetime.now()}')\n    print(datetime.now() - first_run_time)\n    print('\\n')\n\n\nasync def jobs():\n    async with AsyncScheduler() as scheduler:\n        await scheduler.add_schedule(func_or_task_id=periodic_extract_urls,\n                                     trigger=IntervalTrigger(minutes=15, start_time=first_run_time),\n                                     id=\"extract_urls\"\n                                     )\n\n        await scheduler.add_schedule(func_or_task_id=periodic_check_urls,\n                                     <line_mask>\n                                                             start_time=first_run_time + timedelta(seconds=300)),\n                                     id=\"check_urls\"\n                                     )\n\n        await scheduler.wait_until_stopped()\n\n\nrun(jobs())",
            "masked_line": "trigger=IntervalTrigger(minutes=5,",
            "answer": "IntervalTrigger",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_55",
            "model_output": "['<start>trigger=IntervalTrigger(minutes=5),<end>', '<start>trigger=IntervalTrigger(minutes=5),<end>', '<start>trigger=IntervalTrigger(minutes=5),<end>', '<start>trigger=IntervalTrigger(minutes=5),<end>', '<start>trigger=IntervalTrigger(minutes=5),<end>', '<start>trigger=IntervalTrigger(minutes=5),<end>']",
            "model_output_token_clear": "['trigger=IntervalTrigger(minutes=5),', 'trigger=IntervalTrigger(minutes=5),', 'trigger=IntervalTrigger(minutes=5),', 'trigger=IntervalTrigger(minutes=5),', 'trigger=IntervalTrigger(minutes=5),', 'trigger=IntervalTrigger(minutes=5),']"
        },
        {
            "dependency": "elasticsearch",
            "version": "==8.1.2",
            "time": "2022-04-15",
            "description": "This code generates random values for the field 'my_field' and adds them to a list. Every 1000 documents, it sends a bulk request to Elasticsearch to index these documents.",
            "code": "from elasticsearch import Elasticsearch, helpers\nfrom random import getrandbits\n\nes_client = Elasticsearch('https://elastic.host:9200')\n\ndocument_list = []\nfor i in range(1,10000000):\n    document = {'my_field': getrandbits(64)}\n    document_list.append(document)\n    if i % 1000 == 0:\n        helpers.bulk(es_client, document_list, index='my_index')\n        document_list = []",
            "masked_code": "from elasticsearch import Elasticsearch, helpers\nfrom random import getrandbits\n\n<line_mask>\n\ndocument_list = []\nfor i in range(1,10000000):\n    document = {'my_field': getrandbits(64)}\n    document_list.append(document)\n    if i % 1000 == 0:\n        helpers.bulk(es_client, document_list, index='my_index')\n        document_list = []",
            "masked_line": "es_client = Elasticsearch('https://elastic.host:9200')",
            "answer": "Elasticsearch",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_56",
            "model_output": "['<start>es_client = Elasticsearch()<end>', '<start>es_client = Elasticsearch()<end>', '<start>es_client = Elasticsearch()<end>', '<start>es_client = Elasticsearch()<end>', '<start>es_client = Elasticsearch()<end>', '<start>es_client = Elasticsearch()<end>']",
            "model_output_token_clear": "['es_client = Elasticsearch()', 'es_client = Elasticsearch()', 'es_client = Elasticsearch()', 'es_client = Elasticsearch()', 'es_client = Elasticsearch()', 'es_client = Elasticsearch()']"
        },
        {
            "dependency": "elasticsearch",
            "version": "==8.1.2",
            "time": "2022-04-15",
            "description": "The code generates random 64-bit integer values and inserts them into an Elasticsearch index in batches of 1000 documents.",
            "code": "from elasticsearch import Elasticsearch\nfrom random import getrandbits\n\nes_client = Elasticsearch('https://elastic.host:9200')\n\nactions_list = []\nfor i in range(1,10000000):\n    document = {'my_field': getrandbits(64)}\n    actions_list.append({\"index\": {}, \"doc\": document})\n    if i % 1000 == 0:\n        es_client.bulk(operations=actions_list, index='my_index')\n        actions_list = []",
            "masked_code": "<line_mask>\nfrom random import getrandbits\n\nes_client = Elasticsearch('https://elastic.host:9200')\n\nactions_list = []\nfor i in range(1,10000000):\n    document = {'my_field': getrandbits(64)}\n    actions_list.append({\"index\": {}, \"doc\": document})\n    if i % 1000 == 0:\n        es_client.bulk(operations=actions_list, index='my_index')\n        actions_list = []",
            "masked_line": "from elasticsearch import Elasticsearch",
            "answer": "Elasticsearch",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_57",
            "model_output": "['<start>actions_list.append({\"_index\": \"my_index\", \"doc\": document})<end>', '<start>actions_list.append({\"index\": {}, \"doc\": document})<end>', '<start>actions_list.append({\"_index\": \"my_index\", \"doc\": document})<end>', '<start>actions_list.append({\"_index\": \"my_index\", \"doc\": document})<end>', \"<start>es_client.bulk(index='my_index', body=actions_list)<end>\", '<start>actions_list.append({\"_index\": \"my_index\", \"doc\": document})<end>']",
            "model_output_token_clear": "['actions_list.append({\"_index\": \"my_index\", \"doc\": document})', 'actions_list.append({\"index\": {}, \"doc\": document})', 'actions_list.append({\"_index\": \"my_index\", \"doc\": document})', 'actions_list.append({\"_index\": \"my_index\", \"doc\": document})', \"es_client.bulk(index='my_index', body=actions_list)\", 'actions_list.append({\"_index\": \"my_index\", \"doc\": document})']"
        },
        {
            "dependency": "numpy",
            "version": "==1.23.2",
            "time": "2022-08-23",
            "description": "This code creates a function that takes a pandas DataFrame slice as input and returns a DataFrame containing styling information. The function sets the background color to silver for cells where the 'Value' column is less than 10.",
            "code": "def recolor_gray(df_slice: pd.DataFrame) -> pd.DataFrame:\n    # Create an empty DataFrame of styles\n    styles_df = pd.DataFrame('', index=df_slice.index, columns=df_slice.columns)\n    # Make background silver where Value is less than 10\n    styles_df['Procent'] = np.where(\n        # Ensure indexes align correctly\n        df_slice['Value'].reindex_like(df_slice['Procent']) < 10,\n        'background-color: silver', ''\n    )\n    # Return the styles\n    return styles_df",
            "masked_code": "def recolor_gray(df_slice: pd.DataFrame) -> pd.DataFrame:\n    # Create an empty DataFrame of styles\n    styles_df = pd.DataFrame('', index=df_slice.index, columns=df_slice.columns)\n    # Make background silver where Value is less than 10\n    <line_mask>\n        # Ensure indexes align correctly\n        df_slice['Value'].reindex_like(df_slice['Procent']) < 10,\n        'background-color: silver', ''\n    )\n    # Return the styles\n    return styles_df",
            "masked_line": "styles_df['Procent'] = np.where(",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_58",
            "model_output": "[\"<start>styles_df = df_slice['Value'].apply(lambda x: 'background-color: silver' if x < 10 else '')<end>\", \"<start>styles_df = df_slice['Value'].applymap(lambda x: 'background-color: silver' if x < 10 else '')<end>\", \"<start>styles_df = df_slice['Value'].apply(lambda x: 'background-color: silver' if x < 10 else '')<end>\", \"<start>styles_df = df_slice.style.applymap(lambda x: 'background-color: silver' if df_slice['Value'].reindex_like(df_slice['Procent']) < 10 else '')<end>\", \"<start>styles_df = df_slice['Value'].apply(lambda x: 'background-color: silver' if x < 10 else '')<end>\", \"<start>styles_df = df_slice['Value'].apply(lambda x: 'background-color: silver' if x < 10 else '')<end>\"]",
            "model_output_token_clear": "[\"styles_df = df_slice['Value'].apply(lambda x: 'background-color: silver' if x < 10 else '')\", \"styles_df = df_slice['Value'].applymap(lambda x: 'background-color: silver' if x < 10 else '')\", \"styles_df = df_slice['Value'].apply(lambda x: 'background-color: silver' if x < 10 else '')\", \"styles_df = df_slice.style.applymap(lambda x: 'background-color: silver' if df_slice['Value'].reindex_like(df_slice['Procent']) < 10 else '')\", \"styles_df = df_slice['Value'].apply(lambda x: 'background-color: silver' if x < 10 else '')\", \"styles_df = df_slice['Value'].apply(lambda x: 'background-color: silver' if x < 10 else '')\"]"
        },
        {
            "dependency": "numpy",
            "version": "==1.26.0",
            "time": "2023-12-06",
            "description": "The code generates a matrix `c` of size N x 2N, where the even columns contain the identity matrix of size N and the odd columns contain a diagonal matrix created from a given vector.",
            "code": "a = np.eye(N)\nb = np.diag(some_vector)\n\nc = np.empty((N, 2*N))\nc[:, 0::2] = a\nc[:, 1::2] = b",
            "masked_code": "<line_mask>\nb = np.diag(some_vector)\n\nc = np.empty((N, 2*N))\nc[:, 0::2] = a\nc[:, 1::2] = b",
            "masked_line": "a = np.eye(N)",
            "answer": "eye",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_59",
            "model_output": "['<start>a = np.eye(N)<end>', '<start>a = np.eye(N)<end>', '<start>a = np.eye(N)<end>', '<start>a = np.eye(N)<end>', '<start>a = np.eye(N)<end>', '<start>a = np.eye(N)<end>']",
            "model_output_token_clear": "['a = np.eye(N)', 'a = np.eye(N)', 'a = np.eye(N)', 'a = np.eye(N)', 'a = np.eye(N)', 'a = np.eye(N)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.26.0",
            "time": "2023-12-06",
            "description": "The code initializes a matrix of zeros with a size of 2n^2, sets specific elements of the matrix to 1 and some values from a vector, and then reshapes the matrix to a 2D array of size n by 2n.",
            "code": "some_matrix = np.zeros(2 * n**2)\n\nstep = 2 * (n + 1)\n\nsome_matrix[::step] = 1\nsome_matrix[1::step] = some_vector\nsome_matrix = some_matrix.reshape(n, 2 * n)",
            "masked_code": "some_matrix = np.zeros(2 * n**2)\n\nstep = 2 * (n + 1)\n\nsome_matrix[::step] = 1\nsome_matrix[1::step] = some_vector\n<line_mask>",
            "masked_line": "some_matrix = some_matrix.reshape(n, 2 * n)",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_60",
            "model_output": "['<start>some_matrix = some_matrix.reshape(n, -1)<end>', '<start>some_matrix = some_matrix.reshape(n, 2*n)<end>', '<start>some_matrix = some_matrix.reshape(n, 2 * n)<end>', '<start>some_matrix = some_matrix.reshape(n, -1)<end>', '<start>some_matrix = some_matrix.reshape(n, 2 * n)<end>', '<start>some_matrix = some_matrix.reshape(n, 2 * n)<end>']",
            "model_output_token_clear": "['some_matrix = some_matrix.reshape(n, -1)', 'some_matrix = some_matrix.reshape(n, 2*n)', 'some_matrix = some_matrix.reshape(n, 2 * n)', 'some_matrix = some_matrix.reshape(n, -1)', 'some_matrix = some_matrix.reshape(n, 2 * n)', 'some_matrix = some_matrix.reshape(n, 2 * n)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.26.0",
            "time": "2023-12-06",
            "description": "The code generates a matrix of size n by 2n with specific patterns depending on the function:\n\n1. original(n): Fills the matrix with elements from a random uniform vector in every other column, starting with 1 in the first column and the elements of the vector in the following column.\n\n2. variant_1(n): Constructs a matrix with the identity matrix and a diagonal matrix generated from a random uniform vector, interleaving them in the columns of the resulting matrix.\n\n3. variant_2(n): Builds a matrix by setting 1 in every 2 * (n + 1) elements and filling the rest with elements from a random uniform vector, reshaping the resulting array into an n by 2n matrix.",
            "code": "import numpy as np\n\n\ndef original(n):\n    some_vector = np.random.uniform(size=n)\n    some_matrix = np.zeros((n, 2 * n))\n\n    for i in range(n):\n        some_matrix[i, 2 * i] = 1\n        some_matrix[i, 2 * i + 1] = some_vector[i]\n\n\ndef variant_1(n):\n    some_vector = np.random.uniform(size=n)\n\n    a = np.eye(n)\n    b = np.diag(some_vector)\n    \n    c = np.empty((n, 2*n))\n    c[:, 0::2] = a\n    c[:, 1::2] = b\n\n\ndef variant_2(n):\n    some_vector = np.random.uniform(size=n)\n    \n    some_matrix = np.zeros(2 * n**2)\n    step = 2 * (n + 1)\n    some_matrix[::step] = 1\n    some_matrix[1::step] = some_vector\n    some_matrix = some_matrix.reshape(n, 2*n)",
            "masked_code": "import numpy as np\n\n\ndef original(n):\n    some_vector = np.random.uniform(size=n)\n    some_matrix = np.zeros((n, 2 * n))\n\n    for i in range(n):\n        some_matrix[i, 2 * i] = 1\n        some_matrix[i, 2 * i + 1] = some_vector[i]\n\n\ndef variant_1(n):\n    some_vector = np.random.uniform(size=n)\n\n    a = np.eye(n)\n    <line_mask>\n    \n    c = np.empty((n, 2*n))\n    c[:, 0::2] = a\n    c[:, 1::2] = b\n\n\ndef variant_2(n):\n    some_vector = np.random.uniform(size=n)\n    \n    some_matrix = np.zeros(2 * n**2)\n    step = 2 * (n + 1)\n    some_matrix[::step] = 1\n    some_matrix[1::step] = some_vector\n    some_matrix = some_matrix.reshape(n, 2*n)",
            "masked_line": "b = np.diag(some_vector)",
            "answer": "diag",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_61",
            "model_output": "['<start>b = np.diag(some_vector)<end>', '<start>b = np.diag(some_vector)<end>', '<start>b = np.diag(some_vector)<end>', '<start>b = np.diag(some_vector)<end>', '<start>b = np.diag(some_vector)<end>', '<start>b = np.diag(some_vector)<end>']",
            "model_output_token_clear": "['b = np.diag(some_vector)', 'b = np.diag(some_vector)', 'b = np.diag(some_vector)', 'b = np.diag(some_vector)', 'b = np.diag(some_vector)', 'b = np.diag(some_vector)']"
        },
        {
            "dependency": "openai",
            "version": ">=1.0.0",
            "time": "2023-05-31",
            "description": "The code makes an API request to OpenAI to generate completions using the GPT-3.5 model with the prompt \"Say this is a test\". If successful, it prints the response, otherwise it handles any OpenAI API errors.",
            "code": "import os\nfrom openai import OpenAI, OpenAIError\nclient = OpenAI()\nOpenAI.api_key = os.getenv('OPENAI_API_KEY')\n\ntry:\n  # Make your OpenAI API request here\n  response = client.completions.create(\n    model=\"gpt-3.5-turbo-instruct\",\n    prompt=\"Say this is a test\"\n  )\n  print(response)\nexcept OpenAIError as e:\n  # Handle all OpenAI API errors\n  print(f\"Error: {e}\")",
            "masked_code": "import os\nfrom openai import OpenAI, OpenAIError\nclient = OpenAI()\nOpenAI.api_key = os.getenv('OPENAI_API_KEY')\n\ntry:\n  # Make your OpenAI API request here\n  <line_mask>\n    model=\"gpt-3.5-turbo-instruct\",\n    prompt=\"Say this is a test\"\n  )\n  print(response)\nexcept OpenAIError as e:\n  # Handle all OpenAI API errors\n  print(f\"Error: {e}\")",
            "masked_line": "response = client.completions.create(",
            "answer": "create",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_62",
            "model_output": "['<start>response = client.Completion.create(model=\"gpt-3.5-turbo-instruct\", prompt=\"Say this is a test\")<end>', '<start>response = client.Completion.create(model=\"gpt-3.5-turbo-instruct\", prompt=\"Say this is a test\")<end>', '<start>response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")<end>', '<start>response = client.Completion.create(model=\"gpt-3.5-turbo-instruct\", prompt=\"Say this is a test\")<end>', '<start>response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")<end>', '<start>response = client.Completion.create(model=\"gpt-3.5-turbo-instruct\", prompt=\"Say this is a test\")<end>']",
            "model_output_token_clear": "['response = client.Completion.create(model=\"gpt-3.5-turbo-instruct\", prompt=\"Say this is a test\")', 'response = client.Completion.create(model=\"gpt-3.5-turbo-instruct\", prompt=\"Say this is a test\")', 'response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")', 'response = client.Completion.create(model=\"gpt-3.5-turbo-instruct\", prompt=\"Say this is a test\")', 'response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")', 'response = client.Completion.create(model=\"gpt-3.5-turbo-instruct\", prompt=\"Say this is a test\")']"
        },
        {
            "dependency": "openai",
            "version": ">=1.0.0",
            "time": "2023-05-31",
            "description": "This code is making a request to the OpenAI API using the GPT-3.5-turbo-instruct model with a prompt of \"Say this is a test\". It handles different types of errors that can occur during the API request, such as BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, UnprocessableEntityError, RateLimitError, InternalServerError, and APIConnectionError. It prints out the corresponding error message for each type of error.",
            "code": "import os\nimport openai # Import openai\nfrom openai import OpenAI # But don't import OpenAIError\nclient = OpenAI()\nOpenAI.api_key = os.getenv('OPENAI_API_KEY')\n\ntry:\n  # Make your OpenAI API request here\n  response = client.completions.create(\n    model=\"gpt-3.5-turbo-instruct\",\n    prompt=\"Say this is a test\"\n  )\n  print(response)\nexcept openai.BadRequestError as e: # Don't forget to add openai\n  # Handle error 400\n  print(f\"Error 400: {e}\")\nexcept openai.AuthenticationError as e: # Don't forget to add openai\n  # Handle error 401\n  print(f\"Error 401: {e}\")\nexcept openai.PermissionDeniedError as e: # Don't forget to add openai\n  # Handle error 403\n  print(f\"Error 403: {e}\")\nexcept openai.NotFoundError as e: # Don't forget to add openai\n  # Handle error 404\n  print(f\"Error 404: {e}\")\nexcept openai.UnprocessableEntityError as e: # Don't forget to add openai\n  # Handle error 422\n  print(f\"Error 422: {e}\")\nexcept openai.RateLimitError as e: # Don't forget to add openai\n  # Handle error 429\n  print(f\"Error 429: {e}\")\nexcept openai.InternalServerError as e: # Don't forget to add openai\n  # Handle error >=500\n  print(f\"Error >=500: {e}\")\nexcept openai.APIConnectionError as e: # Don't forget to add openai\n  # Handle API connection error\n  print(f\"API connection error: {e}\")",
            "masked_code": "import os\nimport openai # Import openai\nfrom openai import OpenAI # But don't import OpenAIError\nclient = OpenAI()\nOpenAI.api_key = os.getenv('OPENAI_API_KEY')\n\ntry:\n  # Make your OpenAI API request here\n  <line_mask>\n    model=\"gpt-3.5-turbo-instruct\",\n    prompt=\"Say this is a test\"\n  )\n  print(response)\nexcept openai.BadRequestError as e: # Don't forget to add openai\n  # Handle error 400\n  print(f\"Error 400: {e}\")\nexcept openai.AuthenticationError as e: # Don't forget to add openai\n  # Handle error 401\n  print(f\"Error 401: {e}\")\nexcept openai.PermissionDeniedError as e: # Don't forget to add openai\n  # Handle error 403\n  print(f\"Error 403: {e}\")\nexcept openai.NotFoundError as e: # Don't forget to add openai\n  # Handle error 404\n  print(f\"Error 404: {e}\")\nexcept openai.UnprocessableEntityError as e: # Don't forget to add openai\n  # Handle error 422\n  print(f\"Error 422: {e}\")\nexcept openai.RateLimitError as e: # Don't forget to add openai\n  # Handle error 429\n  print(f\"Error 429: {e}\")\nexcept openai.InternalServerError as e: # Don't forget to add openai\n  # Handle error >=500\n  print(f\"Error >=500: {e}\")\nexcept openai.APIConnectionError as e: # Don't forget to add openai\n  # Handle API connection error\n  print(f\"API connection error: {e}\")",
            "masked_line": "response = client.completions.create(",
            "answer": "completions",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_63",
            "model_output": "['<start>response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")<end>', '<start>response = client.create_completion(**{\"model\": \"gpt-3.5-turbo-instruct\", \"prompt\": \"Say this is a test\"})<end>', '<start>response = client.create_completion(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")<end>', '<start>response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")<end>', '<start>response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")<end>', '<start>response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")<end>']",
            "model_output_token_clear": "['response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")', 'response = client.create_completion(**{\"model\": \"gpt-3.5-turbo-instruct\", \"prompt\": \"Say this is a test\"})', 'response = client.create_completion(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")', 'response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")', 'response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")', 'response = client.Completion.create(prompt=\"Say this is a test\", model=\"gpt-3.5-turbo-instruct\")']"
        },
        {
            "dependency": "numpy",
            "version": ">=1.20.0",
            "time": "2023-01-13",
            "description": "The code creates a sliding window view of the 'data' array with a specified 'length'.",
            "code": "swindow = np.lib.stride_tricks.sliding_window_view(data, (length,))",
            "masked_code": "<line_mask>",
            "masked_line": "swindow = np.lib.stride_tricks.sliding_window_view(data, (length,))",
            "answer": "lib",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_64",
            "model_output": "['<start>data_sliding_window = np.lib.stride_tricks.sliding_window_view(data,length)<end>', '<start>data_sliding_window = numpy.array([data[i:i+length] for i in range(len(data)-length+1)])<end>', '<start>data_sliding_window = numpy.lib.stride_tricks.sliding_window_view(data,length)[(...,:-length+1)]<end>', '<start>result = [data[i:i + length] for i in range(len(data) - length + len(length == len(data))) or range(len(data) - length + len(length != len(data)))]<end>', '<start>data_strided = np.lib.stride_tricks.as_strided(data=(data), shape=(len(data)-length+1,length), strides=(data.strides[0],data.strides[0]))<end>', '<start>data_sliding_window = np.lib.stride_tricks.as_strided(data,None,(len(data)-length+1,length))[:(len(data)-length+1)]<end>']",
            "model_output_token_clear": "['data_sliding_window = np.lib.stride_tricks.sliding_window_view(data,length)', 'data_sliding_window = numpy.array([data[i:i+length] for i in range(len(data)-length+1)])', 'data_sliding_window = numpy.lib.stride_tricks.sliding_window_view(data,length)[(...,:-length+1)]', 'result = [data[i:i + length] for i in range(len(data) - length + len(length == len(data))) or range(len(data) - length + len(length != len(data)))]', 'data_strided = np.lib.stride_tricks.as_strided(data=(data), shape=(len(data)-length+1,length), strides=(data.strides[0],data.strides[0]))', 'data_sliding_window = np.lib.stride_tricks.as_strided(data,None,(len(data)-length+1,length))[:(len(data)-length+1)]']"
        },
        {
            "dependency": "numpy",
            "version": ">=1.20.0",
            "time": "2023-01-13",
            "description": "This function calculates the median of sliding windows of a given size within a given array.",
            "code": "def sliding_median(arr, window):\n    return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)",
            "masked_code": "def sliding_median(arr, window):\n    <line_mask>",
            "masked_line": "return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)",
            "answer": "median",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_65",
            "model_output": "['<start>return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)<end>', '<start>return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)<end>', '<start>return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)<end>', '<start>return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)<end>', '<start>return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)<end>', '<start>return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)<end>']",
            "model_output_token_clear": "['return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)', 'return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)', 'return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)', 'return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)', 'return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)', 'return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)']"
        },
        {
            "dependency": "numpy",
            "version": ">=1.20.0",
            "time": "2023-01-13",
            "description": "The code calculates the time taken for two different sliding median functions to run on arrays of various sizes, and then plots the time taken per function call against the array size on a logarithmic scale.",
            "code": "import timeit\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\ndef time_funcs(funcs, sizes, arg_gen, N=20):\n    times = np.zeros((len(sizes), len(funcs)))\n    gdict = globals().copy()\n    for i, s in enumerate(sizes):\n        args = arg_gen(s)\n        print(args)\n        for j, f in enumerate(funcs):\n            gdict.update(locals())\n            try:\n                times[i, j] = timeit.timeit(\"f(*args)\", globals=gdict, number=N) / N\n                print(f\"{i}/{len(sizes)}, {j}/{len(funcs)}, {times[i, j]}\")\n            except ValueError:\n                print(\"ERROR in {f}({*args})\")\n                \n            \n    return times\n\ndef plot_times(times, funcs):\n    fig, ax = plt.subplots()\n    for j, f in enumerate(funcs):\n        ax.plot(sizes, times[:, j], label=f.__name__)\n    \n    \n    ax.set_xlabel(\"Array size\")\n    ax.set_ylabel(\"Time per function call (s)\")\n    ax.set_xscale(\"log\")\n    ax.set_yscale(\"log\")\n    ax.legend()\n    ax.grid()\n    fig.tight_layout()\n    return fig, ax\n\n#%%\ndef arg_gen(n):\n    return [np.random.randint(-100, 100, (n,)), 5]\n    \n#%%\ndef sliding_median_lc(arr, window):\n    return np.array([np.median(arr[i:i+window]) for i in range(len(arr) - window+1)])\n    \n\ndef sliding_median_np(arr, window):    \n    return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)\n\n#%% \nif __name__ == \"__main__\":\n    #%% Set up sim\n    sizes = [5, 10, 50, 100, 500, 1000, 5000, 10_000, 50_000, 100_000]\n    funcs = [sliding_median_lc, sliding_median_np]\n    \n    \n    #%% Run timing\n    time_fcalls = np.zeros((len(sizes), len(funcs))) * np.nan\n    time_fcalls = time_funcs(funcs, sizes, arg_gen)\n    \n    fig, ax = plot_times(time_fcalls, funcs)\n    ax.set_xlabel(f\"Input size\")\n\n    plt.show()",
            "masked_code": "import timeit\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\ndef time_funcs(funcs, sizes, arg_gen, N=20):\n    times = np.zeros((len(sizes), len(funcs)))\n    gdict = globals().copy()\n    for i, s in enumerate(sizes):\n        args = arg_gen(s)\n        print(args)\n        for j, f in enumerate(funcs):\n            gdict.update(locals())\n            try:\n                times[i, j] = timeit.timeit(\"f(*args)\", globals=gdict, number=N) / N\n                print(f\"{i}/{len(sizes)}, {j}/{len(funcs)}, {times[i, j]}\")\n            except ValueError:\n                print(\"ERROR in {f}({*args})\")\n                \n            \n    return times\n\ndef plot_times(times, funcs):\n    fig, ax = plt.subplots()\n    for j, f in enumerate(funcs):\n        ax.plot(sizes, times[:, j], label=f.__name__)\n    \n    \n    ax.set_xlabel(\"Array size\")\n    ax.set_ylabel(\"Time per function call (s)\")\n    ax.set_xscale(\"log\")\n    ax.set_yscale(\"log\")\n    ax.legend()\n    ax.grid()\n    fig.tight_layout()\n    return fig, ax\n\n#%%\ndef arg_gen(n):\n    return [np.random.randint(-100, 100, (n,)), 5]\n    \n#%%\ndef sliding_median_lc(arr, window):\n    return np.array([np.median(arr[i:i+window]) for i in range(len(arr) - window+1)])\n    \n\ndef sliding_median_np(arr, window):    \n    <line_mask>\n\n#%% \nif __name__ == \"__main__\":\n    #%% Set up sim\n    sizes = [5, 10, 50, 100, 500, 1000, 5000, 10_000, 50_000, 100_000]\n    funcs = [sliding_median_lc, sliding_median_np]\n    \n    \n    #%% Run timing\n    time_fcalls = np.zeros((len(sizes), len(funcs))) * np.nan\n    time_fcalls = time_funcs(funcs, sizes, arg_gen)\n    \n    fig, ax = plot_times(time_fcalls, funcs)\n    ax.set_xlabel(f\"Input size\")\n\n    plt.show()",
            "masked_line": "return np.median(np.lib.stride_tricks.sliding_window_view(arr, (window,)), axis=1)",
            "answer": "sliding_window_view",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_66",
            "model_output": "['<start>return np.convolve(arr.flatten(), np.ones(window)/window)[window-1:-window+1]<end>', '<start{return np.convolve(arrravel(), np.ones(window)/window)[window-1:-window+1]}<end>', \"<start>return np.convolve(arr,np.ones(window),'valid')[::window-1]<end>\", '<start>return np.convolve(arr flat(), np.ones(window)/window)[window-1:-window+1]<end>', \"<start>return np.convolve(arr[::-1], np.ones(window), mode='valid')[::-1]<end>\", \"<start>return np.convolve(arr flat[:window], 'valid')<end>\"]",
            "model_output_token_clear": "['return np.convolve(arr.flatten(), np.ones(window)/window)[window-1:-window+1]', 'no_answer', \"return np.convolve(arr,np.ones(window),'valid')[::window-1]\", 'return np.convolve(arr flat(), np.ones(window)/window)[window-1:-window+1]', \"return np.convolve(arr[::-1], np.ones(window), mode='valid')[::-1]\", \"return np.convolve(arr flat[:window], 'valid')\"]"
        },
        {
            "dependency": "pandas",
            "version": ">=1.3.0",
            "time": "2023-07-11",
            "description": "The code calculates whether each element in the column 'd_max' is a peak by checking if the values in a rolling window of size 12 are all the same.",
            "code": "import pandas as pd\nimport numpy as np\ndata = {'d_max': [2, 3] + [6] * 12 + [1, 5, 5, 5]}\ndf = pd.DataFrame(data)\ndf['is_peak'] = df['d_max'][::-1].rolling(12, closed='left').apply(lambda x:len(set(x))==1)[::-1]\ndf",
            "masked_code": "import pandas as pd\nimport numpy as np\ndata = {'d_max': [2, 3] + [6] * 12 + [1, 5, 5, 5]}\ndf = pd.DataFrame(data)\n<line_mask>\ndf",
            "masked_line": "df['is_peak'] = df['d_max'][::-1].rolling(12, closed='left').apply(lambda x:len(set(x))==1)[::-1]",
            "answer": "apply",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_67",
            "model_output": "[\"<start>df['d_max'] = df['d_max'].rolling(12).apply(lambda x: x.max() == x.min())<end>\", \"<start>df = df.assign(d_max_peak=lambda df: df.groupby((df.d_max.shift().gt(6) | df.d_max.shift(-1).gt(6)).cumsum()).transform('max') == df.d_max) <end>\", '<start>df = df.assign(is_peak=lambda x: x.d_max.eq(x.d_max.rolling(12).max()))<end>', \"<start>df = df.assign(peak = (df['d_max'] == df['d_max'].rolling(12).max()).astype(int))<end>\", \"<start>df = df.assign(peak=(df['d_max'] > df['d_max'].rolling(12).mean() + 2*df['d_max'].rolling(12).std()))<end>\", \"<start>df = df.assign(peak=df['d_max'] == df['d_max'].rolling(12).max())<end>\"]",
            "model_output_token_clear": "[\"df['d_max'] = df['d_max'].rolling(12).apply(lambda x: x.max() == x.min())\", \"df = df.assign(d_max_peak=lambda df: df.groupby((df.d_max.shift().gt(6) | df.d_max.shift(-1).gt(6)).cumsum()).transform('max') == df.d_max) \", 'df = df.assign(is_peak=lambda x: x.d_max.eq(x.d_max.rolling(12).max()))', \"df = df.assign(peak = (df['d_max'] == df['d_max'].rolling(12).max()).astype(int))\", \"df = df.assign(peak=(df['d_max'] > df['d_max'].rolling(12).mean() + 2*df['d_max'].rolling(12).std()))\", \"df = df.assign(peak=df['d_max'] == df['d_max'].rolling(12).max())\"]"
        },
        {
            "dependency": "pytest",
            "version": "==7.4.0",
            "time": "2023-07-07",
            "description": "The code defines fixtures for creating an app and a test client for testing a FastAPI application. The 'app' fixture returns the created FastAPI app using the 'create_app' function, while the 'client' fixture returns a TestClient object for testing the app.",
            "code": "import pytest\n\nfrom fastapi.testclient import TestClient\nfrom main import create_app\n\n\n@pytest.fixture\ndef app():\n    return create_app()\n\n\n@pytest.fixture\ndef client(app):\n    return TestClient(app)",
            "masked_code": "import pytest\n\nfrom fastapi.testclient import TestClient\nfrom main import create_app\n\n\n@pytest.fixture\ndef app():\n    return create_app()\n\n\n<line_mask>\ndef client(app):\n    return TestClient(app)",
            "masked_line": "@pytest.fixture",
            "answer": "fixture",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_68",
            "model_output": "['<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>', '<start>@pytest.fixture<end>']",
            "model_output_token_clear": "['@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture', '@pytest.fixture']"
        },
        {
            "dependency": "numpy",
            "version": "==1.23.4",
            "time": "2023-08-09",
            "description": "The code calculates the rolling Euclidean distance between the normalized n most frequent items in a sequence and the n most frequent items in sliding windows of the sequence with specified window size.",
            "code": "def nfrequent(seq, n, count_unique=26):    # 26 is len(string.asci_uppercase)\n    '''get n most frequent items in discending order, n < count_unique\n    with normalized frequency and all the rest at the end'''\n    #counts = np.zeros(count_unique)\n    counts = np.bincount(seq, minlength=count_unique)\n    counts[::-1].sort()    # sort inplace in reversed order\n    counts[n] = counts[n:].sum()\n    return counts[:n+1] / counts[:n+1].sum()\n\ndef rolling_distance(arr, window, step=1, n=10):\n    windows = strided_view(seq, window)\n    total_nfreq = nfrequent(seq, n)\n    distance = np.empty(windows.shape[0] ,dtype=float)\n    for i in range(distance.size):\n        distance[i] = euclidean(total_nfreq, nfrequent(windows[i], n))\n    return distance\n\ndef strided_view(arr, window, step=1):\n    n = arr.size\n    itemsize = arr.itemsize\n    ksteps = 1 + (n - window) // step\n    return as_strided(\n        arr\n        , shape=(ksteps, window)\n        , strides=(itemsize*step, itemsize)\n        , writeable=False\n    )",
            "masked_code": "def nfrequent(seq, n, count_unique=26):    # 26 is len(string.asci_uppercase)\n    '''get n most frequent items in discending order, n < count_unique\n    with normalized frequency and all the rest at the end'''\n    #counts = np.zeros(count_unique)\n    counts = np.bincount(seq, minlength=count_unique)\n    counts[::-1].sort()    # sort inplace in reversed order\n    counts[n] = counts[n:].sum()\n    <line_mask>\n\ndef rolling_distance(arr, window, step=1, n=10):\n    windows = strided_view(seq, window)\n    total_nfreq = nfrequent(seq, n)\n    distance = np.empty(windows.shape[0] ,dtype=float)\n    for i in range(distance.size):\n        distance[i] = euclidean(total_nfreq, nfrequent(windows[i], n))\n    return distance\n\ndef strided_view(arr, window, step=1):\n    n = arr.size\n    itemsize = arr.itemsize\n    ksteps = 1 + (n - window) // step\n    return as_strided(\n        arr\n        , shape=(ksteps, window)\n        , strides=(itemsize*step, itemsize)\n        , writeable=False\n    )",
            "masked_line": "return counts[:n+1] / counts[:n+1].sum()",
            "answer": "sum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_69",
            "model_output": "['<start>counts[n:] = counts[n-1]<end>', '<start>counts[n:] = [counts[n:].sum()] + list(counts[n+1:-1]) + [counts[-1]]<end>', '<start>counts[n:] = counts[n-1]<end>', '<start>counts[n:], [counts[n-1]] * (count_unique - n)<end>', '<start>counts[n:] = 0<end>', '<start>counts[n:] = [counts[n:].sum()] * (count_unique - n)<end>']",
            "model_output_token_clear": "['counts[n:] = counts[n-1]', 'counts[n:] = [counts[n:].sum()] + list(counts[n+1:-1]) + [counts[-1]]', 'counts[n:] = counts[n-1]', 'counts[n:], [counts[n-1]] * (count_unique - n)', 'counts[n:] = 0', 'counts[n:] = [counts[n:].sum()] * (count_unique - n)']"
        },
        {
            "dependency": "customtkinter",
            "version": "==5.1.2",
            "time": "2023-03-13",
            "description": "The code creates a custom tkinter window with a button containing the text 'aaa bbb ccc ddd'. The button's text label is configured to wrap at 50 pixels and then the button is displayed on the window. Finally, the window enters the main event loop.",
            "code": "import customtkinter as ctk\n\nroot = ctk.CTk()\n\nbutton = ctk.CTkButton(root, text='aaa bbb ccc ddd')\nbutton._text_label.configure(wraplength=50)\nbutton.pack()\n\nroot.mainloop()",
            "masked_code": "import customtkinter as ctk\n\nroot = ctk.CTk()\n\n<line_mask>\nbutton._text_label.configure(wraplength=50)\nbutton.pack()\n\nroot.mainloop()",
            "masked_line": "button = ctk.CTkButton(root, text='aaa bbb ccc ddd')",
            "answer": "CTkButton",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_70",
            "model_output": "[\"<start>button = CustomButton(root, root, 'aaa bbb ccc ddd')<end>\", \"<start>button = CustomButton(root, root, 'aaa bbb ccc ddd')<end>\", \"<start>button = CustomButton(root, root, 'aaa bbb ccc ddd')<end>\", \"<start>button = CustomButton(root, root, 'aaa bbb ccc ddd')<end>\", \"<start>button = CustomButton(root=root, betterroot=root, name='aaa bbb ccc ddd')<end>\", \"<start>button = CustomButton(root, root, 'aaa bbb ccc ddd')<end>\"]",
            "model_output_token_clear": "[\"button = CustomButton(root, root, 'aaa bbb ccc ddd')\", \"button = CustomButton(root, root, 'aaa bbb ccc ddd')\", \"button = CustomButton(root, root, 'aaa bbb ccc ddd')\", \"button = CustomButton(root, root, 'aaa bbb ccc ddd')\", \"button = CustomButton(root=root, betterroot=root, name='aaa bbb ccc ddd')\", \"button = CustomButton(root, root, 'aaa bbb ccc ddd')\"]"
        },
        {
            "dependency": "selenium",
            "version": ">=4.3.0",
            "time": "2023-09-27",
            "description": "The code finds and assigns the web page container element with a specific class name to the variable `page_container`.",
            "code": "page_container = driver.find_element(By.XPATH, '//*[@class=\"mw-page-container\"]')",
            "masked_code": "<line_mask>",
            "masked_line": "page_container = driver.find_element(By.XPATH, '//*[@class=\"mw-page-container\"]')",
            "answer": "find_element",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_71",
            "model_output": "['<start>page_container = driver.find_elements_by_class_name(\"class_name\")<end>', '<start>page_container = driver.find_elements_by_class_name(\"class_name\")<end>', '<start>page_container = driver.find_elements_by_class_name(\"class_name\")<end>', '<start>page_container = driver.find_elements_by_class_name(\"class_name\")<end>', '<start>page_container = driver.find_elements_by_class_name(\"class_name\")<end>', '<start>page_container = driver.find_elements_by_class_name(\"class_name\")<end>']",
            "model_output_token_clear": "['page_container = driver.find_elements_by_class_name(\"class_name\")', 'page_container = driver.find_elements_by_class_name(\"class_name\")', 'page_container = driver.find_elements_by_class_name(\"class_name\")', 'page_container = driver.find_elements_by_class_name(\"class_name\")', 'page_container = driver.find_elements_by_class_name(\"class_name\")', 'page_container = driver.find_elements_by_class_name(\"class_name\")']"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.3",
            "time": "2023-07-27",
            "description": "The code reads an existing Excel file, adds a new row to the dataframe, and then writes the updated dataframe back to the existing Excel file.",
            "code": "import pandas as pd\n# Read the existing Excel file\ndf = pd.read_excel('existing_file.xlsx')\n\n# Create a new dataframe with the new row\nnew_row = pd.DataFrame({'key': ['black'], 'value': ['2']})\ndf = pd.concat([df, new_row], ignore_index=True)\n\n# Write the dataframe to the existing Excel file using ExcelWriter\nwith pd.ExcelWriter('existing_file.xlsx', mode='a', if_sheet_exists='overlay') as writer:\n    df.to_excel(writer, sheet_name='Sheet1', index=False)",
            "masked_code": "import pandas as pd\n# Read the existing Excel file\ndf = pd.read_excel('existing_file.xlsx')\n\n# Create a new dataframe with the new row\nnew_row = pd.DataFrame({'key': ['black'], 'value': ['2']})\n<line_mask>\n\n# Write the dataframe to the existing Excel file using ExcelWriter\nwith pd.ExcelWriter('existing_file.xlsx', mode='a', if_sheet_exists='overlay') as writer:\n    df.to_excel(writer, sheet_name='Sheet1', index=False)",
            "masked_line": "df = pd.concat([df, new_row], ignore_index=True)",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_72",
            "model_output": "['<start>df = pd.concat([df, new_row])<end>', '<start>df = pd.concat([df, new_row])<end>', '<start>df = pd.concat([df, new_row])<end>', '<start>df = pd.concat([df, new_row])<end>', '<start>df = pd.concat([df, new_row])<end>', '<start>df = pd.concat([df, new_row])<end>']",
            "model_output_token_clear": "['df = pd.concat([df, new_row])', 'df = pd.concat([df, new_row])', 'df = pd.concat([df, new_row])', 'df = pd.concat([df, new_row])', 'df = pd.concat([df, new_row])', 'df = pd.concat([df, new_row])']"
        },
        {
            "dependency": "selenium",
            "version": ">=4.6",
            "time": "2023-04-13",
            "description": "The code opens a Chrome browser, maximizes the window, navigates to a specified URL, waits for a specific element to become visible, and then prints out the links of all elements matching a specific CSS selector on the webpage.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.ui import WebDriverWait\n\n# Set up the Chrome driver and maximize the window\ndriver = webdriver.Chrome()\ndriver.maximize_window()\n\n# Navigate to the URL\nurl = \"https://www.autotempest.com/results?make=chevrolet&zip=72032&radius=25\"\ndriver.get(url)\n\nlinks = WebDriverWait(driver, 10).until(EC.visibility_of_all_elements_located((By.CSS_SELECTOR, \".result-wrap .listing-title > a\")))\nfor link in links:\n    print(link.get_attribute(\"href\"))",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.ui import WebDriverWait\n\n# Set up the Chrome driver and maximize the window\ndriver = webdriver.Chrome()\n<line_mask>\n\n# Navigate to the URL\nurl = \"https://www.autotempest.com/results?make=chevrolet&zip=72032&radius=25\"\ndriver.get(url)\n\nlinks = WebDriverWait(driver, 10).until(EC.visibility_of_all_elements_located((By.CSS_SELECTOR, \".result-wrap .listing-title > a\")))\nfor link in links:\n    print(link.get_attribute(\"href\"))",
            "masked_line": "driver.maximize_window()",
            "answer": "maximize_window",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_73",
            "model_output": "['<start>driver.maximize_window()<end>', '<start>driver.maximize_window()<end>', '<start>driver.maximize_window()<end>', '<start>driver.maximize_window()<end>', '<start>driver.maximize_window()<end>', '<start>driver.maximize_window()<end>']",
            "model_output_token_clear": "['driver.maximize_window()', 'driver.maximize_window()', 'driver.maximize_window()', 'driver.maximize_window()', 'driver.maximize_window()', 'driver.maximize_window()']"
        },
        {
            "dependency": "pytest",
            "version": "==7.2.0",
            "time": "2023-01-02",
            "description": "This code defines a pytest test function that takes in a filename and a tuple of angles as parameters. Inside the test function, it loads a dataframe from the specified file using a function called load_some_df and performs some operations on the dataframe.",
            "code": "@pytest.mark.parametrize(\"filename,angles\", (\n  (\"data_set1.csv\", (0, 30, 60)),\n  (\"data_set2.csv\", (90, 120, 150)),\n  (\"data_set3.csv\", (180, 210, 240)),\n))\ndef test_df_against_angle(filename, angles):\n  df = load_some_df(filename)\n  ...",
            "masked_code": "<line_mask>\n  (\"data_set1.csv\", (0, 30, 60)),\n  (\"data_set2.csv\", (90, 120, 150)),\n  (\"data_set3.csv\", (180, 210, 240)),\n))\ndef test_df_against_angle(filename, angles):\n  df = load_some_df(filename)\n  ...",
            "masked_line": "@pytest.mark.parametrize(\"filename,angles\", (",
            "answer": "parametrize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_74",
            "model_output": "['<start>@pytest.mark.parametrize(\"filename,angles\", (<end>', '<start>@pytest.mark.parametrize(\"filename,angles\", (<end>', '<start>@pytest.mark.parametrize(\"filename,angles\", (<end>', '<start>@pytest.mark.parametrize(\"filename,angles\", (<end>', '<start>@pytest.mark.parametrize(\"filename,angles\", (<end>', '<start>@pytest.mark.parametrize(\"filename,angles\", (<end>']",
            "model_output_token_clear": "['@pytest.mark.parametrize(\"filename,angles\", (', '@pytest.mark.parametrize(\"filename,angles\", (', '@pytest.mark.parametrize(\"filename,angles\", (', '@pytest.mark.parametrize(\"filename,angles\", (', '@pytest.mark.parametrize(\"filename,angles\", (', '@pytest.mark.parametrize(\"filename,angles\", (']"
        },
        {
            "dependency": "pytest",
            "version": "==7.2.0",
            "time": "2023-01-02",
            "description": "This code defines a test function that takes in a filename and an angle as parameters and asserts True, with different combinations of filenames and angles as test cases specified using pytest's parametrize decorator.",
            "code": "import pytest\n\nfrom itertools import product\n\n\n@pytest.mark.parametrize(\n    \"filename,angle\",\n    (\n        *product((\"data_set1.csv\",), (0, 30, 60)),\n        *product((\"data_set2.csv\",), (90, 120, 150)),\n        *product((\"data_set3.csv\",), (180, 210, 240)),\n    ),\n)\ndef test_angles(filename, angle):\n    assert True",
            "masked_code": "import pytest\n\nfrom itertools import product\n\n\n<line_mask>\n    \"filename,angle\",\n    (\n        *product((\"data_set1.csv\",), (0, 30, 60)),\n        *product((\"data_set2.csv\",), (90, 120, 150)),\n        *product((\"data_set3.csv\",), (180, 210, 240)),\n    ),\n)\ndef test_angles(filename, angle):\n    assert True",
            "masked_line": "@pytest.mark.parametrize(",
            "answer": "parametrize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_75",
            "model_output": "['<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>']",
            "model_output_token_clear": "['@pytest.mark.parametrize', '@pytest.mark.parametrize', '@pytest.mark.parametrize', '@pytest.mark.parametrize', '@pytest.mark.parametrize', '@pytest.mark.parametrize']"
        },
        {
            "dependency": "pytest",
            "version": "==7.2.1",
            "time": "2023-02-20",
            "description": "This code defines a function called my_function that sends a POST request to a specific API endpoint with data, receives a JSON response, and returns a message based on the value of the \"message\" key in the JSON response. The function handles different scenarios based on the value of the \"message\" key, returning \"Successfully created\", \"Already exists\", \"Wrong data\", or the actual message. \n\nIt also includes a test function called test_my_function_suceeds that utilizes mock objects to simulate the behavior of the requests library. The test function validates that my_function correctly handles different JSON responses and returns the expected messages.",
            "code": "import pytest\nimport requests\nfrom unittest import mock\n\n\ndef my_function(data):\n    response = requests.post(\"https://some_api.com\", json=data)\n    json_response = response.json()\n    if json_response[\"message\"] == \"Successfully created\":\n        return \"Successfully created\"\n    elif json_response[\"message\"] == \"Already exists\":\n        return \"Already exists\"\n    elif json_response[\"message\"] == \"Wrong data\":\n        return \"Wrong data\"\n    else:\n        return json_response[\"message\"]\n\n\n@mock.patch(\"requests.post\")\n@pytest.mark.parametrize(\n    \"json_response,expected_return\",\n    [\n        ({\"message\": \"Successfully created\"}, \"Successfully created\"),\n        ({\"message\": \"Already exists\"}, \"Already exists\"),\n        ({\"message\": \"Wrong data\"}, \"Wrong data\"),\n        ({\"message\": \"Some other message\"}, \"Some other message\"),\n    ],\n)\ndef test_my_function_suceeds(mock_post, json_response, expected_return):\n    mock_response = mock.MagicMock()\n    mock_response.json.return_value = json_response\n    mock_post.return_value = mock_response\n    res = my_function(\"\")\n    assert res == expected_return",
            "masked_code": "import pytest\nimport requests\nfrom unittest import mock\n\n\ndef my_function(data):\n    response = requests.post(\"https://some_api.com\", json=data)\n    json_response = response.json()\n    if json_response[\"message\"] == \"Successfully created\":\n        return \"Successfully created\"\n    elif json_response[\"message\"] == \"Already exists\":\n        return \"Already exists\"\n    elif json_response[\"message\"] == \"Wrong data\":\n        return \"Wrong data\"\n    else:\n        return json_response[\"message\"]\n\n\n@mock.patch(\"requests.post\")\n<line_mask>\n    \"json_response,expected_return\",\n    [\n        ({\"message\": \"Successfully created\"}, \"Successfully created\"),\n        ({\"message\": \"Already exists\"}, \"Already exists\"),\n        ({\"message\": \"Wrong data\"}, \"Wrong data\"),\n        ({\"message\": \"Some other message\"}, \"Some other message\"),\n    ],\n)\ndef test_my_function_suceeds(mock_post, json_response, expected_return):\n    mock_response = mock.MagicMock()\n    mock_response.json.return_value = json_response\n    mock_post.return_value = mock_response\n    res = my_function(\"\")\n    assert res == expected_return",
            "masked_line": "@pytest.mark.parametrize(",
            "answer": "mark",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_76",
            "model_output": "['<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>', '<start>@pytest.mark.parametrize<end>']",
            "model_output_token_clear": "['@pytest.mark.parametrize', '@pytest.mark.parametrize', '@pytest.mark.parametrize', '@pytest.mark.parametrize', '@pytest.mark.parametrize', '@pytest.mark.parametrize']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.1.1",
            "time": "2019-08-22",
            "description": "The code generates a figure with a subplot and then creates five random 4x4 arrays. Each array is displayed as an image on the subplot with a specified extent. The code then applies a skew, scale, and translation transformation to each image. Finally, it sets the limits of the y-axis and x-axis of the subplot before displaying the figure with the transformed images.",
            "code": "import numpy\nfrom matplotlib import pyplot\nfrom matplotlib import transforms\nfrom PIL import Image\n\nfig, ax = pyplot.subplots()\n\nfor i in range(5):\n    data = numpy.random.rand(4,4)\n    im = ax.imshow(data, extent=[0, 10, 0, 4])\n    transform = transforms.Affine2D().skew_deg(0, 30).scale(0.5, 1).translate(5*i,0)\n    trans_data = transform + ax.transData\n    im.set_transform(trans_data)\n    ax.set_ylim(0,10)\n    ax.set_xlim(0,25)\n\npyplot.show()",
            "masked_code": "import numpy\nfrom matplotlib import pyplot\nfrom matplotlib import transforms\nfrom PIL import Image\n\nfig, ax = pyplot.subplots()\n\nfor i in range(5):\n    data = numpy.random.rand(4,4)\n    im = ax.imshow(data, extent=[0, 10, 0, 4])\n    transform = transforms.Affine2D().skew_deg(0, 30).scale(0.5, 1).translate(5*i,0)\n    trans_data = transform + ax.transData\n    im.set_transform(trans_data)\n    <line_mask>\n    ax.set_xlim(0,25)\n\npyplot.show()",
            "masked_line": "ax.set_ylim(0,10)",
            "answer": "set_ylim",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_77",
            "model_output": "['<start>im.set_zorder(i)<end>', '<start>im.set_alpha(0.5)<end>', '<start>ax.images.append(im)<end>', '<start>im.set_zorder(i)<end>', '<start>im.set_zorder(1)<end>', '<start>ax.images.append(im)<end>']",
            "model_output_token_clear": "['im.set_zorder(i)', 'im.set_alpha(0.5)', 'ax.images.append(im)', 'im.set_zorder(i)', 'im.set_zorder(1)', 'ax.images.append(im)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-11-08",
            "description": "This code reads an image, converts it to a grayscale image, finds contours in the grayscale image, draws bounding rectangles around the contours with random colors, and then displays and saves the annotated image.",
            "code": "import cv2\nimport numpy as np\n\nimage = cv2.imread('1.png')\ngray = 255 - cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\ncnts = cv2.findContours(gray, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\ncnts = cnts[0] if len(cnts) == 2 else cnts[1]\nfor c in cnts:\n    x,y,w,h = cv2.boundingRect(c)\n    color = list(np.random.random(size=3) * 256)\n    cv2.rectangle(image, (x, y), (x + w, y + h), color, 4)\n\ncv2.imshow('image', image)\ncv2.imwrite('image.png', image)\ncv2.waitKey()",
            "masked_code": "import cv2\nimport numpy as np\n\nimage = cv2.imread('1.png')\ngray = 255 - cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\ncnts = cv2.findContours(gray, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\ncnts = cnts[0] if len(cnts) == 2 else cnts[1]\nfor c in cnts:\n    x,y,w,h = cv2.boundingRect(c)\n    <line_mask>\n    cv2.rectangle(image, (x, y), (x + w, y + h), color, 4)\n\ncv2.imshow('image', image)\ncv2.imwrite('image.png', image)\ncv2.waitKey()",
            "masked_line": "color = list(np.random.random(size=3) * 256)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_78",
            "model_output": "['<start>area = w*h; if area > 9: color = (255, 0, 0);<end>', '<start>area = cv2.contourArea(c) if area > 100: color = (255, 0, 0) else: color = (0, 255, 0)<end>', '<start>area = cv2.contourArea(c)<end>', '<start>area = cv2.contourArea(c)<end>', '<start>area = cv2.contourArea(c) if area > 100: color = (255, 0, 0) else: color = (0, 0, 255)<end>', '<start>area = w*h; if area > 9: color = (0,255,0);<end>']",
            "model_output_token_clear": "['area = w*h; if area > 9: color = (255, 0, 0);', 'area = cv2.contourArea(c) if area > 100: color = (255, 0, 0) else: color = (0, 255, 0)', 'area = cv2.contourArea(c)', 'area = cv2.contourArea(c)', 'area = cv2.contourArea(c) if area > 100: color = (255, 0, 0) else: color = (0, 0, 255)', 'area = w*h; if area > 9: color = (0,255,0);']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-10-25",
            "description": "This code defines functions to create a just-in-time (JIT) integrand function using Numba, to integrate a function using arrays with dummy data, and to perform integration using scipy's quad function.",
            "code": "import numpy as np\nimport numba as nb\nfrom numba import types\nfrom scipy import integrate, LowLevelCallable\nimport ctypes\n\ndef create_jit_integrand_function(integrand_function,args,args_dtype):\n    jitted_function = nb.njit(integrand_function)\n\n    @nb.cfunc(types.float64(types.float64,types.CPointer(args_dtype)))\n    def wrapped(x1,user_data_p):\n        #Array of structs\n        user_data = nb.carray(user_data_p, 1)\n\n        #Extract the data\n        x2=user_data[0].a\n        array1=user_data[0].foo\n        array2=user_data[0].bar\n\n        return jitted_function(x1, x2, array1, array2)\n    return wrapped\n\ndef function_using_arrays(x1, x2, array1, array2):\n    res1 = np.interp(x1, array1[0], array1[1])\n    res2 = np.interp(x2, array2[0], array2[1])\n\n    return res1 + res2\n\ndef jit_with_dummy_data(args,args_dtype):\n    func=create_jit_integrand_function(function_using_arrays,args,args_dtype)\n    return func\n\ndef do_integrate_w_arrays(func,args,lolim=0, hilim=1):\n    integrand_func=LowLevelCallable(func.ctypes,user_data=args.ctypes.data_as(ctypes.c_void_p))\n    return integrate.quad(integrand_func, lolim, hilim)",
            "masked_code": "import numpy as np\nimport numba as nb\nfrom numba import types\nfrom scipy import integrate, LowLevelCallable\nimport ctypes\n\ndef create_jit_integrand_function(integrand_function,args,args_dtype):\n    jitted_function = nb.njit(integrand_function)\n\n    @nb.cfunc(types.float64(types.float64,types.CPointer(args_dtype)))\n    def wrapped(x1,user_data_p):\n        #Array of structs\n        user_data = nb.carray(user_data_p, 1)\n\n        #Extract the data\n        x2=user_data[0].a\n        array1=user_data[0].foo\n        array2=user_data[0].bar\n\n        return jitted_function(x1, x2, array1, array2)\n    return wrapped\n\ndef function_using_arrays(x1, x2, array1, array2):\n    <line_mask>\n    res2 = np.interp(x2, array2[0], array2[1])\n\n    return res1 + res2\n\ndef jit_with_dummy_data(args,args_dtype):\n    func=create_jit_integrand_function(function_using_arrays,args,args_dtype)\n    return func\n\ndef do_integrate_w_arrays(func,args,lolim=0, hilim=1):\n    integrand_func=LowLevelCallable(func.ctypes,user_data=args.ctypes.data_as(ctypes.c_void_p))\n    return integrate.quad(integrand_func, lolim, hilim)",
            "masked_line": "res1 = np.interp(x1, array1[0], array1[1])",
            "answer": "interp",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_79",
            "model_output": "['<start>res1 = np.interp(x1, array1[0], array1[1])<end>', '<start>res1 = np.interp(x1, array1[0], array1[1])<end>', '<start>res1 = np.interp(x1, array1[0], array1[1])<end>', '<start>res1 = np.interp(x1, array1[0], array1[1])<end>', '<start>res1 = np.interp(x1, array1[0], array1[1])<end>', '<start>res1 = np.interp(x1, array1[0], array1[1])<end>']",
            "model_output_token_clear": "['res1 = np.interp(x1, array1[0], array1[1])', 'res1 = np.interp(x1, array1[0], array1[1])', 'res1 = np.interp(x1, array1[0], array1[1])', 'res1 = np.interp(x1, array1[0], array1[1])', 'res1 = np.interp(x1, array1[0], array1[1])', 'res1 = np.interp(x1, array1[0], array1[1])']"
        },
        {
            "dependency": "boto3",
            "version": "==1.9.134",
            "time": "2019-04-25",
            "description": "The code uploads a 100mb file named '100mb.txt' to an S3 bucket named 'test-threads' using boto3 library.",
            "code": "import io\nimport pdb\n\nimport boto3\n\n# From dd if=/dev/zero of=100mb.txt  bs=50M  count=1\nbuf = io.BytesIO(open('100mb.txt', 'rb').read())\nbucket = boto3.resource('s3').Bucket('test-threads')\npdb.run(\"bucket.upload_fileobj(buf, '100mb')\")",
            "masked_code": "import io\nimport pdb\n\nimport boto3\n\n# From dd if=/dev/zero of=100mb.txt  bs=50M  count=1\nbuf = io.BytesIO(open('100mb.txt', 'rb').read())\n<line_mask>\npdb.run(\"bucket.upload_fileobj(buf, '100mb')\")",
            "masked_line": "bucket = boto3.resource('s3').Bucket('test-threads')",
            "answer": "Bucket",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_80",
            "model_output": "[\"<start>bucket = boto3.resource('s3').Bucket('test-threads')<end>\", \"<start>bucket = boto3.resource('s3').Bucket('test-threads')<end>\", \"<start>bucket = boto3.resource('s3').Bucket('test-threads')<end>\", \"<start>bucket = boto3.resource('s3').Bucket('test-threads')<end>\", \"<start>bucket = boto3.resource('s3').Bucket('test-threads')<end>\", \"<start>bucket = boto3.resource('s3').Bucket('test-threads')<end>\"]",
            "model_output_token_clear": "[\"bucket = boto3.resource('s3').Bucket('test-threads')\", \"bucket = boto3.resource('s3').Bucket('test-threads')\", \"bucket = boto3.resource('s3').Bucket('test-threads')\", \"bucket = boto3.resource('s3').Bucket('test-threads')\", \"bucket = boto3.resource('s3').Bucket('test-threads')\", \"bucket = boto3.resource('s3').Bucket('test-threads')\"]"
        },
        {
            "dependency": "numba",
            "version": "==0.45.1",
            "time": "2019-09-29",
            "description": "The function takes two arguments - a list of two numpy arrays and a dictionary. It then calculates the sum of the elements in the second array and the product of the elements in the first array. It multiplies the sum by the value corresponding to key 'k1' in the dictionary and the product by the value corresponding to key 'k2' in the dictionary. Finally, it returns a tuple of the two calculated results.",
            "code": "import numpy as np\nfrom numba import njit\nfrom numba import types\nfrom numba.typed import Dict\nfrom numba.types import DictType\n\n# Let jit infer the types on it's own\n@njit\ndef somefunction(lst_arr, mydict):\n    arr1, arr2 = lst_arr\n    summ = 0\n    prod = 1\n    for i in arr2:\n        summ += i\n    for j in arr1:\n        prod *= j\n\n    result = (summ*mydict['k1'],prod*mydict['k2'])\n    return result\n\n# ~~ Input numpy arrays\na = np.arange(5)+1.0\nb = np.arange(10)+11.0  #<--------------- This is of different shape \narg = (a,b)\n\n# ~~ Input dictionary for the function \nd = Dict.empty(\n    key_type=types.unicode_type,\n    value_type=types.float64)\n\nd['k1'] = 1.5\nd['k2'] = 0.5\n\n\n# This works now\nprint(somefunction(arg, d))",
            "masked_code": "import numpy as np\nfrom numba import njit\nfrom numba import types\nfrom numba.typed import Dict\nfrom numba.types import DictType\n\n# Let jit infer the types on it's own\n@njit\ndef somefunction(lst_arr, mydict):\n    arr1, arr2 = lst_arr\n    summ = 0\n    prod = 1\n    for i in arr2:\n        summ += i\n    for j in arr1:\n        prod *= j\n\n    result = (summ*mydict['k1'],prod*mydict['k2'])\n    return result\n\n# ~~ Input numpy arrays\na = np.arange(5)+1.0\nb = np.arange(10)+11.0  #<--------------- This is of different shape \narg = (a,b)\n\n# ~~ Input dictionary for the function \n<line_mask>\n    key_type=types.unicode_type,\n    value_type=types.float64)\n\nd['k1'] = 1.5\nd['k2'] = 0.5\n\n\n# This works now\nprint(somefunction(arg, d))",
            "masked_line": "d = Dict.empty(",
            "answer": "empty",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_81",
            "model_output": "['<start>d = Dict.empty(key_type=types.unicode_type, value_type=types.float64)<end>', '<start>d = Dict.empty(key_type=types.unicode_type, value_type=types.float64)<end>', '<start>d = Dict.empty(key_type=types.unicode_type, value_type=types.float64)<end>', '<start>d = Dict.empty(key_type=types.unicode_type, value_type=types.float64)<end>', '<start>d = Dict.empty(key_type=types.unicode_type, value_type=types.float64)<end>', '<start>d = Dict.empty(key_type=types.unicode_type, value_type=types.float64)<end>']",
            "model_output_token_clear": "['d = Dict.empty(key_type=types.unicode_type, value_type=types.float64)', 'd = Dict.empty(key_type=types.unicode_type, value_type=types.float64)', 'd = Dict.empty(key_type=types.unicode_type, value_type=types.float64)', 'd = Dict.empty(key_type=types.unicode_type, value_type=types.float64)', 'd = Dict.empty(key_type=types.unicode_type, value_type=types.float64)', 'd = Dict.empty(key_type=types.unicode_type, value_type=types.float64)']"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.4",
            "time": "2019-03-09",
            "description": "The code generates a DataFrame containing financial data for two symbols, 'AA' and 'BB', with columns for open, high, low, close prices, volume, and adjusted close price. The data is generated randomly with 1000 rows and dates ranging from January 2, 1962.",
            "code": "import pandas as pd # version 0.23.4\nimport numpy as np # version 1.15.4\n\nnp.random.seed(1)\n\ndf1 = pd.DataFrame(index=[\n    pd.date_range(start='1962-01-02', periods=1000, freq='D'),\n    ['AA']*500 + ['BB']*500\n], columns=[\n    'price_open',\n    'price_high',\n    'price_low',\n    'price_close',\n    'volume',\n    'price_adj_close'\n], data=np.random.random(size=(1000, 6)))\n\ndf1.index.names = ['date', 'symbol']",
            "masked_code": "import pandas as pd # version 0.23.4\nimport numpy as np # version 1.15.4\n\nnp.random.seed(1)\n\n<line_mask>\n    pd.date_range(start='1962-01-02', periods=1000, freq='D'),\n    ['AA']*500 + ['BB']*500\n], columns=[\n    'price_open',\n    'price_high',\n    'price_low',\n    'price_close',\n    'volume',\n    'price_adj_close'\n], data=np.random.random(size=(1000, 6)))\n\ndf1.index.names = ['date', 'symbol']",
            "masked_line": "df1 = pd.DataFrame(index=[",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_82",
            "model_output": "[\"<start>pd.DataFrame({'date': pd.date_range(start='1962-01-02', periods=1000, freq='D'), 'symbol': ['AA']*500 + ['BB']*500})<end>\", \"<start>pd.DataFrame({ 'date': pd.date_range(start='1962-01-02', periods=1000, freq='D'), 'symbol': ['AA']*500 + ['BB']*500 }, columns=['date', 'symbol'])<end>\", \"<start>pd.DataFrame({pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA']*500 + ['BB']*500}, columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'], data=np.random.random(size=(1000, 6)))<end>\", \"<start>pd.DataFrame({ 'date': pd.date_range(start='1962-01-02', periods=1000, freq='D'), 'symbol': ['AA']*500 + ['BB']*500 })<end>\", \"<start>pd.DataFrame({pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA']*500 + ['BB']*500}, columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'], data=np.random.random(size=(1000, 6)))<end>\", \"<start>pd.DataFrame({pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA']*500 + ['BB']*500}, columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'], data=np.random.random(size=(1000, 6)))<end>\"]",
            "model_output_token_clear": "[\"pd.DataFrame({'date': pd.date_range(start='1962-01-02', periods=1000, freq='D'), 'symbol': ['AA']*500 + ['BB']*500})\", \"pd.DataFrame({ 'date': pd.date_range(start='1962-01-02', periods=1000, freq='D'), 'symbol': ['AA']*500 + ['BB']*500 }, columns=['date', 'symbol'])\", \"pd.DataFrame({pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA']*500 + ['BB']*500}, columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'], data=np.random.random(size=(1000, 6)))\", \"pd.DataFrame({ 'date': pd.date_range(start='1962-01-02', periods=1000, freq='D'), 'symbol': ['AA']*500 + ['BB']*500 })\", \"pd.DataFrame({pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA']*500 + ['BB']*500}, columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'], data=np.random.random(size=(1000, 6)))\", \"pd.DataFrame({pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA']*500 + ['BB']*500}, columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'], data=np.random.random(size=(1000, 6)))\"]"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.4",
            "time": "2019-03-09",
            "description": "The code generates a DataFrame 'df1' with 1000 rows and 6 columns containing random numerical values. The index of the DataFrame consists of dates ranging from '1962-01-02' with a frequency of 1 day, and symbols 'AA' and 'BB'. The columns of the DataFrame represent stock market data such as open price, high price, low price, close price, volume, and adjusted close price.",
            "code": "import pandas as pd # version 0.23.4\nimport numpy as np # version 1.15.4\n\nnp.random.seed(1)\n\ndf1 = pd.DataFrame(index=[\n    pd.date_range(start='1962-01-02', periods=1000, freq='D'),\n    ['AA']*500 + ['BB']*500\n], columns=[\n    'price_open',\n    'price_high',\n    'price_low',\n    'price_close',\n    'volume',\n    'price_adj_close'\n], data=np.random.random(size=(1000, 6)))\n\ndf1.index.names = ['date', 'symbol']",
            "masked_code": "import pandas as pd # version 0.23.4\nimport numpy as np # version 1.15.4\n\n<line_mask>\n\ndf1 = pd.DataFrame(index=[\n    pd.date_range(start='1962-01-02', periods=1000, freq='D'),\n    ['AA']*500 + ['BB']*500\n], columns=[\n    'price_open',\n    'price_high',\n    'price_low',\n    'price_close',\n    'volume',\n    'price_adj_close'\n], data=np.random.random(size=(1000, 6)))\n\ndf1.index.names = ['date', 'symbol']",
            "masked_line": "np.random.seed(1)",
            "answer": "seed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_83",
            "model_output": "[\"<start>df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA', 'BB']]), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])<end>\", \"<start>df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA', 'BB']]), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])<end>\", '<start>data = np.random.random(size=(1000,6))<end>', \"<start>df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA', 'BB']]), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])<end>\", \"<start>df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA', 'BB']]), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])<end>\", \"<start>df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA','BB']], names=['date', 'symbol']), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])<end>\"]",
            "model_output_token_clear": "[\"df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA', 'BB']]), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])\", \"df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA', 'BB']]), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])\", 'data = np.random.random(size=(1000,6))', \"df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA', 'BB']]), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])\", \"df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA', 'BB']]), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])\", \"df1 = pd.DataFrame(np.random.random(size=(1000,6)), index=pd.MultiIndex.from_product([pd.date_range(start='1962-01-02', periods=1000, freq='D'), ['AA','BB']], names=['date', 'symbol']), columns=['price_open', 'price_high', 'price_low', 'price_close', 'volume', 'price_adj_close'])\"]"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-23",
            "description": "The code is processing text data for a classification task. It reads a CSV file with text and labels, tokenizes the text, builds a vocabulary, pads and truncates the sequences, and creates TensorFlow datasets for training and validation. It also includes methods to create feature columns for the text data.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\n\nfrom tensorflow import feature_column\n\nfrom tensorflow.keras.preprocessing.text import Tokenizer\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\nfrom tensorflow.keras.preprocessing.text import text_to_word_sequence\nimport tensorflow.keras.utils as ku\nfrom tensorflow.keras.utils import plot_model\n\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\n\nDATA_PATH = 'C:\\SoloLearnMachineLearning\\Stackoverflow\\TextDataset.csv'\n\n#it is just two column csv, like:\n# text;label\n# A wiki is run using wiki software;0\n# otherwise known as a wiki engine.;1\n\ndataframe = pd.read_csv(DATA_PATH, delimiter = ';')\ndataframe.head()\n\n# Preprocessing before feature_clolumn includes\n# - getting the vocabulary\n# - tokenization, which means only splitting on tokens.\n#   Encoding sentences with vocablary will be done by feature_column!\n# - padding\n# - truncating\n\n# Build vacabulary\nvocab_size = 100\noov_tok = ''\n\nsentences = dataframe['text'].to_list()\n\ntokenizer = Tokenizer(num_words = vocab_size, oov_token=\"\")\n\ntokenizer.fit_on_texts(sentences)\nword_index = tokenizer.word_index\n\n# if word_index shorter then default value of vocab_size we'll save actual size\nvocab_size=len(word_index)\nprint(\"vocab_size = word_index = \",len(word_index))\n\n# Split sentensec on tokens. here token = word\n# text_to_word_sequence() has good default filter for \n# charachters include basic punctuation, tabs, and newlines\ndataframe['text'] = dataframe['text'].apply(text_to_word_sequence)\n\ndataframe.head()\n\nmax_length = 6\n\n# paddind and trancating setnences\n# do that directly with strings without using tokenizer.texts_to_sequences()\n# the feature_colunm will convert strings into numbers\ndataframe['text']=dataframe['text'].apply(lambda x, N=max_length: (x + N * [''])[:N])\ndataframe['text']=dataframe['text'].apply(lambda x, N=max_length: x[:N])\ndataframe.head()\n\n# Define method to create tf.data dataset from Pandas Dataframe\ndef df_to_dataset(dataframe, label_column, shuffle=True, batch_size=32):\n    dataframe = dataframe.copy()\n    #labels = dataframe.pop(label_column)\n    labels = dataframe[label_column]\n\n    ds = tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))\n    if shuffle:\n        ds = ds.shuffle(buffer_size=len(dataframe))\n    ds = ds.batch(batch_size)\n    return ds\n\n# Split dataframe into train and validation sets\ntrain_df, val_df = train_test_split(dataframe, test_size=0.2)\n\nprint(len(train_df), 'train examples')\nprint(len(val_df), 'validation examples')\n\nbatch_size = 32\nds = df_to_dataset(dataframe, 'label',shuffle=False,batch_size=batch_size)\n\ntrain_ds = df_to_dataset(train_df, 'label',  shuffle=False, batch_size=batch_size)\nval_ds = df_to_dataset(val_df, 'label', shuffle=False, batch_size=batch_size)\n\n# and small batch for demo\nexample_batch = next(iter(ds))[0]\nexample_batch\n\n# Helper methods to print exxample outputs of for defined feature_column\n\ndef demo(feature_column):\n    feature_layer = tf.keras.layers.DenseFeatures(feature_column)\n    print(feature_layer(example_batch).numpy())\n\ndef seqdemo(feature_column):\n    sequence_feature_layer = tf.keras.experimental.SequenceFeatures(feature_column)\n    print(sequence_feature_layer(example_batch))",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\n\nfrom tensorflow import feature_column\n\nfrom tensorflow.keras.preprocessing.text import Tokenizer\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\nfrom tensorflow.keras.preprocessing.text import text_to_word_sequence\nimport tensorflow.keras.utils as ku\nfrom tensorflow.keras.utils import plot_model\n\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\n\nDATA_PATH = 'C:\\SoloLearnMachineLearning\\Stackoverflow\\TextDataset.csv'\n\n#it is just two column csv, like:\n# text;label\n# A wiki is run using wiki software;0\n# otherwise known as a wiki engine.;1\n\ndataframe = pd.read_csv(DATA_PATH, delimiter = ';')\ndataframe.head()\n\n# Preprocessing before feature_clolumn includes\n# - getting the vocabulary\n# - tokenization, which means only splitting on tokens.\n#   Encoding sentences with vocablary will be done by feature_column!\n# - padding\n# - truncating\n\n# Build vacabulary\nvocab_size = 100\noov_tok = ''\n\nsentences = dataframe['text'].to_list()\n\ntokenizer = Tokenizer(num_words = vocab_size, oov_token=\"\")\n\ntokenizer.fit_on_texts(sentences)\nword_index = tokenizer.word_index\n\n# if word_index shorter then default value of vocab_size we'll save actual size\nvocab_size=len(word_index)\nprint(\"vocab_size = word_index = \",len(word_index))\n\n# Split sentensec on tokens. here token = word\n# text_to_word_sequence() has good default filter for \n# charachters include basic punctuation, tabs, and newlines\ndataframe['text'] = dataframe['text'].apply(text_to_word_sequence)\n\ndataframe.head()\n\nmax_length = 6\n\n# paddind and trancating setnences\n# do that directly with strings without using tokenizer.texts_to_sequences()\n# the feature_colunm will convert strings into numbers\ndataframe['text']=dataframe['text'].apply(lambda x, N=max_length: (x + N * [''])[:N])\ndataframe['text']=dataframe['text'].apply(lambda x, N=max_length: x[:N])\ndataframe.head()\n\n# Define method to create tf.data dataset from Pandas Dataframe\ndef df_to_dataset(dataframe, label_column, shuffle=True, batch_size=32):\n    dataframe = dataframe.copy()\n    #labels = dataframe.pop(label_column)\n    labels = dataframe[label_column]\n\n    <line_mask>\n    if shuffle:\n        ds = ds.shuffle(buffer_size=len(dataframe))\n    ds = ds.batch(batch_size)\n    return ds\n\n# Split dataframe into train and validation sets\ntrain_df, val_df = train_test_split(dataframe, test_size=0.2)\n\nprint(len(train_df), 'train examples')\nprint(len(val_df), 'validation examples')\n\nbatch_size = 32\nds = df_to_dataset(dataframe, 'label',shuffle=False,batch_size=batch_size)\n\ntrain_ds = df_to_dataset(train_df, 'label',  shuffle=False, batch_size=batch_size)\nval_ds = df_to_dataset(val_df, 'label', shuffle=False, batch_size=batch_size)\n\n# and small batch for demo\nexample_batch = next(iter(ds))[0]\nexample_batch\n\n# Helper methods to print exxample outputs of for defined feature_column\n\ndef demo(feature_column):\n    feature_layer = tf.keras.layers.DenseFeatures(feature_column)\n    print(feature_layer(example_batch).numpy())\n\ndef seqdemo(feature_column):\n    sequence_feature_layer = tf.keras.experimental.SequenceFeatures(feature_column)\n    print(sequence_feature_layer(example_batch))",
            "masked_line": "ds = tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))",
            "answer": "Dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_84",
            "model_output": "['<start>ds = tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))<end>', \"<start>ds=tf.data.Dataset.from_tensor_slices((dict(text=dataframe['text']), labels))<end>\", '<start>ds=tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))<end>', '<start>ds = tf.data.Dataset.from_tensor_slices((dataframe.drop(label_column,axis=1), labels))<end>', '<start>ds=tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))<end>', '<start>ds=tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))<end>']",
            "model_output_token_clear": "['ds = tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))', \"ds=tf.data.Dataset.from_tensor_slices((dict(text=dataframe['text']), labels))\", 'ds=tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))', 'ds = tf.data.Dataset.from_tensor_slices((dataframe.drop(label_column,axis=1), labels))', 'ds=tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))', 'ds=tf.data.Dataset.from_tensor_slices((dict(dataframe), labels))']"
        },
        {
            "dependency": "spacy",
            "version": "==2.2",
            "time": "2019-11-10",
            "description": "The code initializes a spaCy natural language processing model for English and creates a lemmatizer object for lemmatization of words.",
            "code": "import spacy\nnlp = spacy.load('en_core_web_sm')\nlemmatizer = nlp.Defaults.create_lemmatizer()",
            "masked_code": "import spacy\nnlp = spacy.load('en_core_web_sm')\n<line_mask>",
            "masked_line": "lemmatizer = nlp.Defaults.create_lemmatizer()",
            "answer": "Defaults",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_85",
            "model_output": "[\"<start>lemmatizer = nlp.create_pipe('lemmatizer')<end>\", \"<start>lemmatizer = nlp.create_pipe('lemmatizer')<end>\", \"<start>lemmatizer = nlp.create_pipe('lemmatizer')<end>\", \"<start>lemmatizer = nlp.create_pipe('lemmatizer')<end>\", \"<start>lemmatizer = nlp.create_pipe('lemmatizer')<end>\", \"<start>lemmatizer = nlp.create_pipe('lemmatizer')<end>\"]",
            "model_output_token_clear": "[\"lemmatizer = nlp.create_pipe('lemmatizer')\", \"lemmatizer = nlp.create_pipe('lemmatizer')\", \"lemmatizer = nlp.create_pipe('lemmatizer')\", \"lemmatizer = nlp.create_pipe('lemmatizer')\", \"lemmatizer = nlp.create_pipe('lemmatizer')\", \"lemmatizer = nlp.create_pipe('lemmatizer')\"]"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-11-07",
            "description": "The code loads a saved TensorFlow model and uses it to make detections on an image after encoding it. It retrieves the number of detections, detection scores, detection boxes, and detection classes for objects in the image.",
            "code": "import cv2\nimport tensorflow as tf\ncv2.imread(filepath)\nflag, bts = cv.imencode('.jpg', img)\ninp = [bts[:,0].tobytes()]\nwith tf.Session(graph=tf.Graph()) as sess:\n    tf.saved_model.loader.load(sess, ['serve'], 'directory_of_saved_model')\n    graph = tf.get_default_graph()\n    out = sess.run([sess.graph.get_tensor_by_name('num_detections:0'),\n            sess.graph.get_tensor_by_name('detection_scores:0'),\n            sess.graph.get_tensor_by_name('detection_boxes:0'),\n            sess.graph.get_tensor_by_name('detection_classes:0')],\n           feed_dict={'encoded_image_string_tensor:0': inp})",
            "masked_code": "import cv2\nimport tensorflow as tf\ncv2.imread(filepath)\nflag, bts = cv.imencode('.jpg', img)\ninp = [bts[:,0].tobytes()]\nwith tf.Session(graph=tf.Graph()) as sess:\n    <line_mask>\n    graph = tf.get_default_graph()\n    out = sess.run([sess.graph.get_tensor_by_name('num_detections:0'),\n            sess.graph.get_tensor_by_name('detection_scores:0'),\n            sess.graph.get_tensor_by_name('detection_boxes:0'),\n            sess.graph.get_tensor_by_name('detection_classes:0')],\n           feed_dict={'encoded_image_string_tensor:0': inp})",
            "masked_line": "tf.saved_model.loader.load(sess, ['serve'], 'directory_of_saved_model')",
            "answer": "saved_model",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_86",
            "model_output": "['<start>tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)<end>', '<start>tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)<end>', '<start>tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)<end>', '<start>tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)<end>', '<start>tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)<end>', '<start>tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)<end>']",
            "model_output_token_clear": "['tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)', 'tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)', 'tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)', 'tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)', 'tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)', 'tf.saved_model.loader.load(sess, [\"serve\"], path_to_model)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-11-07",
            "description": "This code loads a pre-trained TensorFlow model from a saved directory and uses OpenCV to read and preprocess an image. It then runs the model on the image to detect objects and returns the number of detections, detection scores, detection boxes, and detection classes for the objects in the image.",
            "code": "import cv2\nimport tensorflow as tf\nimport numpy as np\nwith tf.Session(graph=tf.Graph()) as sess:\n    tf.saved_model.loader.load(sess, ['serve'], 'directory_of_saved_model')\n    graph = tf.get_default_graph()\n    # Read and preprocess an image.\n    img = cv2.imread(filepath)\n    # Run the model\n    out = sess.run([sess.graph.get_tensor_by_name('num_detections:0'),\n                    sess.graph.get_tensor_by_name('detection_scores:0'),\n                    sess.graph.get_tensor_by_name('detection_boxes:0'),\n                    sess.graph.get_tensor_by_name('detection_classes:0')],\n                   feed_dict={'map/TensorArrayStack/TensorArrayGatherV3:0': img[np.newaxis, :, :, :]})",
            "masked_code": "import cv2\nimport tensorflow as tf\nimport numpy as np\nwith tf.Session(graph=tf.Graph()) as sess:\n    <line_mask>\n    graph = tf.get_default_graph()\n    # Read and preprocess an image.\n    img = cv2.imread(filepath)\n    # Run the model\n    out = sess.run([sess.graph.get_tensor_by_name('num_detections:0'),\n                    sess.graph.get_tensor_by_name('detection_scores:0'),\n                    sess.graph.get_tensor_by_name('detection_boxes:0'),\n                    sess.graph.get_tensor_by_name('detection_classes:0')],\n                   feed_dict={'map/TensorArrayStack/TensorArrayGatherV3:0': img[np.newaxis, :, :, :]})",
            "masked_line": "tf.saved_model.loader.load(sess, ['serve'], 'directory_of_saved_model')",
            "answer": "loader",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_87",
            "model_output": "['<start>sess.graph.as_default()<end>', '<start>sess.graph.as_default()<end>', \"<start>tf.import_graph_def(od_graph_def, name='')<end>\", '<start>sess.graph.as_default()<end>', '<start>sess.graph.as_default()<end>', '<start>sess.graph.as_default()<end>']",
            "model_output_token_clear": "['sess.graph.as_default()', 'sess.graph.as_default()', \"tf.import_graph_def(od_graph_def, name='')\", 'sess.graph.as_default()', 'sess.graph.as_default()', 'sess.graph.as_default()']"
        },
        {
            "dependency": "selenium",
            "version": "==3.141.0",
            "time": "2019-10-31",
            "description": "This code opens a headless Chrome browser using Selenium, navigates to the Google website, finds the search bar element by its name, checks if it is displayed, and then prints \"ok\" if the search bar is displayed. If any exceptions occur during this process, it prints the exception. Finally, it quits the browser.",
            "code": "#!/usr/bin/python3\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument('--no-sandbox')\noptions.add_argument('--headless')\noptions.add_argument('--disable-dev-shm-usage')\noptions.add_argument(\"--remote-debugging-port=9222\")\n\ntry:\n  driver = webdriver.Chrome(chrome_options=options)\n  driver.get(\"https://www.google.com\")\n  s = driver.find_element_by_name(\"q\")\n  assert s.is_displayed() is True\n  print(\"ok\")\nexcept Exception as ex:\n  print(ex)\n\ndriver.quit()",
            "masked_code": "#!/usr/bin/python3\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\n<line_mask>\noptions.add_argument('--headless')\noptions.add_argument('--disable-dev-shm-usage')\noptions.add_argument(\"--remote-debugging-port=9222\")\n\ntry:\n  driver = webdriver.Chrome(chrome_options=options)\n  driver.get(\"https://www.google.com\")\n  s = driver.find_element_by_name(\"q\")\n  assert s.is_displayed() is True\n  print(\"ok\")\nexcept Exception as ex:\n  print(ex)\n\ndriver.quit()",
            "masked_line": "options.add_argument('--no-sandbox')",
            "answer": "add_argument",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_88",
            "model_output": "[\"<start>options.add_argument('--no-sandbox')<end>\", \"<start>options.add_argument('--window-size=1920,1080')<end>\", \"<start>options.add_argument('--disable-gpu')<end>\", \"<start>options.add_argument('--no-sandbox')<end>\", \"<start>options.add_argument('--no-sandbox')<end>\", '<start>options.binary_location = \"/usr/bin/google-chrome\" <end>']",
            "model_output_token_clear": "[\"options.add_argument('--no-sandbox')\", \"options.add_argument('--window-size=1920,1080')\", \"options.add_argument('--disable-gpu')\", \"options.add_argument('--no-sandbox')\", \"options.add_argument('--no-sandbox')\", 'options.binary_location = \"/usr/bin/google-chrome\" ']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-20",
            "description": "The code creates a new structured array with two columns ('date' and 'val') by combining the data from arrays 'a' and 'c'. It then populates the structured array with data from 'a' and 'c' arrays and prints the structured array with date and value pairs.",
            "code": "# create the compound dtype\ndtype = np.dtype(dict(names=['date', 'val'], formats=[arr.dtype for arr in (a, c)]))\n\n# create an empty structured array\nstruct = np.empty(a.shape[0], dtype=dtype)\n\n# populate the structured array with the data from your column arrays\nstruct['date'], struct['val'] = a.T, c.T\n\nprint(struct)\n# output:\n#     array([('2018-04-01T15:30:00', 0), ('2018-04-01T15:31:00', 1),\n#            ('2018-04-01T15:32:00', 2), ('2018-04-01T15:33:00', 3),\n#            ('2018-04-01T15:34:00', 4)],\n#           dtype=[('date', '",
            "masked_code": "# create the compound dtype\ndtype = np.dtype(dict(names=['date', 'val'], formats=[arr.dtype for arr in (a, c)]))\n\n# create an empty structured array\n<line_mask>\n\n# populate the structured array with the data from your column arrays\nstruct['date'], struct['val'] = a.T, c.T\n\nprint(struct)\n# output:\n#     array([('2018-04-01T15:30:00', 0), ('2018-04-01T15:31:00', 1),\n#            ('2018-04-01T15:32:00', 2), ('2018-04-01T15:33:00', 3),\n#            ('2018-04-01T15:34:00', 4)],\n#           dtype=[('date', '",
            "masked_line": "struct = np.empty(a.shape[0], dtype=dtype)",
            "answer": "empty",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_89",
            "model_output": "['<start>struct = np.empty(len(a), dtype=dtype)<end>', '<start>struct = np.empty(a.shape[0], dtype=dtype)<end>', '<start>struct = np.empty(len(a), dtype=dtype)<end>', '<start>struct = np.empty(len(a), dtype=dtype)<end>', '<start>struct = np.empty(a.shape[0], dtype=dtype)<end>', '<start>struct = np.empty(len(a), dtype=dtype)<end>']",
            "model_output_token_clear": "['struct = np.empty(len(a), dtype=dtype)', 'struct = np.empty(a.shape[0], dtype=dtype)', 'struct = np.empty(len(a), dtype=dtype)', 'struct = np.empty(len(a), dtype=dtype)', 'struct = np.empty(a.shape[0], dtype=dtype)', 'struct = np.empty(len(a), dtype=dtype)']"
        },
        {
            "dependency": "scipy",
            "version": "==0.16.0",
            "time": "2019-05-20",
            "description": "This function calculates a 1-dimensional maximum filter with the specified window size on an input array, replacing the values at the edges with a fill value if necessary.",
            "code": "from scipy.ndimage.filters import maximum_filter1d\n\ndef max_filter1d_same(a, W, fillna=np.nan):\n    out_dtype = np.full(0,fillna).dtype\n    hW = (W-1)//2 # Half window size\n    out = maximum_filter1d(a,size=W, origin=hW)\n    if out.dtype is out_dtype:\n        out[:W-1] = fillna\n    else:\n        out = np.concatenate((np.full(W-1,fillna), out[W-1:]))\n    return out",
            "masked_code": "<line_mask>\n\ndef max_filter1d_same(a, W, fillna=np.nan):\n    out_dtype = np.full(0,fillna).dtype\n    hW = (W-1)//2 # Half window size\n    out = maximum_filter1d(a,size=W, origin=hW)\n    if out.dtype is out_dtype:\n        out[:W-1] = fillna\n    else:\n        out = np.concatenate((np.full(W-1,fillna), out[W-1:]))\n    return out",
            "masked_line": "from scipy.ndimage.filters import maximum_filter1d",
            "answer": "maximum_filter1d",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_90",
            "model_output": "['<start>out = maximum_filter1d(a,size=W, origin=hW)<end>', '<start>out = maximum_filter1d(a,size=W, origin=hW)<end>', '<start>out = maximum_filter1d(a,size=W, origin=hW)<end>', \"<start>out = maximum_filter1d(a,size=W, mode='reflect', origin=hW)<end>\", '<start>out = maximum_filter1d(a,size=W, origin=hW)<end>', '<start=out=hW<end>']",
            "model_output_token_clear": "['out = maximum_filter1d(a,size=W, origin=hW)', 'out = maximum_filter1d(a,size=W, origin=hW)', 'out = maximum_filter1d(a,size=W, origin=hW)', \"out = maximum_filter1d(a,size=W, mode='reflect', origin=hW)\", 'out = maximum_filter1d(a,size=W, origin=hW)', 'no_answer']"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2020-12-17",
            "description": "The code generates a random integer-valued variable using numpy, calculates the probabilities and values from the variable, and then plots the probability distribution of the variable as a line graph.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create an integer-valued random variable using numpy\nrng = np.random.default_rng(123)\nvariable = rng.laplace(loc=0, scale=5, size=1000).round()\n\n# Create dataframe with values and probabilities\nvar_range = variable.max()-variable.min()\nprobabilities, values = np.histogram(variable, bins=int(var_range), density=True)\n\n# Plot probability distribution like in your example\ndf = pd.DataFrame(dict(value=values[:-1], prob=probabilities))\ndf.plot.line(x='value', y='prob')",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create an integer-valued random variable using numpy\nrng = np.random.default_rng(123)\nvariable = rng.laplace(loc=0, scale=5, size=1000).round()\n\n# Create dataframe with values and probabilities\n<line_mask>\nprobabilities, values = np.histogram(variable, bins=int(var_range), density=True)\n\n# Plot probability distribution like in your example\ndf = pd.DataFrame(dict(value=values[:-1], prob=probabilities))\ndf.plot.line(x='value', y='prob')",
            "masked_line": "var_range = variable.max()-variable.min()",
            "answer": "min",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_91",
            "model_output": "['<start>var_range = max(variable) - min(variable)<end>', '<start>var_range = max(variable) - min(variable) + 1<end>', '<start>df = pd.DataFrame(dict(value=np.arange(min(variable), max(variable)+1), prob=[np.sum(variable == val)/len(variable) for val in np.arange(min(variable), max(variable)+1)]))<end>', '<start>var_range = max(variable) - min(variable)<end>', '<start>var_range = variable.max() - variable.min()<end>', '<start>var_range = variable.max() - variable.min()<end>']",
            "model_output_token_clear": "['var_range = max(variable) - min(variable)', 'var_range = max(variable) - min(variable) + 1', 'df = pd.DataFrame(dict(value=np.arange(min(variable), max(variable)+1), prob=[np.sum(variable == val)/len(variable) for val in np.arange(min(variable), max(variable)+1)]))', 'var_range = max(variable) - min(variable)', 'var_range = variable.max() - variable.min()', 'var_range = variable.max() - variable.min()']"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2020-12-17",
            "description": "The code generates a random variable with Laplace distribution using numpy, creates a dataframe with values and probabilities, and then plots the probability distribution as a line graph using pandas and matplotlib.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create an integer-valued random variable using numpy\nrng = np.random.default_rng(123)\nvariable = rng.laplace(loc=0, scale=5, size=1000).round()\n\n# Create dataframe with values and probabilities\nvar_range = variable.max()-variable.min()\nprobabilities, values = np.histogram(variable, bins=int(var_range), density=True)\n\n# Plot probability distribution like in your example\ndf = pd.DataFrame(dict(value=values[:-1], prob=probabilities))\ndf.plot.line(x='value', y='prob')",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create an integer-valued random variable using numpy\nrng = np.random.default_rng(123)\nvariable = rng.laplace(loc=0, scale=5, size=1000).round()\n\n# Create dataframe with values and probabilities\nvar_range = variable.max()-variable.min()\nprobabilities, values = np.histogram(variable, bins=int(var_range), density=True)\n\n# Plot probability distribution like in your example\ndf = pd.DataFrame(dict(value=values[:-1], prob=probabilities))\n<line_mask>",
            "masked_line": "df.plot.line(x='value', y='prob')",
            "answer": "line",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_92",
            "model_output": "[\"<start>plt.plot(df['value'], df['prob'])<end>\", '<start>plt.plot(df.value, df.prob)<end>', \"<start>plt.plot(df['value'], df['prob'])<end>\", \"<start>plt.plot(df['value'], df['prob'])<end>\", \"<start>plt.plot(df['value'], df['prob'])<end>\", \"<start>plt.plot(df['value'], df['prob'])<end>\"]",
            "model_output_token_clear": "[\"plt.plot(df['value'], df['prob'])\", 'plt.plot(df.value, df.prob)', \"plt.plot(df['value'], df['prob'])\", \"plt.plot(df['value'], df['prob'])\", \"plt.plot(df['value'], df['prob'])\", \"plt.plot(df['value'], df['prob'])\"]"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2020-12-17",
            "description": "The code generates a probability distribution plot for measured data using both a histogram and a kernel density estimate (KDE). The histogram is plotted with specified bins and color settings, while the KDE is plotted in black with some transparency. Additionally, the x-axis limits are saved and then reset to improve the readability of the final plot, and a legend is added to differentiate the KDE plot.",
            "code": "# Better way to plot the probability distribution of measured data,\n# with a kernel density estimate\n\ns = pd.Series(variable)\n\n# Plot pandas histogram\ns.plot.hist(bins=20, density=True, edgecolor='w', linewidth=0.5)\n\n# Save default x-axis limits for final formatting because the pandas kde\n# plot uses much wider limits which decreases readability\nax = plt.gca()\nxlim = ax.get_xlim()\n\n# Plot pandas KDE\ns.plot.density(color='black', alpha=0.5) # identical to s.plot.kde(...)\n\n# Reset hist x-axis limits and add legend\nax.set_xlim(xlim)\nax.legend(labels=['KDE'], frameon=False)",
            "masked_code": "# Better way to plot the probability distribution of measured data,\n# with a kernel density estimate\n\ns = pd.Series(variable)\n\n# Plot pandas histogram\ns.plot.hist(bins=20, density=True, edgecolor='w', linewidth=0.5)\n\n# Save default x-axis limits for final formatting because the pandas kde\n# plot uses much wider limits which decreases readability\nax = plt.gca()\nxlim = ax.get_xlim()\n\n# Plot pandas KDE\n<line_mask>\n\n# Reset hist x-axis limits and add legend\nax.set_xlim(xlim)\nax.legend(labels=['KDE'], frameon=False)",
            "masked_line": "s.plot.density(color='black', alpha=0.5) # identical to s.plot.kde(...)",
            "answer": "plot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_93",
            "model_output": "[\"<start>s.plot.kde(color='black', alpha=0.5)<end>\", \"<start>s.plot.kde(color='black', alpha=0.5)<end>\", \"<start>s.plot.kde(linewidth=2, kernel='gau', color='black', alpha=0.5)<end>\", \"<start>s.plot.kde(color='black', alpha=0.5)<end>\", \"<start>s.plot.kde(color='black', alpha=0.5)<end>\", \"<start>s.plot.kde(color='black', alpha=0.5)<end>\"]",
            "model_output_token_clear": "[\"s.plot.kde(color='black', alpha=0.5)\", \"s.plot.kde(color='black', alpha=0.5)\", \"s.plot.kde(linewidth=2, kernel='gau', color='black', alpha=0.5)\", \"s.plot.kde(color='black', alpha=0.5)\", \"s.plot.kde(color='black', alpha=0.5)\", \"s.plot.kde(color='black', alpha=0.5)\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2020-12-17",
            "description": "The code plots the probability distribution of measured data by first creating a pandas Series from the data, then plotting a histogram with 20 bins and density normalized. It saves the default x-axis limits for final formatting, plots a kernel density estimate (KDE) for the data, resets the x-axis limits to the default values, and adds a legend labeling the KDE plot.",
            "code": "# Better way to plot the probability distribution of measured data,\n# with a kernel density estimate\n\ns = pd.Series(variable)\n\n# Plot pandas histogram\ns.plot.hist(bins=20, density=True, edgecolor='w', linewidth=0.5)\n\n# Save default x-axis limits for final formatting because the pandas kde\n# plot uses much wider limits which decreases readability\nax = plt.gca()\nxlim = ax.get_xlim()\n\n# Plot pandas KDE\ns.plot.density(color='black', alpha=0.5) # identical to s.plot.kde(...)\n\n# Reset hist x-axis limits and add legend\nax.set_xlim(xlim)\nax.legend(labels=['KDE'], frameon=False)",
            "masked_code": "# Better way to plot the probability distribution of measured data,\n# with a kernel density estimate\n\ns = pd.Series(variable)\n\n# Plot pandas histogram\ns.plot.hist(bins=20, density=True, edgecolor='w', linewidth=0.5)\n\n# Save default x-axis limits for final formatting because the pandas kde\n# plot uses much wider limits which decreases readability\nax = plt.gca()\nxlim = ax.get_xlim()\n\n# Plot pandas KDE\ns.plot.density(color='black', alpha=0.5) # identical to s.plot.kde(...)\n\n# Reset hist x-axis limits and add legend\nax.set_xlim(xlim)\n<line_mask>",
            "masked_line": "ax.legend(labels=['KDE'], frameon=False)",
            "answer": "legend",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_94",
            "model_output": "[\"<start>ax.legend(['Histogram', 'KDE'])<end>\", '<start>ax.legend([\"Histogram\", \"KDE\"])<end>', '<start>ax.legend([\"Histogram\", \"KDE\"])<end>', '<start>ax.legend([\"Histogram\", \"KDE\"])<end>', \"<start>ax.legend(['Histogram', 'KDE'])<end>\", '<start>ax.legend([\"Histogram\", \"KDE\"])<end>']",
            "model_output_token_clear": "[\"ax.legend(['Histogram', 'KDE'])\", 'ax.legend([\"Histogram\", \"KDE\"])', 'ax.legend([\"Histogram\", \"KDE\"])', 'ax.legend([\"Histogram\", \"KDE\"])', \"ax.legend(['Histogram', 'KDE'])\", 'ax.legend([\"Histogram\", \"KDE\"])']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-05-09",
            "description": "This code calculates the exponential of the negative squared Euclidean distance between each point (x2, y2) and all points in the sample grid, where x2 and y2 are coordinates from the given row and header indices.",
            "code": "rows = np.arange(sample.shape[0])\ncols = np.arange(sample.shape[1])\nx2, y2 = (row[header[i]], row[header[i + 1]])\nout = np.exp(-1 * (np.sqrt((x2 - rows[:,None])**2 + (y2 - cols)**2) / 0.8**2))",
            "masked_code": "rows = np.arange(sample.shape[0])\n<line_mask>\nx2, y2 = (row[header[i]], row[header[i + 1]])\nout = np.exp(-1 * (np.sqrt((x2 - rows[:,None])**2 + (y2 - cols)**2) / 0.8**2))",
            "masked_line": "cols = np.arange(sample.shape[1])",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_95",
            "model_output": "['<start>np.random.shuffle(rows)<end>', '<start>np.random.shuffle(rows)<end>', '<start>np.random.shuffle(rows)<end>', '<start>np.random.shuffle(rows)<end>', '<start>np.random.shuffle(rows)<end>', '<start>np.random.shuffle(rows)<end>']",
            "model_output_token_clear": "['np.random.shuffle(rows)', 'np.random.shuffle(rows)', 'np.random.shuffle(rows)', 'np.random.shuffle(rows)', 'np.random.shuffle(rows)', 'np.random.shuffle(rows)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-05",
            "description": "The code generates a plot with multiple curves, with each curve being a sine wave with added noise.",
            "code": "import numpy as np                 # v 1.19.2\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1)\n\nx = np.linspace(0, 5*np.pi, 50)\ny = np.sin(x)\n# error = np.random.normal(0.1, 0.02, size=x.shape) # I leave this out\nnb_yfuncs = 25\nynoise = rng.normal(1, 0.1, size=(nb_yfuncs, y.size))\nyfuncs = nb_yfuncs*[y] + ynoise\n\nfig, ax = plt.subplots(figsize=(10,4))\nfor yfunc in yfuncs:\n    plt.plot(x, yfunc, 'k-')\n\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n<line_mask>\n\nx = np.linspace(0, 5*np.pi, 50)\ny = np.sin(x)\n# error = np.random.normal(0.1, 0.02, size=x.shape) # I leave this out\nnb_yfuncs = 25\nynoise = rng.normal(1, 0.1, size=(nb_yfuncs, y.size))\nyfuncs = nb_yfuncs*[y] + ynoise\n\nfig, ax = plt.subplots(figsize=(10,4))\nfor yfunc in yfuncs:\n    plt.plot(x, yfunc, 'k-')\n\nplt.show()",
            "masked_line": "rng = np.random.default_rng(seed=1)",
            "answer": "default_rng",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_96",
            "model_output": "['<start>rng = np.random.default_rng()<end>', '<start>rng = np.random.default_rng()<end>', '<start>rng = np.random.default_rng()<end>', '<start>rng = np.random.default_rng()<end>', '<start>rng = np.random.default_rng()<end>', '<start>rng = np.random.default_rng()<end>']",
            "model_output_token_clear": "['rng = np.random.default_rng()', 'rng = np.random.default_rng()', 'rng = np.random.default_rng()', 'rng = np.random.default_rng()', 'rng = np.random.default_rng()', 'rng = np.random.default_rng()']"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-05",
            "description": "This code calculates the mean, minimum, and maximum values of a dataset along the specified axis. It then computes the error between the mean and the minimum values, as well as between the maximum and the mean values. Finally, it generates a plot with error bars and an error band to visualize the data.",
            "code": "ymean = yfuncs.mean(axis=0)\nymin = yfuncs.min(axis=0)\nymax = yfuncs.max(axis=0)\nyerror = np.stack((ymean-ymin, ymax-ymean))\n\nfig, ax = plt.subplots(figsize=(10,4))\nplt.fill_between(x, ymin, ymax, alpha=0.2, label='error band')\nplt.errorbar(x, ymean, yerror, color='tab:blue', ecolor='tab:blue',\n             capsize=3, linewidth=1, label='mean with error bars')\nplt.legend()\n\nplt.show()",
            "masked_code": "ymean = yfuncs.mean(axis=0)\nymin = yfuncs.min(axis=0)\nymax = yfuncs.max(axis=0)\n<line_mask>\n\nfig, ax = plt.subplots(figsize=(10,4))\nplt.fill_between(x, ymin, ymax, alpha=0.2, label='error band')\nplt.errorbar(x, ymean, yerror, color='tab:blue', ecolor='tab:blue',\n             capsize=3, linewidth=1, label='mean with error bars')\nplt.legend()\n\nplt.show()",
            "masked_line": "yerror = np.stack((ymean-ymin, ymax-ymean))",
            "answer": "stack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_97",
            "model_output": "['<start>yerror = np.array([y_errormin, y_errormax]).T<end>', '<start>yerror = np.array([y_errormin, y_errormax]).T<end>', '<start>yerror = np.array([y_errormin, y_errormax])<end>', '<start>yerror = np.array([y_errormin, y_errormax])<end>', '<start>yerror = np.array([y_errormin, y_errormax])<end>', '<start>yerror = np.array([y_errormin, y_errormax]).T<end>']",
            "model_output_token_clear": "['yerror = np.array([y_errormin, y_errormax]).T', 'yerror = np.array([y_errormin, y_errormax]).T', 'yerror = np.array([y_errormin, y_errormax])', 'yerror = np.array([y_errormin, y_errormax])', 'yerror = np.array([y_errormin, y_errormax])', 'yerror = np.array([y_errormin, y_errormax]).T']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-05",
            "description": "The code generates 25 different sinusoidal functions with added noise and plots them on a single graph.",
            "code": "import numpy as np                 # v 1.19.2\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1)\n\nx = np.linspace(0, 5*np.pi, 50)\ny = np.sin(x)\n# error = np.random.normal(0.1, 0.02, size=x.shape) # I leave this out\nnb_yfuncs = 25\nynoise = rng.normal(1, 0.1, size=(nb_yfuncs, y.size))\nyfuncs = nb_yfuncs*[y] + ynoise\n\nfig, ax = plt.subplots(figsize=(10,4))\nfor yfunc in yfuncs:\n    plt.plot(x, yfunc, 'k-')\n\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1)\n\nx = np.linspace(0, 5*np.pi, 50)\ny = np.sin(x)\n# error = np.random.normal(0.1, 0.02, size=x.shape) # I leave this out\nnb_yfuncs = 25\nynoise = rng.normal(1, 0.1, size=(nb_yfuncs, y.size))\nyfuncs = nb_yfuncs*[y] + ynoise\n\n<line_mask>\nfor yfunc in yfuncs:\n    plt.plot(x, yfunc, 'k-')\n\nplt.show()",
            "masked_line": "fig, ax = plt.subplots(figsize=(10,4))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_98",
            "model_output": "['<start>yfuncs = [y + yi for yi in ynoise]<end>', '<start>yfuncs = [y + yi for yi in ynoise]<end>', '<start>yfuncs = [y + yi for yi in ynoise]<end>', '<start>yfuncs = [y + yn for yn in ynoise]<end>', '<start>yfuncs = [y + yi for yi in ynoise]<end>', '<start>yfuncs = [y + yi for yi in ynoise]<end>']",
            "model_output_token_clear": "['yfuncs = [y + yi for yi in ynoise]', 'yfuncs = [y + yi for yi in ynoise]', 'yfuncs = [y + yi for yi in ynoise]', 'yfuncs = [y + yn for yn in ynoise]', 'yfuncs = [y + yi for yi in ynoise]', 'yfuncs = [y + yi for yi in ynoise]']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-05",
            "description": "The code calculates the mean, minimum, and maximum values along the axis of the yfuncs array. It then computes the error values by subtracting the minimum from the mean and the maximum from the mean. Finally, it creates a plot with error bars representing the error band around the mean values of yfuncs.",
            "code": "ymean = yfuncs.mean(axis=0)\nymin = yfuncs.min(axis=0)\nymax = yfuncs.max(axis=0)\nyerror = np.stack((ymean-ymin, ymax-ymean))\n\nfig, ax = plt.subplots(figsize=(10,4))\nplt.fill_between(x, ymin, ymax, alpha=0.2, label='error band')\nplt.errorbar(x, ymean, yerror, color='tab:blue', ecolor='tab:blue',\n             capsize=3, linewidth=1, label='mean with error bars')\nplt.legend()\n\nplt.show()",
            "masked_code": "ymean = yfuncs.mean(axis=0)\nymin = yfuncs.min(axis=0)\nymax = yfuncs.max(axis=0)\nyerror = np.stack((ymean-ymin, ymax-ymean))\n\nfig, ax = plt.subplots(figsize=(10,4))\nplt.fill_between(x, ymin, ymax, alpha=0.2, label='error band')\nplt.errorbar(x, ymean, yerror, color='tab:blue', ecolor='tab:blue',\n             capsize=3, linewidth=1, label='mean with error bars')\nplt.legend()\n\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_99",
            "model_output": "[\"<start>plt.xlabel('X Axis'), plt.ylabel('Y Axis'), plt.title('Mean with Error Bars')<end>\", \"<start>plt.xlabel('x values'), plt.ylabel('y values'), plt.title('Plot with error bars')<end>\", \"<start>plt.xlabel('X'), plt.ylabel('Y'), plt.title('Error band plot')<end>\", \"<start>plt.xlabel('x-axis')<end>\", '<start>ax.set_title(\"Mean with error bars\")<end>', \"<start>ax.set_title('Mean with Error Bars')<end>\"]",
            "model_output_token_clear": "[\"plt.xlabel('X Axis'), plt.ylabel('Y Axis'), plt.title('Mean with Error Bars')\", \"plt.xlabel('x values'), plt.ylabel('y values'), plt.title('Plot with error bars')\", \"plt.xlabel('X'), plt.ylabel('Y'), plt.title('Error band plot')\", \"plt.xlabel('x-axis')\", 'ax.set_title(\"Mean with error bars\")', \"ax.set_title('Mean with Error Bars')\"]"
        },
        {
            "dependency": "ibm-watson",
            "version": ">=4.0",
            "time": "2019-10-05",
            "description": "The code sets up IBM Watson service authentication using an IAM authenticator and a provided API key, then sets the URL for the Watson service.",
            "code": "from ibm_watson import MyService\nfrom ibm_cloud_sdk_core.authenticators import IAMAuthenticator\n\nauthenticator = IAMAuthenticator('{apikey}')\nservice = MyService(\n   authenticator=authenticator\n)\nservice.set_service_url('{url}')",
            "masked_code": "from ibm_watson import MyService\nfrom ibm_cloud_sdk_core.authenticators import IAMAuthenticator\n\nauthenticator = IAMAuthenticator('{apikey}')\n<line_mask>\n   authenticator=authenticator\n)\nservice.set_service_url('{url}')",
            "masked_line": "service = MyService(",
            "answer": "MyService",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_100",
            "model_output": "[\"<start>my_service = MyService('2022-01-01', authenticator=authenticator)<end>\", \"<start>my_service = MyService('2022-01-01', authenticator=authenticator)<end>\", \"<start>my_service = MyService('2022-01-01', authenticator=authenticator)<end>\", \"<start>my_service = MyService('2022-02-16', authenticator=authenticator)<end>\", \"<start>service = MyService('{apikey}', authenticator=authenticator)<end>\", \"<start>my_service = MyService('2021-08-01', authenticator=authenticator)<end>\"]",
            "model_output_token_clear": "[\"my_service = MyService('2022-01-01', authenticator=authenticator)\", \"my_service = MyService('2022-01-01', authenticator=authenticator)\", \"my_service = MyService('2022-01-01', authenticator=authenticator)\", \"my_service = MyService('2022-02-16', authenticator=authenticator)\", \"service = MyService('{apikey}', authenticator=authenticator)\", \"my_service = MyService('2021-08-01', authenticator=authenticator)\"]"
        },
        {
            "dependency": "requests",
            "version": "==2.22.0",
            "time": "2019-12-05",
            "description": "This Python code defines a Azure Functions timer trigger function that runs at a specified frequency. It logs the current UTC timestamp and checks if the timer is past due. It then sends a POST request to a specified URL with parameters and logs the response text.",
            "code": "import datetime\nimport logging\nimport requests\n\nimport azure.functions as func\n\n\ndef main(mytimer: func.TimerRequest) -> None:\n    utc_timestamp = datetime.datetime.utcnow().replace(\n        tzinfo=datetime.timezone.utc).isoformat()\n\n    if mytimer.past_due:\n        logging.info('The timer is past due!')\n\n    logging.info('Python timer trigger function ran at %s', utc_timestamp)\n    url = 'https://functionname.azurewebsites.net/api/httptest?code=master key'\n    PARAMS = {\"name\": \"test\"}\n\n    response_decoded_json = requests.post(url=url, params =PARAMS)\n    logging.info(response_decoded_json.text)",
            "masked_code": "import datetime\nimport logging\nimport requests\n\nimport azure.functions as func\n\n\ndef main(mytimer: func.TimerRequest) -> None:\n    utc_timestamp = datetime.datetime.utcnow().replace(\n        tzinfo=datetime.timezone.utc).isoformat()\n\n    if mytimer.past_due:\n        logging.info('The timer is past due!')\n\n    logging.info('Python timer trigger function ran at %s', utc_timestamp)\n    url = 'https://functionname.azurewebsites.net/api/httptest?code=master key'\n    PARAMS = {\"name\": \"test\"}\n\n    <line_mask>\n    logging.info(response_decoded_json.text)",
            "masked_line": "response_decoded_json = requests.post(url=url, params =PARAMS)",
            "answer": "post",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_101",
            "model_output": "['<start>response_decoded_json = requests.post(url=url, params=PARAMS)<end>', '<start>response_decoded_json = requests.post(url=url, params=PARAMS)<end>', '<start>response_decoded_json = requests.post(url=url, params=PARAMS)<end>', '<start>response_decoded_json = requests.post(url=url, params=PARAMS)<end>', '<start>response_decoded_json = requests.post(url=url, params=PARAMS)<end>', '<start>response_decoded_json = requests.post(url=url, params=PARAMS)<end>']",
            "model_output_token_clear": "['response_decoded_json = requests.post(url=url, params=PARAMS)', 'response_decoded_json = requests.post(url=url, params=PARAMS)', 'response_decoded_json = requests.post(url=url, params=PARAMS)', 'response_decoded_json = requests.post(url=url, params=PARAMS)', 'response_decoded_json = requests.post(url=url, params=PARAMS)', 'response_decoded_json = requests.post(url=url, params=PARAMS)']"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-30",
            "description": "The code generates a real-time histogram of arrival delays by carrier using Bokeh plotting library in Python. The code defines a function to update the plot data asynchronously and a blocking task function that updates the plot data every 5 seconds with random values. Finally, it starts a separate thread to run the blocking task function continuously, while the main thread displays the plot.",
            "code": "from bokeh.models.sources import ColumnDataSource\nfrom bokeh.plotting import figure, curdoc\nfrom functools import partial\nfrom threading import Thread\nfrom random import randint\nfrom tornado import gen\nimport time\n\ndata = {'x': [1, 2, 3, 4], 'y': [10, 20, 30, 40]}\nsource = ColumnDataSource(data)\np = figure(plot_width = 700, plot_height = 700,\n            title = 'Histogram of Arrival Delays by Carrier',\n            x_axis_label = 'Delay (min)', y_axis_label = 'Proportion')\n\ndoc = curdoc()\n\n@gen.coroutine\ndef update(x, y):\n    source.data = {'x': x, 'y': y}\n\ndef blocking_task():\n    while True:\n        # do some blocking computation\n        time.sleep(5)\n        x = [ randint(0, 10) for _ in range(4)]\n        y = [ randint(20, 80) for _ in range(4)]\n        # but update the document from callback\n        doc.add_next_tick_callback(partial(update, x = x, y = y))\n\np.hbar(y = 'x', height = 0.2, right = 'y', source = source)\ndoc.add_root(p)\nthread = Thread(target = blocking_task)\nthread.start()",
            "masked_code": "from bokeh.models.sources import ColumnDataSource\nfrom bokeh.plotting import figure, curdoc\nfrom functools import partial\nfrom threading import Thread\nfrom random import randint\nfrom tornado import gen\nimport time\n\ndata = {'x': [1, 2, 3, 4], 'y': [10, 20, 30, 40]}\nsource = ColumnDataSource(data)\np = figure(plot_width = 700, plot_height = 700,\n            title = 'Histogram of Arrival Delays by Carrier',\n            x_axis_label = 'Delay (min)', y_axis_label = 'Proportion')\n\n<line_mask>\n\n@gen.coroutine\ndef update(x, y):\n    source.data = {'x': x, 'y': y}\n\ndef blocking_task():\n    while True:\n        # do some blocking computation\n        time.sleep(5)\n        x = [ randint(0, 10) for _ in range(4)]\n        y = [ randint(20, 80) for _ in range(4)]\n        # but update the document from callback\n        doc.add_next_tick_callback(partial(update, x = x, y = y))\n\np.hbar(y = 'x', height = 0.2, right = 'y', source = source)\ndoc.add_root(p)\nthread = Thread(target = blocking_task)\nthread.start()",
            "masked_line": "doc = curdoc()",
            "answer": "curdoc",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_102",
            "model_output": "[\"<start>p.circle(x='x', y='y', source=source)<end>\", \"<start>p.circle(x='x', y='y', size=10, source=source)<end>\", \"<start>p.circle(x='x', y='y', source=source)<end>\", \"<start>p.circle(x='x', y='y', source=source)<end>\", \"<start>p.circle(x='x', y='y', source=source)<end>\", \"<start>p.circle(x='x', y='y', size=15, source=source)<end>\"]",
            "model_output_token_clear": "[\"p.circle(x='x', y='y', source=source)\", \"p.circle(x='x', y='y', size=10, source=source)\", \"p.circle(x='x', y='y', source=source)\", \"p.circle(x='x', y='y', source=source)\", \"p.circle(x='x', y='y', source=source)\", \"p.circle(x='x', y='y', size=15, source=source)\"]"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-30",
            "description": "This code creates a Bokeh figure with a histogram of arrival delays by carrier, where the x-axis represents delay in minutes and the y-axis represents proportion. It initializes the data source with predefined values and updates the data source periodically with random values to simulate real-time data updates on the histogram plot.",
            "code": "from bokeh.models.sources import ColumnDataSource\nfrom bokeh.plotting import figure, curdoc\nfrom random import randint\nimport time\n\ndata = {'x': [1, 2, 3, 4], 'y': [10, 20, 30, 40]}\nsource = ColumnDataSource(data)\np = figure(plot_width = 700, plot_height = 700,\n            title = 'Histogram of Arrival Delays by Carrier',\n            x_axis_label = 'Delay (min)', y_axis_label = 'Proportion')\np.hbar(y = 'x', height = 0.2, right = 'y', source = source)\n\ndef update():\n    x = [ randint(0, 10) for _ in range(4)]\n    y = [ randint(20, 80) for _ in range(4)]\n    source.data = {'x': x, 'y': y}\n\ncurdoc().add_periodic_callback(update, 5000)\ncurdoc().add_root(p)",
            "masked_code": "from bokeh.models.sources import ColumnDataSource\nfrom bokeh.plotting import figure, curdoc\nfrom random import randint\nimport time\n\ndata = {'x': [1, 2, 3, 4], 'y': [10, 20, 30, 40]}\nsource = ColumnDataSource(data)\np = figure(plot_width = 700, plot_height = 700,\n            title = 'Histogram of Arrival Delays by Carrier',\n            x_axis_label = 'Delay (min)', y_axis_label = 'Proportion')\n<line_mask>\n\ndef update():\n    x = [ randint(0, 10) for _ in range(4)]\n    y = [ randint(20, 80) for _ in range(4)]\n    source.data = {'x': x, 'y': y}\n\ncurdoc().add_periodic_callback(update, 5000)\ncurdoc().add_root(p)",
            "masked_line": "p.hbar(y = 'x', height = 0.2, right = 'y', source = source)",
            "answer": "hbar",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_103",
            "model_output": "[\"<start>p.circle('x', 'y', source=source)<end>\", \"<start>p.circle('x', 'y', source=source)<end>\", \"<start>p.circle('x', 'y', source=source)<end>\", \"<start>p.circle('x', 'y', source=source)<end>\", \"<start>p.circle('x', 'y', source=source)<end>\", \"<start>p.circle('x', 'y', source=source)<end>\"]",
            "model_output_token_clear": "[\"p.circle('x', 'y', source=source)\", \"p.circle('x', 'y', source=source)\", \"p.circle('x', 'y', source=source)\", \"p.circle('x', 'y', source=source)\", \"p.circle('x', 'y', source=source)\", \"p.circle('x', 'y', source=source)\"]"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-06",
            "description": "This code generates a Bokeh web application with a slider and a radio button group. The radio button group allows the user to select between \"continuous\" and \"on release\" modes for the slider. The slider's value is updated based on the user's interaction, and the value is printed out in the console whenever it changes.",
            "code": "from bokeh.layouts import column\nfrom bokeh.models.callbacks import CustomJS\nfrom bokeh.models.sources import ColumnDataSource\nfrom bokeh.models.widgets import Slider, RadioButtonGroup\nfrom bokeh.plotting import curdoc\n\nsource = ColumnDataSource(data = dict(value = []))\n\ndef cb(attr, old, new): \n    print(\"UPDATE\", source.data['value'])\n\nsource.on_change('data', cb)\n\nmode_select_callback = CustomJS(code = \"\"\"\n    var slider = Bokeh.documents[0].get_model_by_name('my_slider')\n    if (cb_obj.active == 1)\n        slider.callback_policy = \"mouseup\"\n    else (cb_obj.active == 0)\n        slider.callback_policy = \"throttle\" \"\"\")\n\nmodeSelect = RadioButtonGroup(labels = [\"continuous\", \"on release\"], active = 1, button_type = 'default', width = 300)\nmodeSelect.callback = mode_select_callback\nslider = Slider(start = 1, end = 10, value = 1, step = 0.1, callback_policy = 'mouseup', width = 200, name = 'my_slider')\nslider.callback = CustomJS(args = dict(source = source), code = \"source.data = { value: [cb_obj.value] }\")\n\ncurdoc().add_root(column(modeSelect, slider))",
            "masked_code": "from bokeh.layouts import column\nfrom bokeh.models.callbacks import CustomJS\nfrom bokeh.models.sources import ColumnDataSource\nfrom bokeh.models.widgets import Slider, RadioButtonGroup\nfrom bokeh.plotting import curdoc\n\nsource = ColumnDataSource(data = dict(value = []))\n\ndef cb(attr, old, new): \n    print(\"UPDATE\", source.data['value'])\n\nsource.on_change('data', cb)\n\nmode_select_callback = CustomJS(code = \"\"\"\n    var slider = Bokeh.documents[0].get_model_by_name('my_slider')\n    if (cb_obj.active == 1)\n        slider.callback_policy = \"mouseup\"\n    else (cb_obj.active == 0)\n        slider.callback_policy = \"throttle\" \"\"\")\n\nmodeSelect = RadioButtonGroup(labels = [\"continuous\", \"on release\"], active = 1, button_type = 'default', width = 300)\nmodeSelect.callback = mode_select_callback\nslider = Slider(start = 1, end = 10, value = 1, step = 0.1, callback_policy = 'mouseup', width = 200, name = 'my_slider')\nslider.callback = CustomJS(args = dict(source = source), code = \"source.data = { value: [cb_obj.value] }\")\n\n<line_mask>",
            "masked_line": "curdoc().add_root(column(modeSelect, slider))",
            "answer": "curdoc",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_104",
            "model_output": "['<start>curdoc().add_root(column(modeSelect, slider))<end>', '<start>curdoc().add_root(column(modeSelect, slider))<end>', '<start>layout = column(modeSelect, slider)<end>', '<start>curdoc().add_root(column(modeSelect, slider))<end>', '<start>curdoc().add_root(column(modeSelect, slider))<end>', '<start>curdoc().add_root(column(modeSelect, slider))<end>']",
            "model_output_token_clear": "['curdoc().add_root(column(modeSelect, slider))', 'curdoc().add_root(column(modeSelect, slider))', 'layout = column(modeSelect, slider)', 'curdoc().add_root(column(modeSelect, slider))', 'curdoc().add_root(column(modeSelect, slider))', 'curdoc().add_root(column(modeSelect, slider))']"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-06",
            "description": "This code creates a Bokeh layout with a slider widget and a radio button group. The slider allows users to select a value between 1 and 10, and updates a data source with the selected value. The radio button group allows users to switch between continuous and on release callback policies for the slider.",
            "code": "from bokeh.layouts import column\nfrom bokeh.models.callbacks import CustomJS\nfrom bokeh.models.sources import ColumnDataSource\nfrom bokeh.models.widgets import Slider, RadioButtonGroup\nfrom bokeh.plotting import curdoc\n\nlayout = column()\n\ndef create_slider(callback_policy):\n    slider = Slider(start = 1, end = 10, value = 1, step = 0.1, callback_policy = callback_policy, width = 200)\n    slider.callback = CustomJS(args = dict(source = source), code = \"source.data = { value: [cb_obj.value] }\")\n    return slider\n\ndef cb(attr, old, new): print(\"UPDATE\", source.data['value'])\n\nsource = ColumnDataSource(data = dict(value = []))\nsource.on_change('data', cb)\nslider = create_slider(callback_policy = 'mouseup')\n\ndef changeMode(attr, old, new):\n    global slider\n    if modeSelect.active == 0:\n        layout.children.remove(slider)\n        slider = create_slider(callback_policy = 'throttle')\n        layout.children.append(slider)\n    else:\n        layout.children.remove(slider)\n        slider = create_slider(callback_policy = 'mouseup')\n        layout.children.append(slider)\n\nmodeSelect = RadioButtonGroup(labels = [\"continuous\", \"on release\"], active = 1, button_type = 'default', width = 300)\nmodeSelect.on_change('active', changeMode)\n\nlayout.children.append(modeSelect)\nlayout.children.append(slider)\ncurdoc().add_root(layout)",
            "masked_code": "from bokeh.layouts import column\n<line_mask>\nfrom bokeh.models.sources import ColumnDataSource\nfrom bokeh.models.widgets import Slider, RadioButtonGroup\nfrom bokeh.plotting import curdoc\n\nlayout = column()\n\ndef create_slider(callback_policy):\n    slider = Slider(start = 1, end = 10, value = 1, step = 0.1, callback_policy = callback_policy, width = 200)\n    slider.callback = CustomJS(args = dict(source = source), code = \"source.data = { value: [cb_obj.value] }\")\n    return slider\n\ndef cb(attr, old, new): print(\"UPDATE\", source.data['value'])\n\nsource = ColumnDataSource(data = dict(value = []))\nsource.on_change('data', cb)\nslider = create_slider(callback_policy = 'mouseup')\n\ndef changeMode(attr, old, new):\n    global slider\n    if modeSelect.active == 0:\n        layout.children.remove(slider)\n        slider = create_slider(callback_policy = 'throttle')\n        layout.children.append(slider)\n    else:\n        layout.children.remove(slider)\n        slider = create_slider(callback_policy = 'mouseup')\n        layout.children.append(slider)\n\nmodeSelect = RadioButtonGroup(labels = [\"continuous\", \"on release\"], active = 1, button_type = 'default', width = 300)\nmodeSelect.on_change('active', changeMode)\n\nlayout.children.append(modeSelect)\nlayout.children.append(slider)\ncurdoc().add_root(layout)",
            "masked_line": "from bokeh.models.callbacks import CustomJS",
            "answer": "CustomJS",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_105",
            "model_output": "['<start>source = ColumnDataSource(data=dict(value=[1]))<end>', '<start>source = ColumnDataSource(data=dict(value=[1]))<end>', \"<start>layout.children.append(create_slider(callback_policy='mouseup'))<end>\", '<start>layout.children.append(column())<end>', '<start>layout = column()<end>', '<start>layout = column()<end>']",
            "model_output_token_clear": "['source = ColumnDataSource(data=dict(value=[1]))', 'source = ColumnDataSource(data=dict(value=[1]))', \"layout.children.append(create_slider(callback_policy='mouseup'))\", 'layout.children.append(column())', 'layout = column()', 'layout = column()']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-12",
            "description": "The code reads a csv string with columns 'col_a', 'col_b', and 'col_c', converts it into a numpy array, multiplies the values in 'col_a' by 4, and prints the result.",
            "code": "import numpy as np\nfrom io import StringIO\n\ncsv = '''col_a\\tcol_b\\tcol_c\n5.0\\t19.6\\t22.8\n6.0\\t42.42\\t39.208\n'''\n\narr = np.genfromtxt(StringIO(csv), dtype=np.float64, delimiter='\\t', names=True)\n\nxcol_a = arr['col_a']*4\nprint(xcol_a)\n# output: [20. 24.]",
            "masked_code": "import numpy as np\nfrom io import StringIO\n\ncsv = '''col_a\\tcol_b\\tcol_c\n5.0\\t19.6\\t22.8\n6.0\\t42.42\\t39.208\n'''\n\n<line_mask>\n\nxcol_a = arr['col_a']*4\nprint(xcol_a)\n# output: [20. 24.]",
            "masked_line": "arr = np.genfromtxt(StringIO(csv), dtype=np.float64, delimiter='\\t', names=True)",
            "answer": "genfromtxt",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_106",
            "model_output": "[\"<start>arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', skip_header=1)<end>\", \"<start>arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', dtype=None)<end>\", \"<start>arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', skip_header=1)<end>\", \"<start>arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', skip_header=1)<end>\", \"<start>arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', skip_header=1)<end>\", \"<start>arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', dtype=float)<end>\"]",
            "model_output_token_clear": "[\"arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', skip_header=1)\", \"arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', dtype=None)\", \"arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', skip_header=1)\", \"arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', skip_header=1)\", \"arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', skip_header=1)\", \"arr = np.genfromtxt(StringIO(csv), delimiter='\\\\t', dtype=float)\"]"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-01-07",
            "description": "The code defines a CLI application using the Click library in Python. It includes two commands - `command1` and `command2`. \n\n`command1` allows adding arguments to a dictionary stored in the context object.\n\n`command2` takes a single argument and prints out the context object and keyword arguments received.\n\nThe code also includes a custom command class `AcceptAllCommand` that extends the Click `Command` class and implements a custom parser that allows adding options dynamically if they are not already known to the parser.",
            "code": "import click\n\nclass AcceptAllCommand(click.Command):\n\n    def make_parser(self, ctx):\n        \"\"\"Hook 'make_parser' and allow the opt dict to find any option\"\"\"\n        parser = super(AcceptAllCommand, self).make_parser(ctx)\n        command = self\n\n        class AcceptAllDict(dict):\n\n            def __contains__(self, item):\n                \"\"\"If the parser does no know this option, add it\"\"\"\n\n                if not super(AcceptAllDict, self).__contains__(item):\n                    # create an option name\n                    name = item.lstrip('-')\n\n                    # add the option to our command\n                    click.option(item)(command)\n\n                    # get the option instance from the command\n                    option = command.params[-1]\n\n                    # add the option instance to the parser\n                    parser.add_option(\n                        [item], name.replace('-', '_'), obj=option)\n                return True\n\n        # set the parser options to our dict\n        parser._short_opt = AcceptAllDict(parser._short_opt)\n        parser._long_opt = AcceptAllDict(parser._long_opt)\n\n        return parser\n\n\n@click.group(chain=True)\n@click.pass_context\ndef cli(ctx, **kwargs):\n    \"\"\"\"\"\"\n\n\n@cli.command(cls=AcceptAllCommand)\n@click.pass_context\ndef command1(ctx, **kwargs):\n    \"\"\"Add command1.\"\"\"\n    ctx.obj['command1_args'] = {}\n    for k, v in kwargs.items():\n        ctx.obj['command1_args'][k] = v\n\n\n@cli.command()\n@click.argument('command2-argument1', type=str)\n@click.pass_context\ndef command2(ctx, **kwargs):\n    \"\"\"Add command2.\"\"\"\n    print(ctx.obj)\n    print(kwargs)\n\n\nif __name__ == \"__main__\":\n    commands = (\n        \"command1 --cmd1-opt1 foo --cmd1-opt2 bar command2 hello\",\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split(), obj={})\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\nclass AcceptAllCommand(click.Command):\n\n    def make_parser(self, ctx):\n        \"\"\"Hook 'make_parser' and allow the opt dict to find any option\"\"\"\n        parser = super(AcceptAllCommand, self).make_parser(ctx)\n        command = self\n\n        class AcceptAllDict(dict):\n\n            def __contains__(self, item):\n                \"\"\"If the parser does no know this option, add it\"\"\"\n\n                if not super(AcceptAllDict, self).__contains__(item):\n                    # create an option name\n                    name = item.lstrip('-')\n\n                    # add the option to our command\n                    <line_mask>\n\n                    # get the option instance from the command\n                    option = command.params[-1]\n\n                    # add the option instance to the parser\n                    parser.add_option(\n                        [item], name.replace('-', '_'), obj=option)\n                return True\n\n        # set the parser options to our dict\n        parser._short_opt = AcceptAllDict(parser._short_opt)\n        parser._long_opt = AcceptAllDict(parser._long_opt)\n\n        return parser\n\n\n@click.group(chain=True)\n@click.pass_context\ndef cli(ctx, **kwargs):\n    \"\"\"\"\"\"\n\n\n@cli.command(cls=AcceptAllCommand)\n@click.pass_context\ndef command1(ctx, **kwargs):\n    \"\"\"Add command1.\"\"\"\n    ctx.obj['command1_args'] = {}\n    for k, v in kwargs.items():\n        ctx.obj['command1_args'][k] = v\n\n\n@cli.command()\n@click.argument('command2-argument1', type=str)\n@click.pass_context\ndef command2(ctx, **kwargs):\n    \"\"\"Add command2.\"\"\"\n    print(ctx.obj)\n    print(kwargs)\n\n\nif __name__ == \"__main__\":\n    commands = (\n        \"command1 --cmd1-opt1 foo --cmd1-opt2 bar command2 hello\",\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split(), obj={})\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "click.option(item)(command)",
            "answer": "option",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_107",
            "model_output": "[\"<start>command.params.append(click.Option([item], name.replace('-', '_'), help=''))<end>\", \"<start>command.params.append(click.Option([item], name.replace('-', '_'), help=''))<end>\", \"<start>command.params.append(click.Option([item], name.replace('-', '_'), help=''))<end>\", \"<start>command.params.append(click.Option([item], name.replace('-', '_'), help=''))<end>\", \"<start>command.params.append(click.Option([item], name.replace('-', '_'), help=''))<end>\", \"<start>command.params.append(click.Option([item], name.replace('-', '_'))) <end>\"]",
            "model_output_token_clear": "[\"command.params.append(click.Option([item], name.replace('-', '_'), help=''))\", \"command.params.append(click.Option([item], name.replace('-', '_'), help=''))\", \"command.params.append(click.Option([item], name.replace('-', '_'), help=''))\", \"command.params.append(click.Option([item], name.replace('-', '_'), help=''))\", \"command.params.append(click.Option([item], name.replace('-', '_'), help=''))\", \"command.params.append(click.Option([item], name.replace('-', '_'))) \"]"
        },
        {
            "dependency": "tensorflow",
            "version": ">=2.0",
            "time": "2019-10-03",
            "description": "The code configures TensorFlow to allow GPU memory growth during runtime.",
            "code": "import tensorflow as tf\nconfig = tf.compat.v1.ConfigProto()\nconfig.gpu_options.allow_growth = True\ntf.compat.v1.keras.backend.set_session(tf.compat.v1.Session(config=config))",
            "masked_code": "import tensorflow as tf\nconfig = tf.compat.v1.ConfigProto()\nconfig.gpu_options.allow_growth = True\n<line_mask>",
            "masked_line": "tf.compat.v1.keras.backend.set_session(tf.compat.v1.Session(config=config))",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_108",
            "model_output": "['<start>config.gpu_options.per_process_gpu_memory_fraction = 0.12<end>', '<start>config.gpu_options.per_process_gpu_memory_fraction = 0.12<end>', '<start>config.gpu_options.per_process_gpu_memory_fraction = 0.12<end>', '<start>config.gpu_options.per_process_gpu_memory_fraction = 0.12<end>', '<start>config.gpu_options.per_process_gpu_memory_fraction = 0.12<end>', '<start>config.gpu_options.per_process_gpu_memory_fraction = 0.12<end>']",
            "model_output_token_clear": "['config.gpu_options.per_process_gpu_memory_fraction = 0.12', 'config.gpu_options.per_process_gpu_memory_fraction = 0.12', 'config.gpu_options.per_process_gpu_memory_fraction = 0.12', 'config.gpu_options.per_process_gpu_memory_fraction = 0.12', 'config.gpu_options.per_process_gpu_memory_fraction = 0.12', 'config.gpu_options.per_process_gpu_memory_fraction = 0.12']"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2019-10-18",
            "description": "This code sets a random seed of 4 for TensorFlow.",
            "code": "import tensorflow as tf\ntf.set_random_seed(4)",
            "masked_code": "import tensorflow as tf\n<line_mask>",
            "masked_line": "tf.set_random_seed(4)",
            "answer": "set_random_seed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_109",
            "model_output": "['<start>tf.random.set_seed(4)<end>', '<start>tf.random.set_seed(4)<end>', '<start>tf.random.set_seed(4)<end>', '<start>tf.random.set_seed(4)<end>', '<start>tf.random.set_seed(4)<end>', '<start>tf.random.set_seed(4)<end>']",
            "model_output_token_clear": "['tf.random.set_seed(4)', 'tf.random.set_seed(4)', 'tf.random.set_seed(4)', 'tf.random.set_seed(4)', 'tf.random.set_seed(4)', 'tf.random.set_seed(4)']"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2020-05-31",
            "description": "The code sets the learning rate of the optimizer used in the model to 0.001.",
            "code": "from keras import backend as K\nK.set_value(model.optimizer.learning_rate, 0.001)",
            "masked_code": "from keras import backend as K\n<line_mask>",
            "masked_line": "K.set_value(model.optimizer.learning_rate, 0.001)",
            "answer": "set_value",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_110",
            "model_output": "['<start>K.set_value(K.optimizer_lr, 0.001)<end>', '<start>K.set_value(K.optimizer_lr, 0.001)<end>', '<start>K.set_value(K.optimizer_lr, 0.001)<end>', \"<start>K.set_value(K.get_session().run(K.tf_variables('adam')[0].learning_rate), 0.001)<end>\", '<start>K.set_value(K.optimizer.lr, 0.001)<end>', \"<start>K.set_value(K.get_optimizer('adam').lr, 0.001)<end>\"]",
            "model_output_token_clear": "['K.set_value(K.optimizer_lr, 0.001)', 'K.set_value(K.optimizer_lr, 0.001)', 'K.set_value(K.optimizer_lr, 0.001)', \"K.set_value(K.get_session().run(K.tf_variables('adam')[0].learning_rate), 0.001)\", 'K.set_value(K.optimizer.lr, 0.001)', \"K.set_value(K.get_optimizer('adam').lr, 0.001)\"]"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2020-05-31",
            "description": "The code creates a sequential model using Keras with a single dense layer of 1 neuron and takes an input array of shape (10,). It then compiles the model using the mean squared error loss function and the Adam optimizer with a learning rate of 0.01. After training the model for 50 epochs, it changes the learning rate to 0.001 and continues training for another 50 epochs. The code prints the learning rate before and after the training process.",
            "code": "from keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras import backend as K\nimport keras\nimport numpy as np\n\nmodel = Sequential()\n\nmodel.add(Dense(1, input_shape=(10,)))\n\noptimizer = keras.optimizers.Adam(lr=0.01)\nmodel.compile(loss='mse', optimizer=optimizer)\n\nprint(\"Learning rate before first fit:\", model.optimizer.learning_rate.numpy())\n\nmodel.fit(np.random.randn(50,10), np.random.randn(50), epochs=50, verbose=0)\n\n# Change learning rate to 0.001 and train for 50 more epochs\nK.set_value(model.optimizer.learning_rate, 0.001)\nprint(\"Learning rate before second fit:\", model.optimizer.learning_rate.numpy())\n\nmodel.fit(np.random.randn(50,10), \n          np.random.randn(50), \n          initial_epoch=50, \n          epochs=50,\n          verbose=0)",
            "masked_code": "from keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras import backend as K\nimport keras\nimport numpy as np\n\nmodel = Sequential()\n\n<line_mask>\n\noptimizer = keras.optimizers.Adam(lr=0.01)\nmodel.compile(loss='mse', optimizer=optimizer)\n\nprint(\"Learning rate before first fit:\", model.optimizer.learning_rate.numpy())\n\nmodel.fit(np.random.randn(50,10), np.random.randn(50), epochs=50, verbose=0)\n\n# Change learning rate to 0.001 and train for 50 more epochs\nK.set_value(model.optimizer.learning_rate, 0.001)\nprint(\"Learning rate before second fit:\", model.optimizer.learning_rate.numpy())\n\nmodel.fit(np.random.randn(50,10), \n          np.random.randn(50), \n          initial_epoch=50, \n          epochs=50,\n          verbose=0)",
            "masked_line": "model.add(Dense(1, input_shape=(10,)))",
            "answer": "add",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_111",
            "model_output": "['<start>model.add(Dense(units=1, input_dim=10))<end>', '<start>model.add(Dense(units=1, input_dim=10))<end>', '<start>model.add(Dense(units=1, input_dim=10))<end>', '<start>model.add(Dense(units=1, input_dim=10))<end>', \"<start>model.add(Dense(units=1, input_shape=(10,), kernel_initializer='uniform', activation='relu'))<end>\", '<start>model.add(Dense(units=1, input_dim=10))<end>']",
            "model_output_token_clear": "['model.add(Dense(units=1, input_dim=10))', 'model.add(Dense(units=1, input_dim=10))', 'model.add(Dense(units=1, input_dim=10))', 'model.add(Dense(units=1, input_dim=10))', \"model.add(Dense(units=1, input_shape=(10,), kernel_initializer='uniform', activation='relu'))\", 'model.add(Dense(units=1, input_dim=10))']"
        },
        {
            "dependency": "sklearn",
            "version": ">=1.2",
            "time": "2022-12-12",
            "description": "The code generates ROC curve displays for two different estimators (svc and rfc) using the X_test and y_test data, with the rfc display sharing the same plot axis as the svc display.",
            "code": "from sklearn.metrics import RocCurveDisplay\nsvc_disp = RocCurveDisplay.from_estimator(svc, X_test, y_test)\nrfc_disp = RocCurveDisplay.from_estimator(rfc, X_test, y_test, ax=svc_disp.ax_)",
            "masked_code": "from sklearn.metrics import RocCurveDisplay\n<line_mask>\nrfc_disp = RocCurveDisplay.from_estimator(rfc, X_test, y_test, ax=svc_disp.ax_)",
            "masked_line": "svc_disp = RocCurveDisplay.from_estimator(svc, X_test, y_test)",
            "answer": "from_estimator",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_112",
            "model_output": "['<start>svc_disp = RocCurveDisplay.from_estimator(svc,X_test,y_test)<end>', '<start>svc_disp = RocCurveDisplay.from_estimator(svc, X_test, y_test)<end>', '<start>svc_disp = RocCurveDisplay.from_estimator(svc, X_test, y_test)<end>', '<start>svc_disp = RocCurveDisplay.from_estimator(svc,X_test,y_test)<end>', '<start>svc_disp = RocCurveDisplay.from_estimator(svc, X_test, y_test)<end>', '<start>svc_disp = RocCurveDisplay.from_estimator(svc , X_test , y_test)<end>']",
            "model_output_token_clear": "['svc_disp = RocCurveDisplay.from_estimator(svc,X_test,y_test)', 'svc_disp = RocCurveDisplay.from_estimator(svc, X_test, y_test)', 'svc_disp = RocCurveDisplay.from_estimator(svc, X_test, y_test)', 'svc_disp = RocCurveDisplay.from_estimator(svc,X_test,y_test)', 'svc_disp = RocCurveDisplay.from_estimator(svc, X_test, y_test)', 'svc_disp = RocCurveDisplay.from_estimator(svc , X_test , y_test)']"
        },
        {
            "dependency": "tensorflow",
            "version": ">=2.0",
            "time": "2020-06-03",
            "description": "The code generates a TensorFlow dataset consisting of metadata dictionaries with arrays of zeros and ones. Each dictionary contains arrays of different shapes. The dataset is created using a generator function that iterates over the metadata and yields dictionaries with array values for each key. The dataset is then printed in different formats to show its contents.",
            "code": "import tensorflow as tf\n\nN = 100\n# dictionary of arrays:\nmetadata = {'m1': tf.zeros(shape=(N,2)), 'm2': tf.ones(shape=(N,3,5))}\nnum_samples = N\n\ndef meta_dict_gen():\n    for i in range(num_samples):\n        ls = {}\n        for key, val in metadata.items():\n            ls[key] = val[i]\n        yield ls\n\ndataset = tf.data.Dataset.from_generator(\n    meta_dict_gen,\n    output_types={k: tf.float32 for k in metadata},\n    output_shapes={'m1': (2,), 'm2': (3, 5)})\n\nprint(\"tf.data.Dataset type is:\",dataset,\"\\n\")\n\nfor batch in dataset.take(1):\n  print(\"My type is of:\",type(batch),\"\\n\")\n\nprint(\"Lets print just the first row in dataset :\",\"\\n\",list(dataset.take(1).as_numpy_iterator()),\"\\n\")\n\nprint(\"Lets print using the batch.items() :\")\nfor batch in dataset.take(1):\n  for m1, m2 in batch.items():\n    print(\"{:2s}: {}\".format(m1, m2))",
            "masked_code": "import tensorflow as tf\n\nN = 100\n# dictionary of arrays:\nmetadata = {'m1': tf.zeros(shape=(N,2)), 'm2': tf.ones(shape=(N,3,5))}\nnum_samples = N\n\ndef meta_dict_gen():\n    for i in range(num_samples):\n        ls = {}\n        for key, val in metadata.items():\n            ls[key] = val[i]\n        yield ls\n\n<line_mask>\n    meta_dict_gen,\n    output_types={k: tf.float32 for k in metadata},\n    output_shapes={'m1': (2,), 'm2': (3, 5)})\n\nprint(\"tf.data.Dataset type is:\",dataset,\"\\n\")\n\nfor batch in dataset.take(1):\n  print(\"My type is of:\",type(batch),\"\\n\")\n\nprint(\"Lets print just the first row in dataset :\",\"\\n\",list(dataset.take(1).as_numpy_iterator()),\"\\n\")\n\nprint(\"Lets print using the batch.items() :\")\nfor batch in dataset.take(1):\n  for m1, m2 in batch.items():\n    print(\"{:2s}: {}\".format(m1, m2))",
            "masked_line": "dataset = tf.data.Dataset.from_generator(",
            "answer": "data",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_113",
            "model_output": "[\"<start>dataset = tf.data.Dataset.from_generator(meta_dict_gen(), output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})<end>\", \"<start>dataset = tf.data.Dataset.from_generator(meta_dict_gen, output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})<end>\", '<start>dataset = tf.data.Dataset.from_generator(meta_dict_gen,<end>', \"<start>dataset = tf.data.Dataset.from_generator(meta_dict_gen(), output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})<end>\", \"<start>dataset = tf.data.Dataset.from_generator(meta_dict_gen(), output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})<end>\", \"<start>dataset = tf.data.Dataset.from_generator(meta_dict_gen(), output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})<end>\"]",
            "model_output_token_clear": "[\"dataset = tf.data.Dataset.from_generator(meta_dict_gen(), output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})\", \"dataset = tf.data.Dataset.from_generator(meta_dict_gen, output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})\", 'dataset = tf.data.Dataset.from_generator(meta_dict_gen,', \"dataset = tf.data.Dataset.from_generator(meta_dict_gen(), output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})\", \"dataset = tf.data.Dataset.from_generator(meta_dict_gen(), output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})\", \"dataset = tf.data.Dataset.from_generator(meta_dict_gen(), output_types={k: tf.float32 for k in metadata}, output_shapes={'m1': (2,), 'm2': (3, 5)})\"]"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-01-10",
            "description": "The code calculates the adjusted residual values based on certain conditions. If the residual value falls between 0.0 and 0.5, it will be multiplied by -2*1.2. If it falls between 0.5 and 0.7, it will be multiplied by -2*1.0. If the residual value is greater than 0.7, it will be multiplied by -2*2.0. Any residual values that do not meet these conditions will remain unchanged.",
            "code": "import numpy as np\n\nresidual = np.random.rand(10) -0.3 # -0.3 to get some negative values\ncondlist = [(residual>=0.0)&(residual<=0.5), (residual>=0.5)&(residual<=0.7), residual>0.7]\nchoicelist = [-2*1.2*residual, -2*1.0*residual,-2*2.0*residual]\n\nresidual = np.select(condlist, choicelist, default=residual)",
            "masked_code": "import numpy as np\n\nresidual = np.random.rand(10) -0.3 # -0.3 to get some negative values\ncondlist = [(residual>=0.0)&(residual<=0.5), (residual>=0.5)&(residual<=0.7), residual>0.7]\nchoicelist = [-2*1.2*residual, -2*1.0*residual,-2*2.0*residual]\n\n<line_mask>",
            "masked_line": "residual = np.select(condlist, choicelist, default=residual)",
            "answer": "select",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_114",
            "model_output": "['<start>residual = np.select(condlist, choicelist)<end>', '<start>residual = np.select(condlist, choicelist)<end>', '<start>residual = np.select(condlist, choicelist)<end>', '<start>residual = np.select(condlist, choicelist)<end>', '<start>residual = np.select(condlist, choicelist)<end>', '<start>residual = np.select(condlist, choicelist)<end>']",
            "model_output_token_clear": "['residual = np.select(condlist, choicelist)', 'residual = np.select(condlist, choicelist)', 'residual = np.select(condlist, choicelist)', 'residual = np.select(condlist, choicelist)', 'residual = np.select(condlist, choicelist)', 'residual = np.select(condlist, choicelist)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1",
            "time": "2020-06-16",
            "description": "The given Python code defines a dummy neural network using TensorFlow and Keras. The network architecture consists of two dense layers with activation functions, regularization, and output activation. The network is compiled with specific optimizer, loss function, and metrics. \n\nThe `train` function implements callbacks for reducing learning rate on plateau and early stopping based on validation AUC. It generates random data, creates datasets, initializes the model, and trains it for a specified number of epochs using the defined callbacks. \n\nThe code then runs the training process in a loop three times, printing the loop number before each training iteration.",
            "code": "import numpy as np\nimport tensorflow as tf\nimport tensorflow.keras as keras\nfrom tensorflow.keras.metrics import AUC\n\n\ndef dummy_network(input_shape):\n    model = keras.Sequential()\n    model.add(keras.layers.Dense(10,\n                                 input_shape=input_shape,\n                                 activation=tf.nn.relu,\n                                 kernel_initializer='he_normal',\n                                 kernel_regularizer=keras.regularizers.l2(l=1e-3)))\n\n    model.add(keras.layers.Flatten())\n    model.add(keras.layers.Dense(11, activation='softmax'))\n\n    model.compile(optimizer='adagrad',\n                  loss='binary_crossentropy',\n                  metrics=[AUC(name='auc')])\n    return model\n\n\ndef train():\n    CB_lr = tf.keras.callbacks.ReduceLROnPlateau(\n        monitor=\"val_auc\",\n        patience=3,\n        verbose=1,\n        mode=\"max\",\n        min_delta=0.0001,\n        min_lr=1e-6)\n\n    CB_es = tf.keras.callbacks.EarlyStopping(\n        monitor=\"val_auc\",\n        min_delta=0.00001,\n        verbose=1,\n        patience=10,\n        mode=\"max\",\n        restore_best_weights=True)\n    callbacks = [CB_lr, CB_es]\n    y = tf.keras.utils.to_categorical([np.random.randint(0, 11) for _ in range(1000)])\n    x = [np.ones((37, 12, 1)) for _ in range(1000)]\n    dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()\n    val_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()\n    model = dummy_network(input_shape=((37, 12, 1)))\n    model.fit(dummy_dataset, validation_data=val_dataset, epochs=2,\n              steps_per_epoch=len(x) // 100,\n              validation_steps=len(x) // 100, callbacks=callbacks)\n\n\nfor i in range(3):\n    print(f'\\n\\n **** Loop {i} **** \\n\\n')\n    train()",
            "masked_code": "import numpy as np\nimport tensorflow as tf\nimport tensorflow.keras as keras\nfrom tensorflow.keras.metrics import AUC\n\n\ndef dummy_network(input_shape):\n    model = keras.Sequential()\n    model.add(keras.layers.Dense(10,\n                                 input_shape=input_shape,\n                                 activation=tf.nn.relu,\n                                 kernel_initializer='he_normal',\n                                 kernel_regularizer=keras.regularizers.l2(l=1e-3)))\n\n    model.add(keras.layers.Flatten())\n    model.add(keras.layers.Dense(11, activation='softmax'))\n\n    model.compile(optimizer='adagrad',\n                  loss='binary_crossentropy',\n                  metrics=[AUC(name='auc')])\n    return model\n\n\ndef train():\n    CB_lr = tf.keras.callbacks.ReduceLROnPlateau(\n        monitor=\"val_auc\",\n        patience=3,\n        verbose=1,\n        mode=\"max\",\n        min_delta=0.0001,\n        min_lr=1e-6)\n\n    CB_es = tf.keras.callbacks.EarlyStopping(\n        monitor=\"val_auc\",\n        min_delta=0.00001,\n        verbose=1,\n        patience=10,\n        mode=\"max\",\n        restore_best_weights=True)\n    callbacks = [CB_lr, CB_es]\n    y = tf.keras.utils.to_categorical([np.random.randint(0, 11) for _ in range(1000)])\n    x = [np.ones((37, 12, 1)) for _ in range(1000)]\n    <line_mask>\n    val_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()\n    model = dummy_network(input_shape=((37, 12, 1)))\n    model.fit(dummy_dataset, validation_data=val_dataset, epochs=2,\n              steps_per_epoch=len(x) // 100,\n              validation_steps=len(x) // 100, callbacks=callbacks)\n\n\nfor i in range(3):\n    print(f'\\n\\n **** Loop {i} **** \\n\\n')\n    train()",
            "masked_line": "dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()",
            "answer": "batch",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_115",
            "model_output": "['<start>dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()<end>', '<start>dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()<end>', '<start>dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()<end>', '<start>dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()<end>', '<start>dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()<end>', '<start>dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()<end>']",
            "model_output_token_clear": "['dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()', 'dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()', 'dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()', 'dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()', 'dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()', 'dummy_dataset = tf.data.Dataset.from_tensor_slices((x, y)).batch(batch_size=100).repeat()']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1",
            "time": "2020-06-16",
            "description": "This code defines a dummy neural network model using TensorFlow and Keras. The model consists of a input layer with 10 units and a hidden layer with 11 units, both using ReLU and softmax activation functions respectively. The model is compiled with the 'adagrad' optimizer, 'binary_crossentropy' loss function, and AUC metrics for evaluation.",
            "code": "import numpy as np\nimport tensorflow as tf\nimport tensorflow.keras as keras\nfrom tensorflow.keras.metrics import AUC\n\nauc = AUC()\n\ndef dummy_network(input_shape):\n    model = keras.Sequential()\n    model.add(keras.layers.Dense(10,\n                                 input_shape=input_shape,\n                                 activation=tf.nn.relu,\n                                 kernel_initializer='he_normal',\n                                 kernel_regularizer=keras.regularizers.l2(l=1e-3)))\n\n    model.add(keras.layers.Flatten())\n    model.add(keras.layers.Dense(11, activation='softmax'))\n    model.compile(optimizer='adagrad',\n                  loss='binary_crossentropy',\n                  metrics=[auc])\n    return model",
            "masked_code": "import numpy as np\nimport tensorflow as tf\nimport tensorflow.keras as keras\nfrom tensorflow.keras.metrics import AUC\n\nauc = AUC()\n\ndef dummy_network(input_shape):\n    model = keras.Sequential()\n    model.add(keras.layers.Dense(10,\n                                 input_shape=input_shape,\n                                 activation=tf.nn.relu,\n                                 kernel_initializer='he_normal',\n                                 <line_mask>\n\n    model.add(keras.layers.Flatten())\n    model.add(keras.layers.Dense(11, activation='softmax'))\n    model.compile(optimizer='adagrad',\n                  loss='binary_crossentropy',\n                  metrics=[auc])\n    return model",
            "masked_line": "kernel_regularizer=keras.regularizers.l2(l=1e-3)))",
            "answer": "regularizers",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_116",
            "model_output": "['<start>kernel_regularizer=keras.regularizers.l2(0.01)<end>', '<start>kernel_regularizer=tf.keras.regularizers.l2(l=0.01)<end>', \"<start>kernel_regularizer='l2'<end>\", '<start>bias_regularizer=keras.regularizers.l2(0.01)<end>', \"<start>bias_initializer='zeros'<end>\", \"<start>kernel_regularizer='L1L2'<end>\"]",
            "model_output_token_clear": "['kernel_regularizer=keras.regularizers.l2(0.01)', 'kernel_regularizer=tf.keras.regularizers.l2(l=0.01)', \"kernel_regularizer='l2'\", 'bias_regularizer=keras.regularizers.l2(0.01)', \"bias_initializer='zeros'\", \"kernel_regularizer='L1L2'\"]"
        },
        {
            "dependency": "kivy",
            "version": "==2.0.0",
            "time": "2021-04-12",
            "description": "This code defines a Kivy application that utilizes the Android camera to capture frames, process and display them on the screen. The code also increments a counter and displays it on each captured frame.",
            "code": "from kivy.app import App\nfrom kivy.uix.boxlayout import BoxLayout\nfrom kivy.graphics.texture import Texture\nfrom kivy.uix.camera import Camera\nfrom kivy.lang import Builder\nimport numpy as np\nimport cv2\n\nBuilder.load_file(\"myapplayout.kv\")\n\nclass AndroidCamera(Camera):\n    camera_resolution = (640, 480)\n    counter = 0\n\n    def _camera_loaded(self, *largs):\n        self.texture = Texture.create(size=np.flip(self.camera_resolution), colorfmt='rgb')\n        self.texture_size = list(self.texture.size)\n\n    def on_tex(self, *l):\n        if self._camera._buffer is None:\n            return None\n        frame = self.frame_from_buf()\n        self.frame_to_screen(frame)\n        super(AndroidCamera, self).on_tex(*l)\n\n    def frame_from_buf(self):\n        w, h = self.resolution\n        frame = np.frombuffer(self._camera._buffer.tostring(), 'uint8').reshape((h + h // 2, w))\n        frame_bgr = cv2.cvtColor(frame, 93)\n        return np.rot90(frame_bgr, 3)\n\n    def frame_to_screen(self, frame):\n        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        cv2.putText(frame_rgb, str(self.counter), (20, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)\n        self.counter += 1\n        flipped = np.flip(frame_rgb, 0)\n        buf = flipped.tostring()\n        self.texture.blit_buffer(buf, colorfmt='rgb', bufferfmt='ubyte')\n\nclass MyLayout(BoxLayout):\n    pass\n\nclass MyApp(App):\n    def build(self):\n        return MyLayout()\n\nif __name__ == '__main__':\n    MyApp().run()",
            "masked_code": "from kivy.app import App\nfrom kivy.uix.boxlayout import BoxLayout\nfrom kivy.graphics.texture import Texture\nfrom kivy.uix.camera import Camera\nfrom kivy.lang import Builder\nimport numpy as np\nimport cv2\n\nBuilder.load_file(\"myapplayout.kv\")\n\nclass AndroidCamera(Camera):\n    camera_resolution = (640, 480)\n    counter = 0\n\n    def _camera_loaded(self, *largs):\n        self.texture = Texture.create(size=np.flip(self.camera_resolution), colorfmt='rgb')\n        self.texture_size = list(self.texture.size)\n\n    def on_tex(self, *l):\n        if self._camera._buffer is None:\n            return None\n        <line_mask>\n        self.frame_to_screen(frame)\n        super(AndroidCamera, self).on_tex(*l)\n\n    def frame_from_buf(self):\n        w, h = self.resolution\n        frame = np.frombuffer(self._camera._buffer.tostring(), 'uint8').reshape((h + h // 2, w))\n        frame_bgr = cv2.cvtColor(frame, 93)\n        return np.rot90(frame_bgr, 3)\n\n    def frame_to_screen(self, frame):\n        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        cv2.putText(frame_rgb, str(self.counter), (20, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)\n        self.counter += 1\n        flipped = np.flip(frame_rgb, 0)\n        buf = flipped.tostring()\n        self.texture.blit_buffer(buf, colorfmt='rgb', bufferfmt='ubyte')\n\nclass MyLayout(BoxLayout):\n    pass\n\nclass MyApp(App):\n    def build(self):\n        return MyLayout()\n\nif __name__ == '__main__':\n    MyApp().run()",
            "masked_line": "frame = self.frame_from_buf()",
            "answer": "frame_from_buf",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_117",
            "model_output": "['<start>buf = self._camera._buffer.tostring()<end>', '<start>buf = self._camera._buffer.tobytes()<end>', '<start>buf = buf1.tobytes()<end>', '<start>buf = self._camera._buffer.tostring()<end>', '<start>buf = self.frame_from_buf().tobytes()<end>', \"<start>frame = np.frombuffer(self._camera._buffer.tostring(), 'uint8').reshape((self.camera_resolution[1] + self.camera_resolution[1] // 2, self.camera_resolution[0]))<end>\"]",
            "model_output_token_clear": "['buf = self._camera._buffer.tostring()', 'buf = self._camera._buffer.tobytes()', 'buf = buf1.tobytes()', 'buf = self._camera._buffer.tostring()', 'buf = self.frame_from_buf().tobytes()', \"frame = np.frombuffer(self._camera._buffer.tostring(), 'uint8').reshape((self.camera_resolution[1] + self.camera_resolution[1] // 2, self.camera_resolution[0]))\"]"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.5.2",
            "time": "2021-04-12",
            "description": "This code implements a custom camera widget in Kivy that captures frames from the camera, converts them to a format suitable for display, adds a counter to the frame, and displays the frame on the screen. The counter increments with each frame captured and displayed. The main functionality is to display live camera feed with a counter on a Kivy app.",
            "code": "from kivy.app import App\nfrom kivy.uix.boxlayout import BoxLayout\nfrom kivy.graphics.texture import Texture\nfrom kivy.uix.camera import Camera\nfrom kivy.lang import Builder\nimport numpy as np\nimport cv2\n\nBuilder.load_file(\"myapplayout.kv\")\n\nclass AndroidCamera(Camera):\n    camera_resolution = (640, 480)\n    counter = 0\n\n    def _camera_loaded(self, *largs):\n        self.texture = Texture.create(size=np.flip(self.camera_resolution), colorfmt='rgb')\n        self.texture_size = list(self.texture.size)\n\n    def on_tex(self, *l):\n        if self._camera._buffer is None:\n            return None\n        frame = self.frame_from_buf()\n        self.frame_to_screen(frame)\n        super(AndroidCamera, self).on_tex(*l)\n\n    def frame_from_buf(self):\n        w, h = self.resolution\n        frame = np.frombuffer(self._camera._buffer.tostring(), 'uint8').reshape((h + h // 2, w))\n        frame_bgr = cv2.cvtColor(frame, 93)\n        return np.rot90(frame_bgr, 3)\n\n    def frame_to_screen(self, frame):\n        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        cv2.putText(frame_rgb, str(self.counter), (20, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)\n        self.counter += 1\n        flipped = np.flip(frame_rgb, 0)\n        buf = flipped.tostring()\n        self.texture.blit_buffer(buf, colorfmt='rgb', bufferfmt='ubyte')\n\nclass MyLayout(BoxLayout):\n    pass\n\nclass MyApp(App):\n    def build(self):\n        return MyLayout()\n\nif __name__ == '__main__':\n    MyApp().run()",
            "masked_code": "from kivy.app import App\nfrom kivy.uix.boxlayout import BoxLayout\nfrom kivy.graphics.texture import Texture\nfrom kivy.uix.camera import Camera\nfrom kivy.lang import Builder\nimport numpy as np\nimport cv2\n\nBuilder.load_file(\"myapplayout.kv\")\n\nclass AndroidCamera(Camera):\n    camera_resolution = (640, 480)\n    counter = 0\n\n    def _camera_loaded(self, *largs):\n        self.texture = Texture.create(size=np.flip(self.camera_resolution), colorfmt='rgb')\n        self.texture_size = list(self.texture.size)\n\n    def on_tex(self, *l):\n        if self._camera._buffer is None:\n            return None\n        frame = self.frame_from_buf()\n        self.frame_to_screen(frame)\n        super(AndroidCamera, self).on_tex(*l)\n\n    def frame_from_buf(self):\n        w, h = self.resolution\n        frame = np.frombuffer(self._camera._buffer.tostring(), 'uint8').reshape((h + h // 2, w))\n        frame_bgr = cv2.cvtColor(frame, 93)\n        return np.rot90(frame_bgr, 3)\n\n    def frame_to_screen(self, frame):\n        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        <line_mask>\n        self.counter += 1\n        flipped = np.flip(frame_rgb, 0)\n        buf = flipped.tostring()\n        self.texture.blit_buffer(buf, colorfmt='rgb', bufferfmt='ubyte')\n\nclass MyLayout(BoxLayout):\n    pass\n\nclass MyApp(App):\n    def build(self):\n        return MyLayout()\n\nif __name__ == '__main__':\n    MyApp().run()",
            "masked_line": "cv2.putText(frame_rgb, str(self.counter), (20, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)",
            "answer": "putText",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_118",
            "model_output": "[\"<start>img_texture = Texture.create(size=(frame.shape[1], frame.shape[0]), colorfmt='bgr')<end>\", '<start>buf = cv2.flip(frame_rgb).tobytes()<end>', \"<start>img_texture = Texture.create(size=(frame.shape[1], frame.shape[0]), colorfmt='bgr')<end>\", \"<start>self.texture.blit_buffer(buf, colorfmt='rgb', bufferfmt='ubyte')<end>\", \"<start>self.texture.blit_buffer(frame_rgb.tobytes(), colorfmt='rgb', bufferfmt='ubyte')<end>\", \"<start>self.texture.blit_buffer(frame_rgb.tobytes(), colorfmt='rgb', bufferfmt='ubyte')<end>\"]",
            "model_output_token_clear": "[\"img_texture = Texture.create(size=(frame.shape[1], frame.shape[0]), colorfmt='bgr')\", 'buf = cv2.flip(frame_rgb).tobytes()', \"img_texture = Texture.create(size=(frame.shape[1], frame.shape[0]), colorfmt='bgr')\", \"self.texture.blit_buffer(buf, colorfmt='rgb', bufferfmt='ubyte')\", \"self.texture.blit_buffer(frame_rgb.tobytes(), colorfmt='rgb', bufferfmt='ubyte')\", \"self.texture.blit_buffer(frame_rgb.tobytes(), colorfmt='rgb', bufferfmt='ubyte')\"]"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2021-08-18",
            "description": "The code sets a seed value of 42 for random number generation in TensorFlow.",
            "code": "seed_value = 42\nimport tensorflow as tf\ntf.random.set_seed(seed_value)",
            "masked_code": "seed_value = 42\nimport tensorflow as tf\n<line_mask>",
            "masked_line": "tf.random.set_seed(seed_value)",
            "answer": "set_seed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_119",
            "model_output": "['<start>tf.random.set_seed(seed_value)<end>', '<start>tf.random.set_seed(seed_value)<end>', '<start>tf.random.set_seed(seed_value)<end>', '<start>tf.random.set_seed(seed_value)<end>', '<start>tf.random.set_seed(seed_value)<end>', '<start>tf.random.set_seed(seed_value)<end>']",
            "model_output_token_clear": "['tf.random.set_seed(seed_value)', 'tf.random.set_seed(seed_value)', 'tf.random.set_seed(seed_value)', 'tf.random.set_seed(seed_value)', 'tf.random.set_seed(seed_value)', 'tf.random.set_seed(seed_value)']"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2020-11-12",
            "description": "The code sets up a dataframe with columns 'Delay' and 'Time', and creates a dictionary 'error' with maximum and minimum values for different 'Time' values. It does not include any function calls or external dependencies.",
            "code": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# set edgecolor param (this is a global setting, so only set it once)\nplt.rcParams[\"patch.force_edgecolor\"] = True\n\n# setup the dataframe\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n\ndf = pd.DataFrame({'Delay':Delay,'Time':Time})\n\n# create a dict for the errors\nerror = {87: {'max': 90,'min': 60}, 66: {'max': 70,'min': 40}, 90: {'max': 93,'min': 80}, 55: {'max': 60,'min': 23}}",
            "masked_code": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# set edgecolor param (this is a global setting, so only set it once)\nplt.rcParams[\"patch.force_edgecolor\"] = True\n\n# setup the dataframe\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n\n<line_mask>\n\n# create a dict for the errors\nerror = {87: {'max': 90,'min': 60}, 66: {'max': 70,'min': 40}, 90: {'max': 93,'min': 80}, 55: {'max': 60,'min': 23}}",
            "masked_line": "df = pd.DataFrame({'Delay':Delay,'Time':Time})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_120",
            "model_output": "[\"<start>df = pd.DataFrame({'Delay': Delay, 'Time': Time})<end>\", \"<start>df = pd.DataFrame({'Delay': Delay, 'Time': Time})<end>\", \"<start>df = pd.DataFrame({'Delay': Delay, 'Time': Time})<end>\", \"<start>df = pd.DataFrame({'Delay': Delay, 'Time': Time})<end>\", \"<start>df = pd.DataFrame({'Delay': Delay, 'Time': Time})<end>\", \"<start>df = pd.DataFrame({'Delay': Delay, 'Time': Time})<end>\"]",
            "model_output_token_clear": "[\"df = pd.DataFrame({'Delay': Delay, 'Time': Time})\", \"df = pd.DataFrame({'Delay': Delay, 'Time': Time})\", \"df = pd.DataFrame({'Delay': Delay, 'Time': Time})\", \"df = pd.DataFrame({'Delay': Delay, 'Time': Time})\", \"df = pd.DataFrame({'Delay': Delay, 'Time': Time})\", \"df = pd.DataFrame({'Delay': Delay, 'Time': Time})\"]"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2020-11-12",
            "description": "This code sets the capsize parameter for error bars in a plot, creates a dataframe with columns 'Delay', 'Time', ' 'Min', and 'Max', calculates ymin and ymax values, extracts ymin and ymax values into a (2, N) array for the yerr parameter, and plots a barplot with error bars using seaborn.",
            "code": "# set capsize param (this is a global setting, so only set it once)\nplt.rcParams['errorbar.capsize'] = 10\n\n# create dataframe as shown by gepcel\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n_min = [60, 40, 80, 23]\n_max = [90, 70, 93, 60]\ndf = pd.DataFrame({'Delay':Delay,'Time':Time, 'Min': _min, 'Max': _max})\n\n# create ymin and ymax\ndf['ymin'] = df.Time - df.Min\ndf['ymax'] = df.Max - df.Time\n\n# extract ymin and ymax into a (2, N) array as required by the yerr parameter\nyerr = df[['ymin', 'ymax']].T.to_numpy()\n\n# plot with error bars\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.barplot(x='Delay', y='Time', data=df, yerr=yerr, ax=ax)",
            "masked_code": "# set capsize param (this is a global setting, so only set it once)\nplt.rcParams['errorbar.capsize'] = 10\n\n# create dataframe as shown by gepcel\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n_min = [60, 40, 80, 23]\n_max = [90, 70, 93, 60]\ndf = pd.DataFrame({'Delay':Delay,'Time':Time, 'Min': _min, 'Max': _max})\n\n# create ymin and ymax\ndf['ymin'] = df.Time - df.Min\ndf['ymax'] = df.Max - df.Time\n\n# extract ymin and ymax into a (2, N) array as required by the yerr parameter\n<line_mask>\n\n# plot with error bars\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.barplot(x='Delay', y='Time', data=df, yerr=yerr, ax=ax)",
            "masked_line": "yerr = df[['ymin', 'ymax']].T.to_numpy()",
            "answer": "T",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_121",
            "model_output": "[\"<start>yerr = [df[['ymin', 'ymax']].values.T]<end>\", \"<start>yerr = [df['ymin'].values, df['ymax'].values]<end>\", \"<start>yerr = [df[['ymin', 'ymax']].values.T]<end>\", \"<start>yerr = [df[['ymin', 'ymax']].values.T]<end>\", \"<start>yerr = np.array([df['ymin'].values, df['ymax'].values])<end>\", \"<start>yerr = [df[['ymin', 'ymax']].values.T]<end>\"]",
            "model_output_token_clear": "[\"yerr = [df[['ymin', 'ymax']].values.T]\", \"yerr = [df['ymin'].values, df['ymax'].values]\", \"yerr = [df[['ymin', 'ymax']].values.T]\", \"yerr = [df[['ymin', 'ymax']].values.T]\", \"yerr = np.array([df['ymin'].values, df['ymax'].values])\", \"yerr = [df[['ymin', 'ymax']].values.T]\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.0",
            "time": "2020-11-12",
            "description": "The code plots a bar graph using the 'Delay' values as x-axis and 'Time' values as y-axis from a dataframe 'df'. It then adds error lines to each bar in the plot based on the min and max values provided in a dictionary 'error'.",
            "code": "# plot the figure\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.barplot(x='Delay', y='Time', data=df, ax=ax)\n\n# add the lines for the errors \nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_code": "# plot the figure\n<line_mask>\nsns.barplot(x='Delay', y='Time', data=df, ax=ax)\n\n# add the lines for the errors \nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_line": "fig, ax = plt.subplots(figsize=(8, 6))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_122",
            "model_output": "[\"<start=ax=sns.barplot(x='Delay', y='Time', data=df)<end>\", \"<start>ax = sns.barplot(x='Delay', y='Time', data=df)<end>\", \"<start>ax = sns.barplot(x='Delay', y='Time', data=df)<end>\", \"<start>ax = sns.barplot(x='Delay', y='Time', data=df)<end>\", \"<start>ax = sns.barplot(x='Delay', y='Time', data=df)<end>\", \"<start=ax=sns.barplot(x='Delay', y='Time', data=df)<end>\"]",
            "model_output_token_clear": "['no_answer', \"ax = sns.barplot(x='Delay', y='Time', data=df)\", \"ax = sns.barplot(x='Delay', y='Time', data=df)\", \"ax = sns.barplot(x='Delay', y='Time', data=df)\", \"ax = sns.barplot(x='Delay', y='Time', data=df)\", 'no_answer']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.0",
            "time": "2020-11-12",
            "description": "The code sets the capsize parameter for error bars, creates a dataframe with delay, time, min, and max values, calculates ymin and ymax values, extracts ymin and ymax into a 2xN array for error bar parameter, and then plots a barplot with error bars using seaborn library.",
            "code": "# set capsize param (this is a global setting, so only set it once)\nplt.rcParams['errorbar.capsize'] = 10\n\n# create dataframe as shown by gepcel\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n_min = [60, 40, 80, 23]\n_max = [90, 70, 93, 60]\ndf = pd.DataFrame({'Delay':Delay,'Time':Time, 'Min': _min, 'Max': _max})\n\n# create ymin and ymax\ndf['ymin'] = df.Time - df.Min\ndf['ymax'] = df.Max - df.Time\n\n# extract ymin and ymax into a (2, N) array as required by the yerr parameter\nyerr = df[['ymin', 'ymax']].T.to_numpy()\n\n# plot with error bars\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.barplot(x='Delay', y='Time', data=df, yerr=yerr, ax=ax)",
            "masked_code": "# set capsize param (this is a global setting, so only set it once)\nplt.rcParams['errorbar.capsize'] = 10\n\n# create dataframe as shown by gepcel\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n_min = [60, 40, 80, 23]\n_max = [90, 70, 93, 60]\ndf = pd.DataFrame({'Delay':Delay,'Time':Time, 'Min': _min, 'Max': _max})\n\n# create ymin and ymax\ndf['ymin'] = df.Time - df.Min\ndf['ymax'] = df.Max - df.Time\n\n# extract ymin and ymax into a (2, N) array as required by the yerr parameter\nyerr = df[['ymin', 'ymax']].T.to_numpy()\n\n# plot with error bars\n<line_mask>\nsns.barplot(x='Delay', y='Time', data=df, yerr=yerr, ax=ax)",
            "masked_line": "fig, ax = plt.subplots(figsize=(8, 6))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_123",
            "model_output": "['<start>, fig = plt.subplots(figsize=(8,5))<end>', '<start>, ax = plt.subplots()<end>', '<start>, ax = plt.subplots()<end>', '<start>, ax = plt.subplots()<end>', '<start>, fig = plt.subplots(figsize=(8,5))<end>', '<start>, fig = plt.subplots(figsize=(8,5))<end>']",
            "model_output_token_clear": "[', fig = plt.subplots(figsize=(8,5))', ', ax = plt.subplots()', ', ax = plt.subplots()', ', ax = plt.subplots()', ', fig = plt.subplots(figsize=(8,5))', ', fig = plt.subplots(figsize=(8,5))']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.0",
            "time": "2020-11-12",
            "description": "This code creates a bar plot using data from a DataFrame, where the x-axis represents delays and the y-axis represents time. For each bar in the plot, it calculates the bottom left x-coordinate, width, and height of the bar. Then, it retrieves the minimum and maximum values from a dictionary based on the bar's height. Finally, it draws a vertical line within each bar connecting the minimum and maximum values.",
            "code": "fig, ax = plt.subplots(figsize=(8, 6))\n\ndf.plot.bar(x='Delay', y='Time', ax=ax)\n\nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_code": "<line_mask>\n\ndf.plot.bar(x='Delay', y='Time', ax=ax)\n\nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_line": "fig, ax = plt.subplots(figsize=(8, 6))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_124",
            "model_output": "[\"<start>ax = df.plot.bar(x='Delay', y='Time')<end>\", \"<start>ax = df.plot.bar(x='Delay', y='Time')<end>\", '<start=ax<end>', \"<start>ax = df.plot.bar(x='Delay', y='Time')<end>\", '<start=ax<end>', \"<start>ax = df.plot.bar(x='Delay', y='Time')<end>\"]",
            "model_output_token_clear": "[\"ax = df.plot.bar(x='Delay', y='Time')\", \"ax = df.plot.bar(x='Delay', y='Time')\", 'no_answer', \"ax = df.plot.bar(x='Delay', y='Time')\", 'no_answer', \"ax = df.plot.bar(x='Delay', y='Time')\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.0",
            "time": "2020-11-12",
            "description": "This code generates a bar plot using data from a DataFrame, with the x-axis representing the 'Delay' values and the y-axis representing the 'Time' values. It then adds vertical lines to each bar indicating the minimum and maximum values stored in the 'error' dictionary corresponding to each bar's height.",
            "code": "fig, ax = plt.subplots(figsize=(8, 6))\n\nax.bar(x='Delay', height='Time', data=df)\n\nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_code": "<line_mask>\n\nax.bar(x='Delay', height='Time', data=df)\n\nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_line": "fig, ax = plt.subplots(figsize=(8, 6))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_125",
            "model_output": "[\"<start>ax.set_ylabel('Time')<end>\", '<start>ax = plt.gca()<end>', \"<start>ax.set_ylabel('Time')<end>\", '<start>ax = plt.gca()<end>', '<start>ax = plt.gca()<end>', \"<start>ax.set_xlabel('Delay')<end>\"]",
            "model_output_token_clear": "[\"ax.set_ylabel('Time')\", 'ax = plt.gca()', \"ax.set_ylabel('Time')\", 'ax = plt.gca()', 'ax = plt.gca()', \"ax.set_xlabel('Delay')\"]"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.2",
            "time": "2020-11-12",
            "description": "This code generates a bar plot using the data from the 'Delay' and 'Time' columns in a DataFrame named 'df'. It then adds vertical lines to represent error bars for each bar in the plot. The error bars are defined by minimum and maximum values in a dictionary called 'error'.",
            "code": "# plot the figure\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.barplot(x='Delay', y='Time', data=df, ax=ax)\n\n# add the lines for the errors \nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_code": "# plot the figure\nfig, ax = plt.subplots(figsize=(8, 6))\n<line_mask>\n\n# add the lines for the errors \nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_line": "sns.barplot(x='Delay', y='Time', data=df, ax=ax)",
            "answer": "barplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_126",
            "model_output": "[\"<start=ax.errorbar(range(len(df)), df.values.T[0], yerr=[[z[i]['min'] for i in df.values.T[0]], [z[i]['max'] for i in df.values.T[0]]], fmt='o', capsize=5)<end>\", \"<start>ax.errorbar(x+w/2, h, ymin=min_y, ymax=max_y, fmt='none', ecolor='k')<end>\", \"<start=ax.errorbar(range(len(df)), df.values.T[0], yerr=[[v['min'] for v in Delay_error.values()], [v['max'] for v in Delay_error.values()]], fmt='o')<end>\", \"<start>ax.errorbar(x+w/2, h, ymin=min_y, ymax=max_y, fmt='none', ecolor='k')<end>\", \"<start=ax.errorbar(range(len(df)), df.values.T[0], fmt='o', yerr=[[z[i]['min'] for i in df.values.T[0]], [z[i]['max'] - i for i in df.values.T[0]]])<end>\", \"<start>ax.errorbar(x+w/2, h, yerr=[[h-min_y], [max_y-h]], capsize=3, ecolor='k', fmt='none')<end>\"]",
            "model_output_token_clear": "['no_answer', \"ax.errorbar(x+w/2, h, ymin=min_y, ymax=max_y, fmt='none', ecolor='k')\", 'no_answer', \"ax.errorbar(x+w/2, h, ymin=min_y, ymax=max_y, fmt='none', ecolor='k')\", 'no_answer', \"ax.errorbar(x+w/2, h, yerr=[[h-min_y], [max_y-h]], capsize=3, ecolor='k', fmt='none')\"]"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.2",
            "time": "2020-11-12",
            "description": "This code sets the capsize parameter for error bars in a plot, creates a dataframe with columns for 'Delay', 'Time', ' 'Min', and 'Max', calculates ymin and ymax values for error bars, extracts these values into a (2, N) array as required for the yerr parameter, and finally plots a barplot with error bars using the created dataframe.",
            "code": "# set capsize param (this is a global setting, so only set it once)\nplt.rcParams['errorbar.capsize'] = 10\n\n# create dataframe as shown by gepcel\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n_min = [60, 40, 80, 23]\n_max = [90, 70, 93, 60]\ndf = pd.DataFrame({'Delay':Delay,'Time':Time, 'Min': _min, 'Max': _max})\n\n# create ymin and ymax\ndf['ymin'] = df.Time - df.Min\ndf['ymax'] = df.Max - df.Time\n\n# extract ymin and ymax into a (2, N) array as required by the yerr parameter\nyerr = df[['ymin', 'ymax']].T.to_numpy()\n\n# plot with error bars\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.barplot(x='Delay', y='Time', data=df, yerr=yerr, ax=ax)",
            "masked_code": "# set capsize param (this is a global setting, so only set it once)\nplt.rcParams['errorbar.capsize'] = 10\n\n# create dataframe as shown by gepcel\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n_min = [60, 40, 80, 23]\n_max = [90, 70, 93, 60]\ndf = pd.DataFrame({'Delay':Delay,'Time':Time, 'Min': _min, 'Max': _max})\n\n# create ymin and ymax\ndf['ymin'] = df.Time - df.Min\ndf['ymax'] = df.Max - df.Time\n\n# extract ymin and ymax into a (2, N) array as required by the yerr parameter\nyerr = df[['ymin', 'ymax']].T.to_numpy()\n\n# plot with error bars\nfig, ax = plt.subplots(figsize=(8, 6))\n<line_mask>",
            "masked_line": "sns.barplot(x='Delay', y='Time', data=df, yerr=yerr, ax=ax)",
            "answer": "barplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_127",
            "model_output": "[\"<start>sns.barplot(x='Delay', y='Time', data=df, yerr=yerr, ax=ax)<end>\", \"<start>ax.errorbar(df.Delay, df.Time, yerr=yerr, fmt='-o')<end>\", \"<start=ax.errorbar(df.Delay, df.Time, yerr=yerr, fmt='o', capsize=10)<end>\", '<start>ax.errorbar(x=Delay, y=Time, yerr=yerr)', \"<start=ax.errorbar(df.Delay, df.Time, yerr=yerr, fmt='-o')<end>\", \"<start=ax.errorbar(df.Delay, df.Time, yerr=yerr, fmt='o')<end>\"]",
            "model_output_token_clear": "[\"sns.barplot(x='Delay', y='Time', data=df, yerr=yerr, ax=ax)\", \"ax.errorbar(df.Delay, df.Time, yerr=yerr, fmt='-o')\", 'no_answer', 'no_answer', 'no_answer', 'no_answer']"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.1.1",
            "time": "2020-04-14",
            "description": "This code generates a plot with custom tick labels on both the x and y axes. The x-axis values are sorted and displayed as ticks with corresponding labels, as well as the y-axis values. The plot is then displayed with 'Values' as the x-axis label and 'Indices' as the y-axis label.",
            "code": "import matplotlib.pyplot as plt\n\nx_axis_values = ['(-68.18100000000001, 89.754]', '(89.754, 130.42]', '(130.42, 165.601]', '(165.601, 205.456]',\n                 '(205.456, 371.968]']\n\ny_axis_values = ['(-0.123, 0.749]', '(0.749, 0.922]', '(0.922, 1.068]', '(1.068, 1.253]', '(1.253, 2.14]']\n\n# Try to sort the values, before passing to [xticks, yticks]\n# or in which order, you want them along axes\nplt.xticks(ticks=range(len(x_axis_values)), labels=x_axis_values)\nplt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)\n\n# plt.scatter(x_axis_values, y_axis_values)\nplt.xlabel('Values')\nplt.ylabel('Indices')\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\n\nx_axis_values = ['(-68.18100000000001, 89.754]', '(89.754, 130.42]', '(130.42, 165.601]', '(165.601, 205.456]',\n                 '(205.456, 371.968]']\n\ny_axis_values = ['(-0.123, 0.749]', '(0.749, 0.922]', '(0.922, 1.068]', '(1.068, 1.253]', '(1.253, 2.14]']\n\n# Try to sort the values, before passing to [xticks, yticks]\n# or in which order, you want them along axes\nplt.xticks(ticks=range(len(x_axis_values)), labels=x_axis_values)\n<line_mask>\n\n# plt.scatter(x_axis_values, y_axis_values)\nplt.xlabel('Values')\nplt.ylabel('Indices')\n\nplt.show()",
            "masked_line": "plt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)",
            "answer": "yticks",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_128",
            "model_output": "['<start>plt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)<end>', '<start>plt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)<end>', '<start>plt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)<end>', '<start>plt.plot(y_axis_values)<end>', '<start>plt.plot(y_axis_values)', '<start>plt.plot(y_axis_values)']",
            "model_output_token_clear": "['plt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)', 'plt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)', 'plt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)', 'plt.plot(y_axis_values)', 'no_answer', 'no_answer']"
        },
        {
            "dependency": "scikit-learn",
            "version": ">=0.21",
            "time": "2020-03-26",
            "description": "The code calculates the multilabel confusion matrix to evaluate the classification performance of a model on a dataset with multiple labels.",
            "code": "import numpy as np\nfrom sklearn.metrics import multilabel_confusion_matrix\ny_true = np.array([[1, 0, 1, 0, 0],\n                   [0, 1, 0, 1, 1],\n                   [1, 1, 1, 0, 1]])\ny_pred = np.array([[1, 0, 0, 0, 1],\n                   [0, 1, 1, 1, 0],\n                   [1, 1, 1, 0, 0]])\n\nmultilabel_confusion_matrix(y_true, y_pred)\n# result:\narray([[[1, 0],\n        [0, 2]],\n\n       [[1, 0],\n        [0, 2]],\n\n       [[0, 1],\n        [1, 1]],\n\n       [[2, 0],\n        [0, 1]],\n\n       [[0, 1],\n        [2, 0]]])",
            "masked_code": "import numpy as np\n<line_mask>\ny_true = np.array([[1, 0, 1, 0, 0],\n                   [0, 1, 0, 1, 1],\n                   [1, 1, 1, 0, 1]])\ny_pred = np.array([[1, 0, 0, 0, 1],\n                   [0, 1, 1, 1, 0],\n                   [1, 1, 1, 0, 0]])\n\nmultilabel_confusion_matrix(y_true, y_pred)\n# result:\narray([[[1, 0],\n        [0, 2]],\n\n       [[1, 0],\n        [0, 2]],\n\n       [[0, 1],\n        [1, 1]],\n\n       [[2, 0],\n        [0, 1]],\n\n       [[0, 1],\n        [2, 0]]])",
            "masked_line": "from sklearn.metrics import multilabel_confusion_matrix",
            "answer": "multilabel_confusion_matrix",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_129",
            "model_output": "['<start>y_true = np.argmax(y_true, axis=1); y_pred = np.argmax(y_pred, axis=1)<end>', '<start>from sklearn.metrics import multilabel_confusion_matrix<end>', '<start>y_true = np.argmax(y_true, axis=1); y_pred = np.argmax(y_pred, axis=1)<end>', '<start>y_true = np.argmax(y_true, axis=1); y_pred = np.argmax(y_pred, axis=1)<end>', '<start>y_true = np.array([np.argmax(y) for y in y_true])<end>', '<start>from sklearn.metrics import multilabel_confusion_matrix<end>']",
            "model_output_token_clear": "['y_true = np.argmax(y_true, axis=1); y_pred = np.argmax(y_pred, axis=1)', 'from sklearn.metrics import multilabel_confusion_matrix', 'y_true = np.argmax(y_true, axis=1); y_pred = np.argmax(y_pred, axis=1)', 'y_true = np.argmax(y_true, axis=1); y_pred = np.argmax(y_pred, axis=1)', 'y_true = np.array([np.argmax(y) for y in y_true])', 'from sklearn.metrics import multilabel_confusion_matrix']"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-04-24",
            "description": "The code creates a directed multigraph and adds multiple edges between nodes '1', '2', '3', and '4'.",
            "code": "G = nx.MultiDiGraph()\n\nG.add_edge('1','2')\nG.add_edge('1','3')\nG.add_edge('3','2')\nG.add_edge('3','4')\nG.add_edge('4','3')",
            "masked_code": "<line_mask>\n\nG.add_edge('1','2')\nG.add_edge('1','3')\nG.add_edge('3','2')\nG.add_edge('3','4')\nG.add_edge('4','3')",
            "masked_line": "G = nx.MultiDiGraph()",
            "answer": "MultiDiGraph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_130",
            "model_output": "['<start>G = nx.DiGraph()<end>', '<start>G = nx.MultiDiGraph()<end>', '<start>G = nx.DiGraph()<end>', '<start>G = nx.MultiDiGraph()<end>', '<start>G = nx.MultiDiGraph()<end>', '<start>G = nx.MultiDiGraph()<end>']",
            "model_output_token_clear": "['G = nx.DiGraph()', 'G = nx.MultiDiGraph()', 'G = nx.DiGraph()', 'G = nx.MultiDiGraph()', 'G = nx.MultiDiGraph()', 'G = nx.MultiDiGraph()']"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-07",
            "description": "The code generates random daily changes, calculates the total change by cumulatively summing the daily changes starting from -1900, and creates a DataFrame with columns for daily and total changes from a specified start date to end date.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1) # random number generator\n\ndti = pd.bdate_range(start='2020-07-22', end='2020-09-03')\ndaily = rng.normal(loc=0, scale=250, size=dti.size)\ntotal = -1900 + np.cumsum(daily)\n\ndf = pd.DataFrame({'Daily Change': daily,\n                   'Total Change': total},\n                  index=dti)\ndf.head()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1) # random number generator\n\ndti = pd.bdate_range(start='2020-07-22', end='2020-09-03')\n<line_mask>\ntotal = -1900 + np.cumsum(daily)\n\ndf = pd.DataFrame({'Daily Change': daily,\n                   'Total Change': total},\n                  index=dti)\ndf.head()",
            "masked_line": "daily = rng.normal(loc=0, scale=250, size=dti.size)",
            "answer": "normal",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_131",
            "model_output": "['<start>daily = rng.normal(loc=0, scale=0.5, size=len(dti))<end>', '<start>daily = rng.standard_normal(size=len(dti))<end>', '<start>daily = rng.standard_normal(len(dti))<end>', '<start>daily = rng.normal(loc=0, scale=0.5, size=len(dti))<end>', '<start>daily = rng.normal(size=len(dti))<end>', '<start>daily = rng.normal(size=len(dti))<end>']",
            "model_output_token_clear": "['daily = rng.normal(loc=0, scale=0.5, size=len(dti))', 'daily = rng.standard_normal(size=len(dti))', 'daily = rng.standard_normal(len(dti))', 'daily = rng.normal(loc=0, scale=0.5, size=len(dti))', 'daily = rng.normal(size=len(dti))', 'daily = rng.normal(size=len(dti))']"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-01-07",
            "description": "The code generates a DataFrame using Pandas with two columns, 'Daily Change' and 'Total Change'. 'Daily Change' column contains random numbers drawn from a normal distribution with a mean of 0 and a standard deviation of 250. 'Total Change' column is calculated by taking the cumulative sum of the 'Daily Change' column and starting from -1900. The DataFrame is indexed with business days ranging from July 22, 2020, to September 3, 2020.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1) # random number generator\n\ndti = pd.bdate_range(start='2020-07-22', end='2020-09-03')\ndaily = rng.normal(loc=0, scale=250, size=dti.size)\ntotal = -1900 + np.cumsum(daily)\n\ndf = pd.DataFrame({'Daily Change': daily,\n                   'Total Change': total},\n                  index=dti)\ndf.head()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1) # random number generator\n\ndti = pd.bdate_range(start='2020-07-22', end='2020-09-03')\ndaily = rng.normal(loc=0, scale=250, size=dti.size)\ntotal = -1900 + np.cumsum(daily)\n\n<line_mask>\n                   'Total Change': total},\n                  index=dti)\ndf.head()",
            "masked_line": "df = pd.DataFrame({'Daily Change': daily,",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_132",
            "model_output": "[\"<start>df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)<end>\", \"<start>df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)<end>\", \"<start>df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)<end>\", \"<start>df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)<end>\", \"<start>df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)<end>\", \"<start>df = pd.DataFrame({'Daily Change': daily,<end>\"]",
            "model_output_token_clear": "[\"df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)\", \"df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)\", \"df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)\", \"df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)\", \"df = pd.DataFrame({'Daily Change': daily, 'Total Change': total}, index=dti)\", \"df = pd.DataFrame({'Daily Change': daily,\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-07",
            "description": "The code creates a visualization with a line plot and a bar plot using pandas. The line plot shows the total value over time, while the bar plot shows the daily value. Customizations include setting colors, alpha values, linewidth, plot size, and legend location. Additionally, custom x ticks and tick labels are created based on the frequency of data points. Finally, the visualization is displayed using `plt.show()`.",
            "code": "label_daily, label_total = df.columns\n\n# Create pandas line plot: note the 'use_index' parameter\nax = df.plot(y=label_total, color='red', alpha=1, linewidth=1.5,\n             use_index=False, ylabel=label_total)\n\n# Create pandas bar plot: note that the second ylabel must be created\n# after, else it overwrites the previous label on the left\ndf.plot(kind='bar', y=label_daily, color='black', alpha=0.4,\n        ax=ax, secondary_y=True, mark_right=False, figsize=(9, 4))\nplt.ylabel(label_daily, labelpad=10)\n\n# Place legend in a better location: note that because there are two\n# Axes, the combined legend can only be edited with the fig.legend\n# method, and the ax legend must be removed\nax.legend().remove()\nplt.gcf().legend(loc=(0.11, 0.15))\n\n# Create custom x ticks and tick labels\nfreq = 4 # business days\nxticks = ax.get_xticks()\nxticklabels = df.index[::freq].strftime('%b-%d')\nax.set_xticks(xticks[::freq])\nax.set_xticks(xticks, minor=True)\nax.set_xticklabels(xticklabels, rotation=0, ha='center')\n\nplt.show()",
            "masked_code": "label_daily, label_total = df.columns\n\n# Create pandas line plot: note the 'use_index' parameter\nax = df.plot(y=label_total, color='red', alpha=1, linewidth=1.5,\n             use_index=False, ylabel=label_total)\n\n# Create pandas bar plot: note that the second ylabel must be created\n# after, else it overwrites the previous label on the left\ndf.plot(kind='bar', y=label_daily, color='black', alpha=0.4,\n        ax=ax, secondary_y=True, mark_right=False, figsize=(9, 4))\nplt.ylabel(label_daily, labelpad=10)\n\n# Place legend in a better location: note that because there are two\n# Axes, the combined legend can only be edited with the fig.legend\n# method, and the ax legend must be removed\nax.legend().remove()\n<line_mask>\n\n# Create custom x ticks and tick labels\nfreq = 4 # business days\nxticks = ax.get_xticks()\nxticklabels = df.index[::freq].strftime('%b-%d')\nax.set_xticks(xticks[::freq])\nax.set_xticks(xticks, minor=True)\nax.set_xticklabels(xticklabels, rotation=0, ha='center')\n\nplt.show()",
            "masked_line": "plt.gcf().legend(loc=(0.11, 0.15))",
            "answer": "legend",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_133",
            "model_output": "[\"<start>fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right')<end>\", \"<start>fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total)<end>\", \"<start>fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right', ncol=1)<end>\", \"<start>fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right')<end>\", \"<start>fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right')<end>\", \"<start>fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right', ncol=2)<end>\"]",
            "model_output_token_clear": "[\"fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right')\", \"fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total)\", \"fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right', ncol=1)\", \"fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right')\", \"fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right')\", \"fig.legend(ax.get_legend_handles_labels()[0], label_daily + ', ' + label_total, loc='upper right', ncol=2)\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-07",
            "description": "This code creates custom x ticks and tick labels for a plot by setting a fixed major locator for the x-axis at a specified frequency, setting a fixed minor locator for the x-axis, formatting the major ticks with the index values from the data frame in a specific format, and adjusting the appearance of the x tick labels.",
            "code": "import matplotlib.ticker as mticker\n\n# Create custom x ticks and tick labels\nfreq = 4 # business days\nmaj_locator = mticker.FixedLocator(ax.get_xticks()[::freq])\nmin_locator = mticker.FixedLocator(ax.get_xticks())\nax.xaxis.set_major_locator(maj_locator)\nax.xaxis.set_minor_locator(min_locator)\n\nmaj_formatter = mticker.FixedFormatter(df.index[maj_locator.locs].strftime('%b-%d'))\nax.xaxis.set_major_formatter(maj_formatter)\nplt.setp(ax.get_xticklabels(), rotation=0, ha='center')",
            "masked_code": "import matplotlib.ticker as mticker\n\n# Create custom x ticks and tick labels\nfreq = 4 # business days\nmaj_locator = mticker.FixedLocator(ax.get_xticks()[::freq])\nmin_locator = mticker.FixedLocator(ax.get_xticks())\nax.xaxis.set_major_locator(maj_locator)\nax.xaxis.set_minor_locator(min_locator)\n\n<line_mask>\nax.xaxis.set_major_formatter(maj_formatter)\nplt.setp(ax.get_xticklabels(), rotation=0, ha='center')",
            "masked_line": "maj_formatter = mticker.FixedFormatter(df.index[maj_locator.locs].strftime('%b-%d'))",
            "answer": "FixedFormatter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_134",
            "model_output": "[\"<start>maj_formatter = mticker.FuncFormatter(lambda val,pos: '{:.0f}'.format(val))<end>\", \"<start>maj_formatter = mticker.FuncFormatter(lambda val,pos:'{:02g}'.format(val) if val != int(val) else '{:.0f}'.format(val))<end>\", \"<start>maj_formatter = mticker.FuncFormatter(lambda val,pos: '{:.0f}'.format(val))<end>\", \"<start>maj_formatter = mticker.FuncFormatter(lambda x,p : dates_[int(x)].strftime('%Y-%m-%d %H:%M:%S'))<end>\", \"<start>maj_formatter = mticker.FuncFormatter(lambda val,pos: '{:.0f}'.format(val))<end>\", '<start>maj_formatter = mticker.FuncFormatter(lambda val,pos: dates_[int(val)].strftime(\"%Y-%m-%d %H:%M:%S\") if int(val) % freq == 0 else \"\")<end>']",
            "model_output_token_clear": "[\"maj_formatter = mticker.FuncFormatter(lambda val,pos: '{:.0f}'.format(val))\", \"maj_formatter = mticker.FuncFormatter(lambda val,pos:'{:02g}'.format(val) if val != int(val) else '{:.0f}'.format(val))\", \"maj_formatter = mticker.FuncFormatter(lambda val,pos: '{:.0f}'.format(val))\", \"maj_formatter = mticker.FuncFormatter(lambda x,p : dates_[int(x)].strftime('%Y-%m-%d %H:%M:%S'))\", \"maj_formatter = mticker.FuncFormatter(lambda val,pos: '{:.0f}'.format(val))\", 'maj_formatter = mticker.FuncFormatter(lambda val,pos: dates_[int(val)].strftime(\"%Y-%m-%d %H:%M:%S\") if int(val) % freq == 0 else \"\")']"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.1",
            "time": "2020-02-10",
            "description": "The code calculates the rolling sum of the 'target' column in a DataFrame 'df' over a one-hour time window for each index and converts the result to boolean values, storing it in a new column 'required_col'.",
            "code": "indexer = ForwardTimewindowIndexer(\n    index_array=df.index,\n    window_size=pd.to_timedelta('1h'),\n)\ndf['required_col'] = df['target'].rolling(indexer).sum().astype(bool)",
            "masked_code": "indexer = ForwardTimewindowIndexer(\n    index_array=df.index,\n    <line_mask>\n)\ndf['required_col'] = df['target'].rolling(indexer).sum().astype(bool)",
            "masked_line": "window_size=pd.to_timedelta('1h'),",
            "answer": "to_timedelta",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_135",
            "model_output": "[\"<start>window='1h'<end>\", \"<start>window='1h'<end>\", \"<start>window='1h'<end>\", \"<start>window='1h'<end>\", '<start>window=60,<end>', \"<start>window='1h'<end>\"]",
            "model_output_token_clear": "[\"window='1h'\", \"window='1h'\", \"window='1h'\", \"window='1h'\", 'window=60,', \"window='1h'\"]"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-10-04",
            "description": "The code calculates the linear regression model between the variables yh and yn and obtains the correlation coefficient (r_value) which is approximately 0.96.",
            "code": "slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(yh, yn)\nr_value # 0.9625821384210018",
            "masked_code": "<line_mask>\nr_value # 0.9625821384210018",
            "masked_line": "slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(yh, yn)",
            "answer": "stats",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_136",
            "model_output": "['<start>r_value, _ = pearsonr(yh, yn)<end>', '<start>r_value, _ = pearsonr(yh, yn)<end>', '<start>r_value, _ = pearsonr(yh, yn)<end>', '<start>r_value, _ = pearsonr(yh, yn)<end>', '<start>r_value, _ = pearsonr(yh, yn)<end>', '<start>r_value, _ = pearsonr(yh, yn)<end>']",
            "model_output_token_clear": "['r_value, _ = pearsonr(yh, yn)', 'r_value, _ = pearsonr(yh, yn)', 'r_value, _ = pearsonr(yh, yn)', 'r_value, _ = pearsonr(yh, yn)', 'r_value, _ = pearsonr(yh, yn)', 'r_value, _ = pearsonr(yh, yn)']"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.5",
            "time": "2020-12-21",
            "description": "This code reads an Excel file named 'redux2.xlsx' from the 'Sheet1' sheet with no header, and assigns the columns to the names 'foo', 'bar', and 'baz'. It skips one row from the beginning of the file. It uses the 'openpyxl' engine to read the Excel file.",
            "code": "pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo','bar','baz'], engine='openpyxl', skiprows=1)",
            "masked_code": "<line_mask>",
            "masked_line": "pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo','bar','baz'], engine='openpyxl', skiprows=1)",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_137",
            "model_output": "[\"<start>df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)<end>\", \"<start>df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)<end>\", \"<start>df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)<end>\", \"<start>df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)<end>\", \"<start>df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)<end>\", \"<start>df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)<end>\"]",
            "model_output_token_clear": "[\"df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)\", \"df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)\", \"df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)\", \"df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)\", \"df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)\", \"df = pd.read_excel('redux2.xlsx', sheet_name='Sheet1', header=None, names=['foo', 'bar', 'baz'], skiprows=1)\"]"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.5",
            "time": "2020-12-21",
            "description": "The code creates a DataFrame with three columns: 'col1' containing the first 10 lowercase letters, 'col2' containing the next 10 lowercase letters, and 'col3' containing numbers from 1 to 10. It then saves the DataFrame to an Excel file named 'file.xlsx' without the index and prints the DataFrame.",
            "code": "import string\n\ndf = pd.DataFrame({\n    'col1': list(string.ascii_letters[:10]),\n    'col2': list(string.ascii_letters[10:20]),\n    'col3': range(1,11)\n})\n\ndf.to_excel('file.xlsx', index=False)\nprint(df)",
            "masked_code": "import string\n\ndf = pd.DataFrame({\n    'col1': list(string.ascii_letters[:10]),\n    'col2': list(string.ascii_letters[10:20]),\n    'col3': range(1,11)\n})\n\n<line_mask>\nprint(df)",
            "masked_line": "df.to_excel('file.xlsx', index=False)",
            "answer": "to_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_138",
            "model_output": "[\"<start>df.to_excel('file.xlsx', index=False)<end>\", \"<start>df.to_excel('file.xlsx', index=False)<end>\", \"<start>df.to_excel('file.xlsx', index=False)<end>\", \"<start>df.to_excel('file.xlsx', index=False)<end>\", \"<start>df.to_excel('file.xlsx', index=False)<end>\", \"<start>df.to_excel('file.xlsx', index=False)<end>\"]",
            "model_output_token_clear": "[\"df.to_excel('file.xlsx', index=False)\", \"df.to_excel('file.xlsx', index=False)\", \"df.to_excel('file.xlsx', index=False)\", \"df.to_excel('file.xlsx', index=False)\", \"df.to_excel('file.xlsx', index=False)\", \"df.to_excel('file.xlsx', index=False)\"]"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.5",
            "time": "2020-12-21",
            "description": "The code reads data from an Excel file ('file.xlsx') and stores it in a pandas DataFrame with specified column names ('foo', 'bar', 'baz'). It skips the first 3 rows of the Excel file and prints the data in the 4th row of the DataFrame.",
            "code": "filename = 'file.xlsx'\nnames = [\"foo\", \"bar\", \"baz\"]\n\ndata_frame = pd.read_excel(\n    filename,\n    header=None,\n    names=names,\n    engine=\"openpyxl\",\n    skiprows=3,\n    sheet_name=0,\n)\n\nprint(data_frame.iloc[3])",
            "masked_code": "filename = 'file.xlsx'\nnames = [\"foo\", \"bar\", \"baz\"]\n\n<line_mask>\n    filename,\n    header=None,\n    names=names,\n    engine=\"openpyxl\",\n    skiprows=3,\n    sheet_name=0,\n)\n\nprint(data_frame.iloc[3])",
            "masked_line": "data_frame = pd.read_excel(",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_139",
            "model_output": "['<start>data_frame = pd.read_excel<end>', '<start>data_frame = pd.read_excel<end>', '<start>data_frame = pd.read_excel<end>', '<start>data_frame = pd.read_excel<end>', '<start>data_frame = pd.read_excel<end>', '<start>data_frame = pd.read_excel<end>']",
            "model_output_token_clear": "['data_frame = pd.read_excel', 'data_frame = pd.read_excel', 'data_frame = pd.read_excel', 'data_frame = pd.read_excel', 'data_frame = pd.read_excel', 'data_frame = pd.read_excel']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-06-17",
            "description": "The code converts a Keras model to a TensorFlow Lite model with optimized default optimizations, using representative dataset generation for quantization, setting supported operations to TFLITE_BUILTINS_INT8, and specifying input and output types as int8 or uint8.",
            "code": "import tensorflow as tf\nconverter = tf.lite.TFLiteConverter.from_keras_model('model.h5')\nconverter.optimizations = [tf.lite.Optimize.DEFAULT]\ndef representative_dataset_gen():\n  for _ in range(num_calibration_steps):\n    # Get sample input data as a numpy array in a method of your choosing.\n    yield [input]\nconverter.representative_dataset = representative_dataset_gen\nconverter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]\nconverter.inference_input_type = tf.int8  # or tf.uint8\nconverter.inference_output_type = tf.int8  # or tf.uint8\ntflite_quant_model = converter.convert()",
            "masked_code": "import tensorflow as tf\nconverter = tf.lite.TFLiteConverter.from_keras_model('model.h5')\nconverter.optimizations = [tf.lite.Optimize.DEFAULT]\ndef representative_dataset_gen():\n  for _ in range(num_calibration_steps):\n    # Get sample input data as a numpy array in a method of your choosing.\n    yield [input]\nconverter.representative_dataset = representative_dataset_gen\nconverter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]\nconverter.inference_input_type = tf.int8  # or tf.uint8\nconverter.inference_output_type = tf.int8  # or tf.uint8\n<line_mask>",
            "masked_line": "tflite_quant_model = converter.convert()",
            "answer": "convert",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_140",
            "model_output": "['<start>tflite_quant_model = converter.convert()<end>', '<start>tflite_quant_model = converter.convert()<end>', '<start>tflite_quant_model = converter.convert()<end>', '<start>tflite_quant_model = converter.convert()<end>', '<start>tflite_quant_model = converter.convert()<end>', '<start>tflite_quant_model = converter.convert()<end>']",
            "model_output_token_clear": "['tflite_quant_model = converter.convert()', 'tflite_quant_model = converter.convert()', 'tflite_quant_model = converter.convert()', 'tflite_quant_model = converter.convert()', 'tflite_quant_model = converter.convert()', 'tflite_quant_model = converter.convert()']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-06-17",
            "description": "The code loads a pre-trained keras model from a file, converts it to a TensorFlow Lite model using TFLiteConverter, and saves the converted model to a file named \"generated.tflite\".",
            "code": "# WHOLE MODEL\ntflite_model = tf.keras.models.load_model('model.h5')\nconverter = tf.lite.TFLiteConverter.from_keras_model(tflite_model)\ntflite_save = converter.convert()\nopen(\"generated.tflite\", \"wb\").write(tflite_save)",
            "masked_code": "# WHOLE MODEL\n<line_mask>\nconverter = tf.lite.TFLiteConverter.from_keras_model(tflite_model)\ntflite_save = converter.convert()\nopen(\"generated.tflite\", \"wb\").write(tflite_save)",
            "masked_line": "tflite_model = tf.keras.models.load_model('model.h5')",
            "answer": "models",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_141",
            "model_output": "['<start>tflite_model = tf.keras.models.load_model(saved_keras_model)<end>', '<start>tflite_model = tf.keras.models.load_model(saved_keras_model)<end>', '<start>tflite_model = tf.keras.models.load_model(saved_keras_model)<end>', \"<start>tflite_model = tf.keras.models.load_model('model.h5')<end>\", '<start>tflite_model = tf.keras.models.load_model(saved_keras_model)<end>', '<start>tflite_model = tf.keras.models.load_model(saved_keras_model)</start>']",
            "model_output_token_clear": "['tflite_model = tf.keras.models.load_model(saved_keras_model)', 'tflite_model = tf.keras.models.load_model(saved_keras_model)', 'tflite_model = tf.keras.models.load_model(saved_keras_model)', \"tflite_model = tf.keras.models.load_model('model.h5')\", 'tflite_model = tf.keras.models.load_model(saved_keras_model)', 'no_answer']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-06-17",
            "description": "The code converts a saved Keras model into a TensorFlow Lite model.",
            "code": "converter =  tf.lite.TFLiteConverter.from_keras_model_file(saved_keras_model)",
            "masked_code": "<line_mask>",
            "masked_line": "converter =  tf.lite.TFLiteConverter.from_keras_model_file(saved_keras_model)",
            "answer": "TFLiteConverter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_142",
            "model_output": "['<start>tflite_model = converter.convert()<end>', '<start>tflite_model = converter.convert()<end>', '<start>tflite_model = converter.convert()<end>', '<start>tflite_model = converter.convert()<end>', '<start>tflite_model = converter.convert()<end>', '<start>tflite_model = converter.convert()<end>']",
            "model_output_token_clear": "['tflite_model = converter.convert()', 'tflite_model = converter.convert()', 'tflite_model = converter.convert()', 'tflite_model = converter.convert()', 'tflite_model = converter.convert()', 'tflite_model = converter.convert()']"
        },
        {
            "dependency": "numba",
            "version": "==0.43.1",
            "time": "2020-05-30",
            "description": "The code defines a Just-In-Time (JIT) compiled function called \"growdh_no_bloom\" and decorates it with the Numba library's \"jit\" decorator. The function may be optimized for faster execution using the JIT compilation.",
            "code": "from numba import jit\nsig = np.random.randn(44100)\nimport numpy as np\n\nvectorized = jit(growdh_no_bloom)",
            "masked_code": "<line_mask>\nsig = np.random.randn(44100)\nimport numpy as np\n\nvectorized = jit(growdh_no_bloom)",
            "masked_line": "from numba import jit",
            "answer": "jit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_143",
            "model_output": "['<start>vectorized = njit(growdh_no_bloom)<end>', '<start>vectorized = njit(growdh_no_bloom)<end>', '<start>vectorized = njit(growdh_no_bloom)<end>', '<start>vectorized = njit(growdh_no_bloom)<end>', '<start>vectorized = njit()(growdh_no_bloom)<end>', '<start>vectorized = njit(growdh_no_bloom)<end>']",
            "model_output_token_clear": "['vectorized = njit(growdh_no_bloom)', 'vectorized = njit(growdh_no_bloom)', 'vectorized = njit(growdh_no_bloom)', 'vectorized = njit(growdh_no_bloom)', 'vectorized = njit()(growdh_no_bloom)', 'vectorized = njit(growdh_no_bloom)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.15",
            "time": "2020-09-02",
            "description": "The code snippet retrieves the default floating point datatype being used in the TensorFlow Keras backend.",
            "code": "import tensorflow as tf\ntf.keras.backend.floatx()",
            "masked_code": "import tensorflow as tf\n<line_mask>",
            "masked_line": "tf.keras.backend.floatx()",
            "answer": "floatx",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_144",
            "model_output": "[\"<start>K.set_floatx('float64')<end>\", \"<start>K.set_floatx('float64')<end>\", \"<start>K.set_floatx('float64')<end>\", \"<start>K.set_floatx('float64')</end>\", \"<start>K.set_floatx('float64')<end>\", \"<start>K.set_floatx('float64')<end>\"]",
            "model_output_token_clear": "[\"K.set_floatx('float64')\", \"K.set_floatx('float64')\", \"K.set_floatx('float64')\", 'no_answer', \"K.set_floatx('float64')\", \"K.set_floatx('float64')\"]"
        },
        {
            "dependency": "scikit-learn",
            "version": "<0.23",
            "time": "2020-10-24",
            "description": "The code creates an instance of a Logistic Regression model from the scikit-learn library.",
            "code": "import sklearn\nsklearn.__version__\n# 0.22.2\n\nfrom sklearn.linear_model import LogisticRegression\nlr = LogisticRegression()\nlr",
            "masked_code": "import sklearn\nsklearn.__version__\n# 0.22.2\n\nfrom sklearn.linear_model import LogisticRegression\n<line_mask>\nlr",
            "masked_line": "lr = LogisticRegression()",
            "answer": "LogisticRegression",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_145",
            "model_output": "['<start>lr = LogisticRegression()<end>', '<start>lr = LogisticRegression()<end>', '<start>lr = LogisticRegression()<end>', '<start>lr = LogisticRegression()<end>', '<start>lr = LogisticRegression()<end>', '<start>lr = LogisticRegression()<end>']",
            "model_output_token_clear": "['lr = LogisticRegression()', 'lr = LogisticRegression()', 'lr = LogisticRegression()', 'lr = LogisticRegression()', 'lr = LogisticRegression()', 'lr = LogisticRegression()']"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.0",
            "time": "2020-07-28",
            "description": "This code generates an animated line plot visualizing the changing win probabilities for two teams in a game over time. The x-axis represents the remaining game seconds, while the y-axis shows the win probabilities for the away and home teams. The plot updates in real-time to reflect the dynamic changes in win probabilities throughout the game.",
            "code": "import random\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib import rc\nrc('animation', html='jshtml')\n\ngame = pd.DataFrame({\n    'away_wp': [random.randint(-10,10) for _ in range(100)],\n    'home_wp': [random.randint(-10,10) for _ in range(100)],\n    'game_seconds_remaining': list(range(100)),\n})\n\nx = range(len(game))\ny1 = game['away_wp']\ny2 = game['home_wp']\n\nfig = plt.gcf()\nax = plt.gca()\n\nsns.lineplot(x='game_seconds_remaining', y='away_wp', data=game)\nsns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\n\nline1 = ax.lines[0]\nline2 = ax.lines[1]\n\nax.fill_between(game['game_seconds_remaining'], 0.5, game['away_wp'], where=game['away_wp']>.5, color = '#4F2683',alpha=0.3)\nax.fill_between(game['game_seconds_remaining'], 0.5, game['home_wp'], where=game['home_wp']>.5, color = '#869397',alpha=0.3)\n#print(ax.collections)\n\ndef update(num, x, y1, y2, line1, line2):\n    line1.set_data(x[:num], y1[:num])\n    line2.set_data(x[:num], y2[:num])\n\n    ax.clear()\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3)\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)\n\n    return line1,line2\n\nani = animation.FuncAnimation(fig, update, len(x), fargs=[x, y1, y2, line1, line2], interval=295, blit=False)\n\n#plt.show()\n\nani   # display it",
            "masked_code": "import random\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib import rc\nrc('animation', html='jshtml')\n\n<line_mask>\n    'away_wp': [random.randint(-10,10) for _ in range(100)],\n    'home_wp': [random.randint(-10,10) for _ in range(100)],\n    'game_seconds_remaining': list(range(100)),\n})\n\nx = range(len(game))\ny1 = game['away_wp']\ny2 = game['home_wp']\n\nfig = plt.gcf()\nax = plt.gca()\n\nsns.lineplot(x='game_seconds_remaining', y='away_wp', data=game)\nsns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\n\nline1 = ax.lines[0]\nline2 = ax.lines[1]\n\nax.fill_between(game['game_seconds_remaining'], 0.5, game['away_wp'], where=game['away_wp']>.5, color = '#4F2683',alpha=0.3)\nax.fill_between(game['game_seconds_remaining'], 0.5, game['home_wp'], where=game['home_wp']>.5, color = '#869397',alpha=0.3)\n#print(ax.collections)\n\ndef update(num, x, y1, y2, line1, line2):\n    line1.set_data(x[:num], y1[:num])\n    line2.set_data(x[:num], y2[:num])\n\n    ax.clear()\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3)\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)\n\n    return line1,line2\n\nani = animation.FuncAnimation(fig, update, len(x), fargs=[x, y1, y2, line1, line2], interval=295, blit=False)\n\n#plt.show()\n\nani   # display it",
            "masked_line": "game = pd.DataFrame({",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_146",
            "model_output": "[\"<start>game = pd.DataFrame({'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100))})<end>\", \"<start>game = pd.DataFrame({ 'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100))})<end>\", \"<start>game = pd.DataFrame({'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100))})<end>\", \"<start>game = pd.DataFrame({ 'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100)), })<end>\", \"<start>game = pd.DataFrame({'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100))})<end>\", '<start>game = pd.DataFrame({<end>']",
            "model_output_token_clear": "[\"game = pd.DataFrame({'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100))})\", \"game = pd.DataFrame({ 'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100))})\", \"game = pd.DataFrame({'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100))})\", \"game = pd.DataFrame({ 'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100)), })\", \"game = pd.DataFrame({'away_wp': [random.randint(-10,10) for _ in range(100)], 'home_wp': [random.randint(-10,10) for _ in range(100)], 'game_seconds_remaining': list(range(100))})\", 'game = pd.DataFrame({']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.1",
            "time": "2020-07-28",
            "description": "The code generates an animated visualization of a sports game where the win probability of the away and home teams are plotted against the game time in seconds. The animation updates the plot to show the progress of the game over time.",
            "code": "import random\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib import rc\nrc('animation', html='jshtml')\n\ngame = pd.DataFrame({\n    'away_wp': [random.randint(-10,10) for _ in range(100)],\n    'home_wp': [random.randint(-10,10) for _ in range(100)],\n    'game_seconds_remaining': list(range(100)),\n})\n\nx = range(len(game))\ny1 = game['away_wp']\ny2 = game['home_wp']\n\nfig = plt.gcf()\nax = plt.gca()\n\nsns.lineplot(x='game_seconds_remaining', y='away_wp', data=game)\nsns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\n\nline1 = ax.lines[0]\nline2 = ax.lines[1]\n\nax.fill_between(game['game_seconds_remaining'], 0.5, game['away_wp'], where=game['away_wp']>.5, color = '#4F2683',alpha=0.3)\nax.fill_between(game['game_seconds_remaining'], 0.5, game['home_wp'], where=game['home_wp']>.5, color = '#869397',alpha=0.3)\n#print(ax.collections)\n\ndef update(num, x, y1, y2, line1, line2):\n    line1.set_data(x[:num], y1[:num])\n    line2.set_data(x[:num], y2[:num])\n\n    ax.clear()\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3)\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)\n\n    return line1,line2\n\nani = animation.FuncAnimation(fig, update, len(x), fargs=[x, y1, y2, line1, line2], interval=295, blit=False)\n\n#plt.show()\n\nani   # display it",
            "masked_code": "import random\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib import rc\nrc('animation', html='jshtml')\n\ngame = pd.DataFrame({\n    'away_wp': [random.randint(-10,10) for _ in range(100)],\n    'home_wp': [random.randint(-10,10) for _ in range(100)],\n    'game_seconds_remaining': list(range(100)),\n})\n\nx = range(len(game))\ny1 = game['away_wp']\ny2 = game['home_wp']\n\nfig = plt.gcf()\nax = plt.gca()\n\nsns.lineplot(x='game_seconds_remaining', y='away_wp', data=game)\nsns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\n\nline1 = ax.lines[0]\nline2 = ax.lines[1]\n\nax.fill_between(game['game_seconds_remaining'], 0.5, game['away_wp'], where=game['away_wp']>.5, color = '#4F2683',alpha=0.3)\nax.fill_between(game['game_seconds_remaining'], 0.5, game['home_wp'], where=game['home_wp']>.5, color = '#869397',alpha=0.3)\n#print(ax.collections)\n\ndef update(num, x, y1, y2, line1, line2):\n    line1.set_data(x[:num], y1[:num])\n    line2.set_data(x[:num], y2[:num])\n\n    <line_mask>\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3)\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)\n\n    return line1,line2\n\nani = animation.FuncAnimation(fig, update, len(x), fargs=[x, y1, y2, line1, line2], interval=295, blit=False)\n\n#plt.show()\n\nani   # display it",
            "masked_line": "ax.clear()",
            "answer": "clear",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_147",
            "model_output": "['<start>return line1,line2<end>', '<start>return line1,line2<end>', '<start>return line1,line2<end>', '<start>return line1,line2,<end>', \"<start>return line1,line2=ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3),ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)<end>\", \"<start>return line1,line2=ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3), ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)<end>\"]",
            "model_output_token_clear": "['return line1,line2', 'return line1,line2', 'return line1,line2', 'return line1,line2,', \"return line1,line2=ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3),ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)\", \"return line1,line2=ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3), ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)\"]"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.2",
            "time": "2020-07-28",
            "description": "This code generates an animated line plot showing the away team's win probability (away_wp) and the home team's win probability (home_wp) over time during a game. The plot updates with the progress of the game, showing how the win probabilities change throughout the match.",
            "code": "import random\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib import rc\nrc('animation', html='jshtml')\n\ngame = pd.DataFrame({\n    'away_wp': [random.randint(-10,10) for _ in range(100)],\n    'home_wp': [random.randint(-10,10) for _ in range(100)],\n    'game_seconds_remaining': list(range(100)),\n})\n\nx = range(len(game))\ny1 = game['away_wp']\ny2 = game['home_wp']\n\nfig = plt.gcf()\nax = plt.gca()\n\nsns.lineplot(x='game_seconds_remaining', y='away_wp', data=game)\nsns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\n\nline1 = ax.lines[0]\nline2 = ax.lines[1]\n\nax.fill_between(game['game_seconds_remaining'], 0.5, game['away_wp'], where=game['away_wp']>.5, color = '#4F2683',alpha=0.3)\nax.fill_between(game['game_seconds_remaining'], 0.5, game['home_wp'], where=game['home_wp']>.5, color = '#869397',alpha=0.3)\n#print(ax.collections)\n\ndef update(num, x, y1, y2, line1, line2):\n    line1.set_data(x[:num], y1[:num])\n    line2.set_data(x[:num], y2[:num])\n\n    ax.clear()\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3)\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)\n\n    return line1,line2\n\nani = animation.FuncAnimation(fig, update, len(x), fargs=[x, y1, y2, line1, line2], interval=295, blit=False)\n\n#plt.show()\n\nani   # display it",
            "masked_code": "import random\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib import rc\nrc('animation', html='jshtml')\n\ngame = pd.DataFrame({\n    'away_wp': [random.randint(-10,10) for _ in range(100)],\n    'home_wp': [random.randint(-10,10) for _ in range(100)],\n    'game_seconds_remaining': list(range(100)),\n})\n\nx = range(len(game))\ny1 = game['away_wp']\ny2 = game['home_wp']\n\nfig = plt.gcf()\nax = plt.gca()\n\nsns.lineplot(x='game_seconds_remaining', y='away_wp', data=game)\n<line_mask>\n\nline1 = ax.lines[0]\nline2 = ax.lines[1]\n\nax.fill_between(game['game_seconds_remaining'], 0.5, game['away_wp'], where=game['away_wp']>.5, color = '#4F2683',alpha=0.3)\nax.fill_between(game['game_seconds_remaining'], 0.5, game['home_wp'], where=game['home_wp']>.5, color = '#869397',alpha=0.3)\n#print(ax.collections)\n\ndef update(num, x, y1, y2, line1, line2):\n    line1.set_data(x[:num], y1[:num])\n    line2.set_data(x[:num], y2[:num])\n\n    ax.clear()\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['away_wp'][:num], where=game['away_wp'][:num]>.5, color = '#4F2683',alpha=0.3)\n    ax.fill_between(game['game_seconds_remaining'][:num], 0.5, game['home_wp'][:num], where=game['home_wp'][:num]>.5, color = '#869397',alpha=0.3)\n\n    return line1,line2\n\nani = animation.FuncAnimation(fig, update, len(x), fargs=[x, y1, y2, line1, line2], interval=295, blit=False)\n\n#plt.show()\n\nani   # display it",
            "masked_line": "sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)",
            "answer": "lineplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_148",
            "model_output": "[\"<start>sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)<end>\", \"<start>sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)<end>\", \"<start>ani.save('animated_lineplot.gif', writer='pillow')<end>\", \"<start>sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)<end>\", \"<start>sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)<end>\", \"<start>sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)<end>\"]",
            "model_output_token_clear": "[\"sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\", \"sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\", \"ani.save('animated_lineplot.gif', writer='pillow')\", \"sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\", \"sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\", \"sns.lineplot(x='game_seconds_remaining', y='home_wp', data=game)\"]"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-02",
            "description": "The code generates boxplots for the 'cap' and 'cost' variables grouped by 'per' categories, with the 'cap' represented in blue and 'cost' in orange. The x-axis represents the percentage of RES integration, the y-axis shows production capacity (MW) for 'cap' and costs (Rupees) for 'cost'. The boxplots include whiskers showing values below the 5th percentile and above the 95th percentile as outliers.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random dataset similar to the one in the image you shared\nrng = np.random.default_rng(seed=123) # random number generator\ndata = dict(per = np.repeat([20, 40, 60], [60, 30, 10]),\n            cap = rng.choice([70, 90, 220, 240, 320, 330, 340, 360, 410], size=100),\n            cost = rng.integers(low=2050, high=2250, size=100))\ndf = pd.DataFrame(data)\n\n# Pivot table according to the 'per' categories so that the cap and\n# cost variables are grouped by them:\ndf_pivot = df.pivot(columns=['per'])\n\n# Create a list of the cap and cost grouped variables to be plotted \n# in each (twinned) boxplot: note that the NaN values must be removed\n# for the plotting function to work.\ncap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\ncost = [df_pivot['cost'][var].dropna() for var in df_pivot['cost']]\n\n# Create figure and dictionary containing boxplot parameters that are\n# common to both boxplots (according to my style preferences):\n# note that I define the whis parameter so that values below the 5th\n# percentile and above the 95th percentile are shown as outliers\nnb_groups = df['per'].nunique()\nfig, ax1 = plt.subplots(figsize=(9,6))\nbox_param = dict(whis=(5, 95), widths=0.2, patch_artist=True,\n                 flierprops=dict(marker='.', markeredgecolor='black',\n                 fillstyle=None), medianprops=dict(color='black'))\n\n# Create boxplots for 'cap' variable: note the double asterisk used\n# to unpack the dictionary of boxplot parameters\nspace = 0.15\nax1.boxplot(cap, positions=np.arange(nb_groups)-space,\n            boxprops=dict(facecolor='tab:blue'), **box_param)\n\n# Create boxplots for 'cost' variable on twin Axes\nax2 = ax1.twinx()\nax2.boxplot(cost, positions=np.arange(nb_groups)+space,\n            boxprops=dict(facecolor='tab:orange'), **box_param)\n\n# Format x ticks\nlabelsize = 12\nax1.set_xticks(np.arange(nb_groups))\nax1.set_xticklabels([f'{label}%' for label in df['per'].unique()])\nax1.tick_params(axis='x', labelsize=labelsize)\n\n# Format y ticks\nyticks_fmt = dict(axis='y', labelsize=labelsize)\nax1.tick_params(colors='tab:blue', **yticks_fmt)\nax2.tick_params(colors='tab:orange', **yticks_fmt)\n\n# Format axes labels\nlabel_fmt = dict(size=12, labelpad=15)\nax1.set_xlabel('Percentage of RES integration', **label_fmt)\nax1.set_ylabel('Production Capacity (MW)', color='tab:blue', **label_fmt)\nax2.set_ylabel('Costs (Rupees)', color='tab:orange', **label_fmt)\n\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random dataset similar to the one in the image you shared\n<line_mask>\ndata = dict(per = np.repeat([20, 40, 60], [60, 30, 10]),\n            cap = rng.choice([70, 90, 220, 240, 320, 330, 340, 360, 410], size=100),\n            cost = rng.integers(low=2050, high=2250, size=100))\ndf = pd.DataFrame(data)\n\n# Pivot table according to the 'per' categories so that the cap and\n# cost variables are grouped by them:\ndf_pivot = df.pivot(columns=['per'])\n\n# Create a list of the cap and cost grouped variables to be plotted \n# in each (twinned) boxplot: note that the NaN values must be removed\n# for the plotting function to work.\ncap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\ncost = [df_pivot['cost'][var].dropna() for var in df_pivot['cost']]\n\n# Create figure and dictionary containing boxplot parameters that are\n# common to both boxplots (according to my style preferences):\n# note that I define the whis parameter so that values below the 5th\n# percentile and above the 95th percentile are shown as outliers\nnb_groups = df['per'].nunique()\nfig, ax1 = plt.subplots(figsize=(9,6))\nbox_param = dict(whis=(5, 95), widths=0.2, patch_artist=True,\n                 flierprops=dict(marker='.', markeredgecolor='black',\n                 fillstyle=None), medianprops=dict(color='black'))\n\n# Create boxplots for 'cap' variable: note the double asterisk used\n# to unpack the dictionary of boxplot parameters\nspace = 0.15\nax1.boxplot(cap, positions=np.arange(nb_groups)-space,\n            boxprops=dict(facecolor='tab:blue'), **box_param)\n\n# Create boxplots for 'cost' variable on twin Axes\nax2 = ax1.twinx()\nax2.boxplot(cost, positions=np.arange(nb_groups)+space,\n            boxprops=dict(facecolor='tab:orange'), **box_param)\n\n# Format x ticks\nlabelsize = 12\nax1.set_xticks(np.arange(nb_groups))\nax1.set_xticklabels([f'{label}%' for label in df['per'].unique()])\nax1.tick_params(axis='x', labelsize=labelsize)\n\n# Format y ticks\nyticks_fmt = dict(axis='y', labelsize=labelsize)\nax1.tick_params(colors='tab:blue', **yticks_fmt)\nax2.tick_params(colors='tab:orange', **yticks_fmt)\n\n# Format axes labels\nlabel_fmt = dict(size=12, labelpad=15)\nax1.set_xlabel('Percentage of RES integration', **label_fmt)\nax1.set_ylabel('Production Capacity (MW)', color='tab:blue', **label_fmt)\nax2.set_ylabel('Costs (Rupees)', color='tab:orange', **label_fmt)\n\nplt.show()",
            "masked_line": "rng = np.random.default_rng(seed=123) # random number generator",
            "answer": "default_rng",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_149",
            "model_output": "['<start>rng = np.random.default_rng(seed=123)</end>', '<start>rng = np.random.default_rng(seed=123)</end>', '<start>rng = np.random.default_rng(seed=123)<end>', '<start>rng = np.random.default_rng(seed=123)<end>', '<start>rng = np.random.default_rng(seed=123)<end>', '<start>rng = np.random.default_rng(seed=123)<end>']",
            "model_output_token_clear": "['no_answer', 'no_answer', 'rng = np.random.default_rng(seed=123)', 'rng = np.random.default_rng(seed=123)', 'rng = np.random.default_rng(seed=123)', 'rng = np.random.default_rng(seed=123)']"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-01-02",
            "description": "The code generates and plots twin boxplots for production capacity and costs based on a random dataset, grouped by percentage of RES integration.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random dataset similar to the one in the image you shared\nrng = np.random.default_rng(seed=123) # random number generator\ndata = dict(per = np.repeat([20, 40, 60], [60, 30, 10]),\n            cap = rng.choice([70, 90, 220, 240, 320, 330, 340, 360, 410], size=100),\n            cost = rng.integers(low=2050, high=2250, size=100))\ndf = pd.DataFrame(data)\n\n# Pivot table according to the 'per' categories so that the cap and\n# cost variables are grouped by them:\ndf_pivot = df.pivot(columns=['per'])\n\n# Create a list of the cap and cost grouped variables to be plotted \n# in each (twinned) boxplot: note that the NaN values must be removed\n# for the plotting function to work.\ncap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\ncost = [df_pivot['cost'][var].dropna() for var in df_pivot['cost']]\n\n# Create figure and dictionary containing boxplot parameters that are\n# common to both boxplots (according to my style preferences):\n# note that I define the whis parameter so that values below the 5th\n# percentile and above the 95th percentile are shown as outliers\nnb_groups = df['per'].nunique()\nfig, ax1 = plt.subplots(figsize=(9,6))\nbox_param = dict(whis=(5, 95), widths=0.2, patch_artist=True,\n                 flierprops=dict(marker='.', markeredgecolor='black',\n                 fillstyle=None), medianprops=dict(color='black'))\n\n# Create boxplots for 'cap' variable: note the double asterisk used\n# to unpack the dictionary of boxplot parameters\nspace = 0.15\nax1.boxplot(cap, positions=np.arange(nb_groups)-space,\n            boxprops=dict(facecolor='tab:blue'), **box_param)\n\n# Create boxplots for 'cost' variable on twin Axes\nax2 = ax1.twinx()\nax2.boxplot(cost, positions=np.arange(nb_groups)+space,\n            boxprops=dict(facecolor='tab:orange'), **box_param)\n\n# Format x ticks\nlabelsize = 12\nax1.set_xticks(np.arange(nb_groups))\nax1.set_xticklabels([f'{label}%' for label in df['per'].unique()])\nax1.tick_params(axis='x', labelsize=labelsize)\n\n# Format y ticks\nyticks_fmt = dict(axis='y', labelsize=labelsize)\nax1.tick_params(colors='tab:blue', **yticks_fmt)\nax2.tick_params(colors='tab:orange', **yticks_fmt)\n\n# Format axes labels\nlabel_fmt = dict(size=12, labelpad=15)\nax1.set_xlabel('Percentage of RES integration', **label_fmt)\nax1.set_ylabel('Production Capacity (MW)', color='tab:blue', **label_fmt)\nax2.set_ylabel('Costs (Rupees)', color='tab:orange', **label_fmt)\n\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random dataset similar to the one in the image you shared\nrng = np.random.default_rng(seed=123) # random number generator\ndata = dict(per = np.repeat([20, 40, 60], [60, 30, 10]),\n            cap = rng.choice([70, 90, 220, 240, 320, 330, 340, 360, 410], size=100),\n            cost = rng.integers(low=2050, high=2250, size=100))\ndf = pd.DataFrame(data)\n\n# Pivot table according to the 'per' categories so that the cap and\n# cost variables are grouped by them:\ndf_pivot = df.pivot(columns=['per'])\n\n# Create a list of the cap and cost grouped variables to be plotted \n# in each (twinned) boxplot: note that the NaN values must be removed\n# for the plotting function to work.\n<line_mask>\ncost = [df_pivot['cost'][var].dropna() for var in df_pivot['cost']]\n\n# Create figure and dictionary containing boxplot parameters that are\n# common to both boxplots (according to my style preferences):\n# note that I define the whis parameter so that values below the 5th\n# percentile and above the 95th percentile are shown as outliers\nnb_groups = df['per'].nunique()\nfig, ax1 = plt.subplots(figsize=(9,6))\nbox_param = dict(whis=(5, 95), widths=0.2, patch_artist=True,\n                 flierprops=dict(marker='.', markeredgecolor='black',\n                 fillstyle=None), medianprops=dict(color='black'))\n\n# Create boxplots for 'cap' variable: note the double asterisk used\n# to unpack the dictionary of boxplot parameters\nspace = 0.15\nax1.boxplot(cap, positions=np.arange(nb_groups)-space,\n            boxprops=dict(facecolor='tab:blue'), **box_param)\n\n# Create boxplots for 'cost' variable on twin Axes\nax2 = ax1.twinx()\nax2.boxplot(cost, positions=np.arange(nb_groups)+space,\n            boxprops=dict(facecolor='tab:orange'), **box_param)\n\n# Format x ticks\nlabelsize = 12\nax1.set_xticks(np.arange(nb_groups))\nax1.set_xticklabels([f'{label}%' for label in df['per'].unique()])\nax1.tick_params(axis='x', labelsize=labelsize)\n\n# Format y ticks\nyticks_fmt = dict(axis='y', labelsize=labelsize)\nax1.tick_params(colors='tab:blue', **yticks_fmt)\nax2.tick_params(colors='tab:orange', **yticks_fmt)\n\n# Format axes labels\nlabel_fmt = dict(size=12, labelpad=15)\nax1.set_xlabel('Percentage of RES integration', **label_fmt)\nax1.set_ylabel('Production Capacity (MW)', color='tab:blue', **label_fmt)\nax2.set_ylabel('Costs (Rupees)', color='tab:orange', **label_fmt)\n\nplt.show()",
            "masked_line": "cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]",
            "answer": "dropna",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_150",
            "model_output": "[\"<start>cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]<end>\", \"<start>cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]<end>\", \"<start>cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]<end>\", \"<start>cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]<end>\", \"<start>cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]<end>\", \"<start>cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]<end>\"]",
            "model_output_token_clear": "[\"cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\", \"cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\", \"cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\", \"cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\", \"cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\", \"cap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-02",
            "description": "The code generates a random dataset with production capacity and costs, pivots the data according to percentage categories, and creates twinned boxplots to visualize the distribution of production capacity and costs grouped by percentage of RES integration. The boxplots are styled with specific parameters and the axes labels are formatted for clearer presentation. Finally, the boxplots are displayed in a single figure for comparison.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random dataset similar to the one in the image you shared\nrng = np.random.default_rng(seed=123) # random number generator\ndata = dict(per = np.repeat([20, 40, 60], [60, 30, 10]),\n            cap = rng.choice([70, 90, 220, 240, 320, 330, 340, 360, 410], size=100),\n            cost = rng.integers(low=2050, high=2250, size=100))\ndf = pd.DataFrame(data)\n\n# Pivot table according to the 'per' categories so that the cap and\n# cost variables are grouped by them:\ndf_pivot = df.pivot(columns=['per'])\n\n# Create a list of the cap and cost grouped variables to be plotted \n# in each (twinned) boxplot: note that the NaN values must be removed\n# for the plotting function to work.\ncap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\ncost = [df_pivot['cost'][var].dropna() for var in df_pivot['cost']]\n\n# Create figure and dictionary containing boxplot parameters that are\n# common to both boxplots (according to my style preferences):\n# note that I define the whis parameter so that values below the 5th\n# percentile and above the 95th percentile are shown as outliers\nnb_groups = df['per'].nunique()\nfig, ax1 = plt.subplots(figsize=(9,6))\nbox_param = dict(whis=(5, 95), widths=0.2, patch_artist=True,\n                 flierprops=dict(marker='.', markeredgecolor='black',\n                 fillstyle=None), medianprops=dict(color='black'))\n\n# Create boxplots for 'cap' variable: note the double asterisk used\n# to unpack the dictionary of boxplot parameters\nspace = 0.15\nax1.boxplot(cap, positions=np.arange(nb_groups)-space,\n            boxprops=dict(facecolor='tab:blue'), **box_param)\n\n# Create boxplots for 'cost' variable on twin Axes\nax2 = ax1.twinx()\nax2.boxplot(cost, positions=np.arange(nb_groups)+space,\n            boxprops=dict(facecolor='tab:orange'), **box_param)\n\n# Format x ticks\nlabelsize = 12\nax1.set_xticks(np.arange(nb_groups))\nax1.set_xticklabels([f'{label}%' for label in df['per'].unique()])\nax1.tick_params(axis='x', labelsize=labelsize)\n\n# Format y ticks\nyticks_fmt = dict(axis='y', labelsize=labelsize)\nax1.tick_params(colors='tab:blue', **yticks_fmt)\nax2.tick_params(colors='tab:orange', **yticks_fmt)\n\n# Format axes labels\nlabel_fmt = dict(size=12, labelpad=15)\nax1.set_xlabel('Percentage of RES integration', **label_fmt)\nax1.set_ylabel('Production Capacity (MW)', color='tab:blue', **label_fmt)\nax2.set_ylabel('Costs (Rupees)', color='tab:orange', **label_fmt)\n\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random dataset similar to the one in the image you shared\nrng = np.random.default_rng(seed=123) # random number generator\ndata = dict(per = np.repeat([20, 40, 60], [60, 30, 10]),\n            cap = rng.choice([70, 90, 220, 240, 320, 330, 340, 360, 410], size=100),\n            cost = rng.integers(low=2050, high=2250, size=100))\ndf = pd.DataFrame(data)\n\n# Pivot table according to the 'per' categories so that the cap and\n# cost variables are grouped by them:\ndf_pivot = df.pivot(columns=['per'])\n\n# Create a list of the cap and cost grouped variables to be plotted \n# in each (twinned) boxplot: note that the NaN values must be removed\n# for the plotting function to work.\ncap = [df_pivot['cap'][var].dropna() for var in df_pivot['cap']]\ncost = [df_pivot['cost'][var].dropna() for var in df_pivot['cost']]\n\n# Create figure and dictionary containing boxplot parameters that are\n# common to both boxplots (according to my style preferences):\n# note that I define the whis parameter so that values below the 5th\n# percentile and above the 95th percentile are shown as outliers\nnb_groups = df['per'].nunique()\nfig, ax1 = plt.subplots(figsize=(9,6))\nbox_param = dict(whis=(5, 95), widths=0.2, patch_artist=True,\n                 flierprops=dict(marker='.', markeredgecolor='black',\n                 fillstyle=None), medianprops=dict(color='black'))\n\n# Create boxplots for 'cap' variable: note the double asterisk used\n# to unpack the dictionary of boxplot parameters\nspace = 0.15\nax1.boxplot(cap, positions=np.arange(nb_groups)-space,\n            boxprops=dict(facecolor='tab:blue'), **box_param)\n\n# Create boxplots for 'cost' variable on twin Axes\nax2 = ax1.twinx()\nax2.boxplot(cost, positions=np.arange(nb_groups)+space,\n            boxprops=dict(facecolor='tab:orange'), **box_param)\n\n# Format x ticks\nlabelsize = 12\nax1.set_xticks(np.arange(nb_groups))\nax1.set_xticklabels([f'{label}%' for label in df['per'].unique()])\n<line_mask>\n\n# Format y ticks\nyticks_fmt = dict(axis='y', labelsize=labelsize)\nax1.tick_params(colors='tab:blue', **yticks_fmt)\nax2.tick_params(colors='tab:orange', **yticks_fmt)\n\n# Format axes labels\nlabel_fmt = dict(size=12, labelpad=15)\nax1.set_xlabel('Percentage of RES integration', **label_fmt)\nax1.set_ylabel('Production Capacity (MW)', color='tab:blue', **label_fmt)\nax2.set_ylabel('Costs (Rupees)', color='tab:orange', **label_fmt)\n\nplt.show()",
            "masked_line": "ax1.tick_params(axis='x', labelsize=labelsize)",
            "answer": "tick_params",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_151",
            "model_output": "[\"<start>ax1.set_xticklabels([f'{label}%' for label in df['per'].unique()], rotation=labelsize) <end>\", \"<start>ax1.set_xticklabels([f'{label}%' for label in df['per'].unique()], rotation=labelsize) <end>\", \"<start=ax1.set_xticklabels([f'{label}%' for label in df['per'].unique()], rotation=45)<end>\", \"<start>ax1.set_xticklabels([f'{label}%' for label in df['per'].unique()], rotation=45)<end>\", \"<start>ax1.set_xticklabels([f'{label}%' for label in sorted(df['per'].unique())])<end>\", \"<start>ax1.set_xticklabels([f'{label}%' for label in sorted(df['per'].unique())])<end>\"]",
            "model_output_token_clear": "[\"ax1.set_xticklabels([f'{label}%' for label in df['per'].unique()], rotation=labelsize) \", \"ax1.set_xticklabels([f'{label}%' for label in df['per'].unique()], rotation=labelsize) \", 'no_answer', \"ax1.set_xticklabels([f'{label}%' for label in df['per'].unique()], rotation=45)\", \"ax1.set_xticklabels([f'{label}%' for label in sorted(df['per'].unique())])\", \"ax1.set_xticklabels([f'{label}%' for label in sorted(df['per'].unique())])\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-02",
            "description": "This code converts a dataframe into a long format using the 'per' column as a grouping variable, and then creates side-by-side boxplots for each variable. The boxplots are colored by default and display the distribution of the data. Additionally, the code adjusts the spacing between the plots, sets titles for each subplot, and formats the axes labels before showing the plot.",
            "code": "import seaborn as sns    # v 0.11.0\n\n# Convert dataframe to long format with 'per' set aside as a grouping variable\ndf_melt = df.melt(id_vars='per')\n\n# Create side-by-side boxplots of each variable: note that the boxes\n# are colored by default\ng = sns.catplot(kind='box', data=df_melt, x='per', y='value', col='variable',\n                height=4, palette='Blues', sharey=False, saturation=1,\n                width=0.3, fliersize=2, linewidth=1, whis=(5, 95))\n\ng.fig.subplots_adjust(wspace=0.4)\ng.set_titles(col_template='{col_name}', size=12, pad=20)\n\n# Format Axes labels\nlabel_fmt = dict(size=10, labelpad=10)\nfor ax in g.axes.flatten():\n    ax.set_xlabel('Percentage of RES integration', **label_fmt)\ng.axes.flatten()[0].set_ylabel('Production Capacity (MW)', **label_fmt)\ng.axes.flatten()[1].set_ylabel('Costs (Rupees)', **label_fmt)\n\nplt.show()",
            "masked_code": "import seaborn as sns    # v 0.11.0\n\n# Convert dataframe to long format with 'per' set aside as a grouping variable\ndf_melt = df.melt(id_vars='per')\n\n# Create side-by-side boxplots of each variable: note that the boxes\n# are colored by default\ng = sns.catplot(kind='box', data=df_melt, x='per', y='value', col='variable',\n                height=4, palette='Blues', sharey=False, saturation=1,\n                width=0.3, fliersize=2, linewidth=1, whis=(5, 95))\n\ng.fig.subplots_adjust(wspace=0.4)\ng.set_titles(col_template='{col_name}', size=12, pad=20)\n\n# Format Axes labels\nlabel_fmt = dict(size=10, labelpad=10)\nfor ax in g.axes.flatten():\n    ax.set_xlabel('Percentage of RES integration', **label_fmt)\ng.axes.flatten()[0].set_ylabel('Production Capacity (MW)', **label_fmt)\ng.axes.flatten()[1].set_ylabel('Costs (Rupees)', **label_fmt)\n\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_152",
            "model_output": "['<start\"g.set(xlabel=\\'Percentage of RES integration\\', ylabel=[\\'Production Capacity (MW)\\', \\'Costs (Rupees)\\'])\"<end>', '<start>plt.show()<end>', \"<start>g.set(xlabel='', ylabel='')<end>\", \"<start>g.set(xlabel='', ylabel='')<end>\", '<start>g.fig.tight_layout()<end>', '<start\"g.set(xlabel=\\'\\', ylabel=\\'\\')\"']",
            "model_output_token_clear": "['no_answer', 'plt.show()', \"g.set(xlabel='', ylabel='')\", \"g.set(xlabel='', ylabel='')\", 'g.fig.tight_layout()', 'no_answer']"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-01-02",
            "description": "This code generates side-by-side boxplots of variables in a dataframe, with 'per' as a grouping variable. The boxplots are colored by default and the x-axis represents the 'per' variable while the y-axis represents the values. The code also adjusts the layout and formatting of the boxplots and axis labels before displaying the plots.",
            "code": "import seaborn as sns    # v 0.11.0\n\n# Convert dataframe to long format with 'per' set aside as a grouping variable\ndf_melt = df.melt(id_vars='per')\n\n# Create side-by-side boxplots of each variable: note that the boxes\n# are colored by default\ng = sns.catplot(kind='box', data=df_melt, x='per', y='value', col='variable',\n                height=4, palette='Blues', sharey=False, saturation=1,\n                width=0.3, fliersize=2, linewidth=1, whis=(5, 95))\n\ng.fig.subplots_adjust(wspace=0.4)\ng.set_titles(col_template='{col_name}', size=12, pad=20)\n\n# Format Axes labels\nlabel_fmt = dict(size=10, labelpad=10)\nfor ax in g.axes.flatten():\n    ax.set_xlabel('Percentage of RES integration', **label_fmt)\ng.axes.flatten()[0].set_ylabel('Production Capacity (MW)', **label_fmt)\ng.axes.flatten()[1].set_ylabel('Costs (Rupees)', **label_fmt)\n\nplt.show()",
            "masked_code": "import seaborn as sns    # v 0.11.0\n\n# Convert dataframe to long format with 'per' set aside as a grouping variable\ndf_melt = df.melt(id_vars='per')\n\n# Create side-by-side boxplots of each variable: note that the boxes\n# are colored by default\ng = sns.catplot(kind='box', data=df_melt, x='per', y='value', col='variable',\n                height=4, palette='Blues', sharey=False, saturation=1,\n                width=0.3, fliersize=2, linewidth=1, whis=(5, 95))\n\ng.fig.subplots_adjust(wspace=0.4)\ng.set_titles(col_template='{col_name}', size=12, pad=20)\n\n# Format Axes labels\nlabel_fmt = dict(size=10, labelpad=10)\n<line_mask>\n    ax.set_xlabel('Percentage of RES integration', **label_fmt)\ng.axes.flatten()[0].set_ylabel('Production Capacity (MW)', **label_fmt)\ng.axes.flatten()[1].set_ylabel('Costs (Rupees)', **label_fmt)\n\nplt.show()",
            "masked_line": "for ax in g.axes.flatten():",
            "answer": "flatten",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_153",
            "model_output": "['<start>for ax in g.axes.flatten():<end>', '<start>for ax in g.axes.flatten():<end>', \"<start>ax.set_title('Production Capacity (MW)', **label_fmt)<end>\", \"<start>ax.set_title('Production Capacity (MW)', **label_fmt)<end>\", '<start>for ax in g.axes.flatten():<end>', \"<start>ax.set_xlabel('', **label_fmt)<end>\"]",
            "model_output_token_clear": "['for ax in g.axes.flatten():', 'for ax in g.axes.flatten():', \"ax.set_title('Production Capacity (MW)', **label_fmt)\", \"ax.set_title('Production Capacity (MW)', **label_fmt)\", 'for ax in g.axes.flatten():', \"ax.set_xlabel('', **label_fmt)\"]"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2020-10-14",
            "description": "This code creates a pandas DataFrame with three entries, each containing the value 1 and indexed by DateTimeIndex objects representing dates in the years 2010, 2012, and 2011.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame(data=[1,1,1], index=pd.to_datetime(['2010-01-01', '2012-01-01', '2011-01-01']))\n\ndf.info()\n\n#\n#DatetimeIndex: 3 entries, 2010-01-01 to 2011-01-01\n#...",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame(data=[1,1,1], index=pd.to_datetime(['2010-01-01', '2012-01-01', '2011-01-01']))\n\n<line_mask>\n\n#\n#DatetimeIndex: 3 entries, 2010-01-01 to 2011-01-01\n#...",
            "masked_line": "df.info()",
            "answer": "info",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_154",
            "model_output": "[\"<start>df = df.set_index('index')<end>\", \"<start>df.set_index('index')<end>\", \"<start>df = df.set_index('index')<end>\", \"<start>df = df.set_index('index')<end>\", \"<start>df.set_index('index')<end>\", \"<start>df = df.set_index('index')<end>\"]",
            "model_output_token_clear": "[\"df = df.set_index('index')\", \"df.set_index('index')\", \"df = df.set_index('index')\", \"df = df.set_index('index')\", \"df.set_index('index')\", \"df = df.set_index('index')\"]"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-09-17",
            "description": "This code calculates whether the target values are in the top k predictions.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\nfrom tensorflow import nn\n\ny_true = [[0, 0, 1], [0, 1, 0]]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\n\ny_pred=tf.convert_to_tensor(y_pred, dtype=tf.float32)\ny_true = tf.convert_to_tensor([2,1], dtype=tf.int32)\n\nprint(nn.in_top_k(y_true, y_pred,  k=3))",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\nfrom tensorflow import nn\n\ny_true = [[0, 0, 1], [0, 1, 0]]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\n\n<line_mask>\ny_true = tf.convert_to_tensor([2,1], dtype=tf.int32)\n\nprint(nn.in_top_k(y_true, y_pred,  k=3))",
            "masked_line": "y_pred=tf.convert_to_tensor(y_pred, dtype=tf.float32)",
            "answer": "convert_to_tensor",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_155",
            "model_output": "['<start>y_pred_class = tf.argmax(y_pred, axis=1)<end>', '<start>y_pred_class = tf.argmax(y_pred, axis=1)<end>', '<start>y_pred_class = tf.argmax(y_pred, axis=1)<end>', '<start>y_pred_class = tf.argmax(y_pred, axis=1)<end>', '<start>y_pred_class = tf.argmax(y_pred, axis=1)<end>', '<start>y_pred_class = tf.argmax(y_pred, axis=1)<end>']",
            "model_output_token_clear": "['y_pred_class = tf.argmax(y_pred, axis=1)', 'y_pred_class = tf.argmax(y_pred, axis=1)', 'y_pred_class = tf.argmax(y_pred, axis=1)', 'y_pred_class = tf.argmax(y_pred, axis=1)', 'y_pred_class = tf.argmax(y_pred, axis=1)', 'y_pred_class = tf.argmax(y_pred, axis=1)']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.2.1",
            "time": "2020-06-09",
            "description": "This code generates a scatter plot showing the speed of a vehicle over time. The x-axis represents the distance traveled in kilometers, the y-axis represents the time, and the color of the dots represents the speed of the vehicle. The plot is labeled with the date \"NDW 13-03-17\" and includes a colorbar legend indicating the speed.",
            "code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as md\nfrom itertools import product\n\nTime = [f'2017-03-13 {H}:{M}:{S}' for H, M, S in list(product([('0' + str(x))[-2:] for x in range(0, 24)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)]))]\nSpeed = list(130*np.random.rand(len(Time)))\nKilometer = list(50*np.random.rand(len(Time)))\nN130317 = pd.DataFrame({'Time':Time, 'Speed':Speed, 'Kilometer':Kilometer})\n\nN130317['Time'] = pd.to_datetime(N130317['Time'], format = '%Y-%m-%d %H:%M:%S')\n\nmarker_size = 1  # sets size of dots\ncm = plt.cm.get_cmap('plasma_r') #sets colour scheme\nplt.scatter(N130317['Kilometer'], N130317['Time'], marker_size, c=N130317['Speed'], cmap=cm)\nax=plt.gca()\nxfmt = md.DateFormatter('%H:%M')\nax.yaxis.set_major_formatter(xfmt)\nplt.title(\"NDW 13-03-17\")\nplt.xlabel(\"Kilometer\")\nplt.ylabel(\"Time\")\nplt.colorbar().set_label(\"Speed\", labelpad=+1) #Makes a legend\nplt.show()",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as md\nfrom itertools import product\n\nTime = [f'2017-03-13 {H}:{M}:{S}' for H, M, S in list(product([('0' + str(x))[-2:] for x in range(0, 24)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)]))]\nSpeed = list(130*np.random.rand(len(Time)))\nKilometer = list(50*np.random.rand(len(Time)))\nN130317 = pd.DataFrame({'Time':Time, 'Speed':Speed, 'Kilometer':Kilometer})\n\nN130317['Time'] = pd.to_datetime(N130317['Time'], format = '%Y-%m-%d %H:%M:%S')\n\nmarker_size = 1  # sets size of dots\ncm = plt.cm.get_cmap('plasma_r') #sets colour scheme\nplt.scatter(N130317['Kilometer'], N130317['Time'], marker_size, c=N130317['Speed'], cmap=cm)\nax=plt.gca()\nxfmt = md.DateFormatter('%H:%M')\nax.yaxis.set_major_formatter(xfmt)\nplt.title(\"NDW 13-03-17\")\nplt.xlabel(\"Kilometer\")\nplt.ylabel(\"Time\")\n<line_mask>\nplt.show()",
            "masked_line": "plt.colorbar().set_label(\"Speed\", labelpad=+1) #Makes a legend",
            "answer": "set_label",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_156",
            "model_output": "['<start>cbar = plt.colorbar(cm.ScalarMappable(cmap=cm), ax=ax)<end>', '<start>cbar = plt.colorbar(); cbar.ax.xaxis.set_major_formatter(xfmt)<end>', '<start>cbar = plt.colorbar(cm) ; cbar.ax.tick_params(labelsize=10) ; cbar.set_label(\"Speed\")<end>', '<start>cbar = plt.colorbar(cm) <end>', '<start>cbar = plt.colorbar(cm) ; cbar.ax.yaxis.set_major_formatter(xfmt)<end>', '<start>cbar = plt.colorbar()<end>']",
            "model_output_token_clear": "['cbar = plt.colorbar(cm.ScalarMappable(cmap=cm), ax=ax)', 'cbar = plt.colorbar(); cbar.ax.xaxis.set_major_formatter(xfmt)', 'cbar = plt.colorbar(cm) ; cbar.ax.tick_params(labelsize=10) ; cbar.set_label(\"Speed\")', 'cbar = plt.colorbar(cm) ', 'cbar = plt.colorbar(cm) ; cbar.ax.yaxis.set_major_formatter(xfmt)', 'cbar = plt.colorbar()']"
        },
        {
            "dependency": "numpy",
            "version": "==1.18.4",
            "time": "2020-06-09",
            "description": "The code generates a scatter plot showing the relationship between time, kilometer, and speed data. The x-axis represents kilometer values, the y-axis represents time values, and the color of the points represents the speed values. The plot is titled \"NDW 13-03-17\" and includes a color legend indicating the speed values.",
            "code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as md\nfrom itertools import product\n\nTime = [f'2017-03-13 {H}:{M}:{S}' for H, M, S in list(product([('0' + str(x))[-2:] for x in range(0, 24)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)]))]\nSpeed = list(130*np.random.rand(len(Time)))\nKilometer = list(50*np.random.rand(len(Time)))\nN130317 = pd.DataFrame({'Time':Time, 'Speed':Speed, 'Kilometer':Kilometer})\n\nN130317['Time'] = pd.to_datetime(N130317['Time'], format = '%Y-%m-%d %H:%M:%S')\n\nmarker_size = 1  # sets size of dots\ncm = plt.cm.get_cmap('plasma_r') #sets colour scheme\nplt.scatter(N130317['Kilometer'], N130317['Time'], marker_size, c=N130317['Speed'], cmap=cm)\nax=plt.gca()\nxfmt = md.DateFormatter('%H:%M')\nax.yaxis.set_major_formatter(xfmt)\nplt.title(\"NDW 13-03-17\")\nplt.xlabel(\"Kilometer\")\nplt.ylabel(\"Time\")\nplt.colorbar().set_label(\"Speed\", labelpad=+1) #Makes a legend\nplt.show()",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as md\nfrom itertools import product\n\nTime = [f'2017-03-13 {H}:{M}:{S}' for H, M, S in list(product([('0' + str(x))[-2:] for x in range(0, 24)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)]))]\nSpeed = list(130*np.random.rand(len(Time)))\n<line_mask>\nN130317 = pd.DataFrame({'Time':Time, 'Speed':Speed, 'Kilometer':Kilometer})\n\nN130317['Time'] = pd.to_datetime(N130317['Time'], format = '%Y-%m-%d %H:%M:%S')\n\nmarker_size = 1  # sets size of dots\ncm = plt.cm.get_cmap('plasma_r') #sets colour scheme\nplt.scatter(N130317['Kilometer'], N130317['Time'], marker_size, c=N130317['Speed'], cmap=cm)\nax=plt.gca()\nxfmt = md.DateFormatter('%H:%M')\nax.yaxis.set_major_formatter(xfmt)\nplt.title(\"NDW 13-03-17\")\nplt.xlabel(\"Kilometer\")\nplt.ylabel(\"Time\")\nplt.colorbar().set_label(\"Speed\", labelpad=+1) #Makes a legend\nplt.show()",
            "masked_line": "Kilometer = list(50*np.random.rand(len(Time)))",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_157",
            "model_output": "['<start>Kilometer = list(130*np.random.rand(len(Time)))<end>', '<start>Kilometer = list(130*np.random.rand(len(Time)))<end>', '<start>Kilometer = [i for i in range(len(Time))]<end>', '<start>Kilometer = list(130*np.random.rand(len(Time)))<end>', '<start>Kilometer = [i for i in range(len(Time))]<end>', '<start>Kilometer = list(130*np.random.rand(len(Time)))<end>']",
            "model_output_token_clear": "['Kilometer = list(130*np.random.rand(len(Time)))', 'Kilometer = list(130*np.random.rand(len(Time)))', 'Kilometer = [i for i in range(len(Time))]', 'Kilometer = list(130*np.random.rand(len(Time)))', 'Kilometer = [i for i in range(len(Time))]', 'Kilometer = list(130*np.random.rand(len(Time)))']"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.4",
            "time": "2020-06-09",
            "description": "This code generates a scatter plot with speed values colored based on a plasma color scheme. The x-axis represents kilometers and the y-axis represents time. The plot is titled \"NDW 13-03-17\" and includes a colorbar legend indicating the speed values.",
            "code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as md\nfrom itertools import product\n\nTime = [f'2017-03-13 {H}:{M}:{S}' for H, M, S in list(product([('0' + str(x))[-2:] for x in range(0, 24)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)]))]\nSpeed = list(130*np.random.rand(len(Time)))\nKilometer = list(50*np.random.rand(len(Time)))\nN130317 = pd.DataFrame({'Time':Time, 'Speed':Speed, 'Kilometer':Kilometer})\n\nN130317['Time'] = pd.to_datetime(N130317['Time'], format = '%Y-%m-%d %H:%M:%S')\n\nmarker_size = 1  # sets size of dots\ncm = plt.cm.get_cmap('plasma_r') #sets colour scheme\nplt.scatter(N130317['Kilometer'], N130317['Time'], marker_size, c=N130317['Speed'], cmap=cm)\nax=plt.gca()\nxfmt = md.DateFormatter('%H:%M')\nax.yaxis.set_major_formatter(xfmt)\nplt.title(\"NDW 13-03-17\")\nplt.xlabel(\"Kilometer\")\nplt.ylabel(\"Time\")\nplt.colorbar().set_label(\"Speed\", labelpad=+1) #Makes a legend\nplt.show()",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as md\nfrom itertools import product\n\nTime = [f'2017-03-13 {H}:{M}:{S}' for H, M, S in list(product([('0' + str(x))[-2:] for x in range(0, 24)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)],\n                                                              [('0' + str(x))[-2:] for x in range(0, 60)]))]\nSpeed = list(130*np.random.rand(len(Time)))\nKilometer = list(50*np.random.rand(len(Time)))\n<line_mask>\n\nN130317['Time'] = pd.to_datetime(N130317['Time'], format = '%Y-%m-%d %H:%M:%S')\n\nmarker_size = 1  # sets size of dots\ncm = plt.cm.get_cmap('plasma_r') #sets colour scheme\nplt.scatter(N130317['Kilometer'], N130317['Time'], marker_size, c=N130317['Speed'], cmap=cm)\nax=plt.gca()\nxfmt = md.DateFormatter('%H:%M')\nax.yaxis.set_major_formatter(xfmt)\nplt.title(\"NDW 13-03-17\")\nplt.xlabel(\"Kilometer\")\nplt.ylabel(\"Time\")\nplt.colorbar().set_label(\"Speed\", labelpad=+1) #Makes a legend\nplt.show()",
            "masked_line": "N130317 = pd.DataFrame({'Time':Time, 'Speed':Speed, 'Kilometer':Kilometer})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_158",
            "model_output": "[\"<start>N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})<end>\", \"<start>N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})<end>\", \"<start>N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})<end>\", \"<start>N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})<end>\", \"<start>N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})<end>\", \"<start>N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})<end>\"]",
            "model_output_token_clear": "[\"N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})\", \"N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})\", \"N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})\", \"N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})\", \"N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})\", \"N130317 = pd.DataFrame({'Time': Time,'Speed': Speed,'Kilometer': Kilometer})\"]"
        },
        {
            "dependency": "rpy2",
            "version": "==3.x",
            "time": "2020-04-24",
            "description": "The code converts a pandas DataFrame to an R DataFrame using the rpy2 library, and assigns the result to the variable 'rkernel'.",
            "code": "from rpy2.robjects.conversion import localconverter\nfrom rpy2.robjects import pandas2ri\n\n\ndef pandas_to_rpy2(df):\n    with localconverter(ro.default_converter + pandas2ri.converter):\n        return ro.conversion.py2rpy(df)\n\ndef rpy2_to_pandas(r_df):\n    with localconverter(ro.default_converter + pandas2ri.converter):\n        return ro.conversion.rpy2py(r_df)\n\nrkernel = pandas_to_rpy2(df_dism)",
            "masked_code": "from rpy2.robjects.conversion import localconverter\nfrom rpy2.robjects import pandas2ri\n\n\ndef pandas_to_rpy2(df):\n    <line_mask>\n        return ro.conversion.py2rpy(df)\n\ndef rpy2_to_pandas(r_df):\n    with localconverter(ro.default_converter + pandas2ri.converter):\n        return ro.conversion.rpy2py(r_df)\n\nrkernel = pandas_to_rpy2(df_dism)",
            "masked_line": "with localconverter(ro.default_converter + pandas2ri.converter):",
            "answer": "localconverter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_159",
            "model_output": "['<start>with localconverter(ro.default_converter + pandas2ri.converter):<end>', '<start>with localconverter(ro.default_converter + pandas2ri.converter):<end>', '<start>with localconverter(pandas2ri.converter):<end>', '<start>with localconverter(ro.default_converter + pandas2ri.converter):<end>', '<start>with localconverter(ro.default_converter + pandas2ri.converter): return pandas2ri.py2rpy(df)<end>', '<start>with localconverter(ro.default_converter + pandas2ri.converter):<end>']",
            "model_output_token_clear": "['with localconverter(ro.default_converter + pandas2ri.converter):', 'with localconverter(ro.default_converter + pandas2ri.converter):', 'with localconverter(pandas2ri.converter):', 'with localconverter(ro.default_converter + pandas2ri.converter):', 'with localconverter(ro.default_converter + pandas2ri.converter): return pandas2ri.py2rpy(df)', 'with localconverter(ro.default_converter + pandas2ri.converter):']"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-04",
            "description": "The code creates a simulated dataset representing the cycle of traffic lights at an intersection, with different colors representing different states of the traffic lights (green, yellow, red). The dataset includes the duration of each light color in seconds, the number of cycles, and the total duration of the simulation. The data is stored in a pandas dataframe with the intersection ID, current state of the lights, and timestamps as the index.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\n## Create sample dataset\n\n# Light color codes\ngre = 1\nyel_to_red = 2\nred = 3\nyel_to_gre = 4\ncolor_dict = {1: 'green', 2: 'yellow', 3: 'red', 4: 'yellow'}\n\n# Light color duration in seconds\nsec_g = 45\nsec_yr = 3\nsec_r = 90\nsec_yg = 1\n\n# Light cycle\nlight_cycle = [gre, yel_to_red, red, yel_to_gre]\nsec_cycle = [sec_g, sec_yr, sec_r, sec_yg]\n\nncycles = 3\nsec_total = ncycles*sum(sec_cycle)\n\n# Create variables and store them in a pandas dataframe with the datetime as index\nIntersectionId = 12345\ncurrState = np.repeat(ncycles*light_cycle, repeats=ncycles*sec_cycle)\ntime_sec = pd.date_range(start='2021-01-04 08:00:00', freq='S', periods=sec_total)\ndf = pd.DataFrame(dict(IntersectionId = np.repeat(12345, repeats=ncycles*sum(sec_cycle)),\n                       currState = currState),\n                  index = time_sec)",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\n## Create sample dataset\n\n# Light color codes\ngre = 1\nyel_to_red = 2\nred = 3\nyel_to_gre = 4\ncolor_dict = {1: 'green', 2: 'yellow', 3: 'red', 4: 'yellow'}\n\n# Light color duration in seconds\nsec_g = 45\nsec_yr = 3\nsec_r = 90\nsec_yg = 1\n\n# Light cycle\nlight_cycle = [gre, yel_to_red, red, yel_to_gre]\nsec_cycle = [sec_g, sec_yr, sec_r, sec_yg]\n\nncycles = 3\nsec_total = ncycles*sum(sec_cycle)\n\n# Create variables and store them in a pandas dataframe with the datetime as index\nIntersectionId = 12345\n<line_mask>\ntime_sec = pd.date_range(start='2021-01-04 08:00:00', freq='S', periods=sec_total)\ndf = pd.DataFrame(dict(IntersectionId = np.repeat(12345, repeats=ncycles*sum(sec_cycle)),\n                       currState = currState),\n                  index = time_sec)",
            "masked_line": "currState = np.repeat(ncycles*light_cycle, repeats=ncycles*sec_cycle)",
            "answer": "repeat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_160",
            "model_output": "['<start>currState = np.repeat(light_cycle, repeats=ncycles)<end>', '<start>currState = np.repeat(light_cycle, repeats=ncycles)<end>', '<start>currState = np.repeat(light_cycle, repeats=ncycles)<end>', '<start>currState = np.repeat(light_cycle, repeats=ncycles)<end>', '<start>currState = np.repeat(light_cycle, repeats=ncycles)<end>', '<start>currState = np.repeat(light_cycle, repeats=ncycles)<end>']",
            "model_output_token_clear": "['currState = np.repeat(light_cycle, repeats=ncycles)', 'currState = np.repeat(light_cycle, repeats=ncycles)', 'currState = np.repeat(light_cycle, repeats=ncycles)', 'currState = np.repeat(light_cycle, repeats=ncycles)', 'currState = np.repeat(light_cycle, repeats=ncycles)', 'currState = np.repeat(light_cycle, repeats=ncycles)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-04",
            "description": "The code computes variables needed to define the arguments for a plotting function. It identifies the indices where the light changes in a dataset, converts timestamps to matplotlib date numbers, calculates the duration of each light color period, and then creates a horizontal bar chart with colors representing different states. It also formats the x-axis ticks and tick labels as well as the y-axis tick and tick label.",
            "code": "## Compute variables needed to define the plotting function arguments\n\nstates = np.array(df['currState'])\n\n# Create a list of indices of the rows where the light changes\n# (i.e. where a new currState code section starts)\nstarts_indices = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n\n# Append the last index to be able to compute the duration of the last\n# light color period recorded in the dataset\nstarts_end_indices = np.append(starts_indices, states.size-1)\n\n# Get the timestamps of those rows and convert them to python datetime format\nstarts_end_pydt = df.index[starts_end_indices].to_pydatetime()\n\n# Convert the python timestamps to matplotlib date number that is used as the\n# x-axis unit, this makes it easier to format the tick labels\nstarts_end_x = mdates.date2num(starts_end_pydt)\n\n# Get the duration of each light color in matplotlib date number units\nlengths = np.diff(starts_end_x)\n\n# Add one second (computed in python datetime units) to the duration of\n# the last light to make the bar chart left and right inclusive instead\n# of just left inclusive\npydt_second = (max(starts_end_x) - min(starts_end_x))/starts_end_indices[-1]\nlengths[-1] = lengths[-1] + pydt_second\n\n# Compute the arguments for the broken_barh plotting function\nxranges = [(start, length) for start, length in zip(starts_end_x, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_end_indices[:-1]].map(color_dict)\n\n\n## Create horizontal bar with colors by using the broken_barh function\n## and format ticks and tick labels\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n# Create and format x ticks and tick labels\nloc = mdates.AutoDateLocator()\nax.xaxis.set_major_locator(loc)\nformatter = mdates.AutoDateFormatter(loc)\nformatter.scaled[1/(24.*60.)] = '%H:%M:%S' # adjust this according to time range\nax.xaxis.set_major_formatter(formatter)\n\n# Format y-axis and create y tick and tick label\nax.set_ylim(0, 2)\nax.set_yticks([1])\nax.set_yticklabels([df['IntersectionId'][0]])\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_code": "## Compute variables needed to define the plotting function arguments\n\nstates = np.array(df['currState'])\n\n# Create a list of indices of the rows where the light changes\n# (i.e. where a new currState code section starts)\nstarts_indices = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n\n# Append the last index to be able to compute the duration of the last\n# light color period recorded in the dataset\n<line_mask>\n\n# Get the timestamps of those rows and convert them to python datetime format\nstarts_end_pydt = df.index[starts_end_indices].to_pydatetime()\n\n# Convert the python timestamps to matplotlib date number that is used as the\n# x-axis unit, this makes it easier to format the tick labels\nstarts_end_x = mdates.date2num(starts_end_pydt)\n\n# Get the duration of each light color in matplotlib date number units\nlengths = np.diff(starts_end_x)\n\n# Add one second (computed in python datetime units) to the duration of\n# the last light to make the bar chart left and right inclusive instead\n# of just left inclusive\npydt_second = (max(starts_end_x) - min(starts_end_x))/starts_end_indices[-1]\nlengths[-1] = lengths[-1] + pydt_second\n\n# Compute the arguments for the broken_barh plotting function\nxranges = [(start, length) for start, length in zip(starts_end_x, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_end_indices[:-1]].map(color_dict)\n\n\n## Create horizontal bar with colors by using the broken_barh function\n## and format ticks and tick labels\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n# Create and format x ticks and tick labels\nloc = mdates.AutoDateLocator()\nax.xaxis.set_major_locator(loc)\nformatter = mdates.AutoDateFormatter(loc)\nformatter.scaled[1/(24.*60.)] = '%H:%M:%S' # adjust this according to time range\nax.xaxis.set_major_formatter(formatter)\n\n# Format y-axis and create y tick and tick label\nax.set_ylim(0, 2)\nax.set_yticks([1])\nax.set_yticklabels([df['IntersectionId'][0]])\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_line": "starts_end_indices = np.append(starts_indices, states.size-1)",
            "answer": "append",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_161",
            "model_output": "['<start>starts_end_indices = np.append(starts_indices, states.size-1)<end>', '<start>starts_end_indices = np.append(starts_indices, states.size-1)<end>', '<start>starts_end_indices = np.append(starts_indices, states.size-1)<end>', '<start>starts_end_indices = np.append(starts_indices, states.size-1)<end>', '<start>starts_end_indices = np.append(starts_indices, states.size-1)<end>', '<start>starts_end_indices = np.append(starts_indices, states.size-1)<end>']",
            "model_output_token_clear": "['starts_end_indices = np.append(starts_indices, states.size-1)', 'starts_end_indices = np.append(starts_indices, states.size-1)', 'starts_end_indices = np.append(starts_indices, states.size-1)', 'starts_end_indices = np.append(starts_indices, states.size-1)', 'starts_end_indices = np.append(starts_indices, states.size-1)', 'starts_end_indices = np.append(starts_indices, states.size-1)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-04",
            "description": "This code computes the variables needed for the plotting function arguments using the currState variable. It creates a list of indices indicating the rows where the currState code changes, computes durations of each light in seconds, and then computes the arguments for the plotting function. It creates horizontal bars with colors using the broken_barh function and creates appropriate x ticks and tick labels for the plot. Finally, it formats the y-axis limits, ticks, and tick labels before displaying the plot.",
            "code": "## Compute the variables needed for the plotting function arguments\n## using the currState variable\n\nstates = np.array(df['currState'])\n\n# Create list of indices indicating the rows where the currState code\n# changes: note the comma to unpack the tuple\nstarts_indices, = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n# Compute durations of each light in seconds\nlengths = np.diff(starts_indices, append=states.size)\n\n\n## Compute the arguments for the plotting function\n\nxranges = [(start, length) for start, length in zip(starts_indices, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_indices].map(color_dict)\n\n\n## Create horizontal bar with colors using the broken_barh function\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n\n## Create appropriate x ticks and tick labels\n\n# Define time variable and parameters needed for computations\ntime = pd.DatetimeIndex(df.index).asi8 // 10**9 # time is in seconds\ntmin = min(time)\ntmax = max(time)\ntrange = tmax-tmin\n\n# Choose the approximate number of ticks, the exact number depends on\n# the automatically selected time step\napprox_nticks = 6 # low number selected because figure width is only 10 inches\nround_time_steps = [15, 30, 60, 120, 180, 240, 300, 600, 900, 1800, 3600, 7200, 14400]\ntime_step = min(round_time_steps, key=lambda x: abs(x - trange//approx_nticks))\n\n# Create list of x ticks including the right boundary of the last time point\n# in the dataset regardless of whether not it is aligned with the time step\ntimestamps = np.append(np.arange(tmin, tmax, time_step), tmax+1)\nxticks = timestamps-tmin\nax.set_xticks(xticks)\n\n# Create x tick labels with format depending on time step\nfmt_time = '%H:%M:%S' if time_step <= 60 else '%H:%M'\nxticklabels = [pd.to_datetime(ts, unit='s').strftime(fmt_time) for ts in timestamps]\nax.set_xticklabels(xticklabels)\n\n\n## Format y-axis limits, tick and tick label\n\nax.set_ylim(0, 2)\nax.set_yticks([1])\nax.set_yticklabels([df['IntersectionId'][0]])\n\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_code": "## Compute the variables needed for the plotting function arguments\n## using the currState variable\n\nstates = np.array(df['currState'])\n\n# Create list of indices indicating the rows where the currState code\n# changes: note the comma to unpack the tuple\nstarts_indices, = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n# Compute durations of each light in seconds\nlengths = np.diff(starts_indices, append=states.size)\n\n\n## Compute the arguments for the plotting function\n\nxranges = [(start, length) for start, length in zip(starts_indices, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_indices].map(color_dict)\n\n\n## Create horizontal bar with colors using the broken_barh function\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n\n## Create appropriate x ticks and tick labels\n\n# Define time variable and parameters needed for computations\ntime = pd.DatetimeIndex(df.index).asi8 // 10**9 # time is in seconds\ntmin = min(time)\ntmax = max(time)\ntrange = tmax-tmin\n\n# Choose the approximate number of ticks, the exact number depends on\n# the automatically selected time step\napprox_nticks = 6 # low number selected because figure width is only 10 inches\nround_time_steps = [15, 30, 60, 120, 180, 240, 300, 600, 900, 1800, 3600, 7200, 14400]\ntime_step = min(round_time_steps, key=lambda x: abs(x - trange//approx_nticks))\n\n# Create list of x ticks including the right boundary of the last time point\n# in the dataset regardless of whether not it is aligned with the time step\n<line_mask>\nxticks = timestamps-tmin\nax.set_xticks(xticks)\n\n# Create x tick labels with format depending on time step\nfmt_time = '%H:%M:%S' if time_step <= 60 else '%H:%M'\nxticklabels = [pd.to_datetime(ts, unit='s').strftime(fmt_time) for ts in timestamps]\nax.set_xticklabels(xticklabels)\n\n\n## Format y-axis limits, tick and tick label\n\nax.set_ylim(0, 2)\nax.set_yticks([1])\nax.set_yticklabels([df['IntersectionId'][0]])\n\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_line": "timestamps = np.append(np.arange(tmin, tmax, time_step), tmax+1)",
            "answer": "append",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_162",
            "model_output": "['<start>timestamps = np.arange(tmin, tmax + time_step, time_step)<end>', '<start>timestamps = np.arange(tmin, tmax + time_step, time_step)<end>', '<start>timestamps = np.arange(tmin, tmax + time_step, time_step)<end>', '<start>timestamps = np.arange(tmin, tmax + time_step, time_step)<end>', '<start>timestamps = np.arange(tmin, tmax + time_step, time_step)<end>', '<start>timestamps = np.arange(tmin, tmax + time_step, time_step)<end>']",
            "model_output_token_clear": "['timestamps = np.arange(tmin, tmax + time_step, time_step)', 'timestamps = np.arange(tmin, tmax + time_step, time_step)', 'timestamps = np.arange(tmin, tmax + time_step, time_step)', 'timestamps = np.arange(tmin, tmax + time_step, time_step)', 'timestamps = np.arange(tmin, tmax + time_step, time_step)', 'timestamps = np.arange(tmin, tmax + time_step, time_step)']"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-01-04",
            "description": "The code generates a sample dataset representing the light cycle at an intersection. It includes variables such as light colors, duration in seconds, and cycles. The data is stored in a pandas dataframe with the datetime as the index.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\n## Create sample dataset\n\n# Light color codes\ngre = 1\nyel_to_red = 2\nred = 3\nyel_to_gre = 4\ncolor_dict = {1: 'green', 2: 'yellow', 3: 'red', 4: 'yellow'}\n\n# Light color duration in seconds\nsec_g = 45\nsec_yr = 3\nsec_r = 90\nsec_yg = 1\n\n# Light cycle\nlight_cycle = [gre, yel_to_red, red, yel_to_gre]\nsec_cycle = [sec_g, sec_yr, sec_r, sec_yg]\n\nncycles = 3\nsec_total = ncycles*sum(sec_cycle)\n\n# Create variables and store them in a pandas dataframe with the datetime as index\nIntersectionId = 12345\ncurrState = np.repeat(ncycles*light_cycle, repeats=ncycles*sec_cycle)\ntime_sec = pd.date_range(start='2021-01-04 08:00:00', freq='S', periods=sec_total)\ndf = pd.DataFrame(dict(IntersectionId = np.repeat(12345, repeats=ncycles*sum(sec_cycle)),\n                       currState = currState),\n                  index = time_sec)",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\n## Create sample dataset\n\n# Light color codes\ngre = 1\nyel_to_red = 2\nred = 3\nyel_to_gre = 4\ncolor_dict = {1: 'green', 2: 'yellow', 3: 'red', 4: 'yellow'}\n\n# Light color duration in seconds\nsec_g = 45\nsec_yr = 3\nsec_r = 90\nsec_yg = 1\n\n# Light cycle\nlight_cycle = [gre, yel_to_red, red, yel_to_gre]\nsec_cycle = [sec_g, sec_yr, sec_r, sec_yg]\n\nncycles = 3\nsec_total = ncycles*sum(sec_cycle)\n\n# Create variables and store them in a pandas dataframe with the datetime as index\nIntersectionId = 12345\ncurrState = np.repeat(ncycles*light_cycle, repeats=ncycles*sec_cycle)\n<line_mask>\ndf = pd.DataFrame(dict(IntersectionId = np.repeat(12345, repeats=ncycles*sum(sec_cycle)),\n                       currState = currState),\n                  index = time_sec)",
            "masked_line": "time_sec = pd.date_range(start='2021-01-04 08:00:00', freq='S', periods=sec_total)",
            "answer": "date_range",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_163",
            "model_output": "['<start>time_sec = np.arange(ncycles*sum(sec_cycle))<end>', '<start>time_sec = np.arange(ncycles*sum(sec_cycle)) + np.arange(ncycles)[::-1].repeat(sum(sec_cycle)) * sum(sec_cycle)<end>', '<start>time_sec = np.arange(ncycles*sum(sec_cycle))<end>', '<start>time_sec = np.arange(sec_total)<end>', '<start>time_sec = np.arange(ncycles*sum(sec_cycle))<end>', '<start>time_sec = np.arange(sec_total)<end>']",
            "model_output_token_clear": "['time_sec = np.arange(ncycles*sum(sec_cycle))', 'time_sec = np.arange(ncycles*sum(sec_cycle)) + np.arange(ncycles)[::-1].repeat(sum(sec_cycle)) * sum(sec_cycle)', 'time_sec = np.arange(ncycles*sum(sec_cycle))', 'time_sec = np.arange(sec_total)', 'time_sec = np.arange(ncycles*sum(sec_cycle))', 'time_sec = np.arange(sec_total)']"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-01-04",
            "description": "The code calculates the variables needed for a plotting function based on the 'currState' variable in the dataframe. It identifies the rows where the 'currState' code changes, computes the durations of each state, creates ranges for the x-axis, sets colors based on a color dictionary, creates a horizontal bar plot with the specified colors, sets appropriate x-axis ticks and labels with respect to time, and formats the y-axis with specific limits, ticks, and labels. The final output is a grid view of the plot.",
            "code": "## Compute the variables needed for the plotting function arguments\n## using the currState variable\n\nstates = np.array(df['currState'])\n\n# Create list of indices indicating the rows where the currState code\n# changes: note the comma to unpack the tuple\nstarts_indices, = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n# Compute durations of each light in seconds\nlengths = np.diff(starts_indices, append=states.size)\n\n\n## Compute the arguments for the plotting function\n\nxranges = [(start, length) for start, length in zip(starts_indices, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_indices].map(color_dict)\n\n\n## Create horizontal bar with colors using the broken_barh function\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n\n## Create appropriate x ticks and tick labels\n\n# Define time variable and parameters needed for computations\ntime = pd.DatetimeIndex(df.index).asi8 // 10**9 # time is in seconds\ntmin = min(time)\ntmax = max(time)\ntrange = tmax-tmin\n\n# Choose the approximate number of ticks, the exact number depends on\n# the automatically selected time step\napprox_nticks = 6 # low number selected because figure width is only 10 inches\nround_time_steps = [15, 30, 60, 120, 180, 240, 300, 600, 900, 1800, 3600, 7200, 14400]\ntime_step = min(round_time_steps, key=lambda x: abs(x - trange//approx_nticks))\n\n# Create list of x ticks including the right boundary of the last time point\n# in the dataset regardless of whether not it is aligned with the time step\ntimestamps = np.append(np.arange(tmin, tmax, time_step), tmax+1)\nxticks = timestamps-tmin\nax.set_xticks(xticks)\n\n# Create x tick labels with format depending on time step\nfmt_time = '%H:%M:%S' if time_step <= 60 else '%H:%M'\nxticklabels = [pd.to_datetime(ts, unit='s').strftime(fmt_time) for ts in timestamps]\nax.set_xticklabels(xticklabels)\n\n\n## Format y-axis limits, tick and tick label\n\nax.set_ylim(0, 2)\nax.set_yticks([1])\nax.set_yticklabels([df['IntersectionId'][0]])\n\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_code": "## Compute the variables needed for the plotting function arguments\n## using the currState variable\n\nstates = np.array(df['currState'])\n\n# Create list of indices indicating the rows where the currState code\n# changes: note the comma to unpack the tuple\nstarts_indices, = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n# Compute durations of each light in seconds\nlengths = np.diff(starts_indices, append=states.size)\n\n\n## Compute the arguments for the plotting function\n\nxranges = [(start, length) for start, length in zip(starts_indices, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_indices].map(color_dict)\n\n\n## Create horizontal bar with colors using the broken_barh function\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n\n## Create appropriate x ticks and tick labels\n\n# Define time variable and parameters needed for computations\n<line_mask>\ntmin = min(time)\ntmax = max(time)\ntrange = tmax-tmin\n\n# Choose the approximate number of ticks, the exact number depends on\n# the automatically selected time step\napprox_nticks = 6 # low number selected because figure width is only 10 inches\nround_time_steps = [15, 30, 60, 120, 180, 240, 300, 600, 900, 1800, 3600, 7200, 14400]\ntime_step = min(round_time_steps, key=lambda x: abs(x - trange//approx_nticks))\n\n# Create list of x ticks including the right boundary of the last time point\n# in the dataset regardless of whether not it is aligned with the time step\ntimestamps = np.append(np.arange(tmin, tmax, time_step), tmax+1)\nxticks = timestamps-tmin\nax.set_xticks(xticks)\n\n# Create x tick labels with format depending on time step\nfmt_time = '%H:%M:%S' if time_step <= 60 else '%H:%M'\nxticklabels = [pd.to_datetime(ts, unit='s').strftime(fmt_time) for ts in timestamps]\nax.set_xticklabels(xticklabels)\n\n\n## Format y-axis limits, tick and tick label\n\nax.set_ylim(0, 2)\nax.set_yticks([1])\nax.set_yticklabels([df['IntersectionId'][0]])\n\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_line": "time = pd.DatetimeIndex(df.index).asi8 // 10**9 # time is in seconds",
            "answer": "DatetimeIndex",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_164",
            "model_output": "[\"<start>time = df['start_time'].values.astype('int64') // 10**9<end>\", \"<start>time = df['start_time'].values.astype('int64') // 10**9<end>\", '<start>time = df[\\'start_time\\'].map(pd.to_datetime).apply(lambda x: (x - pd.Timestamp(\"1970-01-01\")).total_seconds())</end>', \"<start>time = df['start_time'].values.astype('int64') // 10**9<end>\", \"<start>time = df['start_time'].astype('int64') // 10**9<end>\", \"<start>time = df['start_time'].map(lambda x: (x - df['start_time'].min()).total_seconds())<end>\"]",
            "model_output_token_clear": "[\"time = df['start_time'].values.astype('int64') // 10**9\", \"time = df['start_time'].values.astype('int64') // 10**9\", 'no_answer', \"time = df['start_time'].values.astype('int64') // 10**9\", \"time = df['start_time'].astype('int64') // 10**9\", \"time = df['start_time'].map(lambda x: (x - df['start_time'].min()).total_seconds())\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-04",
            "description": "The code computes variables needed to define the arguments for a plotting function. It identifies the indices where a new currState code section starts, converts timestamps to python datetime format, converts timestamps to matplotlib date number format for x-axis, calculates the duration of each section, adjusts the duration of the last section, and computes arguments for a broken_barh plotting function. Finally, it creates a horizontal bar chart with colors using the broken_barh function and formats ticks and tick labels for both x and y axes.",
            "code": "## Compute variables needed to define the plotting function arguments\n\nstates = np.array(df['currState'])\n\n# Create a list of indices of the rows where the light changes\n# (i.e. where a new currState code section starts)\nstarts_indices = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n\n# Append the last index to be able to compute the duration of the last\n# light color period recorded in the dataset\nstarts_end_indices = np.append(starts_indices, states.size-1)\n\n# Get the timestamps of those rows and convert them to python datetime format\nstarts_end_pydt = df.index[starts_end_indices].to_pydatetime()\n\n# Convert the python timestamps to matplotlib date number that is used as the\n# x-axis unit, this makes it easier to format the tick labels\nstarts_end_x = mdates.date2num(starts_end_pydt)\n\n# Get the duration of each light color in matplotlib date number units\nlengths = np.diff(starts_end_x)\n\n# Add one second (computed in python datetime units) to the duration of\n# the last light to make the bar chart left and right inclusive instead\n# of just left inclusive\npydt_second = (max(starts_end_x) - min(starts_end_x))/starts_end_indices[-1]\nlengths[-1] = lengths[-1] + pydt_second\n\n# Compute the arguments for the broken_barh plotting function\nxranges = [(start, length) for start, length in zip(starts_end_x, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_end_indices[:-1]].map(color_dict)\n\n\n## Create horizontal bar with colors by using the broken_barh function\n## and format ticks and tick labels\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n# Create and format x ticks and tick labels\nloc = mdates.AutoDateLocator()\nax.xaxis.set_major_locator(loc)\nformatter = mdates.AutoDateFormatter(loc)\nformatter.scaled[1/(24.*60.)] = '%H:%M:%S' # adjust this according to time range\nax.xaxis.set_major_formatter(formatter)\n\n# Format y-axis and create y tick and tick label\nax.set_ylim(0, 2)\nax.set_yticks([1])\nax.set_yticklabels([df['IntersectionId'][0]])\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_code": "## Compute variables needed to define the plotting function arguments\n\nstates = np.array(df['currState'])\n\n# Create a list of indices of the rows where the light changes\n# (i.e. where a new currState code section starts)\nstarts_indices = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n\n# Append the last index to be able to compute the duration of the last\n# light color period recorded in the dataset\nstarts_end_indices = np.append(starts_indices, states.size-1)\n\n# Get the timestamps of those rows and convert them to python datetime format\nstarts_end_pydt = df.index[starts_end_indices].to_pydatetime()\n\n# Convert the python timestamps to matplotlib date number that is used as the\n# x-axis unit, this makes it easier to format the tick labels\nstarts_end_x = mdates.date2num(starts_end_pydt)\n\n# Get the duration of each light color in matplotlib date number units\nlengths = np.diff(starts_end_x)\n\n# Add one second (computed in python datetime units) to the duration of\n# the last light to make the bar chart left and right inclusive instead\n# of just left inclusive\npydt_second = (max(starts_end_x) - min(starts_end_x))/starts_end_indices[-1]\nlengths[-1] = lengths[-1] + pydt_second\n\n# Compute the arguments for the broken_barh plotting function\nxranges = [(start, length) for start, length in zip(starts_end_x, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_end_indices[:-1]].map(color_dict)\n\n\n## Create horizontal bar with colors by using the broken_barh function\n## and format ticks and tick labels\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n# Create and format x ticks and tick labels\nloc = mdates.AutoDateLocator()\nax.xaxis.set_major_locator(loc)\nformatter = mdates.AutoDateFormatter(loc)\nformatter.scaled[1/(24.*60.)] = '%H:%M:%S' # adjust this according to time range\nax.xaxis.set_major_formatter(formatter)\n\n# Format y-axis and create y tick and tick label\nax.set_ylim(0, 2)\n<line_mask>\nax.set_yticklabels([df['IntersectionId'][0]])\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_line": "ax.set_yticks([1])",
            "answer": "set_yticks",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_165",
            "model_output": "['<start>ax.set_ylabel(\"Intersection ID\")<end>', '<start>ax.set_yticks([0.75])<end>', '<start>ax.set_ylabel(\"Intersection Id\")<end>', '<start>ax.set_ylabel(\"Intersection ID\")<end>', '<start>ax.set_ylabel(\"Intersection Id\")<end>', '<start>ax.set_ylabel(\"Intersection Id\")<end>']",
            "model_output_token_clear": "['ax.set_ylabel(\"Intersection ID\")', 'ax.set_yticks([0.75])', 'ax.set_ylabel(\"Intersection Id\")', 'ax.set_ylabel(\"Intersection ID\")', 'ax.set_ylabel(\"Intersection Id\")', 'ax.set_ylabel(\"Intersection Id\")']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-04",
            "description": "The code computes variables needed for plotting a horizontal bar graph showing transitions between different states in a given dataset. It calculates the durations of each state, assigns colors to each state, creates the bar graph, sets appropriate x-axis ticks and labels, and formats the y-axis.",
            "code": "## Compute the variables needed for the plotting function arguments\n## using the currState variable\n\nstates = np.array(df['currState'])\n\n# Create list of indices indicating the rows where the currState code\n# changes: note the comma to unpack the tuple\nstarts_indices, = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n# Compute durations of each light in seconds\nlengths = np.diff(starts_indices, append=states.size)\n\n\n## Compute the arguments for the plotting function\n\nxranges = [(start, length) for start, length in zip(starts_indices, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_indices].map(color_dict)\n\n\n## Create horizontal bar with colors using the broken_barh function\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n\n## Create appropriate x ticks and tick labels\n\n# Define time variable and parameters needed for computations\ntime = pd.DatetimeIndex(df.index).asi8 // 10**9 # time is in seconds\ntmin = min(time)\ntmax = max(time)\ntrange = tmax-tmin\n\n# Choose the approximate number of ticks, the exact number depends on\n# the automatically selected time step\napprox_nticks = 6 # low number selected because figure width is only 10 inches\nround_time_steps = [15, 30, 60, 120, 180, 240, 300, 600, 900, 1800, 3600, 7200, 14400]\ntime_step = min(round_time_steps, key=lambda x: abs(x - trange//approx_nticks))\n\n# Create list of x ticks including the right boundary of the last time point\n# in the dataset regardless of whether not it is aligned with the time step\ntimestamps = np.append(np.arange(tmin, tmax, time_step), tmax+1)\nxticks = timestamps-tmin\nax.set_xticks(xticks)\n\n# Create x tick labels with format depending on time step\nfmt_time = '%H:%M:%S' if time_step <= 60 else '%H:%M'\nxticklabels = [pd.to_datetime(ts, unit='s').strftime(fmt_time) for ts in timestamps]\nax.set_xticklabels(xticklabels)\n\n\n## Format y-axis limits, tick and tick label\n\nax.set_ylim(0, 2)\nax.set_yticks([1])\nax.set_yticklabels([df['IntersectionId'][0]])\n\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_code": "## Compute the variables needed for the plotting function arguments\n## using the currState variable\n\nstates = np.array(df['currState'])\n\n# Create list of indices indicating the rows where the currState code\n# changes: note the comma to unpack the tuple\nstarts_indices, = np.where(np.concatenate(([True], states[:-1] != states[1:])))\n# Compute durations of each light in seconds\nlengths = np.diff(starts_indices, append=states.size)\n\n\n## Compute the arguments for the plotting function\n\nxranges = [(start, length) for start, length in zip(starts_indices, lengths)]\nyranges = (0.75, 0.5)\ncolors = df['currState'][starts_indices].map(color_dict)\n\n\n## Create horizontal bar with colors using the broken_barh function\n\nfig, ax = plt.subplots(figsize=(10,2))\nax.broken_barh(xranges, yranges, facecolors=colors, zorder=2)\n\n\n## Create appropriate x ticks and tick labels\n\n# Define time variable and parameters needed for computations\ntime = pd.DatetimeIndex(df.index).asi8 // 10**9 # time is in seconds\ntmin = min(time)\ntmax = max(time)\ntrange = tmax-tmin\n\n# Choose the approximate number of ticks, the exact number depends on\n# the automatically selected time step\napprox_nticks = 6 # low number selected because figure width is only 10 inches\nround_time_steps = [15, 30, 60, 120, 180, 240, 300, 600, 900, 1800, 3600, 7200, 14400]\ntime_step = min(round_time_steps, key=lambda x: abs(x - trange//approx_nticks))\n\n# Create list of x ticks including the right boundary of the last time point\n# in the dataset regardless of whether not it is aligned with the time step\ntimestamps = np.append(np.arange(tmin, tmax, time_step), tmax+1)\nxticks = timestamps-tmin\nax.set_xticks(xticks)\n\n# Create x tick labels with format depending on time step\nfmt_time = '%H:%M:%S' if time_step <= 60 else '%H:%M'\nxticklabels = [pd.to_datetime(ts, unit='s').strftime(fmt_time) for ts in timestamps]\nax.set_xticklabels(xticklabels)\n\n\n## Format y-axis limits, tick and tick label\n\nax.set_ylim(0, 2)\nax.set_yticks([1])\n<line_mask>\n\n\nplt.grid(axis='x', alpha=0.5, zorder=1)\n\nplt.show()",
            "masked_line": "ax.set_yticklabels([df['IntersectionId'][0]])",
            "answer": "set_yticklabels",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_166",
            "model_output": "[\"<start>ax.set_yticklabels([''])<end>\", \"<start>ax.set_yticklabels([''])<end>\", \"<start>ax.set_yticklabels([''])<end>\", \"<start>ax.set_yticklabels(['State'])<end>\", \"<start>ax.set_yticklabels([''])<end>\", \"<start>ax.set_yticklabels([''])<end>\"]",
            "model_output_token_clear": "[\"ax.set_yticklabels([''])\", \"ax.set_yticklabels([''])\", \"ax.set_yticklabels([''])\", \"ax.set_yticklabels(['State'])\", \"ax.set_yticklabels([''])\", \"ax.set_yticklabels([''])\"]"
        },
        {
            "dependency": "numpy",
            "version": ">=1.17",
            "time": "2020-07-11",
            "description": "The code randomly selects 10 data points from the given test_data list, converts them to float values, and adds Gaussian jitter to each data point using a specific bandwidth factor.",
            "code": "import numpy\n\ngen=numpy.random.Generator(npr.PCG64())\ntest_data = [0, 8, 12, 35, 40, 4, 1, 0, 0, 0]\n# Choose 10 data points from `test_data` at random.\nc=gen.integers(0, len(test_data), size=10)\nc=numpy.asarray([float(test_data[d]) for d in c])\n# Add a Gaussian jitter.\n# Use the bandwidth factor in your example.\nc+=gen.normal(0, 0.18)",
            "masked_code": "import numpy\n\ngen=numpy.random.Generator(npr.PCG64())\ntest_data = [0, 8, 12, 35, 40, 4, 1, 0, 0, 0]\n# Choose 10 data points from `test_data` at random.\nc=gen.integers(0, len(test_data), size=10)\nc=numpy.asarray([float(test_data[d]) for d in c])\n# Add a Gaussian jitter.\n# Use the bandwidth factor in your example.\n<line_mask>",
            "masked_line": "c+=gen.normal(0, 0.18)",
            "answer": "normal",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_167",
            "model_output": "['<start>c += gen.normal(loc=0, scale=0.33)<end>', '<start>c += numpy.random.normal(0, 0.33, size=10)<end>', '<start>c += gen.normal(0, 0.33)<end>', '<start>c += gen.normal(loc=0, scale=0.33)<end>', '<start>c += numpy.random.normal(0, 0.33, size=10)<end>', '<start>c += gen.normal(loc=0, scale=0.33)<end>']",
            "model_output_token_clear": "['c += gen.normal(loc=0, scale=0.33)', 'c += numpy.random.normal(0, 0.33, size=10)', 'c += gen.normal(0, 0.33)', 'c += gen.normal(loc=0, scale=0.33)', 'c += numpy.random.normal(0, 0.33, size=10)', 'c += gen.normal(loc=0, scale=0.33)']"
        },
        {
            "dependency": "kivy",
            "version": "==1.11.1",
            "time": "2020-04-08",
            "description": "This code creates a Kivy application that displays a grid layout with 100 buttons, each labeled with a number from 0 to 99.",
            "code": "from kivy.app import App\nfrom kivy.uix.button import Button\nfrom kivy.uix.gridlayout import GridLayout\n\nclass DropApp(App):\n    def build(self):\n\n        layout = GridLayout(cols=1, spacing=10)\n        for i in range(100):\n            btn = Button(text=str(i), size_hint_y=None, height=40)\n            layout.add_widget(btn)\n        return layout\n\nif __name__ == '__main__':\n    DropApp().run()",
            "masked_code": "from kivy.app import App\nfrom kivy.uix.button import Button\nfrom kivy.uix.gridlayout import GridLayout\n\nclass DropApp(App):\n    def build(self):\n\n        layout = GridLayout(cols=1, spacing=10)\n        for i in range(100):\n            btn = Button(text=str(i), size_hint_y=None, height=40)\n            <line_mask>\n        return layout\n\nif __name__ == '__main__':\n    DropApp().run()",
            "masked_line": "layout.add_widget(btn)",
            "answer": "add_widget",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_168",
            "model_output": "['<start>layout.add_widget(btn)<end>', '<start>layout.add_widget(btn)<end>', '<start>layout.add_widget(btn)<end>', '<start>layout.add_widget(btn)<end>', '<start>layout.add_widget(btn)<end>', '<start>layout.add_widget(btn)<end>']",
            "model_output_token_clear": "['layout.add_widget(btn)', 'layout.add_widget(btn)', 'layout.add_widget(btn)', 'layout.add_widget(btn)', 'layout.add_widget(btn)', 'layout.add_widget(btn)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2020-05-15",
            "description": "The code creates a TensorFlow graph and sets it as the default graph. It defines a placeholder for 1D tensors of text input, loads a pre-trained Universal Sentence Encoder module from TensorFlow Hub, embeds the text input using the module, and initializes global variables and tables. Finally, it creates a TensorFlow session, initializes it, and runs the initialization operation.",
            "code": "# Create graph and finalize (finalizing optional but recommended).\ng = tf.Graph()\nwith g.as_default():\n  # We will be feeding 1D tensors of text into the graph.\n  text_input = tf.placeholder(dtype=tf.string, shape=[None])\n  embed = hub.Module(\"https://tfhub.dev/google/universal-sentence-encoder/2\")\n  embedded_text = embed(text_input)\n  init_op = tf.group([tf.global_variables_initializer(), tf.tables_initializer()])\ng.finalize()\n\n# Create session and initialize.\nsession = tf.Session(graph=g)\nsession.run(init_op)",
            "masked_code": "# Create graph and finalize (finalizing optional but recommended).\ng = tf.Graph()\nwith g.as_default():\n  # We will be feeding 1D tensors of text into the graph.\n  text_input = tf.placeholder(dtype=tf.string, shape=[None])\n  embed = hub.Module(\"https://tfhub.dev/google/universal-sentence-encoder/2\")\n  embedded_text = embed(text_input)\n  <line_mask>\ng.finalize()\n\n# Create session and initialize.\nsession = tf.Session(graph=g)\nsession.run(init_op)",
            "masked_line": "init_op = tf.group([tf.global_variables_initializer(), tf.tables_initializer()])",
            "answer": "group",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_169",
            "model_output": "['<start>init_op = tf.tables_initializer()<end>', '<start>init_op = tf.compat.v1.tables_initializer()<end>', '<start>init_op = tf.compat.v1.tables_initializer()<end>', '<start>init_op = tf.compat.v1.tables_initializer()<end>', '<start>init_op = tf.tables_initializer()<end>', '<start>init_op = tf.tables_initializer()<end>']",
            "model_output_token_clear": "['init_op = tf.tables_initializer()', 'init_op = tf.compat.v1.tables_initializer()', 'init_op = tf.compat.v1.tables_initializer()', 'init_op = tf.compat.v1.tables_initializer()', 'init_op = tf.tables_initializer()', 'init_op = tf.tables_initializer()']"
        },
        {
            "dependency": "plotly",
            "version": "==5.5.0",
            "time": "2021-12-29",
            "description": "The code generates a visualization of medal data using Plotly Express and Plotly Graph Objects. It converts numbers to words using the Inflect library and displays the visualization with text annotations.",
            "code": "import plotly.express as px\nimport plotly.graph_objects as go\nimport inflect\n\np = inflect.engine()\ndf = px.data.medals_wide(indexed=True)\nfig = px.imshow(df, text_auto=True)\nfig2 = go.Figure(fig.data, fig.layout)\nfig2 = fig2.update_traces(text=df.applymap(p.number_to_words).values, texttemplate=\"%{text}\", hovertemplate=None)\n\nfig.show()\nfig2.show()",
            "masked_code": "import plotly.express as px\nimport plotly.graph_objects as go\nimport inflect\n\np = inflect.engine()\ndf = px.data.medals_wide(indexed=True)\nfig = px.imshow(df, text_auto=True)\nfig2 = go.Figure(fig.data, fig.layout)\nfig2 = fig2.update_traces(text=df.applymap(p.number_to_words).values, texttemplate=\"%{text}\", hovertemplate=None)\n\nfig.show()\n<line_mask>",
            "masked_line": "fig2.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_170",
            "model_output": "['<start>fig2.show()<end>', '<start>fig2.show()<end>', '<start>fig2.show()<end>', '<start>fig2.show()<end>', '<start>fig2.show()<end>', '<start>fig2.show()<end>']",
            "model_output_token_clear": "['fig2.show()', 'fig2.show()', 'fig2.show()', 'fig2.show()', 'fig2.show()', 'fig2.show()']"
        },
        {
            "dependency": "plotly",
            "version": "==5.5.0",
            "time": "2021-12-29",
            "description": "This code generates a dashboard using Dash framework with a graph displaying the data from the medals_wide dataset in a heatmap format. The data is transformed using the inflect library to convert numbers to words in the graph annotations. The graph is updated through a callback function triggered by an interval component.",
            "code": "import numpy as np\nimport dash\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom dash.dependencies import Input, Output, State\nfrom jupyter_dash import JupyterDash\nimport inflect\n\n# Build App\napp = JupyterDash(__name__, external_scripts=[\"https://cdn.plot.ly/plotly-2.8.3.min.js\"])\napp.scripts.config.serve_locally = False\napp.layout = dash.html.Div(\n    [\n        dash.dcc.Interval(id=\"run\", max_intervals=1),\n        dash.dcc.Graph(id=\"fig\"),\n    ]\n)\n\n\ndef hm():\n    p = inflect.engine()\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df, text_auto=True)\n    fig2 = go.Figure(fig.data, fig.layout)\n    fig2 = fig2.update_traces(\n        text=df.applymap(p.number_to_words).values,\n        texttemplate=\"%{text}\",\n        hovertemplate=None,\n    )\n    return fig2.update_layout(title=f\"dash: {dash.__version__}\")\n\n\n@app.callback(Output(\"fig\", \"figure\"), Input(\"run\", \"n_intervals\"))\ndef createFig(n):\n    return hm()\n\n\n# Run app and display result inline in the notebook\napp.run_server(mode=\"inline\")",
            "masked_code": "import numpy as np\nimport dash\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom dash.dependencies import Input, Output, State\nfrom jupyter_dash import JupyterDash\nimport inflect\n\n# Build App\napp = JupyterDash(__name__, external_scripts=[\"https://cdn.plot.ly/plotly-2.8.3.min.js\"])\napp.scripts.config.serve_locally = False\napp.layout = dash.html.Div(\n    [\n        dash.dcc.Interval(id=\"run\", max_intervals=1),\n        dash.dcc.Graph(id=\"fig\"),\n    ]\n)\n\n\ndef hm():\n    p = inflect.engine()\n    df = px.data.medals_wide(indexed=True)\n    <line_mask>\n    fig2 = go.Figure(fig.data, fig.layout)\n    fig2 = fig2.update_traces(\n        text=df.applymap(p.number_to_words).values,\n        texttemplate=\"%{text}\",\n        hovertemplate=None,\n    )\n    return fig2.update_layout(title=f\"dash: {dash.__version__}\")\n\n\n@app.callback(Output(\"fig\", \"figure\"), Input(\"run\", \"n_intervals\"))\ndef createFig(n):\n    return hm()\n\n\n# Run app and display result inline in the notebook\napp.run_server(mode=\"inline\")",
            "masked_line": "fig = px.imshow(df, text_auto=True)",
            "answer": "imshow",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_171",
            "model_output": "[\"<start>fig = px.imshow(df, color_continuous_scale='blues')<end>\", '<start>fig = px.imshow(df) <end>', '<start>fig = px.imshow(df, color_continuous_scale=\"blues\")<end>', \"<start>fig = px.imshow(df, color_continuous_scale='gray')<end>\", \"<start>fig = px.imshow(df, color_continuous_scale='gray')<end>\", '<start>fig = px.imshow(df)<end>']",
            "model_output_token_clear": "[\"fig = px.imshow(df, color_continuous_scale='blues')\", 'fig = px.imshow(df) ', 'fig = px.imshow(df, color_continuous_scale=\"blues\")', \"fig = px.imshow(df, color_continuous_scale='gray')\", \"fig = px.imshow(df, color_continuous_scale='gray')\", 'fig = px.imshow(df)']"
        },
        {
            "dependency": "dash",
            "version": "==2.0.0",
            "time": "2021-12-29",
            "description": "This code generates a dashboard using Dash and Plotly libraries in Python. It reads data from a sample dataset, converts numerical values to text using the inflect library, and displays the data as an interactive heatmap with text annotations. The dashboard layout includes an interval component for updating the data and a graph component for displaying the heatmap.",
            "code": "import numpy as np\nimport dash\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom dash.dependencies import Input, Output, State\nfrom jupyter_dash import JupyterDash\nimport inflect\n\n# Build App\napp = JupyterDash(__name__, external_scripts=[\"https://cdn.plot.ly/plotly-2.8.3.min.js\"])\napp.scripts.config.serve_locally = False\napp.layout = dash.html.Div(\n    [\n        dash.dcc.Interval(id=\"run\", max_intervals=1),\n        dash.dcc.Graph(id=\"fig\"),\n    ]\n)\n\n\ndef hm():\n    p = inflect.engine()\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df, text_auto=True)\n    fig2 = go.Figure(fig.data, fig.layout)\n    fig2 = fig2.update_traces(\n        text=df.applymap(p.number_to_words).values,\n        texttemplate=\"%{text}\",\n        hovertemplate=None,\n    )\n    return fig2.update_layout(title=f\"dash: {dash.__version__}\")\n\n\n@app.callback(Output(\"fig\", \"figure\"), Input(\"run\", \"n_intervals\"))\ndef createFig(n):\n    return hm()\n\n\n# Run app and display result inline in the notebook\napp.run_server(mode=\"inline\")",
            "masked_code": "import numpy as np\nimport dash\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom dash.dependencies import Input, Output, State\nfrom jupyter_dash import JupyterDash\nimport inflect\n\n# Build App\napp = JupyterDash(__name__, external_scripts=[\"https://cdn.plot.ly/plotly-2.8.3.min.js\"])\napp.scripts.config.serve_locally = False\n<line_mask>\n    [\n        dash.dcc.Interval(id=\"run\", max_intervals=1),\n        dash.dcc.Graph(id=\"fig\"),\n    ]\n)\n\n\ndef hm():\n    p = inflect.engine()\n    df = px.data.medals_wide(indexed=True)\n    fig = px.imshow(df, text_auto=True)\n    fig2 = go.Figure(fig.data, fig.layout)\n    fig2 = fig2.update_traces(\n        text=df.applymap(p.number_to_words).values,\n        texttemplate=\"%{text}\",\n        hovertemplate=None,\n    )\n    return fig2.update_layout(title=f\"dash: {dash.__version__}\")\n\n\n@app.callback(Output(\"fig\", \"figure\"), Input(\"run\", \"n_intervals\"))\ndef createFig(n):\n    return hm()\n\n\n# Run app and display result inline in the notebook\napp.run_server(mode=\"inline\")",
            "masked_line": "app.layout = dash.html.Div(",
            "answer": "Div",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_172",
            "model_output": "['<start>app.layout = html.Div([dash.dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\"),])<end>', '<start>app.layout = html.Div([dash.dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\")])<end>', '<start>app.layout = html.Div([dash.dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\"),])<end>', '<start>app.layout = html.Div([dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\")])<end>', '<start>app.layout = html.Div([dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\"),])<end>', '<start>app.layout = html.Div([dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\")])<end>']",
            "model_output_token_clear": "['app.layout = html.Div([dash.dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\"),])', 'app.layout = html.Div([dash.dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\")])', 'app.layout = html.Div([dash.dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\"),])', 'app.layout = html.Div([dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\")])', 'app.layout = html.Div([dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\"),])', 'app.layout = html.Div([dcc.Interval(id=\"run\", max_intervals=1), dash.dcc.Graph(id=\"fig\")])']"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.5",
            "time": "2021-03-16",
            "description": "The code reads an Excel file named \"Presentaciones.xlsx\" using the openpyxl engine and prints the contents of the file using pandas.",
            "code": "import pandas as pd\n# Use openpyxl.\ndf = pd.read_excel(r'X:...\\Presentaciones.xlsx', engine='openpyxl')\nprint(df)",
            "masked_code": "import pandas as pd\n# Use openpyxl.\n<line_mask>\nprint(df)",
            "masked_line": "df = pd.read_excel(r'X:...\\Presentaciones.xlsx', engine='openpyxl')",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_173",
            "model_output": "['<start>df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")<end>', '<start>df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")<end>', '<start>df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")<end>', '<start>df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")<end>', '<start>df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")<end>', '<start>df = pd.read_excel(\"Presentaciones.xlsx\")<end>']",
            "model_output_token_clear": "['df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")', 'df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")', 'df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")', 'df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")', 'df = pd.read_excel(\"Presentaciones.xlsx\", engine=\"openpyxl\")', 'df = pd.read_excel(\"Presentaciones.xlsx\")']"
        },
        {
            "dependency": "numpy",
            "version": "==1.20",
            "time": "2021-08-18",
            "description": "The code calculates scores based on comparing sliding windows of size 10 to the last element in each window of a given dataframe. The calculated scores are then stored in a new dataframe with columns corresponding to the original dataframe.",
            "code": "from numpy.lib.stride_tricks import sliding_window_view\ndata = df.to_numpy()\nsw = sliding_window_view(data, 10, axis=0)\nscores_np = (sw <= sw[..., -1:]).sum(axis=2) / sw.shape[-1]\nscores_np_df = pd.DataFrame(scores_np, columns=df.columns)",
            "masked_code": "<line_mask>\ndata = df.to_numpy()\nsw = sliding_window_view(data, 10, axis=0)\nscores_np = (sw <= sw[..., -1:]).sum(axis=2) / sw.shape[-1]\nscores_np_df = pd.DataFrame(scores_np, columns=df.columns)",
            "masked_line": "from numpy.lib.stride_tricks import sliding_window_view",
            "answer": "sliding_window_view",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_174",
            "model_output": "['<start>sw = np.lib.stride_tricks.sliding_window_view(data, window_shape=(10,))<end>', '<start>sw = numpy.lib.stride_tricks.sliding_window_view(data, window_shape=(10,))[..., :10]<end>', '<start>sw = numpy.lib.stride_tricks.sliding_window_view(data, window_shape=(10,), axis=0)<end>', '<start>sliding_window_view = np.lib.stride_tricks.sliding_window_view<end>', '<start>np.lib.stride_tricks.sliding_window_view(data, window_size=10) <end>', '<start>np.less_equal.outer(data, data[:, -1:])<end>']",
            "model_output_token_clear": "['sw = np.lib.stride_tricks.sliding_window_view(data, window_shape=(10,))', 'sw = numpy.lib.stride_tricks.sliding_window_view(data, window_shape=(10,))[..., :10]', 'sw = numpy.lib.stride_tricks.sliding_window_view(data, window_shape=(10,), axis=0)', 'sliding_window_view = np.lib.stride_tricks.sliding_window_view', 'np.lib.stride_tricks.sliding_window_view(data, window_size=10) ', 'np.less_equal.outer(data, data[:, -1:])']"
        },
        {
            "dependency": "scipy",
            "version": "==1.7.3",
            "time": "2021-12-06",
            "description": "This Python code uses the scipy library to calculate the binned statistic of a dataset based on specified bins. It calculates the mean statistic for the values in each bin, handling missing values represented as NaN.",
            "code": "import scipy\nscipy.__version__\n'1.7.3'\nimport scipy.stats, numpy as np\nx = [0.5, 0.5, 1.5, 1.5]\nvalues = [10, 20, np.nan, 40]\nscipy.stats.binned_statistic(x, values, statistic='mean', bins=(0, 1, 2)).statistic\narray([15., nan])\nscipy.stats.binned_statistic(x, values, statistic=np.nanmean, bins=(0, 1, 2)).statistic\narray([15., 40.])",
            "masked_code": "import scipy\nscipy.__version__\n'1.7.3'\nimport scipy.stats, numpy as np\nx = [0.5, 0.5, 1.5, 1.5]\nvalues = [10, 20, np.nan, 40]\n<line_mask>\narray([15., nan])\nscipy.stats.binned_statistic(x, values, statistic=np.nanmean, bins=(0, 1, 2)).statistic\narray([15., 40.])",
            "masked_line": "scipy.stats.binned_statistic(x, values, statistic='mean', bins=(0, 1, 2)).statistic",
            "answer": "stats",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_175",
            "model_output": "['<start>values = np.nan_to_num(values)<end>', '<start>values = np.nan_to_num(values)<end>', '<start>values = np.nan_to_num(values)<end>', '<start-values = [v for v in values if not np.isnan(v)]<end>', '<start$values = np.nan_to_num(values)<end>', '<start>values = np.nanmean(np.array([val for val in values if not np.isnan(val)]))<end>']",
            "model_output_token_clear": "['values = np.nan_to_num(values)', 'values = np.nan_to_num(values)', 'values = np.nan_to_num(values)', 'no_answer', 'no_answer', 'values = np.nanmean(np.array([val for val in values if not np.isnan(val)]))']"
        },
        {
            "dependency": "plotly",
            "version": "==4.10",
            "time": "2021-09-18",
            "description": "This code creates an image representation using plotly express and displays it with customized x and y axis ranges.",
            "code": "import plotly.express as px\nfig = px.imshow(\n    img,\n    #color_continuous_scale='gray',\n    binary_string=True\n)\n\nfig.update_xaxes(range=[xmin, xmax])\nfig.update_yaxes(range=[ymax, ymin])\nfig.show()",
            "masked_code": "import plotly.express as px\nfig = px.imshow(\n    img,\n    #color_continuous_scale='gray',\n    binary_string=True\n)\n\nfig.update_xaxes(range=[xmin, xmax])\nfig.update_yaxes(range=[ymax, ymin])\n<line_mask>",
            "masked_line": "fig.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_176",
            "model_output": "['<start>fig.update_yaxes(title_text=\"Value\")<end>', '<start>fig.update_yaxes(title_text=\"Value\")<end>', '<start>fig.update_yaxes(title_text=\"Value\")<end>', \"<start>fig.update_yaxes(title_text='Value', title_standoff=0)<end>\", \"<start>fig.update_yaxes(title_text='Value', title_standoff=0)<end>\", \"<start>fig.update_yaxes(title_text='Value', title_standoff=0)<end>\"]",
            "model_output_token_clear": "['fig.update_yaxes(title_text=\"Value\")', 'fig.update_yaxes(title_text=\"Value\")', 'fig.update_yaxes(title_text=\"Value\")', \"fig.update_yaxes(title_text='Value', title_standoff=0)\", \"fig.update_yaxes(title_text='Value', title_standoff=0)\", \"fig.update_yaxes(title_text='Value', title_standoff=0)\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-17",
            "description": "The code generates two semilogy plots with exponentially increasing values for x and y functions that are nearly identical. The first plot displays minor ticks, while the second plot does not show minor ticks due to the y range covering less than 9 integer powers and the figure height being less than 4 inches. The plots are displayed in a figure with a height of 3 inches using Matplotlib defaults.",
            "code": "import numpy as np                 # v 1.19.2\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.ticker as ticker\n\n# Create sample data with exponentially increasing values for x and\n# the y functions and where the y functions are nearly identical\nx = 10**np.linspace(0, 3, 30)\ny1 = x**2\ny2 = x**2.5\n\n# Create figure and subplots containing semilogy plots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 3))\nfig.suptitle('Matplotlib defaults with figure height of 3 inches', y=1.25)\n\nax1.set_title('Minor ticks are shown\\n\\n', pad=10)\nax1.semilogy(x, y1, label='y1')\nax1.legend(loc='lower right')\n\nax2.set_title(f'Minor ticks are not shown:\\nthe y range covers less than 9 \\\ninteger\\npowers, but the figure height is <4 inches', pad=10)\nax2.semilogy(x, y2, label='y2')\nax2.legend(loc='lower right')\n\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.ticker as ticker\n\n# Create sample data with exponentially increasing values for x and\n# the y functions and where the y functions are nearly identical\nx = 10**np.linspace(0, 3, 30)\ny1 = x**2\ny2 = x**2.5\n\n# Create figure and subplots containing semilogy plots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 3))\nfig.suptitle('Matplotlib defaults with figure height of 3 inches', y=1.25)\n\nax1.set_title('Minor ticks are shown\\n\\n', pad=10)\nax1.semilogy(x, y1, label='y1')\nax1.legend(loc='lower right')\n\nax2.set_title(f'Minor ticks are not shown:\\nthe y range covers less than 9 \\\ninteger\\npowers, but the figure height is <4 inches', pad=10)\nax2.semilogy(x, y2, label='y2')\nax2.legend(loc='lower right')\n\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_177",
            "model_output": "['<start>ax2.minorticks_off()<end>', \"<start>ax.get_yticklabels(which='minor')[0].set_visible(False)<end>\", '<start>ax2.minorticks_off()<end>', '<start>ax2.minorticks_off()<end>', '<start>ax2.minorticks_off()<end>', \"<start>ax2.tick_params(axis='y', which='minor', labelsize=0)<end>\"]",
            "model_output_token_clear": "['ax2.minorticks_off()', \"ax.get_yticklabels(which='minor')[0].set_visible(False)\", 'ax2.minorticks_off()', 'ax2.minorticks_off()', 'ax2.minorticks_off()', \"ax2.tick_params(axis='y', which='minor', labelsize=0)\"]"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-17",
            "description": "The code generates two semilogy plots with exponentially increasing values for x and y functions, where the y functions are nearly identical. The first plot shows minor ticks, while the second plot does not show minor ticks when the y range covers less than 9 integer powers and the figure height is less than 4 inches.",
            "code": "import numpy as np                 # v 1.19.2\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.ticker as ticker\n\n# Create sample data with exponentially increasing values for x and\n# the y functions and where the y functions are nearly identical\nx = 10**np.linspace(0, 3, 30)\ny1 = x**2\ny2 = x**2.5\n\n# Create figure and subplots containing semilogy plots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 3))\nfig.suptitle('Matplotlib defaults with figure height of 3 inches', y=1.25)\n\nax1.set_title('Minor ticks are shown\\n\\n', pad=10)\nax1.semilogy(x, y1, label='y1')\nax1.legend(loc='lower right')\n\nax2.set_title(f'Minor ticks are not shown:\\nthe y range covers less than 9 \\\ninteger\\npowers, but the figure height is <4 inches', pad=10)\nax2.semilogy(x, y2, label='y2')\nax2.legend(loc='lower right')\n\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.ticker as ticker\n\n# Create sample data with exponentially increasing values for x and\n# the y functions and where the y functions are nearly identical\n<line_mask>\ny1 = x**2\ny2 = x**2.5\n\n# Create figure and subplots containing semilogy plots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 3))\nfig.suptitle('Matplotlib defaults with figure height of 3 inches', y=1.25)\n\nax1.set_title('Minor ticks are shown\\n\\n', pad=10)\nax1.semilogy(x, y1, label='y1')\nax1.legend(loc='lower right')\n\nax2.set_title(f'Minor ticks are not shown:\\nthe y range covers less than 9 \\\ninteger\\npowers, but the figure height is <4 inches', pad=10)\nax2.semilogy(x, y2, label='y2')\nax2.legend(loc='lower right')\n\nplt.show()",
            "masked_line": "x = 10**np.linspace(0, 3, 30)",
            "answer": "linspace",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_178",
            "model_output": "['<start>x = np.arange(0.1, 13, 0.1)<end>', '<start>x = np.arange(0.1, 10, 0.01)<end>', '<start>x = np.logspace(-3, 3, 100)<end>', '<start>x = np.arange(0.1, 13, 0.1)<end>', '<start>x = np.arange(0.1, 10, 0.01)<end>', '<start>x = np.arange(0.1, 13, 0.1)<end>']",
            "model_output_token_clear": "['x = np.arange(0.1, 13, 0.1)', 'x = np.arange(0.1, 10, 0.01)', 'x = np.logspace(-3, 3, 100)', 'x = np.arange(0.1, 13, 0.1)', 'x = np.arange(0.1, 10, 0.01)', 'x = np.arange(0.1, 13, 0.1)']"
        },
        {
            "dependency": "rpy2",
            "version": "==3.4.x",
            "time": "2021-02-28",
            "description": "This code sets the width of the R console output to 80 characters.",
            "code": "import rpy2.robjects as robjects\nrobjects.r(\"options(width=80)\")",
            "masked_code": "import rpy2.robjects as robjects\n<line_mask>",
            "masked_line": "robjects.r(\"options(width=80)\")",
            "answer": "r",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_179",
            "model_output": "['<start>robjects.r(\"options(width=80)\")<end>', '<start>robjects.r(\"options(width=80)\")<end>', '<start>robjects.r(\"options(width=80)\")<end>', '<start>robjects.r(\"options(width=80)\")<end>', '<start>robjects.r(\"options(width=80)\")<end>', '<start>robjects.r(\"options(width=80)\")<end>']",
            "model_output_token_clear": "['robjects.r(\"options(width=80)\")', 'robjects.r(\"options(width=80)\")', 'robjects.r(\"options(width=80)\")', 'robjects.r(\"options(width=80)\")', 'robjects.r(\"options(width=80)\")', 'robjects.r(\"options(width=80)\")']"
        },
        {
            "dependency": "rpy2",
            "version": "==3.4.x",
            "time": "2021-02-28",
            "description": "This code sets the width of the output to 80 characters in the R environment using the rpy2 package.",
            "code": "from rpy2.robjects.packages import importr\nbase = importr('base')\nbase.options(width=80)",
            "masked_code": "from rpy2.robjects.packages import importr\n<line_mask>\nbase.options(width=80)",
            "masked_line": "base = importr('base')",
            "answer": "importr",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_180",
            "model_output": "[\"<start>base = importr('base')<end>\", \"<start>base = importr('base')<end>\", \"<start>base = importr('base')<end>\", \"<start>base = importr('base')<end>\", \"<start>base = importr('base')<end>\", \"<start>base = importr('base')<end>\"]",
            "model_output_token_clear": "[\"base = importr('base')\", \"base = importr('base')\", \"base = importr('base')\", \"base = importr('base')\", \"base = importr('base')\", \"base = importr('base')\"]"
        },
        {
            "dependency": "audiomath",
            "version": ">=1.16.0",
            "time": "2021-09-24",
            "description": "The code creates a new sound object by reading a sound file ('mySample.wav') and then applies a Hann window to fade in and out the sound over a duration of 5 seconds.",
            "code": "from audiomath import Sound\n\nsound01 = Sound('mySample.wav')\nsoundFadedInAndOut = sound01 * sound01.MakeHannWindow(5)  # note the multiplication",
            "masked_code": "from audiomath import Sound\n\nsound01 = Sound('mySample.wav')\n<line_mask>",
            "masked_line": "soundFadedInAndOut = sound01 * sound01.MakeHannWindow(5)  # note the multiplication",
            "answer": "MakeHannWindow",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_181",
            "model_output": "['<start>sound01 = sound01 * sound01.MakeHannWindow(5)<end>', '<start>sound01 = sound01 * sound01.MakeHannWindow(5)<end>', '<start>sound01 = sound01 * sound01.MakeHannWindow(5)<end>', '<start>sound01 = sound01 * sound01.MakeHannWindow(5)<end>', '<start>sound01 = sound01 * sound01.MakeHannWindow(5)<end>', '<start>sound01 = sound01 * sound01.MakeHannWindow(5)<end>']",
            "model_output_token_clear": "['sound01 = sound01 * sound01.MakeHannWindow(5)', 'sound01 = sound01 * sound01.MakeHannWindow(5)', 'sound01 = sound01 * sound01.MakeHannWindow(5)', 'sound01 = sound01 * sound01.MakeHannWindow(5)', 'sound01 = sound01 * sound01.MakeHannWindow(5)', 'sound01 = sound01 * sound01.MakeHannWindow(5)']"
        },
        {
            "dependency": "audiomath",
            "version": ">=1.16.0",
            "time": "2021-09-24",
            "description": "The code creates a sound object from a wav file and then creates a new sound object that is a copy of the original sound but with faded in and out effects applied to it.",
            "code": "from audiomath import Sound\n\nsound01 = Sound('mySample.wav')\nsoundFadedInAndOut = sound01.Copy().Fade(risetime=0.5, falltime=0.5, hann=True)",
            "masked_code": "from audiomath import Sound\n\nsound01 = Sound('mySample.wav')\n<line_mask>",
            "masked_line": "soundFadedInAndOut = sound01.Copy().Fade(risetime=0.5, falltime=0.5, hann=True)",
            "answer": "Fade",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_182",
            "model_output": "['<start>sound02 = sound01.fade_in(0.5).fade_out(0.5)<end>', '<start>sound02 = sound01.fadein(0.5).fadeout(0.5)<end>', '<start>sound02 = sound01.fade_in(0.5).fade_out(0.5)<end>', '<start>sound02 = sound01.fade_in(duration=0.5).fade_out(duration=0.5)<end>', '<start>sound02 = sound01.fade_in(1).fade_out(1)<end>', '<start>sound02 = sound01.fadein(0.5).fadeout(0.5)<end>']",
            "model_output_token_clear": "['sound02 = sound01.fade_in(0.5).fade_out(0.5)', 'sound02 = sound01.fadein(0.5).fadeout(0.5)', 'sound02 = sound01.fade_in(0.5).fade_out(0.5)', 'sound02 = sound01.fade_in(duration=0.5).fade_out(duration=0.5)', 'sound02 = sound01.fade_in(1).fade_out(1)', 'sound02 = sound01.fadein(0.5).fadeout(0.5)']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.4.2",
            "time": "2021-08-16",
            "description": "The code generates a 2D cross-section plot of a vector field, where vectors are plotted at specified points (X, Z) with magnitudes based on the length of the vectors. The colormap is defined to show variations in vector magnitudes, and the plot is displayed with inverted y-axis, labels, and a color bar.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\n# DATA FIELD (1,N,M)\ndz = np.array([[[0.24884899, 0.24884899, 0.24884899, 0.24884899, 0.24884899,\n         0.24884899],\n        [0.248849  , 0.248849  , 0.248849  , 0.248849  , 0.248849  ,\n         0.248849  ],\n        [0.24885767, 0.24885513, 0.24885108, 0.24885113, 0.2488552 ,\n         0.24885767],\n        [0.2451304 , 0.24563262, 0.24642831, 0.24641793, 0.24561579,\n         0.2451304 ],\n        [0.0764377 , 0.12581053, 0.09866768, 0.10043774, 0.12461962,\n         0.0764377 ],\n        [0.03382106, 0.03394624, 0.03414449, 0.03414171, 0.03394174,\n         0.03382106]]])\n\ndx = np.zeros(np.shape(dz))\ndy = np.zeros(np.shape(dz))\n\n# DATA POINTS (N,)\nX = np.array([0. , 0.2, 0.4, 0.6, 0.8, 1. ])\nY = X\nZ = np.array([-500., -360., -220.,  -80.,   60.,  200.])\n\n\n# COMPUTE LENGTH OF VECTORS\nlength = np.sqrt(dx[0]**2+ dz[0]**2)\n\n# COLORMAP DEFINITION\ncmap = plt.cm.jet\nmy_cmap = cmap(np.arange(cmap.N))\nalphas = np.linspace(0, 1, cmap.N)\nBG = np.asarray([1., 1., 1.,])\nfor i in range(cmap.N):\n    my_cmap[i,:-1] = my_cmap[i,:-1] * alphas[i] + BG * (1.-alphas[i])\nmy_cmap = ListedColormap(my_cmap)\n\n# PLOT 2D Cross-Section of vector field\nfig = plt.figure(dpi=300)\nQ = plt.quiver(X, Z, dx[0], dz[0], length, units='xy' ,angles='xy', scale=0.005,\n       pivot = \"tail\", headaxislength = 5, headlength = 5, cmap=my_cmap)\nfig.colorbar(Q)\nplt.gca().invert_yaxis()\nplt.ylabel(\"Z\")\nplt.xlabel(\"X\")\nplt.title(\"2D Cross-Section\")\n\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\n# DATA FIELD (1,N,M)\ndz = np.array([[[0.24884899, 0.24884899, 0.24884899, 0.24884899, 0.24884899,\n         0.24884899],\n        [0.248849  , 0.248849  , 0.248849  , 0.248849  , 0.248849  ,\n         0.248849  ],\n        [0.24885767, 0.24885513, 0.24885108, 0.24885113, 0.2488552 ,\n         0.24885767],\n        [0.2451304 , 0.24563262, 0.24642831, 0.24641793, 0.24561579,\n         0.2451304 ],\n        [0.0764377 , 0.12581053, 0.09866768, 0.10043774, 0.12461962,\n         0.0764377 ],\n        [0.03382106, 0.03394624, 0.03414449, 0.03414171, 0.03394174,\n         0.03382106]]])\n\ndx = np.zeros(np.shape(dz))\ndy = np.zeros(np.shape(dz))\n\n# DATA POINTS (N,)\nX = np.array([0. , 0.2, 0.4, 0.6, 0.8, 1. ])\nY = X\nZ = np.array([-500., -360., -220.,  -80.,   60.,  200.])\n\n\n# COMPUTE LENGTH OF VECTORS\nlength = np.sqrt(dx[0]**2+ dz[0]**2)\n\n# COLORMAP DEFINITION\ncmap = plt.cm.jet\nmy_cmap = cmap(np.arange(cmap.N))\nalphas = np.linspace(0, 1, cmap.N)\nBG = np.asarray([1., 1., 1.,])\nfor i in range(cmap.N):\n    my_cmap[i,:-1] = my_cmap[i,:-1] * alphas[i] + BG * (1.-alphas[i])\n<line_mask>\n\n# PLOT 2D Cross-Section of vector field\nfig = plt.figure(dpi=300)\nQ = plt.quiver(X, Z, dx[0], dz[0], length, units='xy' ,angles='xy', scale=0.005,\n       pivot = \"tail\", headaxislength = 5, headlength = 5, cmap=my_cmap)\nfig.colorbar(Q)\nplt.gca().invert_yaxis()\nplt.ylabel(\"Z\")\nplt.xlabel(\"X\")\nplt.title(\"2D Cross-Section\")\n\nplt.show()",
            "masked_line": "my_cmap = ListedColormap(my_cmap)",
            "answer": "ListedColormap",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_183",
            "model_output": "['<start>my_cmap[:, -1] = alphas<end>', '<start>my_cmap[:, -1] = alphas<end>', '<start>my_cmap.set_alpha(alphas)<end>', '<start>my_cmap.set_under(BG)<end>', '<start>my_cmap.set_alpha(alphas)<end>', '<start>my_cmap[:, -1] = alphas<end>']",
            "model_output_token_clear": "['my_cmap[:, -1] = alphas', 'my_cmap[:, -1] = alphas', 'my_cmap.set_alpha(alphas)', 'my_cmap.set_under(BG)', 'my_cmap.set_alpha(alphas)', 'my_cmap[:, -1] = alphas']"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.4.2",
            "time": "2021-08-16",
            "description": "This code creates a 3D quiver plot with arrows indicating vector directions. The length and color of the arrows are determined by the magnitudes of the vectors. The plot is displayed using matplotlib.",
            "code": "import numpy as np, matplotlib.pyplot as plt\n\n\ndef plot_3d_quiver(x, y, z, u, v, w):\n    c = np.sqrt(np.abs(v)**2 + np.abs(u)**2 + np.abs(w)**2)\n    length = np.repeat(((c - c.min())/(c.max() - c.min())).ravel(), 3)\n    c = (c.ravel() - c.min())/c.ptp()\n    c = np.concatenate((c, np.repeat(c, 2)))\n    c = plt.cm.jet(c)\n\n    c[:, -1] = 1 - length\n\n    fig = plt.figure(dpi = 300)\n    ax = fig.gca(projection = '3d')\n    ax.quiver(x, y, z, u, v, w, colors = c, length = .5, arrow_length_ratio = 0.2, cmap = plt.cm.jet)\n    ax.axis('off')\n\n\nx, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.2))\nu = x\nv = y\nw = z\n\nplot_3d_quiver(x, y, z, u, v, w)\n\nplt.show()",
            "masked_code": "import numpy as np, matplotlib.pyplot as plt\n\n\ndef plot_3d_quiver(x, y, z, u, v, w):\n    c = np.sqrt(np.abs(v)**2 + np.abs(u)**2 + np.abs(w)**2)\n    length = np.repeat(((c - c.min())/(c.max() - c.min())).ravel(), 3)\n    c = (c.ravel() - c.min())/c.ptp()\n    c = np.concatenate((c, np.repeat(c, 2)))\n    c = plt.cm.jet(c)\n\n    c[:, -1] = 1 - length\n\n    fig = plt.figure(dpi = 300)\n    ax = fig.gca(projection = '3d')\n    ax.quiver(x, y, z, u, v, w, colors = c, length = .5, arrow_length_ratio = 0.2, cmap = plt.cm.jet)\n    <line_mask>\n\n\nx, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.2))\nu = x\nv = y\nw = z\n\nplot_3d_quiver(x, y, z, u, v, w)\n\nplt.show()",
            "masked_line": "ax.axis('off')",
            "answer": "axis",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_184",
            "model_output": "[\"<start>ax.set_xlabel('X'), ax.set_ylabel('Y'), ax.set_zlabel('Z')<end>\", \"<start>ax.set_xlabel('X'); ax.set_ylabel('Y'); ax.set_zlabel('Z')<end>\", '<start>ax.set_xlabel(\"X\"), ax.set_ylabel(\"Y\"), ax.set_zlabel(\"Z\")<end>', '<start>ax.view_init(elev=30., azim=60)<end>', '<start>ax.set_axis_off()<end>', '<start>ax.view_init(elev=30., azim=60);<end>']",
            "model_output_token_clear": "[\"ax.set_xlabel('X'), ax.set_ylabel('Y'), ax.set_zlabel('Z')\", \"ax.set_xlabel('X'); ax.set_ylabel('Y'); ax.set_zlabel('Z')\", 'ax.set_xlabel(\"X\"), ax.set_ylabel(\"Y\"), ax.set_zlabel(\"Z\")', 'ax.view_init(elev=30., azim=60)', 'ax.set_axis_off()', 'ax.view_init(elev=30., azim=60);']"
        },
        {
            "dependency": "keras",
            "version": "==1.0.1",
            "time": "2021-03-07",
            "description": "The code initializes a neural network model with a convolutional layer, setting the number of filters to 24, filter size to 5x5, padding to 'same', weight initialization to 'he_normal', input shape to (target_Width, target_Height, 3), and dimension ordering to 'tf'.",
            "code": "from keras.models import Sequential\nmodel = Sequential()\nmodel.add(keras.layers.convolutional.Convolution2D(24, 5, 5, padding='same',init='he_normal', input_shape = (target_Width,target_Height, 3),dim_ordering=\"tf\"))",
            "masked_code": "from keras.models import Sequential\nmodel = Sequential()\n<line_mask>",
            "masked_line": "model.add(keras.layers.convolutional.Convolution2D(24, 5, 5, padding='same',init='he_normal', input_shape = (target_Width,target_Height, 3),dim_ordering=\"tf\"))",
            "answer": "add",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_185",
            "model_output": "[\"<start>model.add(Conv2D(filters=24, kernel_size=(5,5), kernel_initializer='he_normal', padding='same', input_shape=(target_Width,target_Height,3)))<end>\", \"<start>model.add(Conv2D(filters=24, kernel_size=(5,5), kernel_initializer='he_normal', padding='same', input_shape=(target_Width,target_Height,3)))<end>\", \"<start>model.add(Conv2D(24,(5,5), activation='relu', input_shape=(target_Width,target_Height ,3)))<end>\", \"<start>model.add(Conv2D(filters=24, kernel_size=(5,5), kernel_initializer='he_normal', padding='same', input_shape=(target_Width,target_Height,3)))<end>\", \"<start>model.add(Conv2D(24,(5,5),padding='same',input_shape=(target_Width,target_Height,3),kernel_initializer='he_normal',data_format='channels_last'))<end>\", \"<start>model.add(Conv2D(24,(5,5), kernel_initializer='he_normal', padding='same', input_shape=(target_Width,target_Height,3)))<end>\"]",
            "model_output_token_clear": "[\"model.add(Conv2D(filters=24, kernel_size=(5,5), kernel_initializer='he_normal', padding='same', input_shape=(target_Width,target_Height,3)))\", \"model.add(Conv2D(filters=24, kernel_size=(5,5), kernel_initializer='he_normal', padding='same', input_shape=(target_Width,target_Height,3)))\", \"model.add(Conv2D(24,(5,5), activation='relu', input_shape=(target_Width,target_Height ,3)))\", \"model.add(Conv2D(filters=24, kernel_size=(5,5), kernel_initializer='he_normal', padding='same', input_shape=(target_Width,target_Height,3)))\", \"model.add(Conv2D(24,(5,5),padding='same',input_shape=(target_Width,target_Height,3),kernel_initializer='he_normal',data_format='channels_last'))\", \"model.add(Conv2D(24,(5,5), kernel_initializer='he_normal', padding='same', input_shape=(target_Width,target_Height,3)))\"]"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-11-14",
            "description": "This code creates a pandas DataFrame with columns 'A' and 'B', prints the initial DataFrame along with the data types of the columns, updates the values in columns 'A' and 'B' with new values, and prints the updated DataFrame along with the updated data types of the columns.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({'A': [1.2, 2.3], 'B': [3.4, 4.5]})\nprint(df)\nprint(df.dtypes)\ndf.loc[:, 'A':'B'] = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df)\nprint(df.dtypes)",
            "masked_code": "import pandas as pd\n\n<line_mask>\nprint(df)\nprint(df.dtypes)\ndf.loc[:, 'A':'B'] = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df)\nprint(df.dtypes)",
            "masked_line": "df = pd.DataFrame({'A': [1.2, 2.3], 'B': [3.4, 4.5]})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_186",
            "model_output": "[\"<start>df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})<end>\", \"<start>df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})<end>\", \"<start>df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})<end>\", \"<start>df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})<end>\", \"<start>df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})<end>\", \"<start>df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})<end>\"]",
            "model_output_token_clear": "[\"df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})\", \"df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})\", \"df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})\", \"df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})\", \"df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})\", \"df = pd.DataFrame({'A': [1, 2, 3], 'B': [400, np.nan, 600]})\"]"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-11-14",
            "description": "The code creates a DataFrame with columns 'A' and 'B' containing floats, prints the DataFrame and its data types, then updates the values in columns 'A' and 'B' with integer values, prints the updated DataFrame and its data types.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({'A': [1.2, 2.3], 'B': [3.4, 4.5]})\nprint(df)\nprint(df.dtypes)\ndf[['A', 'B']] = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df)\nprint(df.dtypes)",
            "masked_code": "import pandas as pd\n\n<line_mask>\nprint(df)\nprint(df.dtypes)\ndf[['A', 'B']] = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df)\nprint(df.dtypes)",
            "masked_line": "df = pd.DataFrame({'A': [1.2, 2.3], 'B': [3.4, 4.5]})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_187",
            "model_output": "[\"<start>df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})<end>\", \"<start>df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})<end>\", \"<start>df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})<end>\", \"<start>df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})<end>\", \"<start>df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})<end>\", \"<start>df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})<end>\"]",
            "model_output_token_clear": "[\"df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})\", \"df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})\", \"df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})\", \"df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})\", \"df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})\", \"df = pd.DataFrame({'A': [1.0, 2.0], 'B': [3.0, 4.0]})\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.1",
            "time": "2021-03-26",
            "description": "This code creates a 3D plot with specific aspect ratios set for each axis.",
            "code": "fig = plt.figure(figsize=(7, 7))\nax = fig.add_subplot(111, projection='3d')\nax.set_box_aspect((1, 3, 1))",
            "masked_code": "fig = plt.figure(figsize=(7, 7))\n<line_mask>\nax.set_box_aspect((1, 3, 1))",
            "masked_line": "ax = fig.add_subplot(111, projection='3d')",
            "answer": "add_subplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_188",
            "model_output": "[\"<start>ax = fig.add_subplot(projection='3d')<end>\", \"<start>ax = fig.add_subplot(projection='3d')<end>\", \"<start>ax = fig.add_subplot(projection='3d')<end>\", \"<start>ax = fig.add_subplot(projection='3d')<end>\", \"<start>ax = fig.add_subplot(projection='3d')<end>\", \"<start>ax = fig.add_subplot(projection='3d')<end>\"]",
            "model_output_token_clear": "[\"ax = fig.add_subplot(projection='3d')\", \"ax = fig.add_subplot(projection='3d')\", \"ax = fig.add_subplot(projection='3d')\", \"ax = fig.add_subplot(projection='3d')\", \"ax = fig.add_subplot(projection='3d')\", \"ax = fig.add_subplot(projection='3d')\"]"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.1",
            "time": "2021-03-26",
            "description": "This code generates a 3D bar plot with multiple segments, each segment represented by a different color. The plot consists of three segments, each with different heights and colors. The plot also includes labels for the x, y, and z axes, as well as a legend indicating the colors of each segment.",
            "code": "import pandas as pd\nimport matplotlib.pyplot as plt  \nfrom mpl_toolkits.mplot3d import axes3d\nimport numpy as np\nimport matplotlib as mpl\n\ndz=[]\nz0 = np.array([ 1.,  3.,  11.,   8.,   7.,   6.,   6.,   6.,   5.,   4.,\n                3.,   11.,   10.,  1.,  1.,  7., 1.,  3.,  11.,   8.,\n                8.,   7.,   6.,   6., 1.,  1.,  7., 1.,])\ndz.append(z0)\n\nz1 =[ 5.,   5.,   8.,   4.,   2.,   0.,   0.,   0.,   0.,   0.,   0.,\n      1.,   6.,  5.,   7.,   2., 1.,  3.,  11.,   8., 8.,   7.,   6.,   6.,\n      1.,  1.,  7., 1.,]\n\ndz.append(z1)\n\nz2 =[ 15.,   5.,   8.,   2.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n      3.,   5.,  2.,   7.,   2., 1.,  3.,  11.,   8., 8.,   7.,   6.,   6.,\n      1.,  1.,  7., 1.,]\n\ndz.append(z2)\n\n_zpos = z0*0\n\n\nxlabels = pd.Index(['X01', 'X02', 'X03', 'X04'], dtype='object')\n\nylabels = pd.Index(['Y01', 'Y02', 'Y03', 'Y04', 'Y05', 'Y06', 'Y07'], dtype='object')\n\nx = np.arange(xlabels.shape[0])\n\ny = np.arange(ylabels.shape[0])\n\nx_M, y_M = np.meshgrid(x, y, copy=False)\n\nfig = plt.figure(figsize=(7, 7))\nax = fig.add_subplot(111, projection='3d')\nax.set_box_aspect((1, 3.5, 1))\nax.view_init(15, 35)\n\nls = mpl.colors.LightSource(azdeg=30, altdeg=10)\n\n# Making the intervals in the axes match with their respective entries\nax.xaxis.set_ticks(x + 0.5/2.)\nax.yaxis.set_ticks(y + 0.5/2.)\n\n# Renaming the ticks as they were before\nax.xaxis.set_ticklabels(xlabels)\nax.yaxis.set_ticklabels(ylabels)\n\n# Labeling the 3 dimensions\nax.set_xlabel('X label')\nax.set_ylabel('Y label')\nax.set_zlabel('Z label')\n\n# Choosing the range of values to be extended in the set colormap\nvalues = np.linspace(0.2, 1., x_M.ravel().shape[0])\n\n# Selecting an appropriate colormap\n\ncolors = ['#FFC04C', 'blue', '#3e9a19', \n          '#599be5','#bf666f','#a235bf','#848381','#fb90d6','#fb9125']\n\n# Increase the number of segment to 3 by changing the X in 'range(X)' to 3.\nfor i in range(3):\n    ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos, dx=0.2, dy=0.1, dz=dz[i], \n              color=colors[i], lightsource=ls)\n    _zpos += dz[i]\n \n\nSegment1_proxy         = plt.Rectangle((0, 0), 1, 1, fc=\"#FFC04C\")   \nSegment2_proxy         = plt.Rectangle((0, 0), 1, 1, fc=\"blue\")\nSegment3_proxy         = plt.Rectangle((0, 0), 1, 1, fc=\"#3e9a19\")\n\nax.legend([Segment1_proxy,\n           Segment2_proxy,\n           Segment3_proxy],['Segment1',\n                            'Segment2',\n                            'Segment3'\n         ])\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport matplotlib.pyplot as plt  \nfrom mpl_toolkits.mplot3d import axes3d\nimport numpy as np\nimport matplotlib as mpl\n\ndz=[]\nz0 = np.array([ 1.,  3.,  11.,   8.,   7.,   6.,   6.,   6.,   5.,   4.,\n                3.,   11.,   10.,  1.,  1.,  7., 1.,  3.,  11.,   8.,\n                8.,   7.,   6.,   6., 1.,  1.,  7., 1.,])\ndz.append(z0)\n\nz1 =[ 5.,   5.,   8.,   4.,   2.,   0.,   0.,   0.,   0.,   0.,   0.,\n      1.,   6.,  5.,   7.,   2., 1.,  3.,  11.,   8., 8.,   7.,   6.,   6.,\n      1.,  1.,  7., 1.,]\n\ndz.append(z1)\n\nz2 =[ 15.,   5.,   8.,   2.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n      3.,   5.,  2.,   7.,   2., 1.,  3.,  11.,   8., 8.,   7.,   6.,   6.,\n      1.,  1.,  7., 1.,]\n\ndz.append(z2)\n\n_zpos = z0*0\n\n\nxlabels = pd.Index(['X01', 'X02', 'X03', 'X04'], dtype='object')\n\nylabels = pd.Index(['Y01', 'Y02', 'Y03', 'Y04', 'Y05', 'Y06', 'Y07'], dtype='object')\n\nx = np.arange(xlabels.shape[0])\n\ny = np.arange(ylabels.shape[0])\n\nx_M, y_M = np.meshgrid(x, y, copy=False)\n\nfig = plt.figure(figsize=(7, 7))\nax = fig.add_subplot(111, projection='3d')\nax.set_box_aspect((1, 3.5, 1))\nax.view_init(15, 35)\n\nls = mpl.colors.LightSource(azdeg=30, altdeg=10)\n\n# Making the intervals in the axes match with their respective entries\nax.xaxis.set_ticks(x + 0.5/2.)\nax.yaxis.set_ticks(y + 0.5/2.)\n\n# Renaming the ticks as they were before\nax.xaxis.set_ticklabels(xlabels)\nax.yaxis.set_ticklabels(ylabels)\n\n# Labeling the 3 dimensions\nax.set_xlabel('X label')\nax.set_ylabel('Y label')\nax.set_zlabel('Z label')\n\n# Choosing the range of values to be extended in the set colormap\nvalues = np.linspace(0.2, 1., x_M.ravel().shape[0])\n\n# Selecting an appropriate colormap\n\ncolors = ['#FFC04C', 'blue', '#3e9a19', \n          '#599be5','#bf666f','#a235bf','#848381','#fb90d6','#fb9125']\n\n# Increase the number of segment to 3 by changing the X in 'range(X)' to 3.\nfor i in range(3):\n    <line_mask>\n              color=colors[i], lightsource=ls)\n    _zpos += dz[i]\n \n\nSegment1_proxy         = plt.Rectangle((0, 0), 1, 1, fc=\"#FFC04C\")   \nSegment2_proxy         = plt.Rectangle((0, 0), 1, 1, fc=\"blue\")\nSegment3_proxy         = plt.Rectangle((0, 0), 1, 1, fc=\"#3e9a19\")\n\nax.legend([Segment1_proxy,\n           Segment2_proxy,\n           Segment3_proxy],['Segment1',\n                            'Segment2',\n                            'Segment3'\n         ])\n\nplt.show()",
            "masked_line": "ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos, dx=0.2, dy=0.1, dz=dz[i],",
            "answer": "bar3d",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_189",
            "model_output": "['<start>ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1, dy=1,dz=dz[i], color=colors[i], lightsource=ls)<end>', '<start>ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1, dy=1,dz=dz[i],<end>', '<start>ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1/len(zlabels), dy=1/len(xlabels), dz=dz[i], color=colors[i], lightsource=ls)<end>', '<start>ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1, dy=1,dz=dz[i], color=colors[i], lightsource=ls)<end>', '<start>ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1 , dy=1 , dz=dz[i], color=colors[i], lightsource=ls)<end>', '<start>ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1 , dy=1 , dz=dz[i], color=colors[i], lightsource=ls)<end>']",
            "model_output_token_clear": "['ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1, dy=1,dz=dz[i], color=colors[i], lightsource=ls)', 'ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1, dy=1,dz=dz[i],', 'ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1/len(zlabels), dy=1/len(xlabels), dz=dz[i], color=colors[i], lightsource=ls)', 'ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1, dy=1,dz=dz[i], color=colors[i], lightsource=ls)', 'ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1 , dy=1 , dz=dz[i], color=colors[i], lightsource=ls)', 'ax.bar3d(x_M.ravel(), y_M.ravel(), _zpos.ravel(), dx=1 , dy=1 , dz=dz[i], color=colors[i], lightsource=ls)']"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2021-01-25",
            "description": "This code sets the logging verbosity of TensorFlow to hide error messages.",
            "code": "import tensorflow as tf\ntf.logging.set_verbosity(tf.logging.ERROR)",
            "masked_code": "import tensorflow as tf\n<line_mask>",
            "masked_line": "tf.logging.set_verbosity(tf.logging.ERROR)",
            "answer": "set_verbosity",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_190",
            "model_output": "[\"<start>os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'<end>\", \"<start>os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'<end>\", \"<start>os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'<end>\", \"<start>os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'<end>\", \"<start>os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'<end>\", \"<start>os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'<end>\"]",
            "model_output_token_clear": "[\"os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\", \"os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\", \"os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\", \"os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\", \"os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\", \"os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\"]"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.4",
            "time": "2023-03-17",
            "description": "This code creates a DataFrame using pandas with columns A, B, C, and D. It then adds new columns E, F, and G to the DataFrame with specific values assigned to each row based on the dictionary d.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({'A': [3, 9, 3, 4], 'B': [7, 1, 6, 0], 'C': [9, 0, 3, 4], 'D': [1, 8, 0, 0]})\n\nd = {0:10,1:20,2:30,3:40}\n\ndf.loc[:,'E'] = pd.Series({0:10,1:20,2:30,3:40})\ndf.loc[:,'F'] = {0:10,1:20,2:30,3:40}\ndf.loc[:,'G'] = {0:10,1:20,2:30,3:40}\ndf.loc[:,'G'] = {0:10,1:20,2:30,3:40}\ndf",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame({'A': [3, 9, 3, 4], 'B': [7, 1, 6, 0], 'C': [9, 0, 3, 4], 'D': [1, 8, 0, 0]})\n\nd = {0:10,1:20,2:30,3:40}\n\n<line_mask>\ndf.loc[:,'F'] = {0:10,1:20,2:30,3:40}\ndf.loc[:,'G'] = {0:10,1:20,2:30,3:40}\ndf.loc[:,'G'] = {0:10,1:20,2:30,3:40}\ndf",
            "masked_line": "df.loc[:,'E'] = pd.Series({0:10,1:20,2:30,3:40})",
            "answer": "Series",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_191",
            "model_output": "[\"<start>df.loc[:, 'E'] = d;<end>\", \"<start>df.loc[:, 'E'] = d.values()<end>\", \"<start>df.loc[:, 'E':'G'] = pd.DataFrame([d]*len(df))<end>\", \"<start>df.loc[:, 'E'] = d;<end>\", \"<start>df.loc[:, 'E'] = d.keys(); df.loc[:, 'F'] = d.values(); df.loc[:, 'G'] = d.values()<end>\", \"<start>df.loc[:, 'E'] = d.values()<end>\"]",
            "model_output_token_clear": "[\"df.loc[:, 'E'] = d;\", \"df.loc[:, 'E'] = d.values()\", \"df.loc[:, 'E':'G'] = pd.DataFrame([d]*len(df))\", \"df.loc[:, 'E'] = d;\", \"df.loc[:, 'E'] = d.keys(); df.loc[:, 'F'] = d.values(); df.loc[:, 'G'] = d.values()\", \"df.loc[:, 'E'] = d.values()\"]"
        },
        {
            "dependency": "tqdm",
            "version": "==4.62.2",
            "time": "2022-02-27",
            "description": "The code generates a large dataset with 100,000,000 rows and 4 columns of random numbers and then squares the contents of each element in a column-wise fashion using pandas and numpy.",
            "code": "from tqdm import tqdm # version 4.62.2\nimport pandas as pd # version 1.4.1\nimport numpy as np\n\ntqdm.pandas(desc='My bar!') # lots of cool paramiters you can pass here. \n# the below line generates a very large dataset for us to work with. \ndf = pd.DataFrame(np.random.randn(100000000, 4), columns=['a','b','c','d'])\n# the below line will square the contents of each element in an column-wise \n# fashion \ndf.progress_apply(lambda x: x**2)",
            "masked_code": "from tqdm import tqdm # version 4.62.2\nimport pandas as pd # version 1.4.1\nimport numpy as np\n\n<line_mask>\n# the below line generates a very large dataset for us to work with. \ndf = pd.DataFrame(np.random.randn(100000000, 4), columns=['a','b','c','d'])\n# the below line will square the contents of each element in an column-wise \n# fashion \ndf.progress_apply(lambda x: x**2)",
            "masked_line": "tqdm.pandas(desc='My bar!') # lots of cool paramiters you can pass here.",
            "answer": "pandas",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_192",
            "model_output": "['<start>for _ in tqdm(range(1)): <end>', '<start>random_state = tqdm(total=100000000, unit=\"iter\")<end>', '<start>tqdm.tqdm(unit=\"rows\", total=100000000)<end>', '<start>for i in tqdm(range(100000000), desc=\"Generating dataset\"): pass<end>', \"<start>for i in tqdm(range(100), desc='Generating dataset'): <end>\", '<start>for _ in tqdm(range(1)): <end>']",
            "model_output_token_clear": "['for _ in tqdm(range(1)): ', 'random_state = tqdm(total=100000000, unit=\"iter\")', 'tqdm.tqdm(unit=\"rows\", total=100000000)', 'for i in tqdm(range(100000000), desc=\"Generating dataset\"): pass', \"for i in tqdm(range(100), desc='Generating dataset'): \", 'for _ in tqdm(range(1)): ']"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.1",
            "time": "2022-02-27",
            "description": "The code generates a large dataset with random numbers in 4 columns and then squares the contents of each element in a column-wise fashion.",
            "code": "from tqdm import tqdm # version 4.62.2\nimport pandas as pd # version 1.4.1\nimport numpy as np\n\ntqdm.pandas(desc='My bar!') # lots of cool paramiters you can pass here. \n# the below line generates a very large dataset for us to work with. \ndf = pd.DataFrame(np.random.randn(100000000, 4), columns=['a','b','c','d'])\n# the below line will square the contents of each element in an column-wise \n# fashion \ndf.progress_apply(lambda x: x**2)",
            "masked_code": "from tqdm import tqdm # version 4.62.2\nimport pandas as pd # version 1.4.1\nimport numpy as np\n\ntqdm.pandas(desc='My bar!') # lots of cool paramiters you can pass here. \n# the below line generates a very large dataset for us to work with. \ndf = pd.DataFrame(np.random.randn(100000000, 4), columns=['a','b','c','d'])\n# the below line will square the contents of each element in an column-wise \n# fashion \n<line_mask>",
            "masked_line": "df.progress_apply(lambda x: x**2)",
            "answer": "progress_apply",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_193",
            "model_output": "[\"<start>df[['a', 'b', 'c', 'd']] = df[['a', 'b', 'c', 'd']].pow(2)<end>\", '<start>df = df.applymap(np.square)<end>', '<start>df = df.apply(np.square)<end>', '<start>df = df.pow(2)<end>', \"<start>df[['a','b','c','d']] = df[['a','b','c','d']].pow(2)<end>\", '<start>df.apply(np.square)<end>']",
            "model_output_token_clear": "[\"df[['a', 'b', 'c', 'd']] = df[['a', 'b', 'c', 'd']].pow(2)\", 'df = df.applymap(np.square)', 'df = df.apply(np.square)', 'df = df.pow(2)', \"df[['a','b','c','d']] = df[['a','b','c','d']].pow(2)\", 'df.apply(np.square)']"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.5",
            "time": "2022-04-08",
            "description": "The code generates a 200x100 DataFrame filled with random numbers using numpy, then initializes a list res with two elements [0,0].",
            "code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(\n    np.random.rand(200,100)\n)\nperiod = 10\nres = [0,0]",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n<line_mask>\n    np.random.rand(200,100)\n)\nperiod = 10\nres = [0,0]",
            "masked_line": "df = pd.DataFrame(",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_194",
            "model_output": "['<start>df = pd.DataFrame(np.random.rand(200,100))<end>', '<start>df = pd.DataFrame(np.random.rand(200,100))<end>', '<start>df = pd.DataFrame(np.random.rand(200,100))<end>', '<start>df = pd.DataFrame(np.random.rand(200,100))<end>', '<start>df = pd.DataFrame(np.random.rand(200,100))<end>', '<start>df = pd.DataFrame(np.random.rand(200,100))<end>']",
            "model_output_token_clear": "['df = pd.DataFrame(np.random.rand(200,100))', 'df = pd.DataFrame(np.random.rand(200,100))', 'df = pd.DataFrame(np.random.rand(200,100))', 'df = pd.DataFrame(np.random.rand(200,100))', 'df = pd.DataFrame(np.random.rand(200,100))', 'df = pd.DataFrame(np.random.rand(200,100))']"
        },
        {
            "dependency": "PyYAML",
            "version": "==6.0",
            "time": "2022-01-22",
            "description": "This code reads a YAML file named \"test.cwl\", loads its content into a dictionary, then modifies the dictionary by adding a new input item, and finally writes the updated dictionary back to a new YAML file named \"test-new.cwl\".",
            "code": "import yaml\n# Read file\nwith open(\"test.cwl\", 'r') as cwl_file:  \n    cwl_dict = yaml.safe_load(cwl_file)\n\n# Write file\nwith open(\"test-new.cwl\", 'w') as cwl_file:\n    cwl_dict[\"inputs\"] = [{\"id\" : 2, \"type\": \"ABC\"}]\n    yaml.dump(cwl_dict, cwl_file)",
            "masked_code": "import yaml\n# Read file\nwith open(\"test.cwl\", 'r') as cwl_file:  \n    cwl_dict = yaml.safe_load(cwl_file)\n\n# Write file\nwith open(\"test-new.cwl\", 'w') as cwl_file:\n    cwl_dict[\"inputs\"] = [{\"id\" : 2, \"type\": \"ABC\"}]\n    <line_mask>",
            "masked_line": "yaml.dump(cwl_dict, cwl_file)",
            "answer": "dump",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_195",
            "model_output": "['<start>yaml.dump(cwl_dict, cwl_file)<end>', '<start>yaml.dump(cwl_dict, cwl_file)<end>', '<start>yaml.dump(cwl_dict, cwl_file)<end>', '<start>yaml.dump(cwl_dict, cwl_file)<end>', '<start>yaml.dump(cwl_dict, cwl_file)<end>', '<start>yaml.safe_dump(cwl_dict, cwl_file)<end>']",
            "model_output_token_clear": "['yaml.dump(cwl_dict, cwl_file)', 'yaml.dump(cwl_dict, cwl_file)', 'yaml.dump(cwl_dict, cwl_file)', 'yaml.dump(cwl_dict, cwl_file)', 'yaml.dump(cwl_dict, cwl_file)', 'yaml.safe_dump(cwl_dict, cwl_file)']"
        },
        {
            "dependency": "numba",
            "version": "==0.55.2",
            "time": "2022-06-11",
            "description": "The function calculates the sorted eigenvalues of a square symmetric matrix constructed from the provided main diagonal values and random off-diagonal values.",
            "code": "import numpy as np\nfrom numpy import linalg as LA\nfrom numba import guvectorize, int64, float64          # tested with numba 0.55.2\n\n@guvectorize([(float64[:], int64, float64[:])], '(n),()->(n)')\ndef func(main, n, res):\n    nprime = n-1\n    off = np.random.normal(0., 1., (nprime, nprime))   # all arguments provided\n    tril = np.tril(off, -1)\n    W_n = tril + tril.T\n    np.fill_diagonal(W_n, main)\n\n    eigenvalues = LA.eigvals(W_n)\n    res = np.flip(np.sort(eigenvalues))                # res filled with the result\n                                                       # return removed\nmain = np.sqrt(2) * np.random.normal(size=(3-1))\nfunc(main, 3)                                          # call without last argument",
            "masked_code": "import numpy as np\nfrom numpy import linalg as LA\nfrom numba import guvectorize, int64, float64          # tested with numba 0.55.2\n\n<line_mask>\ndef func(main, n, res):\n    nprime = n-1\n    off = np.random.normal(0., 1., (nprime, nprime))   # all arguments provided\n    tril = np.tril(off, -1)\n    W_n = tril + tril.T\n    np.fill_diagonal(W_n, main)\n\n    eigenvalues = LA.eigvals(W_n)\n    res = np.flip(np.sort(eigenvalues))                # res filled with the result\n                                                       # return removed\nmain = np.sqrt(2) * np.random.normal(size=(3-1))\nfunc(main, 3)                                          # call without last argument",
            "masked_line": "@guvectorize([(float64[:], int64, float64[:])], '(n),()->(n)')",
            "answer": "guvectorize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_196",
            "model_output": "[\"<start>@guvectorize([(int64, int64, float64[:, ::1])], '(n, n) -> ()', target='cuda')<end>\", \"<start>@guvectorize([(int64, int64, float64[:, ::1])], '(n, n) -> ()', target='cuda')<end>\", \"<start>@guvectorize([(int64, int64, float64[:])], '(n,n) -> ()', target='numpy')<end>\", \"<start>@guvectorize([(int64, int64, float64[:, ::1])], '(n, n) -> ()', target='numpy')<end>\", \"<start>@guvectorize([(int64, int64, float64[:])], '(n,n) -> ()', target='parallel')<end>\", \"<start>@guvectorize(['void(int64, int64, float64[:])'], '(n, n) -> ()', target='cpu')<end>\"]",
            "model_output_token_clear": "[\"@guvectorize([(int64, int64, float64[:, ::1])], '(n, n) -> ()', target='cuda')\", \"@guvectorize([(int64, int64, float64[:, ::1])], '(n, n) -> ()', target='cuda')\", \"@guvectorize([(int64, int64, float64[:])], '(n,n) -> ()', target='numpy')\", \"@guvectorize([(int64, int64, float64[:, ::1])], '(n, n) -> ()', target='numpy')\", \"@guvectorize([(int64, int64, float64[:])], '(n,n) -> ()', target='parallel')\", \"@guvectorize(['void(int64, int64, float64[:])'], '(n, n) -> ()', target='cpu')\"]"
        },
        {
            "dependency": "cartopy",
            "version": "==0.20.2",
            "time": "2022-03-07",
            "description": "This code reads a specific data file in \".h5\" format, extracts a 2D image array from the file, and then creates a plot of the image with geostationary coastlines overlaid on it using matplotlib and cartopy libraries.",
            "code": "import h5py\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\nfn = '3DIMG_30MAR2018_0000_L1B_STD.h5' #filename (the \".h5\" file)\nwith h5py.File(fn) as f:  \n    img_arr = f['IMG_TIR1'][0,:,:] \n    \nmap_proj = ccrs.Geostationary(central_longitude=82.0)\n\nfig = plt.figure(figsize=(10,10))\nax = plt.axes(projection=map_proj)\nax.coastlines(color='white')\n\n# Image extent in Geostationary coordinates:\nimg_extent_sat = ax.get_extent(crs=map_proj)    \nimg_extent_sat = [1.04*x for x in img_extent_sat]\n\nim = plt.imshow(img_arr, extent=img_extent_sat) \nplt.colorbar(im)\nplt.title('plot raw IMG_TIR1 data + Geostationary coastlines')",
            "masked_code": "import h5py\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\nfn = '3DIMG_30MAR2018_0000_L1B_STD.h5' #filename (the \".h5\" file)\nwith h5py.File(fn) as f:  \n    img_arr = f['IMG_TIR1'][0,:,:] \n    \n<line_mask>\n\nfig = plt.figure(figsize=(10,10))\nax = plt.axes(projection=map_proj)\nax.coastlines(color='white')\n\n# Image extent in Geostationary coordinates:\nimg_extent_sat = ax.get_extent(crs=map_proj)    \nimg_extent_sat = [1.04*x for x in img_extent_sat]\n\nim = plt.imshow(img_arr, extent=img_extent_sat) \nplt.colorbar(im)\nplt.title('plot raw IMG_TIR1 data + Geostationary coastlines')",
            "masked_line": "map_proj = ccrs.Geostationary(central_longitude=82.0)",
            "answer": "Geostationary",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_197",
            "model_output": "['<start>map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)<end>', '<start>map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)<end>', '<start>map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)<end>', '<start>map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)<end>', '<start>map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)<end>', '<start>map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)<end>']",
            "model_output_token_clear": "['map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)', 'map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)', 'map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)', 'map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)', 'map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)', 'map_proj = ccrs.Geostationary(central_longitude=sat_long,satellite_height=sat_hght)']"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.2",
            "time": "2022-04-28",
            "description": "The code generates a joint plot using the seaborn library, displaying a scatter plot of 'orbital_period' against 'distance' from the 'planets' dataset, with logarithmic scaling on the marginal plots.",
            "code": "import seaborn as sns\n\n# test dataset\nplanets = sns.load_dataset('planets')\n\ng = sns.jointplot(data=planets, x=\"orbital_period\", y=\"distance\", marginal_kws=dict(log_scale=True))",
            "masked_code": "import seaborn as sns\n\n# test dataset\n<line_mask>\n\ng = sns.jointplot(data=planets, x=\"orbital_period\", y=\"distance\", marginal_kws=dict(log_scale=True))",
            "masked_line": "planets = sns.load_dataset('planets')",
            "answer": "load_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_198",
            "model_output": "['<start>planets = df<end>', \"<start>planets = pd.DataFrame({'orbital_period': [...], 'distance': [...]})<end>\", '<start>planets = df<end>', '<start>planets = df<end>', '<start>planets = df<end>', '<start>planets = pd.DataFrame({...})<end>']",
            "model_output_token_clear": "['planets = df', \"planets = pd.DataFrame({'orbital_period': [...], 'distance': [...]})\", 'planets = df', 'planets = df', 'planets = df', 'planets = pd.DataFrame({...})']"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.2",
            "time": "2022-04-28",
            "description": "The code creates a joint plot using seaborn library to visualize the relationship between the orbital period and distance of planets. The plot uses logarithmic scales for both x and y axes.",
            "code": "g = sns.jointplot(data=planets, x=\"orbital_period\", y=\"distance\")\n\ng.ax_joint.set_xscale('log')\ng.ax_joint.set_yscale('log')",
            "masked_code": "g = sns.jointplot(data=planets, x=\"orbital_period\", y=\"distance\")\n\ng.ax_joint.set_xscale('log')\n<line_mask>",
            "masked_line": "g.ax_joint.set_yscale('log')",
            "answer": "ax_joint",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_199",
            "model_output": "[\"<start>g.ax_joint.set_yscale('log')<end>\", \"<start>g.ax_joint.set_yscale('log')<end>\", \"<start>g.ax_joint.set_yscale('log')<end>\", \"<start>g.ax_joint.set_yscale('log')<end>\", \"<start>g.ax_joint.set_yscale('log')<end>\", \"<start>g.ax_joint.set_yscale('log')<end>\"]",
            "model_output_token_clear": "[\"g.ax_joint.set_yscale('log')\", \"g.ax_joint.set_yscale('log')\", \"g.ax_joint.set_yscale('log')\", \"g.ax_joint.set_yscale('log')\", \"g.ax_joint.set_yscale('log')\", \"g.ax_joint.set_yscale('log')\"]"
        },
        {
            "dependency": "Flask",
            "version": ">0.11",
            "time": "2022-12-21",
            "description": "This code creates a Flask web application with a socket.io server that serves a webpage with the content of 'index.html' when a user visits the root URL. The server runs on '127.0.0.1:8000' in debug mode.",
            "code": "from flask import Flask, render_template\nfrom flask_socketio import SocketIO\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'blahBlah'\napp.config['SERVER_NAME'] = '127.0.0.1:8000'\nsocket = SocketIO(app)\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\nif __name__ == '__main__':\n    socket.run(app, debug=True)",
            "masked_code": "from flask import Flask, render_template\nfrom flask_socketio import SocketIO\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'blahBlah'\napp.config['SERVER_NAME'] = '127.0.0.1:8000'\nsocket = SocketIO(app)\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\nif __name__ == '__main__':\n    <line_mask>",
            "masked_line": "socket.run(app, debug=True)",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_200",
            "model_output": "['<start>socket.run(app, debug=True)<end>', '<start>socket.run(app, debug=True)<end>', '<start>socket.run(app, debug=True)<end>', '<start>socket.run(app, debug=True)<end>', '<start>socket.run(app, debug=True)<end>', '<start>socket.run(app, debug=True)<end>']",
            "model_output_token_clear": "['socket.run(app, debug=True)', 'socket.run(app, debug=True)', 'socket.run(app, debug=True)', 'socket.run(app, debug=True)', 'socket.run(app, debug=True)', 'socket.run(app, debug=True)']"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2022-05-21",
            "description": "This code sets the random seed to 42, ensuring that the random number generation within the code is reproducible.",
            "code": "np.random.seed(42)",
            "masked_code": "<line_mask>",
            "masked_line": "np.random.seed(42)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_201"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2022-05-21",
            "description": "This code simulates a Poisson distribution with a mean (mu) of 13. It generates a random sample of size 5000 from a Poisson distribution with mean 13, and then creates a histogram of the data to visualize the distribution. Additionally, it plots the probability mass function at the mean value of 13, showing the variance and median of the distribution.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\n\nnp.random.seed(42)\nx = np.arange(0,24, 1)\ny = stats.poisson.pmf(x, mu=13)\na =stats.poisson.rvs(mu=13, size=5000)\n\n#plt.stem(a,x)\nplt.hist(a,bins=x,density=True,edgecolor=\"red\")\nplt.title(\"Poisson Verteilung mit Erwartungswert 13\")\nplt.xlabel(\"Anzahl M.\")\nplt.ylabel(\"Wahrscheinlichkeit\")\n\"\"\"\ni=10\no=30\nwhile i != o:\n  if y[i]*100<0.5:\n    #print(i)\n    break\n  i+=1\n\"\"\"\n\n#plot to specific x value\nplt.xlim(0, 23)\n\nplt.plot()\nplt.plot(13, y[13], marker='x', markersize=5, color=\"black\",label=\"Varianz\")\nplt.plot(13, y[13], marker='x', markersize=5, color=\"black\",label=\"Median\")\nplt.legend(loc=\"upper left\")\n\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\n\nnp.random.seed(42)\n<line_mask>\ny = stats.poisson.pmf(x, mu=13)\na =stats.poisson.rvs(mu=13, size=5000)\n\n#plt.stem(a,x)\nplt.hist(a,bins=x,density=True,edgecolor=\"red\")\nplt.title(\"Poisson Verteilung mit Erwartungswert 13\")\nplt.xlabel(\"Anzahl M.\")\nplt.ylabel(\"Wahrscheinlichkeit\")\n\"\"\"\ni=10\no=30\nwhile i != o:\n  if y[i]*100<0.5:\n    #print(i)\n    break\n  i+=1\n\"\"\"\n\n#plot to specific x value\nplt.xlim(0, 23)\n\nplt.plot()\nplt.plot(13, y[13], marker='x', markersize=5, color=\"black\",label=\"Varianz\")\nplt.plot(13, y[13], marker='x', markersize=5, color=\"black\",label=\"Median\")\nplt.legend(loc=\"upper left\")\n\nplt.show()",
            "masked_line": "x = np.arange(0,24, 1)",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_202"
        },
        {
            "dependency": "bokeh",
            "version": "==2.4.2",
            "time": "2022-04-08",
            "description": "This code generates a Bokeh plot with a red background, containing multiple white square patches arranged in a grid pattern. The patches have the same size and are distributed in a 5x5 grid on the plot. The y and x grid lines are not visible in the final plot.",
            "code": "import numpy as np\n\nfrom bokeh.models import ColumnDataSource, Patches\nfrom bokeh.plotting import figure\nfrom bokeh.io import show\n\nxpts = np.array([0, 0, 1, 1])\nypts = np.array([0, 1, 1, 0])\n\nsource = ColumnDataSource(dict(\n        xs=np.array([(xpts+j) for i in range(5) for j in range(5)]),\n        ys=np.array([ypts+i for i in range(5) for j in range(5)]),\n    )\n)\n\nfig = figure(\n    title=None, width=300, height=300,\n    min_border=0,background_fill_color=\"red\")\n\nglyph = Patches(xs=\"xs\", ys=\"ys\", fill_color=\"white\",line_width=0)\nfig.add_glyph(source, glyph)\nfig.ygrid.visible = False\nfig.xgrid.visible = False\nshow(fig)",
            "masked_code": "import numpy as np\n\nfrom bokeh.models import ColumnDataSource, Patches\nfrom bokeh.plotting import figure\nfrom bokeh.io import show\n\nxpts = np.array([0, 0, 1, 1])\nypts = np.array([0, 1, 1, 0])\n\nsource = ColumnDataSource(dict(\n        xs=np.array([(xpts+j) for i in range(5) for j in range(5)]),\n        ys=np.array([ypts+i for i in range(5) for j in range(5)]),\n    )\n)\n\nfig = figure(\n    title=None, width=300, height=300,\n    min_border=0,background_fill_color=\"red\")\n\nglyph = Patches(xs=\"xs\", ys=\"ys\", fill_color=\"white\",line_width=0)\n<line_mask>\nfig.ygrid.visible = False\nfig.xgrid.visible = False\nshow(fig)",
            "masked_line": "fig.add_glyph(source, glyph)",
            "answer": "add_glyph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_203"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4.0",
            "time": "2022-05-23",
            "description": "The code creates a TensorFlow Dataset containing two classes, class_a and class_b, each with tensors of integer values. The code then modifies the dataset by setting a custom attribute called class_names for the dataset and prints the element specifications. Finally, the code maps a lambda function to the dataset, batches the dataset into groups of 5, and updates the class_names attribute again before printing the element specifications.",
            "code": "import tensorflow as tf\n\ndataset = {\n    \"class_a\": [tf.constant(v) for v in range(10)],\n    \"class_b\": [tf.constant(v) for v in range(10,20)]\n}\na = tf.data.Dataset.from_tensor_slices(dataset)\nprint(a.element_spec)\n# {'class_a': TensorSpec(shape=(), dtype=tf.int32, name=None), 'class_b': TensorSpec(shape=(), dtype=tf.int32, name=None)}\n\na.class_names = \"alielie\"\nprint(a.class_names,a.element_spec)\n# alielie {'class_a': TensorSpec(shape=(), dtype=tf.int32, name=None), 'class_b': TensorSpec(shape=(), dtype=tf.int32, name=None)}\n\na = a.map(lambda x:x)\na.class_names = \"alielie1\"\nprint(a.class_names,a.element_spec)\n# alielie1 {'class_a': TensorSpec(shape=(), dtype=tf.int32, name=None), 'class_b': TensorSpec(shape=(), dtype=tf.int32, name=None)}\n\na = a.batch(5)\na.class_names = \"alielie2\"\nprint(a.class_names,a.element_spec)\n# alielie2 {'class_a': TensorSpec(shape=(), dtype=tf.int32, name=None), 'class_b': TensorSpec(shape=(), dtype=tf.int32, name=None)}",
            "masked_code": "import tensorflow as tf\n\ndataset = {\n    \"class_a\": [tf.constant(v) for v in range(10)],\n    \"class_b\": [tf.constant(v) for v in range(10,20)]\n}\n<line_mask>\nprint(a.element_spec)\n# {'class_a': TensorSpec(shape=(), dtype=tf.int32, name=None), 'class_b': TensorSpec(shape=(), dtype=tf.int32, name=None)}\n\na.class_names = \"alielie\"\nprint(a.class_names,a.element_spec)\n# alielie {'class_a': TensorSpec(shape=(), dtype=tf.int32, name=None), 'class_b': TensorSpec(shape=(), dtype=tf.int32, name=None)}\n\na = a.map(lambda x:x)\na.class_names = \"alielie1\"\nprint(a.class_names,a.element_spec)\n# alielie1 {'class_a': TensorSpec(shape=(), dtype=tf.int32, name=None), 'class_b': TensorSpec(shape=(), dtype=tf.int32, name=None)}\n\na = a.batch(5)\na.class_names = \"alielie2\"\nprint(a.class_names,a.element_spec)\n# alielie2 {'class_a': TensorSpec(shape=(), dtype=tf.int32, name=None), 'class_b': TensorSpec(shape=(), dtype=tf.int32, name=None)}",
            "masked_line": "a = tf.data.Dataset.from_tensor_slices(dataset)",
            "answer": "from_tensor_slices",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_204"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4",
            "time": "2022-03-05",
            "description": "The code creates a figure with two subfigures side by side, each containing two axes. It then plots the minimum and maximum temperatures of Saturdays and Sundays from the years 2012 and 2015 on the respective axes. Each subfigure is given a suptitle indicating the year being displayed.",
            "code": "# create 1x2 subfigures\nfig = plt.figure(constrained_layout=True, figsize=(12, 5))\n(subfig_l, subfig_r) = fig.subfigures(nrows=1, ncols=2, wspace=0.07)\n\n# create top/box axes in left subfig\n(ax_lt, ax_lb) = subfig_l.subplots(nrows=2, ncols=1)\n\n# plot 2012 saturdays on left-top axes\ndfSat12 = dfSat.loc[dfSat['date'].dt.year.eq(2012)]\ndfSat12.plot(ax=ax_lt, x='date', y='temp_min')\ndfSat12.plot(ax=ax_lt, x='date', y='temp_max')\nax_lt.set_ylim(-20, 50)\nax_lt.set_ylabel('Saturdays')\n\n# plot 2012 sundays on left-top axes\ndfSun12 = dfSun.loc[dfSun['date'].dt.year.eq(2012)]\ndfSun12.plot(ax=ax_lb, x='date', y='temp_min')\ndfSun12.plot(ax=ax_lb, x='date', y='temp_max')\nax_lb.set_ylim(-20, 50)\nax_lb.set_ylabel('Sundays')\n\n# set suptitle for left subfig\nsubfig_l.suptitle('2012', size='x-large', weight='bold')\n\n# create top/box axes in right subfig\n(ax_rt, ax_rb) = subfig_r.subplots(nrows=2, ncols=1)\n\n# plot 2015 saturdays on left-top axes\ndfSat15 = dfSat.loc[dfSat['date'].dt.year.eq(2015)]\ndfSat15.plot(ax=ax_rt, x='date', y='temp_min')\ndfSat15.plot(ax=ax_rt, x='date', y='temp_max')\nax_rt.set_ylim(-20, 50)\nax_rt.set_ylabel('Saturdays')\n\n# plot 2015 sundays on left-top axes\ndfSun15 = dfSun.loc[dfSun['date'].dt.year.eq(2015)]\ndfSun15.plot(ax=ax_rb, x='date', y='temp_min')\ndfSun15.plot(ax=ax_rb, x='date', y='temp_max')\nax_rb.set_ylim(-20, 50)\nax_rb.set_ylabel('Sundays')\n\n# set suptitle for right subfig\nsubfig_r.suptitle('2015', size='x-large', weight='bold')",
            "masked_code": "# create 1x2 subfigures\nfig = plt.figure(constrained_layout=True, figsize=(12, 5))\n<line_mask>\n\n# create top/box axes in left subfig\n(ax_lt, ax_lb) = subfig_l.subplots(nrows=2, ncols=1)\n\n# plot 2012 saturdays on left-top axes\ndfSat12 = dfSat.loc[dfSat['date'].dt.year.eq(2012)]\ndfSat12.plot(ax=ax_lt, x='date', y='temp_min')\ndfSat12.plot(ax=ax_lt, x='date', y='temp_max')\nax_lt.set_ylim(-20, 50)\nax_lt.set_ylabel('Saturdays')\n\n# plot 2012 sundays on left-top axes\ndfSun12 = dfSun.loc[dfSun['date'].dt.year.eq(2012)]\ndfSun12.plot(ax=ax_lb, x='date', y='temp_min')\ndfSun12.plot(ax=ax_lb, x='date', y='temp_max')\nax_lb.set_ylim(-20, 50)\nax_lb.set_ylabel('Sundays')\n\n# set suptitle for left subfig\nsubfig_l.suptitle('2012', size='x-large', weight='bold')\n\n# create top/box axes in right subfig\n(ax_rt, ax_rb) = subfig_r.subplots(nrows=2, ncols=1)\n\n# plot 2015 saturdays on left-top axes\ndfSat15 = dfSat.loc[dfSat['date'].dt.year.eq(2015)]\ndfSat15.plot(ax=ax_rt, x='date', y='temp_min')\ndfSat15.plot(ax=ax_rt, x='date', y='temp_max')\nax_rt.set_ylim(-20, 50)\nax_rt.set_ylabel('Saturdays')\n\n# plot 2015 sundays on left-top axes\ndfSun15 = dfSun.loc[dfSun['date'].dt.year.eq(2015)]\ndfSun15.plot(ax=ax_rb, x='date', y='temp_min')\ndfSun15.plot(ax=ax_rb, x='date', y='temp_max')\nax_rb.set_ylim(-20, 50)\nax_rb.set_ylabel('Sundays')\n\n# set suptitle for right subfig\nsubfig_r.suptitle('2015', size='x-large', weight='bold')",
            "masked_line": "(subfig_l, subfig_r) = fig.subfigures(nrows=1, ncols=2, wspace=0.07)",
            "answer": "subfigures",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_205"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.2",
            "time": "2022-01-16",
            "description": "The code generates two dataframes with random values and creates a seaborn relational plot with multiple lines for each \"Sample ID\" using the data from the dataframes. It also adds a secondary y-axis with different data for each \"Sample ID\" on the plot.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame({'r': np.random.randint(1, 31, 200),\n                    'dvr': np.random.uniform(100, 1000, 200),\n                    'Sample ID': np.random.randint(1, 5, 200)})\ndf2 = pd.DataFrame({'r': np.random.randint(1, 31, 300),\n                    'dvlnr': np.random.uniform(1, 10, 300),\n                    'Sample ID': np.random.randint(1, 5, 300)})\n\ng = sns.relplot(data=df1, x='r', y='dvr', col='Sample ID', col_wrap=2, kind=\"line\", height=4, aspect=1.5,\n                color='dodgerblue')\n\nfor sample_id, ax in g.axes_dict.items():  # axes_dict is new in seaborn 0.11.2\n    ax1 = ax.twinx()\n    sns.lineplot(data=df2[df2['Sample ID'] == sample_id], x='r', y='dvlnr', color='crimson', ax=ax1)\n\nplt.tight_layout()\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport numpy as np\n\ndf1 = pd.DataFrame({'r': np.random.randint(1, 31, 200),\n                    'dvr': np.random.uniform(100, 1000, 200),\n                    'Sample ID': np.random.randint(1, 5, 200)})\ndf2 = pd.DataFrame({'r': np.random.randint(1, 31, 300),\n                    'dvlnr': np.random.uniform(1, 10, 300),\n                    'Sample ID': np.random.randint(1, 5, 300)})\n\ng = sns.relplot(data=df1, x='r', y='dvr', col='Sample ID', col_wrap=2, kind=\"line\", height=4, aspect=1.5,\n                color='dodgerblue')\n\n<line_mask>\n    ax1 = ax.twinx()\n    sns.lineplot(data=df2[df2['Sample ID'] == sample_id], x='r', y='dvlnr', color='crimson', ax=ax1)\n\nplt.tight_layout()\nplt.show()",
            "masked_line": "for sample_id, ax in g.axes_dict.items():  # axes_dict is new in seaborn 0.11.2",
            "answer": "axes_dict",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_206"
        },
        {
            "dependency": "networkx",
            "version": "==2.8.7",
            "time": "2022-10-19",
            "description": "The code generates a random bipartite graph with 3 nodes in one part and 2 nodes in the other part, with an edge connecting the two parts having a probability of 0.5. The graph is undirected.",
            "code": "from networkx.algorithms import bipartite\ng = bipartite.random_graph(3, 2, 0.5, seed = None, directed = False)",
            "masked_code": "from networkx.algorithms import bipartite\n<line_mask>",
            "masked_line": "g = bipartite.random_graph(3, 2, 0.5, seed = None, directed = False)",
            "answer": "random_graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_207"
        },
        {
            "dependency": "networkx",
            "version": "==2.8.7",
            "time": "2022-10-19",
            "description": "The code generates a random bipartite graph with 3 nodes in one partition and 2 nodes in the other partition, with edges between nodes randomly added based on a probability of 0.5. The graph is undirected.",
            "code": "g = nx.bipartite.random_graph(3, 2, 0.5, seed = None, directed = False)",
            "masked_code": "<line_mask>",
            "masked_line": "g = nx.bipartite.random_graph(3, 2, 0.5, seed = None, directed = False)",
            "answer": "random_graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_208"
        },
        {
            "dependency": "pyspark",
            "version": "==3.2.1",
            "time": "2022-06-13",
            "description": "This code connects to a local Spark session, reads data from a CSV file, removes the file header, and writes the data to a Kafka topic named \"foobar\" with a specified bootstrap server address.",
            "code": "from pyspark.sql import SparkSession\n\nscala_version = '2.12'  # TODO: Ensure this is correct\nspark_version = '3.2.1'\npackages = [\n    f'org.apache.spark:spark-sql-kafka-0-10_{scala_version}:{spark_version}',\n    'org.apache.kafka:kafka-clients:3.2.0'\n]\nspark = SparkSession.builder\\\n   .master(\"local\")\\\n   .appName(\"kafka-example\")\\\n   .config(\"spark.jars.packages\", \",\".join(packages))\\\n   .getOrCreate()\n\n# Read all lines into a single value dataframe  with column 'value'\n# TODO: Replace with real file. \ndf = spark.read.text('file:///tmp/data.csv')\n\n# TODO: Remove the file header, if it exists\n\n# Write\ndf.write.format(\"kafka\")\\\n  .option(\"kafka.bootstrap.servers\", \"localhost:9092\")\\\n  .option(\"topic\", \"foobar\")\\\n  .save()",
            "masked_code": "from pyspark.sql import SparkSession\n\nscala_version = '2.12'  # TODO: Ensure this is correct\nspark_version = '3.2.1'\npackages = [\n    f'org.apache.spark:spark-sql-kafka-0-10_{scala_version}:{spark_version}',\n    'org.apache.kafka:kafka-clients:3.2.0'\n]\nspark = SparkSession.builder\\\n   .master(\"local\")\\\n   .appName(\"kafka-example\")\\\n   .config(\"spark.jars.packages\", \",\".join(packages))\\\n   .getOrCreate()\n\n# Read all lines into a single value dataframe  with column 'value'\n# TODO: Replace with real file. \n<line_mask>\n\n# TODO: Remove the file header, if it exists\n\n# Write\ndf.write.format(\"kafka\")\\\n  .option(\"kafka.bootstrap.servers\", \"localhost:9092\")\\\n  .option(\"topic\", \"foobar\")\\\n  .save()",
            "masked_line": "df = spark.read.text('file:///tmp/data.csv')",
            "answer": "text",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_209"
        },
        {
            "dependency": "datasets",
            "version": "==2.12.0",
            "time": "2023-05-01",
            "description": "The code loads a dataset from a CSV file located at the specified path, using a tab delimiter.",
            "code": "from datasets import load_dataset\n\ndataset = load_dataset(\"csv\", 'path/to/your/file.tsv', delimiter='\\t')",
            "masked_code": "from datasets import load_dataset\n\n<line_mask>",
            "masked_line": "dataset = load_dataset(\"csv\", 'path/to/your/file.tsv', delimiter='\\t')",
            "answer": "load_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_210"
        },
        {
            "dependency": "numpy",
            "version": "==1.23.3",
            "time": "2023-01-10",
            "description": "Calculate a sliding window view of the data array with a specified window length.",
            "code": "swindow = np.lib.stride_tricks.sliding_window_view(data, (length,))",
            "masked_code": "<line_mask>",
            "masked_line": "swindow = np.lib.stride_tricks.sliding_window_view(data, (length,))",
            "answer": "lib",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_211"
        },
        {
            "dependency": "numpy",
            "version": "==1.23.3",
            "time": "2023-01-10",
            "description": "The code calculates the time taken by different functions to perform rolling correlation using different methods, stores the times in a matrix, and then plots the time per function call against the input size.",
            "code": "import timeit\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\ndef time_funcs(funcs, sizes, arg_gen, N=20):\n    times = np.zeros((len(sizes), len(funcs)))\n    gdict = globals().copy()\n    for i, s in enumerate(sizes):\n        args = arg_gen(s)\n        print(args)\n        for j, f in enumerate(funcs):\n            gdict.update(locals())\n            try:\n                times[i, j] = timeit.timeit(\"f(*args)\", globals=gdict, number=N) / N\n                print(f\"{i}/{len(sizes)}, {j}/{len(funcs)}, {times[i, j]}\")\n            except ValueError:\n                print(f\"ERROR in {f}, with args=\", *args)\n                \n            \n    return times\n\ndef plot_times(times, funcs):\n    fig, ax = plt.subplots()\n    for j, f in enumerate(funcs):\n        ax.plot(sizes, times[:, j], label=f.__name__)\n    \n    \n    ax.set_xlabel(\"Array size\")\n    ax.set_ylabel(\"Time per function call (s)\")\n    ax.set_xscale(\"log\")\n    ax.set_yscale(\"log\")\n    ax.legend()\n    ax.grid()\n    fig.tight_layout()\n    return fig, ax\n\n#%%\ndef arg_gen(n):\n    return [np.random.randint(-100, 100, (n,)), 5]\n    \n#%%\ndef f_OP_loopy(data, length):\n    x = np.zeros_like(data).astype('float32')\n    for i in range(length-1, data.shape[0]):\n        x[i] = np.corrcoef(data[i - length + 1:i+1], np.arange(length))[0, 1]\n    return x\n    \n\ndef f_PH_numpy(data, length):    \n    swindow = np.lib.stride_tricks.sliding_window_view(data, (length,))\n    cc = vec_corrcoef(swindow, np.arange(length))\n    x = np.zeros(data.shape)\n    x[-len(cc):] = cc\n    return x\n\ndef f_RA_recur(data, length):\n    return np.concatenate((\n        np.zeros([length,]),\n        rolling_correlation_recurse(data, 0, length)\n    ))\n\ndef f_RA_numpy(data, length):\n    n = len(data)\n    cc = np.corrcoef(np.lib.stride_tricks.sliding_window_view(data, length), np.tile(np.arange(length), (n-length+1, 1)))[:n-length+1, -1]\n    x = np.zeros(data.shape)\n    x[-len(cc):] = cc\n    return x\n#%%\n\ndef rolling_correlation_recurse(data, i, length) :\n    assert i+length < data.size\n    left = np.array([np.corrcoef(data[i:i+length], np.arange(length))[0, 1]])\n    if i+length+1 == data.size :\n        return left\n    right = rolling_correlation_recurse(data, i+1, length)\n    return np.concatenate((left, right))\n\ndef vec_corrcoef(X, y, axis=1):\n    Xm = np.mean(X, axis=axis, keepdims=True)\n    ym = np.mean(y)\n    n = np.sum((X - Xm) * (y - ym), axis=axis)\n    d = np.sqrt(np.sum((X - Xm)**2, axis=axis) * np.sum((y - ym)**2))\n    return n / d\n\n#%% \nif __name__ == \"__main__\":\n    #%% Set up sim\n    sizes = [5, 10, 50, 100, 500, 1000, 5000, 10_000] #, 50_000, 100_000]\n    funcs = [f_OP_loopy, #f_RA_recur,\n             f_PH_numpy, f_RA_numpy]\n    \n    \n    #%% Run timing\n    time_fcalls = np.zeros((len(sizes), len(funcs))) * np.nan\n    time_fcalls = time_funcs(funcs, sizes, arg_gen)\n    \n    fig, ax = plot_times(time_fcalls, funcs)\n    ax.set_xlabel(f\"Input size\")\n\n    plt.show()\n    input(\"Enter x to exit\")",
            "masked_code": "import timeit\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\ndef time_funcs(funcs, sizes, arg_gen, N=20):\n    times = np.zeros((len(sizes), len(funcs)))\n    gdict = globals().copy()\n    for i, s in enumerate(sizes):\n        args = arg_gen(s)\n        print(args)\n        for j, f in enumerate(funcs):\n            gdict.update(locals())\n            try:\n                times[i, j] = timeit.timeit(\"f(*args)\", globals=gdict, number=N) / N\n                print(f\"{i}/{len(sizes)}, {j}/{len(funcs)}, {times[i, j]}\")\n            except ValueError:\n                print(f\"ERROR in {f}, with args=\", *args)\n                \n            \n    return times\n\ndef plot_times(times, funcs):\n    fig, ax = plt.subplots()\n    for j, f in enumerate(funcs):\n        ax.plot(sizes, times[:, j], label=f.__name__)\n    \n    \n    ax.set_xlabel(\"Array size\")\n    ax.set_ylabel(\"Time per function call (s)\")\n    ax.set_xscale(\"log\")\n    ax.set_yscale(\"log\")\n    ax.legend()\n    ax.grid()\n    fig.tight_layout()\n    return fig, ax\n\n#%%\ndef arg_gen(n):\n    return [np.random.randint(-100, 100, (n,)), 5]\n    \n#%%\ndef f_OP_loopy(data, length):\n    x = np.zeros_like(data).astype('float32')\n    for i in range(length-1, data.shape[0]):\n        <line_mask>\n    return x\n    \n\ndef f_PH_numpy(data, length):    \n    swindow = np.lib.stride_tricks.sliding_window_view(data, (length,))\n    cc = vec_corrcoef(swindow, np.arange(length))\n    x = np.zeros(data.shape)\n    x[-len(cc):] = cc\n    return x\n\ndef f_RA_recur(data, length):\n    return np.concatenate((\n        np.zeros([length,]),\n        rolling_correlation_recurse(data, 0, length)\n    ))\n\ndef f_RA_numpy(data, length):\n    n = len(data)\n    cc = np.corrcoef(np.lib.stride_tricks.sliding_window_view(data, length), np.tile(np.arange(length), (n-length+1, 1)))[:n-length+1, -1]\n    x = np.zeros(data.shape)\n    x[-len(cc):] = cc\n    return x\n#%%\n\ndef rolling_correlation_recurse(data, i, length) :\n    assert i+length < data.size\n    left = np.array([np.corrcoef(data[i:i+length], np.arange(length))[0, 1]])\n    if i+length+1 == data.size :\n        return left\n    right = rolling_correlation_recurse(data, i+1, length)\n    return np.concatenate((left, right))\n\ndef vec_corrcoef(X, y, axis=1):\n    Xm = np.mean(X, axis=axis, keepdims=True)\n    ym = np.mean(y)\n    n = np.sum((X - Xm) * (y - ym), axis=axis)\n    d = np.sqrt(np.sum((X - Xm)**2, axis=axis) * np.sum((y - ym)**2))\n    return n / d\n\n#%% \nif __name__ == \"__main__\":\n    #%% Set up sim\n    sizes = [5, 10, 50, 100, 500, 1000, 5000, 10_000] #, 50_000, 100_000]\n    funcs = [f_OP_loopy, #f_RA_recur,\n             f_PH_numpy, f_RA_numpy]\n    \n    \n    #%% Run timing\n    time_fcalls = np.zeros((len(sizes), len(funcs))) * np.nan\n    time_fcalls = time_funcs(funcs, sizes, arg_gen)\n    \n    fig, ax = plot_times(time_fcalls, funcs)\n    ax.set_xlabel(f\"Input size\")\n\n    plt.show()\n    input(\"Enter x to exit\")",
            "masked_line": "x[i] = np.corrcoef(data[i - length + 1:i+1], np.arange(length))[0, 1]",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_212"
        },
        {
            "dependency": "duckdb",
            "version": "==0.6.0",
            "time": "2023-03-19",
            "description": "The code connects to a DuckDB database and imports an empty database.",
            "code": "import duckdb\nconn=duckdb.connect('')\nconn.execute(\"IMPORT DATABASE ''\")",
            "masked_code": "import duckdb\nconn=duckdb.connect('')\n<line_mask>",
            "masked_line": "conn.execute(\"IMPORT DATABASE ''\")",
            "answer": "execute",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_213"
        },
        {
            "dependency": "pandas",
            "version": ">2.0.x",
            "time": "2023-08-06",
            "description": "Converts the 'datetime' column in the dataframe 'df' to datetime format and outputs the data type of the 'datetime' column as datetime64[ns].",
            "code": "df['datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# datetime64[ns]",
            "masked_code": "<line_mask>\n\nprint(df['datetime'].dtypes)\n# datetime64[ns]",
            "masked_line": "df['datetime'] = pd.to_datetime(df['datetime'])",
            "answer": "to_datetime",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_214"
        },
        {
            "dependency": "pandas",
            "version": ">2.0.x",
            "time": "2023-08-06",
            "description": "The code converts the 'datetime' column in a DataFrame from object type to datetime type.",
            "code": "import pandas as pd\n\nprint(pd.__version__)\n# '2.0.3'\n\ndata = {\n    'id': [1, 2, 3],\n    'testcolumn': ['A', 'B', 'C'],\n    'datetime': ['2023-07-25 10:30:00', '2023-07-26 12:45:00', \n                 '2023-07-27 15:15:00'],\n    'value': ['100', '200', '300']\n    }\n\ndf = pd.DataFrame(data)\n\nprint(df['datetime'].dtypes)\n# object\n\nprint(type(df.loc[0, 'datetime']))\n# \n\ndf.loc[:, 'datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# object\n\nprint(type(df.loc[0, 'datetime']))\n#",
            "masked_code": "import pandas as pd\n\nprint(pd.__version__)\n# '2.0.3'\n\ndata = {\n    'id': [1, 2, 3],\n    'testcolumn': ['A', 'B', 'C'],\n    'datetime': ['2023-07-25 10:30:00', '2023-07-26 12:45:00', \n                 '2023-07-27 15:15:00'],\n    'value': ['100', '200', '300']\n    }\n\n<line_mask>\n\nprint(df['datetime'].dtypes)\n# object\n\nprint(type(df.loc[0, 'datetime']))\n# \n\ndf.loc[:, 'datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# object\n\nprint(type(df.loc[0, 'datetime']))\n#",
            "masked_line": "df = pd.DataFrame(data)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_215"
        },
        {
            "dependency": "pandas",
            "version": ">2.0.x",
            "time": "2023-08-06",
            "description": "The code displays the version of the pandas library being used, creates a DataFrame from the data, converts the 'datetime' column to a string data type, and then converts it to datetime data type.",
            "code": "print(pd.__version__)\n# '2.0.3'\n\ndf = pd.DataFrame(data)\n\ndf['datetime'] = df['datetime'].astype('string')\n\nprint(df['datetime'].dtypes)\n# string\n\ndf.loc[:, 'datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# datetime64[ns]",
            "masked_code": "print(pd.__version__)\n# '2.0.3'\n\n<line_mask>\n\ndf['datetime'] = df['datetime'].astype('string')\n\nprint(df['datetime'].dtypes)\n# string\n\ndf.loc[:, 'datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# datetime64[ns]",
            "masked_line": "df = pd.DataFrame(data)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_216"
        },
        {
            "dependency": "pandas",
            "version": "==2.1.0",
            "time": "2023-09-14",
            "description": "This code creates a dictionary of headers with a specified user-agent string, a dictionary of attributes for HTML parsing, and then uses pandas to read HTML content from a specified URL using the provided headers and attributes.",
            "code": "headers = {\n    \"User-Agent\": (\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\"\n        \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36\"\n    )\n}\n\nattributes = {\"class\": \"table_bd\"}\n\nlist_of_df = pd.read_html(url_trainer, storage_options=headers, attrs=attributes)",
            "masked_code": "headers = {\n    \"User-Agent\": (\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\"\n        \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36\"\n    )\n}\n\nattributes = {\"class\": \"table_bd\"}\n\n<line_mask>",
            "masked_line": "list_of_df = pd.read_html(url_trainer, storage_options=headers, attrs=attributes)",
            "answer": "read_html",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_217"
        },
        {
            "dependency": "ansible-runner",
            "version": ">=2.3.3",
            "time": "2023-06-17",
            "description": "The code executes an Ansible task to add a line \"foobar\" to a file named \"myfile\" on the localhost.",
            "code": "import ansible_runner\n\ntask = {\n    'name': 'Add line to file',\n    'action': {\n        'module': 'lineinfile',\n        'args': 'path=myfile line=foobar'\n    }\n}\n\nresult = ansible_runner.run(private_data_dir='./', host_pattern='localhost', module_args_str=task['action']['args'], module=task['action']['module'])\n\nprint(result)",
            "masked_code": "import ansible_runner\n\ntask = {\n    'name': 'Add line to file',\n    'action': {\n        'module': 'lineinfile',\n        'args': 'path=myfile line=foobar'\n    }\n}\n\n<line_mask>\n\nprint(result)",
            "masked_line": "result = ansible_runner.run(private_data_dir='./', host_pattern='localhost', module_args_str=task['action']['args'], module=task['action']['module'])",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_218"
        },
        {
            "dependency": "Flask",
            "version": "==2.3.x",
            "time": "2023-10-01",
            "description": "The code allows access to the app instance using current_app and logs a debug message using current_app.logger.",
            "code": "from flask import current_app\n\n# You can now use current_app to access the app instance\ncurrent_app.route('/')\ncurrent_app.logger.debug('Debug message')",
            "masked_code": "from flask import current_app\n\n# You can now use current_app to access the app instance\n<line_mask>\ncurrent_app.logger.debug('Debug message')",
            "masked_line": "current_app.route('/')",
            "answer": "route",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_219"
        },
        {
            "dependency": "tensorflow",
            "version": ">=2.3",
            "time": "2023-04-12",
            "description": "The code defines an exponential decay learning rate schedule for the Adam optimizer in TensorFlow. The initial learning rate is set to 0.01, and it will decay by a factor of 0.9 every 10000 steps.",
            "code": "import tensorflow as tf\nlr_schedule = tf.keras.optimizers.schedules.ExponentialDecay(\n    initial_learning_rate=0.01,\n    decay_steps=10000,\n    decay_rate=0.9)\noptimizer = tf.keras.optimizers.Adam(learning_rate=lr_schedule)",
            "masked_code": "import tensorflow as tf\n<line_mask>\n    initial_learning_rate=0.01,\n    decay_steps=10000,\n    decay_rate=0.9)\noptimizer = tf.keras.optimizers.Adam(learning_rate=lr_schedule)",
            "masked_line": "lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay(",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_220"
        },
        {
            "dependency": "dash",
            "version": "==2.9.0",
            "time": "2023-03-17",
            "description": "This code initializes a Dash web application.",
            "code": "from dash import Dash\n\napp = Dash(__name__)",
            "masked_code": "<line_mask>\n\napp = Dash(__name__)",
            "masked_line": "from dash import Dash",
            "answer": "Dash",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_221"
        },
        {
            "dependency": "scipy",
            "version": "==1.1.0",
            "time": "2019-02-20",
            "description": "The code calculates the null space of a given matrix.",
            "code": "import scipy.linalg as la\nla.null_space(...)",
            "masked_code": "import scipy.linalg as la\n<line_mask>",
            "masked_line": "la.null_space(...)",
            "answer": "null_space",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_222"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-05-09",
            "description": "This code sets the random seed values for Python, TensorFlow, NumPy, and the random module to ensure reproducibility of random processes.",
            "code": "def reset_random_seeds():\n   os.environ['PYTHONHASHSEED']=str(2)\n   tf.random.set_seed(2)\n   np.random.seed(2)\n   random.seed(2)",
            "masked_code": "def reset_random_seeds():\n   os.environ['PYTHONHASHSEED']=str(2)\n   <line_mask>\n   np.random.seed(2)\n   random.seed(2)",
            "masked_line": "tf.random.set_seed(2)",
            "answer": "set_seed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_223"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-05-09",
            "description": "The code defines a neural network model using TensorFlow to predict output based on input data, trains the model on random data, and evaluates the performance of the model by computing the mean squared error loss. The random seed for the initialization and training process is set to ensure reproducibility.",
            "code": "import os\n####*IMPORANT*: Have to do this line *before* importing tensorflow\nos.environ['PYTHONHASHSEED']=str(2)\n\nimport tensorflow as tf\nimport tensorflow.keras as keras\nimport tensorflow.keras.layers \nimport random\nimport pandas as pd\nimport numpy as np\n\ndef reset_random_seeds():\n   os.environ['PYTHONHASHSEED']=str(2)\n   tf.random.set_seed(2)\n   np.random.seed(2)\n   random.seed(2)\n\n#make some random data\nreset_random_seeds()\nNUM_ROWS = 1000\nNUM_FEATURES = 10\nrandom_data = np.random.normal(size=(NUM_ROWS, NUM_FEATURES))\ndf = pd.DataFrame(data=random_data, columns=['x_' + str(ii) for ii in range(NUM_FEATURES)])\ny = df.sum(axis=1) + np.random.normal(size=(NUM_ROWS))\n\ndef run(x, y):\n    reset_random_seeds()\n\n    model = keras.Sequential([\n            keras.layers.Dense(40, input_dim=df.shape[1], activation='relu'),\n            keras.layers.Dense(20, activation='relu'),\n            keras.layers.Dense(10, activation='relu'),\n            keras.layers.Dense(1, activation='linear')\n        ])\n    NUM_EPOCHS = 100\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.fit(x, y, epochs=NUM_EPOCHS, verbose=0)\n    predictions = model.predict(x).flatten()\n    loss = model.evaluate(x,  y) #This prints out the loss by side-effect\n\n#With Tensorflow 2.0 this is now reproducible! \nrun(df, y)\nrun(df, y)\nrun(df, y)",
            "masked_code": "import os\n####*IMPORANT*: Have to do this line *before* importing tensorflow\nos.environ['PYTHONHASHSEED']=str(2)\n\nimport tensorflow as tf\nimport tensorflow.keras as keras\nimport tensorflow.keras.layers \nimport random\nimport pandas as pd\nimport numpy as np\n\ndef reset_random_seeds():\n   os.environ['PYTHONHASHSEED']=str(2)\n   tf.random.set_seed(2)\n   np.random.seed(2)\n   random.seed(2)\n\n#make some random data\nreset_random_seeds()\nNUM_ROWS = 1000\nNUM_FEATURES = 10\nrandom_data = np.random.normal(size=(NUM_ROWS, NUM_FEATURES))\ndf = pd.DataFrame(data=random_data, columns=['x_' + str(ii) for ii in range(NUM_FEATURES)])\ny = df.sum(axis=1) + np.random.normal(size=(NUM_ROWS))\n\ndef run(x, y):\n    reset_random_seeds()\n\n    model = keras.Sequential([\n            keras.layers.Dense(40, input_dim=df.shape[1], activation='relu'),\n            keras.layers.Dense(20, activation='relu'),\n            keras.layers.Dense(10, activation='relu'),\n            <line_mask>\n        ])\n    NUM_EPOCHS = 100\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    model.fit(x, y, epochs=NUM_EPOCHS, verbose=0)\n    predictions = model.predict(x).flatten()\n    loss = model.evaluate(x,  y) #This prints out the loss by side-effect\n\n#With Tensorflow 2.0 this is now reproducible! \nrun(df, y)\nrun(df, y)\nrun(df, y)",
            "masked_line": "keras.layers.Dense(1, activation='linear')",
            "answer": "layers",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_224"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-12-25",
            "description": "This code defines an Adam optimizer with a learning rate of 0.1 and creates two TensorFlow variables, x and y, which are added to a list called var_list.",
            "code": "import tensorflow as tf\nfrom tensorflow import keras \n\nopt = tf.keras.optimizers.Adam(learning_rate=0.1)\n\nx = tf.Variable([3.0, 4.0]) \ny = tf.Variable([1.0, 1.0, 1.0, 1.0])\nvar_list = [x, y]",
            "masked_code": "import tensorflow as tf\nfrom tensorflow import keras \n\n<line_mask>\n\nx = tf.Variable([3.0, 4.0]) \ny = tf.Variable([1.0, 1.0, 1.0, 1.0])\nvar_list = [x, y]",
            "masked_line": "opt = tf.keras.optimizers.Adam(learning_rate=0.1)",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_225"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-12-25",
            "description": "Calculate the gradient of the sum of x squared and the sum of y with respect to the variables in the var_list.",
            "code": "with tf.GradientTape() as tape:\n    loss = tf.reduce_sum(x ** 2) + tf.reduce_sum(y) \n\ngrads = tape.gradient(loss, var_list)",
            "masked_code": "<line_mask>\n    loss = tf.reduce_sum(x ** 2) + tf.reduce_sum(y) \n\ngrads = tape.gradient(loss, var_list)",
            "masked_line": "with tf.GradientTape() as tape:",
            "answer": "GradientTape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_226"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-12-25",
            "description": "The function clip_grad limits the gradient values to 10 if they exceed 1000. The processed gradients are then used to apply gradients to the variables in var_list using the optimizer opt.",
            "code": "def clip_grad(grad):\n    if grad > 1000:\n        grad = 10\n    return grad\n\nprocessed_grads = [tf.map_fn(clip_grad, g) for g in grads]\n\nopt.apply_gradients(zip(processed_grads, var_list))",
            "masked_code": "def clip_grad(grad):\n    if grad > 1000:\n        grad = 10\n    return grad\n\n<line_mask>\n\nopt.apply_gradients(zip(processed_grads, var_list))",
            "masked_line": "processed_grads = [tf.map_fn(clip_grad, g) for g in grads]",
            "answer": "map_fn",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_227"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-03-13",
            "description": "This code imports TensorFlow version 1, and disables TensorFlow version 2 behavior in the program.",
            "code": "import tensorflow.compat.v1 as tf\ntf.disable_v2_behavior()",
            "masked_code": "import tensorflow.compat.v1 as tf\n<line_mask>",
            "masked_line": "tf.disable_v2_behavior()",
            "answer": "disable_v2_behavior",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_228"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-03-10",
            "description": "The code sets the TensorFlow logging level to only display error messages.",
            "code": "tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)",
            "masked_code": "<line_mask>",
            "masked_line": "tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)",
            "answer": "logging",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_229"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-05-18",
            "description": "The code defines and initializes a neural network model using Tensorflow and Tensorflow Probability to create a probabilistic model with a single dense layer and a Normal distribution output.",
            "code": "import tensorflow as tf\nimport tensorboard\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tensorflow_probability as tfp\nfrom tensorflow_model_optimization.sparsity import keras as sparsity\nfrom tensorflow import keras\n\n\ntf.compat.v1.disable_eager_execution()\n\n\ntfd = tfp.distributions\n\ninit = tf.compat.v1.global_variables_initializer()\n\nwith tf.compat.v1.Session() as sess:\n    sess.run(init)\n\n    model = tf.keras.Sequential([\n      tf.keras.layers.Dense(1,kernel_initializer='glorot_uniform'),\n      tfp.layers.DistributionLambda(lambda t: tfd.Normal(loc=t, scale=1))\n    ])",
            "masked_code": "import tensorflow as tf\nimport tensorboard\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tensorflow_probability as tfp\nfrom tensorflow_model_optimization.sparsity import keras as sparsity\nfrom tensorflow import keras\n\n\n<line_mask>\n\n\ntfd = tfp.distributions\n\ninit = tf.compat.v1.global_variables_initializer()\n\nwith tf.compat.v1.Session() as sess:\n    sess.run(init)\n\n    model = tf.keras.Sequential([\n      tf.keras.layers.Dense(1,kernel_initializer='glorot_uniform'),\n      tfp.layers.DistributionLambda(lambda t: tfd.Normal(loc=t, scale=1))\n    ])",
            "masked_line": "tf.compat.v1.disable_eager_execution()",
            "answer": "compat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_230"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-05-09",
            "description": "The code loads an image file, decodes it as a JPEG image using TensorFlow, and then converts the RGB image into a BGR image using OpenCV. Finally, it displays the BGR image using OpenCV.",
            "code": "import tensorflow as tf\nimport cv2\n\n\ndef load(image_file):\n    image = tf.io.read_file(image_file)\n    image = tf.image.decode_jpeg(image)\n    return image\n\n\nwink = load(\"wink.jpg\")\nprint(wink.shape, wink.dtype)\n\n# Get a Numpy BGR image from a RGB tf.Tensor\nimage = cv2.cvtColor(wink.numpy(), cv2.COLOR_RGB2BGR)\n\ncv2.imshow(\"image\", image)\ncv2.waitKey()",
            "masked_code": "import tensorflow as tf\nimport cv2\n\n\ndef load(image_file):\n    <line_mask>\n    image = tf.image.decode_jpeg(image)\n    return image\n\n\nwink = load(\"wink.jpg\")\nprint(wink.shape, wink.dtype)\n\n# Get a Numpy BGR image from a RGB tf.Tensor\nimage = cv2.cvtColor(wink.numpy(), cv2.COLOR_RGB2BGR)\n\ncv2.imshow(\"image\", image)\ncv2.waitKey()",
            "masked_line": "image = tf.io.read_file(image_file)",
            "answer": "read_file",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_231"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-11-07",
            "description": "The code is used to create an image data generator for training a neural network model. It includes various image augmentation techniques such as rotation, shifting, rescaling, shearing, zooming, and flipping. The generator will load images from a specified directory, resize them to 150x150 pixels, batch them in groups of 16, save them in PNG format, and use sparse class labels for the images. The color mode is set to RGBA.",
            "code": "from tensorflow.python.keras.preprocessing.image import ImageDataGenerator\n\ntrain_datagen = ImageDataGenerator(\n    rotation_range=10,\n    width_shift_range=0.1,\n    height_shift_range=0.1,\n    rescale=1. / 255,\n    shear_range=0.1,\n    zoom_range=0.2,\n    horizontal_flip=False,\n    fill_mode='nearest')\n\ntrain_generator = train_datagen.flow_from_directory(\n    train_data_dir,\n    target_size=(150, 150),\n    batch_size=16,\n    save_format='png',\n    class_mode='sparse',\n    color_mode='rgba')",
            "masked_code": "from tensorflow.python.keras.preprocessing.image import ImageDataGenerator\n\ntrain_datagen = ImageDataGenerator(\n    rotation_range=10,\n    width_shift_range=0.1,\n    height_shift_range=0.1,\n    rescale=1. / 255,\n    shear_range=0.1,\n    zoom_range=0.2,\n    horizontal_flip=False,\n    fill_mode='nearest')\n\n<line_mask>\n    train_data_dir,\n    target_size=(150, 150),\n    batch_size=16,\n    save_format='png',\n    class_mode='sparse',\n    color_mode='rgba')",
            "masked_line": "train_generator = train_datagen.flow_from_directory(",
            "answer": "flow_from_directory",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_232"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-10-26",
            "description": "The code creates a convolutional neural network model that consists of a convolutional layer with 64 filters, a 2x2 max pooling layer, and a flattening layer. It then displays a summary of the model architecture.",
            "code": "from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten\n\nexample_model = Sequential()\nexample_model.add(Conv2D(64, (3, 3), activation='relu', padding='same', input_shape=(100, 100, 1)))\nexample_model.add(MaxPooling2D((2, 2)))\nexample_model.add(Flatten())\nexample_model.summary()",
            "masked_code": "from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten\n\nexample_model = Sequential()\n<line_mask>\nexample_model.add(MaxPooling2D((2, 2)))\nexample_model.add(Flatten())\nexample_model.summary()",
            "masked_line": "example_model.add(Conv2D(64, (3, 3), activation='relu', padding='same', input_shape=(100, 100, 1)))",
            "answer": "add",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_233"
        },
        {
            "dependency": "wagtail",
            "version": "==2.4",
            "time": "2019-01-31",
            "description": "This code defines a Wagtail ModelAdmin class for managing EmailUser models. It sets up various options such as menu label, menu icon, list display fields, list filters, and ordering for the UserAdmin model. Finally, it registers the UserAdmin model with the Wagtail modeladmin.",
            "code": "from wagtail.contrib.modeladmin.options import (\n    ModelAdmin, modeladmin_register\n)\n\nfrom .models import EmailUser\n\n\nclass UserAdmin(ModelAdmin):\n    model = EmailUser\n    menu_label = 'Users'\n    menu_icon = 'fa-folder-open'\n    add_to_settings_menu = True\n    list_display = ('email', 'first_name', 'last_name', 'is_training')\n    list_filter = ('is_staff', 'is_superuser')\n    ordering = ('email',)\n\n\nmodeladmin_register(UserAdmin)",
            "masked_code": "from wagtail.contrib.modeladmin.options import (\n    <line_mask>\n)\n\nfrom .models import EmailUser\n\n\nclass UserAdmin(ModelAdmin):\n    model = EmailUser\n    menu_label = 'Users'\n    menu_icon = 'fa-folder-open'\n    add_to_settings_menu = True\n    list_display = ('email', 'first_name', 'last_name', 'is_training')\n    list_filter = ('is_staff', 'is_superuser')\n    ordering = ('email',)\n\n\nmodeladmin_register(UserAdmin)",
            "masked_line": "ModelAdmin, modeladmin_register",
            "answer": "modeladmin_register",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_234"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-05-04",
            "description": "The code generates two random matrices A and B, each with the shape [10,000, 10,000], computes their matrix product, and returns the sum of all elements in the resulting matrix.",
            "code": "import tensorflow as tf\n\ndef get_values():\n  A = tf.random.normal([10_000,10_000])\n  B = tf.random.normal([10_000,10_000])\n  return A,B\n\n@tf.function\ndef compute():\n  A,B = get_values()\n  return tf.reduce_sum(tf.matmul(A,B))\n\nprint(compute())",
            "masked_code": "import tensorflow as tf\n\ndef get_values():\n  <line_mask>\n  B = tf.random.normal([10_000,10_000])\n  return A,B\n\n@tf.function\ndef compute():\n  A,B = get_values()\n  return tf.reduce_sum(tf.matmul(A,B))\n\nprint(compute())",
            "masked_line": "A = tf.random.normal([10_000,10_000])",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_235"
        },
        {
            "dependency": "selenium",
            "version": "==4.0.0a5",
            "time": "2020-04-15",
            "description": "This code opens a Microsoft Edge browser using Selenium WebDriver and navigates to a specified URL with a page load timeout of 40 seconds.",
            "code": "# using edge directly, since you can see 'selenium.webdriver.chromium.webdriver' used in site-packages\\selenium\\webdriver\\edge\\webdriver.py\nfrom selenium import webdriver\nfrom selenium.webdriver.edge.options import Options\nfrom selenium.webdriver.edge.service import Service\nfrom selenium.webdriver.edge.webdriver import WebDriver\n...\n...\ndriveroptions = Options()\n# remember to set use_chromium\ndriveroptions.use_chromium = True\ndriveroptions.add_argument('--start-maximized')\ndriveroptions.binary_location = env_programfiles_x86 + \"\\\\Microsoft\\\\Edge\\\\Application\\\\msedge.exe\"\n\nservice = Service(executable_path=\"msedgedriver.exe\")\ndriver = webdriver.Edge(options=driveroptions, service=service)\n\ndriver.set_page_load_timeout(40)\ndriver.get(page_url)",
            "masked_code": "# using edge directly, since you can see 'selenium.webdriver.chromium.webdriver' used in site-packages\\selenium\\webdriver\\edge\\webdriver.py\nfrom selenium import webdriver\nfrom selenium.webdriver.edge.options import Options\nfrom selenium.webdriver.edge.service import Service\nfrom selenium.webdriver.edge.webdriver import WebDriver\n...\n...\ndriveroptions = Options()\n# remember to set use_chromium\ndriveroptions.use_chromium = True\ndriveroptions.add_argument('--start-maximized')\ndriveroptions.binary_location = env_programfiles_x86 + \"\\\\Microsoft\\\\Edge\\\\Application\\\\msedge.exe\"\n\n<line_mask>\ndriver = webdriver.Edge(options=driveroptions, service=service)\n\ndriver.set_page_load_timeout(40)\ndriver.get(page_url)",
            "masked_line": "service = Service(executable_path=\"msedgedriver.exe\")",
            "answer": "Service",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_236"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-02-27",
            "description": "The code optimizes a given mathematical function using the L-BFGS-B optimization method provided by the scipy.optimize package. The function to be optimized is defined by the model function, which calculates the sum of squared differences between the input and a constant value. The val_and_grad function computes the value and gradient of the model function at a given input. The func function processes the values and gradients returned by val_and_grad for optimization. The final result of the optimization is printed out.",
            "code": "import tensorflow as tf\nimport numpy as np\nimport scipy.optimize as sopt\n\ndef model(x):\n    return tf.reduce_sum(tf.square(x-tf.constant(2, dtype=tf.float32)))\n\n@tf.function\ndef val_and_grad(x):\n    with tf.GradientTape() as tape:\n        tape.watch(x)\n        loss = model(x)\n    grad = tape.gradient(loss, x)\n    return loss, grad\n\ndef func(x):\n    return [vv.numpy().astype(np.float64)  for vv in val_and_grad(tf.constant(x, dtype=tf.float32))]\n\nresdd= sopt.minimize(fun=func, x0=np.ones(5),\n                                      jac=True, method='L-BFGS-B')\n\nprint(\"info:\\n\",resdd)",
            "masked_code": "import tensorflow as tf\nimport numpy as np\nimport scipy.optimize as sopt\n\ndef model(x):\n    return tf.reduce_sum(tf.square(x-tf.constant(2, dtype=tf.float32)))\n\n@tf.function\ndef val_and_grad(x):\n    <line_mask>\n        tape.watch(x)\n        loss = model(x)\n    grad = tape.gradient(loss, x)\n    return loss, grad\n\ndef func(x):\n    return [vv.numpy().astype(np.float64)  for vv in val_and_grad(tf.constant(x, dtype=tf.float32))]\n\nresdd= sopt.minimize(fun=func, x0=np.ones(5),\n                                      jac=True, method='L-BFGS-B')\n\nprint(\"info:\\n\",resdd)",
            "masked_line": "with tf.GradientTape() as tape:",
            "answer": "GradientTape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_237"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2019-10-29",
            "description": "The code optimizes a variable var1 using stochastic gradient descent (SGD) with a learning rate of 0.1 for 1000 iterations. The loss function is calculated based on the current value of var1 and is minimized to update var1. The final value of var1 is printed after each iteration.",
            "code": "import tensorflow as tf\n\nopt = tf.keras.optimizers.SGD(learning_rate=0.1)\nvar1 = tf.Variable(tf.random.normal([1]))\ndef loss():\n    var2 = tf.add(tf.multiply(-2, var1), 1)\n    return var1 * var1 + var2\n\nfor i in range(1000):\n    opt.minimize(loss, var_list=[var1])\n    print('var1: {}'.format(var1.numpy()))\n    # ...\n    # var1: [0.9999999]",
            "masked_code": "import tensorflow as tf\n\nopt = tf.keras.optimizers.SGD(learning_rate=0.1)\nvar1 = tf.Variable(tf.random.normal([1]))\ndef loss():\n    <line_mask>\n    return var1 * var1 + var2\n\nfor i in range(1000):\n    opt.minimize(loss, var_list=[var1])\n    print('var1: {}'.format(var1.numpy()))\n    # ...\n    # var1: [0.9999999]",
            "masked_line": "var2 = tf.add(tf.multiply(-2, var1), 1)",
            "answer": "add",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_238"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.2.2",
            "time": "2019-03-15",
            "description": "The code creates a scatter plot with red dots on an axes with specified x and y limits. The plot contains example data points that are displayed using a logarithmic scale for the y-axis.",
            "code": "import numpy as np\nfrom matplotlib import pyplot\n\nfig = pyplot.figure()\nax = fig.add_axes((0.1, 0.1, 0.8, 0.8),autoscale_on=False)\n\n#Empty data plot\npoints = ax.scatter([],[], color='r', zorder=2)\n#ax properties\nax.set_xlim(-10, 10)\nax.set_ylim(5e-2, 5e3)\nax.set_yscale(\"log\")\n\n#Example data points\nx_data = [-5, -3, 0, 3, 5]\ny_data = [1, 10, 1000, 10, 1]\n#Set data points\npoints.set_offsets(np.dstack((x_data, y_data))[0]) # <--- Here [0]\npyplot.show()",
            "masked_code": "import numpy as np\nfrom matplotlib import pyplot\n\n<line_mask>\nax = fig.add_axes((0.1, 0.1, 0.8, 0.8),autoscale_on=False)\n\n#Empty data plot\npoints = ax.scatter([],[], color='r', zorder=2)\n#ax properties\nax.set_xlim(-10, 10)\nax.set_ylim(5e-2, 5e3)\nax.set_yscale(\"log\")\n\n#Example data points\nx_data = [-5, -3, 0, 3, 5]\ny_data = [1, 10, 1000, 10, 1]\n#Set data points\npoints.set_offsets(np.dstack((x_data, y_data))[0]) # <--- Here [0]\npyplot.show()",
            "masked_line": "fig = pyplot.figure()",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_239"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-02",
            "description": "The code assigns the value 2 to a TensorFlow variable 'a', then tries to reassign the value to 5 using the assign method, and finally checks if the value of 'a' is indeed 5.",
            "code": "import tensorflow as tf\n\na = tf.Variable(2)\na.assign(5)\nassert a.numpy() == 5",
            "masked_code": "import tensorflow as tf\n\n<line_mask>\na.assign(5)\nassert a.numpy() == 5",
            "masked_line": "a = tf.Variable(2)",
            "answer": "Variable",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_240"
        },
        {
            "dependency": "django",
            "version": "==3.1",
            "time": "2020-08-08",
            "description": "The code disables the navigation sidebar on the Django admin site.",
            "code": "from django.contrib import admin\n\nadmin.autodiscover()\nadmin.site.enable_nav_sidebar = False",
            "masked_code": "from django.contrib import admin\n\n<line_mask>\nadmin.site.enable_nav_sidebar = False",
            "masked_line": "admin.autodiscover()",
            "answer": "autodiscover",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_241"
        },
        {
            "dependency": "django",
            "version": "==3.1.4",
            "time": "2020-12-07",
            "description": "This Python code sets up a router for handling different types of protocols (websocket and http) using Django ASGI application for HTTP requests and specific URL patterns for websocket requests defined in romanize.routing module.",
            "code": "# dwtools.routing\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom django.core.asgi import get_asgi_application\n\nimport romanize.routing\n\napplication = ProtocolTypeRouter(\n    {\n        \"websocket\": URLRouter(romanize.routing.websocket_urlpatterns),\n        \"http\": get_asgi_application(),\n    },\n)",
            "masked_code": "# dwtools.routing\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom django.core.asgi import get_asgi_application\n\nimport romanize.routing\n\napplication = ProtocolTypeRouter(\n    {\n        \"websocket\": URLRouter(romanize.routing.websocket_urlpatterns),\n        <line_mask>\n    },\n)",
            "masked_line": "\"http\": get_asgi_application(),",
            "answer": "get_asgi_application",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_242"
        },
        {
            "dependency": "channels",
            "version": "==3.0.2",
            "time": "2020-12-07",
            "description": "The code sets up a protocol type router for handling websocket and http connections, using URLRouter for websocket connections defined in romanize.routing.websocket_urlpatterns and get_asgi_application for http connections.",
            "code": "# dwtools.routing\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom django.core.asgi import get_asgi_application\n\nimport romanize.routing\n\napplication = ProtocolTypeRouter(\n    {\n        \"websocket\": URLRouter(romanize.routing.websocket_urlpatterns),\n        \"http\": get_asgi_application(),\n    },\n)",
            "masked_code": "# dwtools.routing\n<line_mask>\nfrom django.core.asgi import get_asgi_application\n\nimport romanize.routing\n\napplication = ProtocolTypeRouter(\n    {\n        \"websocket\": URLRouter(romanize.routing.websocket_urlpatterns),\n        \"http\": get_asgi_application(),\n    },\n)",
            "masked_line": "from channels.routing import ProtocolTypeRouter, URLRouter",
            "answer": "URLRouter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_243"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-03-06",
            "description": "The code calculates the cosine similarity, normalized Euclidean distance, and Euclidean distance between two tensors x1 and y1 in TensorFlow.",
            "code": "import tensorflow as tf\n\n# It should be tf 2.0 or greater\nprint(\"Tensorflow Version:\",tf.__version__)\n\n#Create Tensors\nx1 = tf.constant([1.0, 112332.0, 89889.0], shape=(1,3))\nprint(\"x1 tensor shape:\",x1.shape)\ny1 = tf.constant([1.0, -2.0, -8.0], shape=(1,3))\nprint(\"y1 tensor shape:\",y1.shape)\n\n#Cosine Similarity\ns = tf.keras.losses.cosine_similarity(x1,y1)\nprint(\"Cosine Similarity:\",s)\n\n#Normalized Euclidean Distance\ns = tf.norm(tf.nn.l2_normalize(x1, 0)-tf.nn.l2_normalize(y1, 0),ord='euclidean')\nprint(\"Normalized Euclidean Distance:\",s)\n\n#Euclidean Distance\ns = tf.norm(x1-y1,ord='euclidean')\nprint(\"Euclidean Distance:\",s)",
            "masked_code": "import tensorflow as tf\n\n# It should be tf 2.0 or greater\nprint(\"Tensorflow Version:\",tf.__version__)\n\n#Create Tensors\nx1 = tf.constant([1.0, 112332.0, 89889.0], shape=(1,3))\nprint(\"x1 tensor shape:\",x1.shape)\ny1 = tf.constant([1.0, -2.0, -8.0], shape=(1,3))\nprint(\"y1 tensor shape:\",y1.shape)\n\n#Cosine Similarity\n<line_mask>\nprint(\"Cosine Similarity:\",s)\n\n#Normalized Euclidean Distance\ns = tf.norm(tf.nn.l2_normalize(x1, 0)-tf.nn.l2_normalize(y1, 0),ord='euclidean')\nprint(\"Normalized Euclidean Distance:\",s)\n\n#Euclidean Distance\ns = tf.norm(x1-y1,ord='euclidean')\nprint(\"Euclidean Distance:\",s)",
            "masked_line": "s = tf.keras.losses.cosine_similarity(x1,y1)",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_244"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2021-01-04",
            "description": "This code defines a custom callback class, CosineDecayRestarts, that implements a cosine learning rate decay with restarts for a TensorFlow keras model training. The callback adjusts the learning rate at the beginning of each training batch based on a cosine decay formula with optional restarts.",
            "code": "from collections.abc import Iterable\nfrom tensorflow.keras.callbacks import *\nfrom tensorflow.keras import backend as K\nimport tensorflow as tf\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.framework import constant_op\nimport math\n\n\nclass CosineDecayRestarts(tf.keras.callbacks.Callback):\n    def __init__(self, initial_learning_rate, first_decay_steps, alpha=0.0, t_mul=2.0, m_mul=1.0):\n        super(CosineDecayRestarts, self).__init__()\n        self.initial_learning_rate = initial_learning_rate\n        self.first_decay_steps = first_decay_steps\n        self.alpha = alpha\n        self.t_mul = t_mul\n        self.m_mul = m_mul\n        self.batch_step = 0\n\n    def on_train_batch_begin(self, step, logs=None):\n        if not hasattr(self.model.optimizer, \"lr\"):\n            raise ValueError('Optimizer must have a \"lr\" attribute.')\n        # Get the current learning rate from model's optimizer.\n        lr = float(tf.keras.backend.get_value(self.model.optimizer.learning_rate))\n        # Call schedule function to get the scheduled learning rate.\n        scheduled_lr = self.schedule(self.batch_step, lr)\n        # Set the value back to the optimizer before this epoch starts\n        tf.keras.backend.set_value(self.model.optimizer.lr, scheduled_lr)\n        self.batch_step += 1\n\n    def schedule(self, step, lr):\n        def compute_step(completed_fraction, geometric=False):\n            \"\"\"Helper for `cond` operation.\"\"\"\n            if geometric:\n                i_restart = math_ops.floor(\n                  math_ops.log(1.0 - completed_fraction * (1.0 - self.t_mul)) /\n                  math_ops.log(self.t_mul))\n\n                sum_r = (1.0 - self.t_mul**i_restart) / (1.0 - self.t_mul)\n                completed_fraction = (completed_fraction - sum_r) / self.t_mul**i_restart\n\n            else:\n                i_restart = math_ops.floor(completed_fraction)\n                completed_fraction -= i_restart\n\n            return i_restart, completed_fraction\n\n        completed_fraction = step / self.first_decay_steps\n\n        i_restart, completed_fraction = control_flow_ops.cond(\n          math_ops.equal(self.t_mul, 1.0),\n          lambda: compute_step(completed_fraction, geometric=False),\n          lambda: compute_step(completed_fraction, geometric=True))\n\n        m_fac = self.m_mul**i_restart\n        cosine_decayed = 0.5 * m_fac * (1.0 + math_ops.cos(\n          constant_op.constant(math.pi) * completed_fraction))\n        decayed = (1 - self.alpha) * cosine_decayed + self.alpha\n\n        return math_ops.multiply(self.initial_learning_rate, decayed)",
            "masked_code": "from collections.abc import Iterable\nfrom tensorflow.keras.callbacks import *\nfrom tensorflow.keras import backend as K\nimport tensorflow as tf\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.framework import constant_op\nimport math\n\n\nclass CosineDecayRestarts(tf.keras.callbacks.Callback):\n    def __init__(self, initial_learning_rate, first_decay_steps, alpha=0.0, t_mul=2.0, m_mul=1.0):\n        super(CosineDecayRestarts, self).__init__()\n        self.initial_learning_rate = initial_learning_rate\n        self.first_decay_steps = first_decay_steps\n        self.alpha = alpha\n        self.t_mul = t_mul\n        self.m_mul = m_mul\n        self.batch_step = 0\n\n    def on_train_batch_begin(self, step, logs=None):\n        if not hasattr(self.model.optimizer, \"lr\"):\n            raise ValueError('Optimizer must have a \"lr\" attribute.')\n        # Get the current learning rate from model's optimizer.\n        lr = float(tf.keras.backend.get_value(self.model.optimizer.learning_rate))\n        # Call schedule function to get the scheduled learning rate.\n        scheduled_lr = self.schedule(self.batch_step, lr)\n        # Set the value back to the optimizer before this epoch starts\n        <line_mask>\n        self.batch_step += 1\n\n    def schedule(self, step, lr):\n        def compute_step(completed_fraction, geometric=False):\n            \"\"\"Helper for `cond` operation.\"\"\"\n            if geometric:\n                i_restart = math_ops.floor(\n                  math_ops.log(1.0 - completed_fraction * (1.0 - self.t_mul)) /\n                  math_ops.log(self.t_mul))\n\n                sum_r = (1.0 - self.t_mul**i_restart) / (1.0 - self.t_mul)\n                completed_fraction = (completed_fraction - sum_r) / self.t_mul**i_restart\n\n            else:\n                i_restart = math_ops.floor(completed_fraction)\n                completed_fraction -= i_restart\n\n            return i_restart, completed_fraction\n\n        completed_fraction = step / self.first_decay_steps\n\n        i_restart, completed_fraction = control_flow_ops.cond(\n          math_ops.equal(self.t_mul, 1.0),\n          lambda: compute_step(completed_fraction, geometric=False),\n          lambda: compute_step(completed_fraction, geometric=True))\n\n        m_fac = self.m_mul**i_restart\n        cosine_decayed = 0.5 * m_fac * (1.0 + math_ops.cos(\n          constant_op.constant(math.pi) * completed_fraction))\n        decayed = (1 - self.alpha) * cosine_decayed + self.alpha\n\n        return math_ops.multiply(self.initial_learning_rate, decayed)",
            "masked_line": "tf.keras.backend.set_value(self.model.optimizer.lr, scheduled_lr)",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_245"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.5.0",
            "time": "2021-03-28",
            "description": "The code is using SHAP (SHapley Additive exPlanations) library to explain the output of a deep learning model built using TensorFlow. It trains a neural network model on the iris dataset, then uses SHAP to explain the model predictions by calculating the SHAP values for the first 3 instances in the test set and visualizing the results using a force plot.",
            "code": "import shap\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\n\nimport tensorflow as tf    \ntf.compat.v1.disable_v2_behavior() # <-- HERE !\n\nimport tensorflow.keras.backend as K\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.python.keras.layers import Dense\nfrom tensorflow.python.keras import Sequential\nfrom tensorflow.keras import optimizers\n\nprint(\"SHAP version is:\", shap.__version__)\nprint(\"Tensorflow version is:\", tf.__version__)\n\nX_train, X_test, Y_train, Y_test = train_test_split(\n    *shap.datasets.iris(), test_size=0.2, random_state=0\n)\n\nY_train = to_categorical(Y_train, num_classes=3)\nY_test = to_categorical(Y_test, num_classes=3)\n\n# Define baseline model\nmodel = tf.keras.models.Sequential()\nmodel.add(tf.keras.layers.Dense(8, input_dim=len(X_train.columns), activation=\"relu\"))\nmodel.add(tf.keras.layers.Dense(3, activation=\"softmax\"))\n# model.summary()\n\n# compile the model\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n\nhist = model.fit(X_train, Y_train, batch_size=5, epochs=200, verbose=0)\n\n# select a set of background examples to take an expectation over\nbackground = X_train.iloc[np.random.choice(X_train.shape[0], 100, replace=False)]\n\nexplainer = shap.DeepExplainer(\n    (model.layers[0].input, model.layers[-1].output), background\n)\nshap_values = explainer.shap_values(X_test[:3].values) # <-- HERE !\n\n# print the JS visualization code to the notebook\nshap.initjs()\nshap.force_plot(\n    explainer.expected_value[0], shap_values[0][0], feature_names=X_train.columns\n)",
            "masked_code": "import shap\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\n\nimport tensorflow as tf    \n<line_mask>\n\nimport tensorflow.keras.backend as K\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.python.keras.layers import Dense\nfrom tensorflow.python.keras import Sequential\nfrom tensorflow.keras import optimizers\n\nprint(\"SHAP version is:\", shap.__version__)\nprint(\"Tensorflow version is:\", tf.__version__)\n\nX_train, X_test, Y_train, Y_test = train_test_split(\n    *shap.datasets.iris(), test_size=0.2, random_state=0\n)\n\nY_train = to_categorical(Y_train, num_classes=3)\nY_test = to_categorical(Y_test, num_classes=3)\n\n# Define baseline model\nmodel = tf.keras.models.Sequential()\nmodel.add(tf.keras.layers.Dense(8, input_dim=len(X_train.columns), activation=\"relu\"))\nmodel.add(tf.keras.layers.Dense(3, activation=\"softmax\"))\n# model.summary()\n\n# compile the model\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n\nhist = model.fit(X_train, Y_train, batch_size=5, epochs=200, verbose=0)\n\n# select a set of background examples to take an expectation over\nbackground = X_train.iloc[np.random.choice(X_train.shape[0], 100, replace=False)]\n\nexplainer = shap.DeepExplainer(\n    (model.layers[0].input, model.layers[-1].output), background\n)\nshap_values = explainer.shap_values(X_test[:3].values) # <-- HERE !\n\n# print the JS visualization code to the notebook\nshap.initjs()\nshap.force_plot(\n    explainer.expected_value[0], shap_values[0][0], feature_names=X_train.columns\n)",
            "masked_line": "tf.compat.v1.disable_v2_behavior() # <-- HERE !",
            "answer": "disable_v2_behavior",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_246"
        },
        {
            "dependency": "shap",
            "version": "==0.39.0",
            "time": "2021-03-28",
            "description": "This code performs model training using a neural network on the Iris dataset. It uses SHAP (SHapley Additive exPlanations) to explain the model predictions by calculating Shapley values for the input features. The code also generates a force plot visualization of the SHAP values.",
            "code": "import shap\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\n\nimport tensorflow as tf    \ntf.compat.v1.disable_v2_behavior() # <-- HERE !\n\nimport tensorflow.keras.backend as K\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.python.keras.layers import Dense\nfrom tensorflow.python.keras import Sequential\nfrom tensorflow.keras import optimizers\n\nprint(\"SHAP version is:\", shap.__version__)\nprint(\"Tensorflow version is:\", tf.__version__)\n\nX_train, X_test, Y_train, Y_test = train_test_split(\n    *shap.datasets.iris(), test_size=0.2, random_state=0\n)\n\nY_train = to_categorical(Y_train, num_classes=3)\nY_test = to_categorical(Y_test, num_classes=3)\n\n# Define baseline model\nmodel = tf.keras.models.Sequential()\nmodel.add(tf.keras.layers.Dense(8, input_dim=len(X_train.columns), activation=\"relu\"))\nmodel.add(tf.keras.layers.Dense(3, activation=\"softmax\"))\n# model.summary()\n\n# compile the model\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n\nhist = model.fit(X_train, Y_train, batch_size=5, epochs=200, verbose=0)\n\n# select a set of background examples to take an expectation over\nbackground = X_train.iloc[np.random.choice(X_train.shape[0], 100, replace=False)]\n\nexplainer = shap.DeepExplainer(\n    (model.layers[0].input, model.layers[-1].output), background\n)\nshap_values = explainer.shap_values(X_test[:3].values) # <-- HERE !\n\n# print the JS visualization code to the notebook\nshap.initjs()\nshap.force_plot(\n    explainer.expected_value[0], shap_values[0][0], feature_names=X_train.columns\n)",
            "masked_code": "import shap\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\n\nimport tensorflow as tf    \ntf.compat.v1.disable_v2_behavior() # <-- HERE !\n\nimport tensorflow.keras.backend as K\nfrom tensorflow.keras.utils import to_categorical\nfrom tensorflow.python.keras.layers import Dense\nfrom tensorflow.python.keras import Sequential\nfrom tensorflow.keras import optimizers\n\nprint(\"SHAP version is:\", shap.__version__)\nprint(\"Tensorflow version is:\", tf.__version__)\n\nX_train, X_test, Y_train, Y_test = train_test_split(\n    <line_mask>\n)\n\nY_train = to_categorical(Y_train, num_classes=3)\nY_test = to_categorical(Y_test, num_classes=3)\n\n# Define baseline model\nmodel = tf.keras.models.Sequential()\nmodel.add(tf.keras.layers.Dense(8, input_dim=len(X_train.columns), activation=\"relu\"))\nmodel.add(tf.keras.layers.Dense(3, activation=\"softmax\"))\n# model.summary()\n\n# compile the model\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n\nhist = model.fit(X_train, Y_train, batch_size=5, epochs=200, verbose=0)\n\n# select a set of background examples to take an expectation over\nbackground = X_train.iloc[np.random.choice(X_train.shape[0], 100, replace=False)]\n\nexplainer = shap.DeepExplainer(\n    (model.layers[0].input, model.layers[-1].output), background\n)\nshap_values = explainer.shap_values(X_test[:3].values) # <-- HERE !\n\n# print the JS visualization code to the notebook\nshap.initjs()\nshap.force_plot(\n    explainer.expected_value[0], shap_values[0][0], feature_names=X_train.columns\n)",
            "masked_line": "*shap.datasets.iris(), test_size=0.2, random_state=0",
            "answer": "iris",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_247"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.7.0",
            "time": "2023-01-11",
            "description": "The code creates a Charuco board object with specific dimensions and parameters for calibration purposes using Aruco markers in OpenCV.",
            "code": "import cv2\n\naruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\nboard = cv2.aruco.CharucoBoard((11, 8), 0.015, 0.011, aruco_dict)",
            "masked_code": "import cv2\n\n<line_mask>\nboard = cv2.aruco.CharucoBoard((11, 8), 0.015, 0.011, aruco_dict)",
            "masked_line": "aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)",
            "answer": "getPredefinedDictionary",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_248"
        },
        {
            "dependency": "selenium",
            "version": "==4.11.2",
            "time": "2023-08-07",
            "description": "The code opens a Chrome web browser using Selenium and navigates to the Google homepage.",
            "code": "from selenium import webdriver\n\ndriver = webdriver.Chrome()\ndriver.get(\"https://www.google.com/\")",
            "masked_code": "from selenium import webdriver\n\ndriver = webdriver.Chrome()\n<line_mask>",
            "masked_line": "driver.get(\"https://www.google.com/\")",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_249"
        },
        {
            "dependency": "selenium",
            "version": "==4.8",
            "time": "2023-08-21",
            "description": "This code snippet initializes a Selenium webdriver for Chrome browser with specified options and executable path.",
            "code": "# using selenium 4.8 and python 3.9\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\n\noptions = Options()\noptions.binary_location = 'path to chrome.exe'\n## this is the chromium for testing which can be downloaded from the link given below\n\ndriver = webdriver.Chrome(chrome_options = options, executable_path = 'path to chromedriver.exe')\n## must be the same as the downloaded version of chrome cft.",
            "masked_code": "# using selenium 4.8 and python 3.9\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\n\noptions = Options()\noptions.binary_location = 'path to chrome.exe'\n## this is the chromium for testing which can be downloaded from the link given below\n\n<line_mask>\n## must be the same as the downloaded version of chrome cft.",
            "masked_line": "driver = webdriver.Chrome(chrome_options = options, executable_path = 'path to chromedriver.exe')",
            "answer": "Chrome",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_250"
        },
        {
            "dependency": "selenium",
            "version": "==4.6",
            "time": "2023-07-29",
            "description": "The code opens a Chrome browser using Selenium, maximizes the window, and navigates to the Google homepage.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"start-maximized\")\ndriver = webdriver.Chrome(options=options)\ndriver.get(\"https://www.google.com/\")",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\n<line_mask>\noptions.add_argument(\"start-maximized\")\ndriver = webdriver.Chrome(options=options)\ndriver.get(\"https://www.google.com/\")",
            "masked_line": "options = Options()",
            "answer": "Options",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_251"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.1",
            "time": "2019-01-03",
            "description": "The code snippet calculates the frequency of each unique value in the given series and returns the result as a dictionary.",
            "code": "# Value Counts comparison.\nser.value_counts(sort=False).to_dict()           # value_counts\ndict(zip(*np.unique(ser, return_counts=True)))   # np.unique\nCounter(ser)                                     # Counter",
            "masked_code": "# Value Counts comparison.\nser.value_counts(sort=False).to_dict()           # value_counts\n<line_mask>\nCounter(ser)                                     # Counter",
            "masked_line": "dict(zip(*np.unique(ser, return_counts=True)))   # np.unique",
            "answer": "unique",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_252"
        },
        {
            "dependency": "sklearn",
            "version": ">=0.21",
            "time": "2019-02-12",
            "description": "This code builds a machine learning pipeline that preprocesses the input data by imputing missing values, standardizing numerical features, and one-hot encoding categorical features. It then fits a linear regression model to predict the target variable based on the preprocessed data. The code also retrieves the feature names after one-hot encoding the categorical features.",
            "code": "import numpy as np\nimport pandas as pd\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.linear_model import LinearRegression\n\ndf = pd.DataFrame({'brand': ['aaaa', 'asdfasdf', 'sadfds', 'NaN'],\n                   'category': ['asdf', 'asfa', 'asdfas', 'as'],\n                   'num1': [1, 1, 0, 0],\n                   'target': [0.2, 0.11, 1.34, 1.123]})\n\nnumeric_features = ['num1']\nnumeric_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='median')),\n    ('scaler', StandardScaler())])\n\ncategorical_features = ['brand', 'category']\ncategorical_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='constant', fill_value='missing')),\n    ('onehot', OneHotEncoder(handle_unknown='ignore'))])\n\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', numeric_transformer, numeric_features),\n        ('cat', categorical_transformer, categorical_features)])\n\nclf = Pipeline(steps=[('preprocessor', preprocessor),\n                      ('regressor',  LinearRegression())])\nclf.fit(df.drop('target', 1), df['target'])\n\nclf.named_steps['preprocessor'].transformers_[1][1]\\\n   .named_steps['onehot'].get_feature_names(categorical_features)\n\n# ['brand_NaN' 'brand_aaaa' 'brand_asdfasdf' 'brand_sadfds' 'category_as'\n#  'category_asdf' 'category_asdfas' 'category_asfa']",
            "masked_code": "import numpy as np\nimport pandas as pd\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.linear_model import LinearRegression\n\ndf = pd.DataFrame({'brand': ['aaaa', 'asdfasdf', 'sadfds', 'NaN'],\n                   'category': ['asdf', 'asfa', 'asdfas', 'as'],\n                   'num1': [1, 1, 0, 0],\n                   'target': [0.2, 0.11, 1.34, 1.123]})\n\nnumeric_features = ['num1']\nnumeric_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='median')),\n    ('scaler', StandardScaler())])\n\ncategorical_features = ['brand', 'category']\ncategorical_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='constant', fill_value='missing')),\n    ('onehot', OneHotEncoder(handle_unknown='ignore'))])\n\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', numeric_transformer, numeric_features),\n        ('cat', categorical_transformer, categorical_features)])\n\nclf = Pipeline(steps=[('preprocessor', preprocessor),\n                      <line_mask>\nclf.fit(df.drop('target', 1), df['target'])\n\nclf.named_steps['preprocessor'].transformers_[1][1]\\\n   .named_steps['onehot'].get_feature_names(categorical_features)\n\n# ['brand_NaN' 'brand_aaaa' 'brand_asdfasdf' 'brand_sadfds' 'category_as'\n#  'category_asdf' 'category_asdfas' 'category_asfa']",
            "masked_line": "('regressor',  LinearRegression())])",
            "answer": "LinearRegression",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_253"
        },
        {
            "dependency": "selenium",
            "version": "==3.141.59",
            "time": "2019-08-22",
            "description": "The code initiates a headless Chrome browser with specific options, sets download behavior for a specific path, navigates to a website, scrolls to a specific position, clicks on a download button, and prints messages indicating the initialization, button click, and completion.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"--headless\")\noptions.add_argument(\"--window-size=1920,1080\")\noptions.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"])\noptions.add_experimental_option('useAutomationExtension', False)\ndriver = webdriver.Chrome(chrome_options=options, executable_path=r'C:\\Utility\\BrowserDrivers\\chromedriver.exe', service_args=[\"--log-path=./Logs/DubiousDan.log\"])\nprint (\"Headless Chrome Initialized\")\nparams = {'behavior': 'allow', 'downloadPath': r'C:\\Users\\Debanjan.B\\Downloads'}\ndriver.execute_cdp_cmd('Page.setDownloadBehavior', params)\ndriver.get(\"https://www.mockaroo.com/\")\ndriver.execute_script(\"scroll(0, 250)\"); \nWebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.CSS_SELECTOR, \"button#download\"))).click()\nprint (\"Download button clicked\")\n#driver.quit()",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.chrome.options import Options\n\n<line_mask>\noptions.add_argument(\"--headless\")\noptions.add_argument(\"--window-size=1920,1080\")\noptions.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"])\noptions.add_experimental_option('useAutomationExtension', False)\ndriver = webdriver.Chrome(chrome_options=options, executable_path=r'C:\\Utility\\BrowserDrivers\\chromedriver.exe', service_args=[\"--log-path=./Logs/DubiousDan.log\"])\nprint (\"Headless Chrome Initialized\")\nparams = {'behavior': 'allow', 'downloadPath': r'C:\\Users\\Debanjan.B\\Downloads'}\ndriver.execute_cdp_cmd('Page.setDownloadBehavior', params)\ndriver.get(\"https://www.mockaroo.com/\")\ndriver.execute_script(\"scroll(0, 250)\"); \nWebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.CSS_SELECTOR, \"button#download\"))).click()\nprint (\"Download button clicked\")\n#driver.quit()",
            "masked_line": "options = Options()",
            "answer": "Options",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_254"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-10-17",
            "description": "This code generates a scatter plot of random data points with 'x' and 'y' values using the hvplot library as the backend for plotting.",
            "code": "import numpy as np\nimport pandas as pd\n\nimport hvplot\nimport hvplot.pandas\n\npd.options.plotting.backend = 'hvplot'\n\ndata = np.random.normal(size=[50, 2])\n\ndf = pd.DataFrame(data, columns=['x', 'y'])\n\ndf.plot(kind='scatter', x='x', y='y')",
            "masked_code": "import numpy as np\nimport pandas as pd\n\nimport hvplot\nimport hvplot.pandas\n\npd.options.plotting.backend = 'hvplot'\n\ndata = np.random.normal(size=[50, 2])\n\n<line_mask>\n\ndf.plot(kind='scatter', x='x', y='y')",
            "masked_line": "df = pd.DataFrame(data, columns=['x', 'y'])",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_255"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.4.3",
            "time": "2019-02-22",
            "description": "This code generates a histogram plot using the seaborn library for the given data points. The x-axis of the plot shows the range from 1 to 31 with ticks at each integer value.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = [5,8,12,18,19,19.9,20.1,21,24,28] \n\nfig, ax = plt.subplots()\nsns.histplot(data, ax=ax)  # distplot is deprecate and replaced by histplot\nax.set_xlim(1,31)\nax.set_xticks(range(1,32))\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = [5,8,12,18,19,19.9,20.1,21,24,28] \n\nfig, ax = plt.subplots()\nsns.histplot(data, ax=ax)  # distplot is deprecate and replaced by histplot\nax.set_xlim(1,31)\nax.set_xticks(range(1,32))\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_256"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.2",
            "time": "2019-02-22",
            "description": "This code generates a histogram plot of the data values in the variable 'data' using seaborn library and matplotlib. It sets the x-axis limits from 1 to 31 and displays the plot.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = [5,8,12,18,19,19.9,20.1,21,24,28] \n\nfig, ax = plt.subplots()\nsns.histplot(data, ax=ax)  # distplot is deprecate and replaced by histplot\nax.set_xlim(1,31)\nax.set_xticks(range(1,32))\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = [5,8,12,18,19,19.9,20.1,21,24,28] \n\nfig, ax = plt.subplots()\n<line_mask>\nax.set_xlim(1,31)\nax.set_xticks(range(1,32))\nplt.show()",
            "masked_line": "sns.histplot(data, ax=ax)  # distplot is deprecate and replaced by histplot",
            "answer": "histplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_257"
        },
        {
            "dependency": "nltk",
            "version": "==3.4.5",
            "time": "2020-02-09",
            "description": "The code retrieves the list of file identifiers for the stopwords corpus in NLTK.",
            "code": "from nltk.corpus import stopwords\nprint(stopwords.fileids())",
            "masked_code": "from nltk.corpus import stopwords\n<line_mask>",
            "masked_line": "print(stopwords.fileids())",
            "answer": "fileids",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_258"
        },
        {
            "dependency": "scipy",
            "version": "==0.16.1",
            "time": "2019-06-27",
            "description": "This function calculates the p-value for a given correlation coefficient using the beta distribution.",
            "code": "import pandas as pd\nfrom scipy.special import betainc\n\ndef pvalue(corr, n=50):\n    df = n - 2\n    t_squared = corr**2 * (df / ((1.0 - corr) * (1.0 + corr)))\n    prob = betainc(0.5*df, 0.5, df/(df+t_squared))\n    return prob",
            "masked_code": "import pandas as pd\nfrom scipy.special import betainc\n\ndef pvalue(corr, n=50):\n    df = n - 2\n    t_squared = corr**2 * (df / ((1.0 - corr) * (1.0 + corr)))\n    <line_mask>\n    return prob",
            "masked_line": "prob = betainc(0.5*df, 0.5, df/(df+t_squared))",
            "answer": "betainc",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_259"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0.0",
            "time": "2019-12-14",
            "description": "The code splits the input TFRecord dataset into 10 different TFRecord files, with each file containing a portion of the original dataset based on the specified shard index.",
            "code": "import tensorflow as tf\n\nraw_dataset = tf.data.TFRecordDataset(\"input_file.tfrecord\")\n\nshards = 10\n\nfor i in range(shards):\n    writer = tf.data.experimental.TFRecordWriter(f\"output_file-part-{i}.tfrecord\")\n    writer.write(raw_dataset.shard(shards, i))",
            "masked_code": "import tensorflow as tf\n\n<line_mask>\n\nshards = 10\n\nfor i in range(shards):\n    writer = tf.data.experimental.TFRecordWriter(f\"output_file-part-{i}.tfrecord\")\n    writer.write(raw_dataset.shard(shards, i))",
            "masked_line": "raw_dataset = tf.data.TFRecordDataset(\"input_file.tfrecord\")",
            "answer": "TFRecordDataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_260"
        },
        {
            "dependency": "cryptography",
            "version": "==3.0",
            "time": "2019-02-16",
            "description": "The code generates a PKCS12 key and certificate bundle using the given key, certificates, and password encryption.",
            "code": "from cryptography.hazmat.primitives.serialization.pkcs12 import generate_pkcs12\n\npem_pkcs12 = generate_pkcs12(\n    BestAvailableEncryption(b\"somepassword\"), \n    key, \n    [cert1, cert2]\n)",
            "masked_code": "from cryptography.hazmat.primitives.serialization.pkcs12 import generate_pkcs12\n\n<line_mask>\n    BestAvailableEncryption(b\"somepassword\"), \n    key, \n    [cert1, cert2]\n)",
            "masked_line": "pem_pkcs12 = generate_pkcs12(",
            "answer": "generate_pkcs12",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_261"
        },
        {
            "dependency": "pandas-profiling",
            "version": "==2.4",
            "time": "2020-03-18",
            "description": "The code generates a minimalistic profile report for a pandas DataFrame and saves it as an HTML file named \"output.html\".",
            "code": "from pandas_profiling import ProfileReport\n\n\nprofile = ProfileReport(df, minimal=True)\nprofile.to_file(output_file=\"output.html\")",
            "masked_code": "from pandas_profiling import ProfileReport\n\n\nprofile = ProfileReport(df, minimal=True)\n<line_mask>",
            "masked_line": "profile.to_file(output_file=\"output.html\")",
            "answer": "to_file",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_262"
        },
        {
            "dependency": "ccxt",
            "version": ">1.20.31",
            "time": "2019-12-14",
            "description": "The code initializes a connection to the Binance exchange using the CCXT library, loads the market data, and sets options for trading futures.",
            "code": "import ccxt\nprint('CCXT version:', ccxt.__version__)  # requires CCXT version > 1.20.31\nexchange = ccxt.binance({\n    'apiKey': 'YOUR_API_KEY',\n    'secret': 'YOUR_API_SECRET',\n    'enableRateLimit': True,\n    'options': {\n        'defaultType': 'future',  # -------------- quotes and 'future'\n    },\n})\n\nexchange.load_markets()\n\n# exchange.verbose = True  # uncomment this line if it doesn't work\n\n# your code here...",
            "masked_code": "import ccxt\nprint('CCXT version:', ccxt.__version__)  # requires CCXT version > 1.20.31\nexchange = ccxt.binance({\n    'apiKey': 'YOUR_API_KEY',\n    'secret': 'YOUR_API_SECRET',\n    'enableRateLimit': True,\n    'options': {\n        'defaultType': 'future',  # -------------- quotes and 'future'\n    },\n})\n\n<line_mask>\n\n# exchange.verbose = True  # uncomment this line if it doesn't work\n\n# your code here...",
            "masked_line": "exchange.load_markets()",
            "answer": "load_markets",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_263"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2019-10-16",
            "description": "The code creates a directed graph from a pandas DataFrame where each row represents a parent-child relationship with respective levels. It then identifies the roots of the graph (nodes with parent level 0) and lists their descendants in a new DataFrame.",
            "code": "import networkx as nx\nimport pandas as pd\n\ndata = [['A', 'B', 0, 1],\n        ['B', 'C', 1, 2],\n        ['B', 'D', 1, 2],\n        ['X', 'Y', 0, 2],\n        ['X', 'D', 0, 2],\n        ['Y', 'Z', 2, 3]]\n\ndf = pd.DataFrame(data=data, columns=['parent', 'child', 'parent_level', 'child_level'])\n\nroots = df.parent[df.parent_level.eq(0)].unique()\ndg = nx.from_pandas_edgelist(df, source='parent', target='child', create_using=nx.DiGraph)\n\nresult = pd.DataFrame(data=[[root, nx.descendants(dg, root)] for root in roots], columns=['root', 'children'])\nprint(result)",
            "masked_code": "import networkx as nx\nimport pandas as pd\n\ndata = [['A', 'B', 0, 1],\n        ['B', 'C', 1, 2],\n        ['B', 'D', 1, 2],\n        ['X', 'Y', 0, 2],\n        ['X', 'D', 0, 2],\n        ['Y', 'Z', 2, 3]]\n\ndf = pd.DataFrame(data=data, columns=['parent', 'child', 'parent_level', 'child_level'])\n\nroots = df.parent[df.parent_level.eq(0)].unique()\n<line_mask>\n\nresult = pd.DataFrame(data=[[root, nx.descendants(dg, root)] for root in roots], columns=['root', 'children'])\nprint(result)",
            "masked_line": "dg = nx.from_pandas_edgelist(df, source='parent', target='child', create_using=nx.DiGraph)",
            "answer": "from_pandas_edgelist",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_264"
        },
        {
            "dependency": "pytest",
            "version": "==4.6.3",
            "time": "2019-06-28",
            "description": "This code tests the execution of Python scripts in a specified directory using the runpy module.",
            "code": "# test_spam.py\n\nimport pathlib\nimport runpy\nimport pytest\n\nscripts = pathlib.Path(__file__, '..', 'scripts').resolve().glob('*.py')\n\n\n@pytest.mark.parametrize('script', scripts)\ndef test_script_execution(script):\n    runpy.run_path(script)",
            "masked_code": "# test_spam.py\n\nimport pathlib\nimport runpy\nimport pytest\n\nscripts = pathlib.Path(__file__, '..', 'scripts').resolve().glob('*.py')\n\n\n<line_mask>\ndef test_script_execution(script):\n    runpy.run_path(script)",
            "masked_line": "@pytest.mark.parametrize('script', scripts)",
            "answer": "mark",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_265"
        },
        {
            "dependency": "numba",
            "version": "==0.42",
            "time": "2019-02-07",
            "description": "This code calculates the cumulative sum of elements in a sequence, and adds them to a list with corresponding indices if the running sum exceeds a specified maximum value.",
            "code": "from numba import njit, prange\n\n@njit(parallel=True)\ndef dynamic_cumsum(seq, index, max_value):\n    cumsum = []\n    running = 0\n    for i in prange(len(seq)):\n        if running > max_value:\n            cumsum.append([index[i], running])\n            running = 0\n        running += seq[i] \n    cumsum.append([index[-1], running])\n\n    return cumsum\n\ndynamic_cumsum(np.ones(100), np.arange(100), 10)",
            "masked_code": "from numba import njit, prange\n\n<line_mask>\ndef dynamic_cumsum(seq, index, max_value):\n    cumsum = []\n    running = 0\n    for i in prange(len(seq)):\n        if running > max_value:\n            cumsum.append([index[i], running])\n            running = 0\n        running += seq[i] \n    cumsum.append([index[-1], running])\n\n    return cumsum\n\ndynamic_cumsum(np.ones(100), np.arange(100), 10)",
            "masked_line": "@njit(parallel=True)",
            "answer": "njit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_266"
        },
        {
            "dependency": "plotly",
            "version": "==5.5.0",
            "time": "2022-03-12",
            "description": "The code generates a horizontal bar plot using Plotly Express to visualize the counts of different words in a DataFrame. The y-axis represents the words and the x-axis represents the counts. The y-axis categories are ordered in ascending order based on the total counts.",
            "code": "import plotly.express as px\ndat = pd.DataFrame({'word': ['apple', 'grape', 'orange', 'pear'],\n                     'counts': [20, 5, 25, 10] } )\n\nfig = px.bar(dat, x = 'counts',y='word', orientation='h')\nfig.update_layout(yaxis={'categoryorder':'total ascending'}) # add only this line",
            "masked_code": "import plotly.express as px\ndat = pd.DataFrame({'word': ['apple', 'grape', 'orange', 'pear'],\n                     'counts': [20, 5, 25, 10] } )\n\nfig = px.bar(dat, x = 'counts',y='word', orientation='h')\n<line_mask>",
            "masked_line": "fig.update_layout(yaxis={'categoryorder':'total ascending'}) # add only this line",
            "answer": "update_layout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_267"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-05-26",
            "description": "This code defines a command-line interface using the Click library in Python. It defines a command named 'Colored-Magic' with an option to specify a color. It also defines a Magic class with two attributes, magic_foo and magic_bar, and a method to print them as a string. The code then executes a series of commands, printing the Click version, Python version, and the result of calling the cli function with the specified commands.",
            "code": "import click\n\n@click.command('Colored-Magic')\n@click.option('--color')\n@magic_options\ndef cli(magic, color):\n    click.echo(str(magic))\n    click.echo(color)\n\n\nclass Magic(object):\n    def __init__(self, magic_foo, magic_bar):\n        self.magic_foo = magic_foo\n        self.magic_bar = magic_bar\n\n    def __str__(self):\n        return \"foo: {}  bar: {}\".format(self.magic_foo, self.magic_bar)\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '--magic-foo fooby --magic-bar barbecue',\n        '--magic-foo fooby',\n        '--magic-bar barbecue',\n        '',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\n@click.command('Colored-Magic')\n@click.option('--color')\n@magic_options\ndef cli(magic, color):\n    click.echo(str(magic))\n    <line_mask>\n\n\nclass Magic(object):\n    def __init__(self, magic_foo, magic_bar):\n        self.magic_foo = magic_foo\n        self.magic_bar = magic_bar\n\n    def __str__(self):\n        return \"foo: {}  bar: {}\".format(self.magic_foo, self.magic_bar)\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '--magic-foo fooby --magic-bar barbecue',\n        '--magic-foo fooby',\n        '--magic-bar barbecue',\n        '',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "click.echo(color)",
            "answer": "echo",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_268"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-11",
            "description": "This code converts a list of integers into a categorical format using one-hot encoding, then decodes the one-hot encoded values back into the original integers.",
            "code": "import numpy as np\ny = [0, 1, 2, 0, 4, 5]\nY = to_categorical(y, num_classes=len(y))\nprint(Y)\ny = np.argmax(Y, axis=-1)\nprint(y)\n# [0, 1, 2, 0, 4, 5]",
            "masked_code": "import numpy as np\ny = [0, 1, 2, 0, 4, 5]\nY = to_categorical(y, num_classes=len(y))\nprint(Y)\n<line_mask>\nprint(y)\n# [0, 1, 2, 0, 4, 5]",
            "masked_line": "y = np.argmax(Y, axis=-1)",
            "answer": "argmax",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_269"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-01-17",
            "description": "The code performs binary erosion on the input array 'a', where the erosion is applied using a structuring element of ones with a size of 'n', resulting in an output array of integers.",
            "code": "from scipy.ndimage.morphology import binary_erosion\n\nout = binary_erosion(a==0,np.ones(n),origin=(n-1)//2).astype(int)",
            "masked_code": "<line_mask>\n\nout = binary_erosion(a==0,np.ones(n),origin=(n-1)//2).astype(int)",
            "masked_line": "from scipy.ndimage.morphology import binary_erosion",
            "answer": "binary_erosion",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_270"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-05-17",
            "description": "This code performs linear regression on a set of data points by fitting a polynomial function of degree 2. It generates the scatter plot of the original data points and plots the fitted polynomial curve on top of it.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\nones = np.ones(4)\nxfeature = np.asarray([0,1,2,3])\nsquaredfeature = xfeature ** 2\nb = np.asarray([1,2,0,3])\n\nfeatures = np.concatenate((np.vstack(ones),np.vstack(xfeature),np.vstack(squaredfeature)), axis = 1) # Change - remove the y values\n\ndeterminants = np.linalg.lstsq(features, b)[0] # Change - use least squares\nplt.scatter(xfeature,b)\nu = np.linspace(0,3,100)\nplt.plot(u, u**2*determinants[2] + u*determinants[1] + determinants[0] )\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\nones = np.ones(4)\nxfeature = np.asarray([0,1,2,3])\nsquaredfeature = xfeature ** 2\n<line_mask>\n\nfeatures = np.concatenate((np.vstack(ones),np.vstack(xfeature),np.vstack(squaredfeature)), axis = 1) # Change - remove the y values\n\ndeterminants = np.linalg.lstsq(features, b)[0] # Change - use least squares\nplt.scatter(xfeature,b)\nu = np.linspace(0,3,100)\nplt.plot(u, u**2*determinants[2] + u*determinants[1] + determinants[0] )\nplt.show()",
            "masked_line": "b = np.asarray([1,2,0,3])",
            "answer": "asarray",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_271"
        },
        {
            "dependency": "numba",
            "version": "==0.44",
            "time": "2019-06-05",
            "description": "This code defines a numba jit compiled function named 'func' that takes in a numpy array 'x' and a string 'y'. The function prints the value of 'y' and then returns the input numpy array 'x'.",
            "code": "import numpy as np\nimport numba as nb\n\nfrom numba import types\n\n@nb.jit(nb.float64[:](nb.float64[:], types.unicode_type), nopython=True, cache=True)\ndef func(x, y='cont'):\n    \"\"\"\n    :param x: is np.array, x.shape=(n,)\n    :param y: is a string, \n    :return: a np.array of same shape as x\n    \"\"\"\n    print(y)\n    return x",
            "masked_code": "import numpy as np\nimport numba as nb\n\nfrom numba import types\n\n<line_mask>\ndef func(x, y='cont'):\n    \"\"\"\n    :param x: is np.array, x.shape=(n,)\n    :param y: is a string, \n    :return: a np.array of same shape as x\n    \"\"\"\n    print(y)\n    return x",
            "masked_line": "@nb.jit(nb.float64[:](nb.float64[:], types.unicode_type), nopython=True, cache=True)",
            "answer": "jit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_272"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-06-19",
            "description": "The function of this code is to define a custom SaverBuilder class in TensorFlow for restoring variables from a checkpoint file by casting the restored variables to float32 data type. The bulk_restore method iterates over saveables and their specs to collect information about the variables to restore. It then restores the variables from a checkpoint file with float32 data type and returns the restored variables casted back to their original data types.",
            "code": "import tensorflow as tf\nfrom tensorflow.python.training.saver import BaseSaverBuilder\n\nclass CastFromFloat32SaverBuilder(BaseSaverBuilder):\n  # Based on tensorflow.python.training.saver.BulkSaverBuilder.bulk_restore\n  def bulk_restore(self, filename_tensor, saveables, preferred_shard,\n                   restore_sequentially):\n    from tensorflow.python.ops import io_ops\n    restore_specs = []\n    for saveable in saveables:\n      for spec in saveable.specs:\n        restore_specs.append((spec.name, spec.slice_spec, spec.dtype))\n    names, slices, dtypes = zip(*restore_specs)\n    restore_dtypes = [tf.float32 for _ in dtypes]\n    with tf.device(\"cpu:0\"):\n      restored = io_ops.restore_v2(filename_tensor, names, slices, restore_dtypes)\n      return [tf.cast(r, dt) for r, dt in zip(restored, dtypes)]",
            "masked_code": "import tensorflow as tf\nfrom tensorflow.python.training.saver import BaseSaverBuilder\n\nclass CastFromFloat32SaverBuilder(BaseSaverBuilder):\n  # Based on tensorflow.python.training.saver.BulkSaverBuilder.bulk_restore\n  def bulk_restore(self, filename_tensor, saveables, preferred_shard,\n                   restore_sequentially):\n    from tensorflow.python.ops import io_ops\n    restore_specs = []\n    for saveable in saveables:\n      for spec in saveable.specs:\n        restore_specs.append((spec.name, spec.slice_spec, spec.dtype))\n    names, slices, dtypes = zip(*restore_specs)\n    restore_dtypes = [tf.float32 for _ in dtypes]\n    with tf.device(\"cpu:0\"):\n      <line_mask>\n      return [tf.cast(r, dt) for r, dt in zip(restored, dtypes)]",
            "masked_line": "restored = io_ops.restore_v2(filename_tensor, names, slices, restore_dtypes)",
            "answer": "restore_v2",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_273"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-15",
            "description": "This code generates a bar chart using Bokeh library in Python. The chart displays the values of 'pid' on the y-axis and 'name' on the x-axis. It includes a hover tool that displays additional information such as 'user' and 'pid' when a bar is hovered over.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.models import ColumnDataSource, HoverTool, CustomJS, FactorRange\n\npid = [1, 2, 3, 4, 5, 6]\nuser = ['user1', 'user2', 'user3', 'user4', None, 'user6']\nname = ['name', 'name2', 'name3', 'name4', 'name5', 'name6']\n\nsource = ColumnDataSource(data = dict(pid = pid, user = user, name = name))\n\np = figure(x_range = FactorRange(*name), sizing_mode = 'stretch_both', title = \"Test\", toolbar_location = None, tools = \"\")\np.vbar(x = 'name', top = 'pid', width = 0.2, source = source)\n\ncode = '''  hover.tooltips = [[\"Name\", \"@name\"], [\"PID\", \"@pid\"]];\n            if (cb_data.index.indices.length > 0) { \n                index = cb_data.index.indices[0];\n                counts = source.data.user[index]\n\n                if (counts != null)\n                    hover.tooltips = [[\"Name\", \"@name\"], [\"User\", \"@user\"], [\"PID\", \"@pid\"]];                                       \n            } '''\nhover = HoverTool()\nhover.callback = CustomJS(args = dict(source = source, hover = hover), code = code)\np.add_tools(hover)\n\nshow(p)",
            "masked_code": "from bokeh.plotting import figure, show\n<line_mask>\n\npid = [1, 2, 3, 4, 5, 6]\nuser = ['user1', 'user2', 'user3', 'user4', None, 'user6']\nname = ['name', 'name2', 'name3', 'name4', 'name5', 'name6']\n\nsource = ColumnDataSource(data = dict(pid = pid, user = user, name = name))\n\np = figure(x_range = FactorRange(*name), sizing_mode = 'stretch_both', title = \"Test\", toolbar_location = None, tools = \"\")\np.vbar(x = 'name', top = 'pid', width = 0.2, source = source)\n\ncode = '''  hover.tooltips = [[\"Name\", \"@name\"], [\"PID\", \"@pid\"]];\n            if (cb_data.index.indices.length > 0) { \n                index = cb_data.index.indices[0];\n                counts = source.data.user[index]\n\n                if (counts != null)\n                    hover.tooltips = [[\"Name\", \"@name\"], [\"User\", \"@user\"], [\"PID\", \"@pid\"]];                                       \n            } '''\nhover = HoverTool()\nhover.callback = CustomJS(args = dict(source = source, hover = hover), code = code)\np.add_tools(hover)\n\nshow(p)",
            "masked_line": "from bokeh.models import ColumnDataSource, HoverTool, CustomJS, FactorRange",
            "answer": "CustomJS",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_274"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.1",
            "time": "2019-04-23",
            "description": "This code generates a figure with two subplots displaying sin(x) and cos(x) functions. The code also defines a function called rectspan that plots a rectangle between x1 and x2 on both subplots, connecting them with a vertical line. Finally, it calls the rectspan function with x1=1 and x2=2 to highlight the region between x=1 and x=2 on both plots with a black rectangle.",
            "code": "import matplotlib.pyplot as plt\nfrom matplotlib.patches import ConnectionPatch\nimport numpy as np\n\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=False, sharey=False, figsize=(15,9))\n\nx = 2 * np.pi * np.arange(1000) / 1000 \ny1 = np.sin(x)\ny2 = np.cos(x)\n\nax1.plot(x,y1)\nax2.plot(x,y2)\n\ndef rectspan(x1, x2, ax1, ax2, **kwargs):\n    line1, = ax1.plot([x1, x1, x2, x2],[0,1,1,0], \n                      transform=ax1.get_xaxis_transform(), **kwargs)\n    line2, = ax2.plot([x1, x1, x2, x2],[1,0,0,1], \n                      transform=ax2.get_xaxis_transform(), **kwargs)\n    for x in (x1, x2):\n        p = ConnectionPatch((x,1), (x,0), \n                            coordsA=ax2.get_xaxis_transform(),\n                            coordsB=ax1.get_xaxis_transform(), **kwargs)\n        ax1.add_artist(p)\n\nrectspan(1, 2, ax1, ax2, color=\"k\", linewidth=3)\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nfrom matplotlib.patches import ConnectionPatch\nimport numpy as np\n\n<line_mask>\n\nx = 2 * np.pi * np.arange(1000) / 1000 \ny1 = np.sin(x)\ny2 = np.cos(x)\n\nax1.plot(x,y1)\nax2.plot(x,y2)\n\ndef rectspan(x1, x2, ax1, ax2, **kwargs):\n    line1, = ax1.plot([x1, x1, x2, x2],[0,1,1,0], \n                      transform=ax1.get_xaxis_transform(), **kwargs)\n    line2, = ax2.plot([x1, x1, x2, x2],[1,0,0,1], \n                      transform=ax2.get_xaxis_transform(), **kwargs)\n    for x in (x1, x2):\n        p = ConnectionPatch((x,1), (x,0), \n                            coordsA=ax2.get_xaxis_transform(),\n                            coordsB=ax1.get_xaxis_transform(), **kwargs)\n        ax1.add_artist(p)\n\nrectspan(1, 2, ax1, ax2, color=\"k\", linewidth=3)\nplt.show()",
            "masked_line": "fig, (ax1, ax2) = plt.subplots(2, 1, sharex=False, sharey=False, figsize=(15,9))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_275"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-07-25",
            "description": "This code calculates the number of business days between two given dates.",
            "code": "import pandas as pd\nimport numpy as np\n\ndate1 = \"01/07/2019\"\ndate2 = \"08/07/2019\"\n\ndate1 = pd.to_datetime(date1,format=\"%d/%m/%Y\").date()\ndate2 = pd.to_datetime(date2,format=\"%d/%m/%Y\").date()\n\ndays = np.busday_count( date1 , date2)\nprint(days)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\ndate1 = \"01/07/2019\"\ndate2 = \"08/07/2019\"\n\ndate1 = pd.to_datetime(date1,format=\"%d/%m/%Y\").date()\ndate2 = pd.to_datetime(date2,format=\"%d/%m/%Y\").date()\n\n<line_mask>\nprint(days)",
            "masked_line": "days = np.busday_count( date1 , date2)",
            "answer": "busday_count",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_276"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.3",
            "time": "2021-03-24",
            "description": "This code creates a figure with 3 subplots arranged horizontally, each subplot contains a line plot with x-axis values [1, 2, 3] and a title indicating its index. The figure has an overall title 'suptitle' and the subplots are arranged neatly with tight layout.",
            "code": "import matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(1, 3)\nfor i, ax in enumerate(axs):\n    ax.plot([1, 2, 3])\n    ax.set_title(f'Axes {i}')\n\nfig.suptitle('suptitle')\nfig.tight_layout()",
            "masked_code": "import matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(1, 3)\nfor i, ax in enumerate(axs):\n    ax.plot([1, 2, 3])\n    ax.set_title(f'Axes {i}')\n\n<line_mask>\nfig.tight_layout()",
            "masked_line": "fig.suptitle('suptitle')",
            "answer": "suptitle",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_277"
        },
        {
            "dependency": "dash",
            "version": "==1.19.0",
            "time": "2021-02-20",
            "description": "The code creates a Dash web application with a DataTable displaying a pandas DataFrame. It includes a callback function that displays the value of the active cell in the DataTable when clicked.",
            "code": "# import modules    \nimport json    \nimport pandas as pd    \nimport dash\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\nimport dash_table\n\n# prepare dash_table    \nsize = 5\ndf = pd.DataFrame([], index=range(size))\ndf['num'] = range(size)\ndf['char'] = list('abcdefghijk')[:size]    \ntab = dash_table.DataTable(\n    id='table',\n    columns=[{\"name\": i, \"id\": i} for i in df.columns],\n    data=df.to_dict('records'),\n    tooltip_data=[\n        {\n            # (B) multiply cell value by 10 for demonstration purpose\n            column: {'value': str(value*10), 'type': 'markdown'}\n            for column, value in row.items()\n        } for row in df.to_dict('records')\n    ],\n    tooltip_delay=0,\n    tooltip_duration=None\n)\n\n# set layout    \napp = dash.Dash('SimpleExample')     \napp.layout = html.Div([\n    tab,\n    html.Div(id='click-data', style={'whiteSpace': 'pre-wrap'}),\n\n])\n\n# define callback        \n@app.callback(\n    Output('click-data', 'children'),\n    [Input('table', 'active_cell')],\n     # (A) pass table as data input to get current value from active cell \"coordinates\"\n    [State('table', 'data')]\n)\ndef display_click_data(active_cell, table_data):\n    if active_cell:\n        cell = json.dumps(active_cell, indent=2)    \n        row = active_cell['row']\n        col = active_cell['column_id']\n        value = table_data[row][col]\n        out = '%s\\n%s' % (cell, value)\n    else:\n        out = 'no cell selected'\n    return out\n \n# run app    \nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "# import modules    \nimport json    \nimport pandas as pd    \nimport dash\nimport dash_html_components as html\n<line_mask>\nimport dash_table\n\n# prepare dash_table    \nsize = 5\ndf = pd.DataFrame([], index=range(size))\ndf['num'] = range(size)\ndf['char'] = list('abcdefghijk')[:size]    \ntab = dash_table.DataTable(\n    id='table',\n    columns=[{\"name\": i, \"id\": i} for i in df.columns],\n    data=df.to_dict('records'),\n    tooltip_data=[\n        {\n            # (B) multiply cell value by 10 for demonstration purpose\n            column: {'value': str(value*10), 'type': 'markdown'}\n            for column, value in row.items()\n        } for row in df.to_dict('records')\n    ],\n    tooltip_delay=0,\n    tooltip_duration=None\n)\n\n# set layout    \napp = dash.Dash('SimpleExample')     \napp.layout = html.Div([\n    tab,\n    html.Div(id='click-data', style={'whiteSpace': 'pre-wrap'}),\n\n])\n\n# define callback        \n@app.callback(\n    Output('click-data', 'children'),\n    [Input('table', 'active_cell')],\n     # (A) pass table as data input to get current value from active cell \"coordinates\"\n    [State('table', 'data')]\n)\ndef display_click_data(active_cell, table_data):\n    if active_cell:\n        cell = json.dumps(active_cell, indent=2)    \n        row = active_cell['row']\n        col = active_cell['column_id']\n        value = table_data[row][col]\n        out = '%s\\n%s' % (cell, value)\n    else:\n        out = 'no cell selected'\n    return out\n \n# run app    \nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_line": "from dash.dependencies import Input, Output, State",
            "answer": "State",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_278"
        },
        {
            "dependency": "dash-table",
            "version": "==4.11.2",
            "time": "2021-02-20",
            "description": "This code creates a Dash web application that displays a DataTable with tooltip functionality. Users can click on a cell in the table to get the value of that cell displayed below the table.",
            "code": "# import modules    \nimport json    \nimport pandas as pd    \nimport dash\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\nimport dash_table\n\n# prepare dash_table    \nsize = 5\ndf = pd.DataFrame([], index=range(size))\ndf['num'] = range(size)\ndf['char'] = list('abcdefghijk')[:size]    \ntab = dash_table.DataTable(\n    id='table',\n    columns=[{\"name\": i, \"id\": i} for i in df.columns],\n    data=df.to_dict('records'),\n    tooltip_data=[\n        {\n            # (B) multiply cell value by 10 for demonstration purpose\n            column: {'value': str(value*10), 'type': 'markdown'}\n            for column, value in row.items()\n        } for row in df.to_dict('records')\n    ],\n    tooltip_delay=0,\n    tooltip_duration=None\n)\n\n# set layout    \napp = dash.Dash('SimpleExample')     \napp.layout = html.Div([\n    tab,\n    html.Div(id='click-data', style={'whiteSpace': 'pre-wrap'}),\n\n])\n\n# define callback        \n@app.callback(\n    Output('click-data', 'children'),\n    [Input('table', 'active_cell')],\n     # (A) pass table as data input to get current value from active cell \"coordinates\"\n    [State('table', 'data')]\n)\ndef display_click_data(active_cell, table_data):\n    if active_cell:\n        cell = json.dumps(active_cell, indent=2)    \n        row = active_cell['row']\n        col = active_cell['column_id']\n        value = table_data[row][col]\n        out = '%s\\n%s' % (cell, value)\n    else:\n        out = 'no cell selected'\n    return out\n \n# run app    \nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "# import modules    \nimport json    \nimport pandas as pd    \nimport dash\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\nimport dash_table\n\n# prepare dash_table    \nsize = 5\ndf = pd.DataFrame([], index=range(size))\ndf['num'] = range(size)\ndf['char'] = list('abcdefghijk')[:size]    \n<line_mask>\n    id='table',\n    columns=[{\"name\": i, \"id\": i} for i in df.columns],\n    data=df.to_dict('records'),\n    tooltip_data=[\n        {\n            # (B) multiply cell value by 10 for demonstration purpose\n            column: {'value': str(value*10), 'type': 'markdown'}\n            for column, value in row.items()\n        } for row in df.to_dict('records')\n    ],\n    tooltip_delay=0,\n    tooltip_duration=None\n)\n\n# set layout    \napp = dash.Dash('SimpleExample')     \napp.layout = html.Div([\n    tab,\n    html.Div(id='click-data', style={'whiteSpace': 'pre-wrap'}),\n\n])\n\n# define callback        \n@app.callback(\n    Output('click-data', 'children'),\n    [Input('table', 'active_cell')],\n     # (A) pass table as data input to get current value from active cell \"coordinates\"\n    [State('table', 'data')]\n)\ndef display_click_data(active_cell, table_data):\n    if active_cell:\n        cell = json.dumps(active_cell, indent=2)    \n        row = active_cell['row']\n        col = active_cell['column_id']\n        value = table_data[row][col]\n        out = '%s\\n%s' % (cell, value)\n    else:\n        out = 'no cell selected'\n    return out\n \n# run app    \nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_line": "tab = dash_table.DataTable(",
            "answer": "DataTable",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_279"
        },
        {
            "dependency": "numpy",
            "version": "==1.7.0",
            "time": "2019-12-13",
            "description": "This code generates mesh grids of different dimensions, with the output dimensions transposed from the input dimensions. It starts with 2D mesh grids and then progresses to 3D, 4D, and 5D mesh grids, where the first two output dimensions are transposed from the input while the rest are in input order.",
            "code": "import numpy as np\n\n#specify input dimensions of different lengths to aid in identifying which index dimension belongs to in output\nx = np.linspace(0,60,7)\ny = np.linspace(0,50,6)\nz = np.linspace(0,40,5)\ni = np.linspace(0,30,4)\nj = np.linspace(0,20,3)\n\n#2D mesh grid, output dimensions transposed from input\nxx, yy = np.meshgrid(x,y,indexing='ij')\nprint(xx.shape)\nprint(yy.shape)\n\n#3D mesh grid, first two output dimensions transposed from input\nxx, yy, zz = np.meshgrid(x,y,z,indexing='ij')\nprint(xx.shape)\nprint(yy.shape)\nprint(zz.shape)\n\n#4D meshgrid, first two output dimensions transposed from input, rest are in input order\nxx, yy, zz, ii = np.meshgrid(x,y,z,i,indexing='ij')\nprint(xx.shape)\nprint(yy.shape)\nprint(zz.shape)\nprint(ii.shape)\n\n#5D meshgrid, first two output dimensions transposed from input, rest are in input order\nxx, yy, zz, ii, jj = np.meshgrid(x,y,z,i,j,indexing='ij')\nprint(xx.shape)\nprint(yy.shape)\nprint(zz.shape)\nprint(ii.shape)\nprint(jj.shape)",
            "masked_code": "import numpy as np\n\n#specify input dimensions of different lengths to aid in identifying which index dimension belongs to in output\n<line_mask>\ny = np.linspace(0,50,6)\nz = np.linspace(0,40,5)\ni = np.linspace(0,30,4)\nj = np.linspace(0,20,3)\n\n#2D mesh grid, output dimensions transposed from input\nxx, yy = np.meshgrid(x,y,indexing='ij')\nprint(xx.shape)\nprint(yy.shape)\n\n#3D mesh grid, first two output dimensions transposed from input\nxx, yy, zz = np.meshgrid(x,y,z,indexing='ij')\nprint(xx.shape)\nprint(yy.shape)\nprint(zz.shape)\n\n#4D meshgrid, first two output dimensions transposed from input, rest are in input order\nxx, yy, zz, ii = np.meshgrid(x,y,z,i,indexing='ij')\nprint(xx.shape)\nprint(yy.shape)\nprint(zz.shape)\nprint(ii.shape)\n\n#5D meshgrid, first two output dimensions transposed from input, rest are in input order\nxx, yy, zz, ii, jj = np.meshgrid(x,y,z,i,j,indexing='ij')\nprint(xx.shape)\nprint(yy.shape)\nprint(zz.shape)\nprint(ii.shape)\nprint(jj.shape)",
            "masked_line": "x = np.linspace(0,60,7)",
            "answer": "linspace",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_280"
        },
        {
            "dependency": "scipy",
            "version": "==0.16.0",
            "time": "2019-05-26",
            "description": "This code performs flood fill algorithm in a numpy array 'a' starting from the coordinates 'xy' with a new value 'newval'.",
            "code": "from scipy.ndimage.measurements import label\n\ndef floodfill_by_xy_scipy(a,xy,newval):\n    x,y = xy\n    l = label(a==a[x,y])[0]\n    a[l==l[x,y]] = newval\n    return a",
            "masked_code": "<line_mask>\n\ndef floodfill_by_xy_scipy(a,xy,newval):\n    x,y = xy\n    l = label(a==a[x,y])[0]\n    a[l==l[x,y]] = newval\n    return a",
            "masked_line": "from scipy.ndimage.measurements import label",
            "answer": "label",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_281"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-29",
            "description": "This code generates an interactive line plot using Bokeh library, showing stock prices for AAPL, IBM, MSFT, and GOOG. The plot has a legend that allows the user to hide/show the lines by clicking on the legend entries. The plot is displayed in an HTML file named \"interactive_legend.html\".",
            "code": "import pandas as pd\nfrom bokeh.palettes import Spectral4\nfrom bokeh.plotting import figure, output_file, show\nfrom bokeh.sampledata.stocks import AAPL, IBM, MSFT, GOOG\n\np = figure(plot_width = 800, plot_height = 250, x_axis_type = \"datetime\")\np.title.text = 'Click on legend entries to hide the corresponding lines'\n\nstocks = [\"AAPL\", \"IBM\", \"MSFT\", \"GOOG\"]\nlines = {}\nfor data, name, color in zip([AAPL, IBM, MSFT, GOOG], stocks, Spectral4):\n    df = pd.DataFrame(data)\n    df['date'] = pd.to_datetime(df['date'])\n    lines[name] = p.line(df['date'], df['close'], line_width = 2, color = color, alpha = 0.8, legend = name)\n\nlines[\"AAPL\"].visible = False\n\np.legend.location = \"top_left\"\np.legend.click_policy = \"hide\"\n\noutput_file(\"interactive_legend.html\", title = \"interactive_legend.py example\")\nshow(p)",
            "masked_code": "import pandas as pd\nfrom bokeh.palettes import Spectral4\nfrom bokeh.plotting import figure, output_file, show\nfrom bokeh.sampledata.stocks import AAPL, IBM, MSFT, GOOG\n\n<line_mask>\np.title.text = 'Click on legend entries to hide the corresponding lines'\n\nstocks = [\"AAPL\", \"IBM\", \"MSFT\", \"GOOG\"]\nlines = {}\nfor data, name, color in zip([AAPL, IBM, MSFT, GOOG], stocks, Spectral4):\n    df = pd.DataFrame(data)\n    df['date'] = pd.to_datetime(df['date'])\n    lines[name] = p.line(df['date'], df['close'], line_width = 2, color = color, alpha = 0.8, legend = name)\n\nlines[\"AAPL\"].visible = False\n\np.legend.location = \"top_left\"\np.legend.click_policy = \"hide\"\n\noutput_file(\"interactive_legend.html\", title = \"interactive_legend.py example\")\nshow(p)",
            "masked_line": "p = figure(plot_width = 800, plot_height = 250, x_axis_type = \"datetime\")",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_282"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.0.2",
            "time": "2019-01-24",
            "description": "The code generates a plot of y = x^2 from x = 0 to x = 1000, and formats the y-axis ticks in scientific notation with matplotlib.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nplt.figure()\nx = np.linspace(0,1000)\ny = x**2\nplt.plot(x,y)\nplt.gca().yaxis.set_major_formatter(plt.ScalarFormatter(useMathText=True))\nplt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nplt.figure()\nx = np.linspace(0,1000)\ny = x**2\nplt.plot(x,y)\n<line_mask>\nplt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))\nplt.show()",
            "masked_line": "plt.gca().yaxis.set_major_formatter(plt.ScalarFormatter(useMathText=True))",
            "answer": "ScalarFormatter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_283"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-05-23",
            "description": "This code creates a Bokeh interactive dashboard with two dropdown menus. The first dropdown menu allows users to select a country, and the second dropdown menu dynamically changes to display cities from the selected country.",
            "code": "from bokeh.io import curdoc\nfrom bokeh.models import Select, Column\nimport pandas as pd\n\ndf = pd.DataFrame()\ndf['France'] = ['Paris', 'Lione', 'Marseille']\ndf['Italy'] = ['Rome','Milan', 'Rimini']\ndf['Spain'] = ['Madrid', 'Barcelona', 'Bilbao']\ndf['Country']   = ['France', 'Italy', 'Spain']\n\nselect_country = Select(title=\"Country\",  options=list(df['Country']), value = 'France')\nselect_city = Select(title = 'Cities', value = 'Paris', options = list(df['France']))\n\ndef update_layout(attr, old, new):\n    country_selected = select_country.value\n    select_city.options = list(df[country_selected].values)\n\nselect_country.on_change('value', update_layout)\nselect_city.on_change('value', update_layout)\nlayout = Column(select_country, select_city)\ncurdoc().add_root(layout)",
            "masked_code": "from bokeh.io import curdoc\n<line_mask>\nimport pandas as pd\n\ndf = pd.DataFrame()\ndf['France'] = ['Paris', 'Lione', 'Marseille']\ndf['Italy'] = ['Rome','Milan', 'Rimini']\ndf['Spain'] = ['Madrid', 'Barcelona', 'Bilbao']\ndf['Country']   = ['France', 'Italy', 'Spain']\n\nselect_country = Select(title=\"Country\",  options=list(df['Country']), value = 'France')\nselect_city = Select(title = 'Cities', value = 'Paris', options = list(df['France']))\n\ndef update_layout(attr, old, new):\n    country_selected = select_country.value\n    select_city.options = list(df[country_selected].values)\n\nselect_country.on_change('value', update_layout)\nselect_city.on_change('value', update_layout)\nlayout = Column(select_country, select_city)\ncurdoc().add_root(layout)",
            "masked_line": "from bokeh.models import Select, Column",
            "answer": "Select",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_284"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-17",
            "description": "The code generates a Bokeh plot showing the adjusted closing price and volume of a stock (in this case, AAPL stock) over time. The plot includes a line graph for adjusted close price, with hover tooltips displaying the date, adjusted close price, and volume for each data point.",
            "code": "import numpy as np\nfrom bokeh.io import output_file, show\nfrom bokeh.models import ColumnDataSource, HoverTool\nfrom bokeh.plotting import figure\nfrom bokeh.sampledata.stocks import AAPL\n\ndef datetime(x):\n    return np.array(x, dtype = np.datetime64)\n\nsource = ColumnDataSource(data = {'date'      : datetime(AAPL['date'][::10]),\n                                  'adj close' : AAPL['adj_close'][::10],\n                                  'volume'    : AAPL['volume'][::10]})\n\np = figure(plot_height = 250, x_axis_type = \"datetime\", sizing_mode = \"scale_width\")\n\np.background_fill_color = \"#f5f5f5\"\np.grid.grid_line_color = \"white\"\np.xaxis.axis_label = 'Date'\np.yaxis.axis_label = 'Price'\np.axis.axis_line_color = None\n\np.line(x = 'date', y = 'adj close', line_width = 2, color = '#ebbd5b', source = source)\n\nhover = HoverTool(mode = 'vline')\nhover.tooltips = [('date', '@date{%F}'), ('close', '$@{adj close}{%0.2f}'), ('volume', '@volume{0.00 a}')]\nhover.formatters = {'date': 'datetime', 'adj close' : 'printf'}\np.add_tools(hover)\n\nshow(p)",
            "masked_code": "import numpy as np\nfrom bokeh.io import output_file, show\n<line_mask>\nfrom bokeh.plotting import figure\nfrom bokeh.sampledata.stocks import AAPL\n\ndef datetime(x):\n    return np.array(x, dtype = np.datetime64)\n\nsource = ColumnDataSource(data = {'date'      : datetime(AAPL['date'][::10]),\n                                  'adj close' : AAPL['adj_close'][::10],\n                                  'volume'    : AAPL['volume'][::10]})\n\np = figure(plot_height = 250, x_axis_type = \"datetime\", sizing_mode = \"scale_width\")\n\np.background_fill_color = \"#f5f5f5\"\np.grid.grid_line_color = \"white\"\np.xaxis.axis_label = 'Date'\np.yaxis.axis_label = 'Price'\np.axis.axis_line_color = None\n\np.line(x = 'date', y = 'adj close', line_width = 2, color = '#ebbd5b', source = source)\n\nhover = HoverTool(mode = 'vline')\nhover.tooltips = [('date', '@date{%F}'), ('close', '$@{adj close}{%0.2f}'), ('volume', '@volume{0.00 a}')]\nhover.formatters = {'date': 'datetime', 'adj close' : 'printf'}\np.add_tools(hover)\n\nshow(p)",
            "masked_line": "from bokeh.models import ColumnDataSource, HoverTool",
            "answer": "HoverTool",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_285"
        },
        {
            "dependency": "requests",
            "version": "==2.21.0",
            "time": "2019-02-14",
            "description": "The code retrieves all the href links of products listed on Amazon under a specific category.",
            "code": "import requests\nimport lxml, lxml.html\n\nurl = 'https://www.amazon.com/s/ref=lp_266162_nr_n_0?fst=as%3Aoff&rh=n%3A283155%2Cn%3A%211000%2Cn%3A1%2Cn%3A173508%2Cn%3A266162%2Cn%3A3564986011&bbn=266162&ie=UTF8&qid=1550120216&rnid=266162'\nr = requests.get(url)\nhtml = lxml.html.fromstring(r.content)\nlinks = html.cssselect('.a-fixed-left-grid-col .a-col-left a')\nfor link in links:\n    print(link.attrib['href'])",
            "masked_code": "import requests\nimport lxml, lxml.html\n\nurl = 'https://www.amazon.com/s/ref=lp_266162_nr_n_0?fst=as%3Aoff&rh=n%3A283155%2Cn%3A%211000%2Cn%3A1%2Cn%3A173508%2Cn%3A266162%2Cn%3A3564986011&bbn=266162&ie=UTF8&qid=1550120216&rnid=266162'\n<line_mask>\nhtml = lxml.html.fromstring(r.content)\nlinks = html.cssselect('.a-fixed-left-grid-col .a-col-left a')\nfor link in links:\n    print(link.attrib['href'])",
            "masked_line": "r = requests.get(url)",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_286"
        },
        {
            "dependency": "lxml",
            "version": "==4.3.1",
            "time": "2019-02-14",
            "description": "The code is fetching a webpage from Amazon and extracting all the links from the specified CSS selectors in the HTML content of the webpage. Finally, it prints out the href attribute value of each extracted link.",
            "code": "import requests\nimport lxml, lxml.html\n\nurl = 'https://www.amazon.com/s/ref=lp_266162_nr_n_0?fst=as%3Aoff&rh=n%3A283155%2Cn%3A%211000%2Cn%3A1%2Cn%3A173508%2Cn%3A266162%2Cn%3A3564986011&bbn=266162&ie=UTF8&qid=1550120216&rnid=266162'\nr = requests.get(url)\nhtml = lxml.html.fromstring(r.content)\nlinks = html.cssselect('.a-fixed-left-grid-col .a-col-left a')\nfor link in links:\n    print(link.attrib['href'])",
            "masked_code": "import requests\nimport lxml, lxml.html\n\nurl = 'https://www.amazon.com/s/ref=lp_266162_nr_n_0?fst=as%3Aoff&rh=n%3A283155%2Cn%3A%211000%2Cn%3A1%2Cn%3A173508%2Cn%3A266162%2Cn%3A3564986011&bbn=266162&ie=UTF8&qid=1550120216&rnid=266162'\nr = requests.get(url)\n<line_mask>\nlinks = html.cssselect('.a-fixed-left-grid-col .a-col-left a')\nfor link in links:\n    print(link.attrib['href'])",
            "masked_line": "html = lxml.html.fromstring(r.content)",
            "answer": "fromstring",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_287"
        },
        {
            "dependency": "torch",
            "version": "==1.0",
            "time": "2019-01-10",
            "description": "The code defines a neural network model (actor) with 3 linear layers along with ReLU activation functions in between, and a softmax function at the end. The model takes an input of size 9 and outputs a vector of size 27.",
            "code": "import torch\n\nactor = torch.nn.Sequential(\n    torch.nn.Linear(9, 20), # output shape has to be specified\n    torch.nn.ReLU(),\n    torch.nn.Linear(20, 20), # same goes over here\n    torch.nn.ReLU(),\n    torch.nn.Linear(20, 27), # and here\n    torch.nn.Softmax(),\n)\n\nprint(actor)",
            "masked_code": "import torch\n\nactor = torch.nn.Sequential(\n    torch.nn.Linear(9, 20), # output shape has to be specified\n    torch.nn.ReLU(),\n    torch.nn.Linear(20, 20), # same goes over here\n    torch.nn.ReLU(),\n    torch.nn.Linear(20, 27), # and here\n    <line_mask>\n)\n\nprint(actor)",
            "masked_line": "torch.nn.Softmax(),",
            "answer": "nn",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_288"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-03",
            "description": "This code returns the n nearest points to a given point (x, y) from a list of points.",
            "code": "import numpy as np\n\ndef get_nearest_point(x, y, n):\n\n    dist = [Distance(point[0], point[1], x, y) for point in points]\n    indices = np.argsort(dist)\n    return [points[i] for i in indices[:n]]",
            "masked_code": "import numpy as np\n\ndef get_nearest_point(x, y, n):\n\n    dist = [Distance(point[0], point[1], x, y) for point in points]\n    <line_mask>\n    return [points[i] for i in indices[:n]]",
            "masked_line": "indices = np.argsort(dist)",
            "answer": "argsort",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_289"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.1",
            "time": "2019-10-23",
            "description": "The code splits the values in the 'Column in question' column by ';' and expands the DataFrame to have one row for each split value. It then calculates the adjusted 'Quantity' by dividing the original quantity by the number of split values for each row.",
            "code": "import pandas as pd\nimport numpy as np\n\n\ndf = pd.DataFrame({'Quantity':[6,50,25,4]\n                  ,'Column in question':['1;2;3;4;5;6','','','7;8;9;10']\n                  ,'Price':['$1.00','$10.00','$0.10','$25.00']\n                  ,'Invoice Close Date':['9/3/2019','9/27/2019','9/18/2019','9/30/2019']})\n\ndf_out = df.assign(ciq=df['Column in question'].str.split(';')).explode('ciq')\\\n           .drop('Column in question', axis=1)\\\n           .rename(columns={'ciq':'Column in question'})\n\ndf_out['Quantity'] = (df_out['Quantity'] / df_out.groupby(level=0)['Quantity'].transform('size'))\n\ndf_out",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n\ndf = pd.DataFrame({'Quantity':[6,50,25,4]\n                  ,'Column in question':['1;2;3;4;5;6','','','7;8;9;10']\n                  ,'Price':['$1.00','$10.00','$0.10','$25.00']\n                  ,'Invoice Close Date':['9/3/2019','9/27/2019','9/18/2019','9/30/2019']})\n\n<line_mask>\n           .drop('Column in question', axis=1)\\\n           .rename(columns={'ciq':'Column in question'})\n\ndf_out['Quantity'] = (df_out['Quantity'] / df_out.groupby(level=0)['Quantity'].transform('size'))\n\ndf_out",
            "masked_line": "df_out = df.assign(ciq=df['Column in question'].str.split(';')).explode('ciq')\\",
            "answer": "explode",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_290"
        },
        {
            "dependency": "Flask",
            "version": "==0.10.1",
            "time": "2019-12-12",
            "description": "This code sets up a Flask web application with two routes: '/ping' returns an empty string and '/invocations' returns the message \"should do inference with your model here\". When the code is executed, the Flask application runs in debug mode on host '0.0.0.0' and port 8080.",
            "code": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/ping')\ndef ping():\n    return ''\n\n@app.route('/invocations')\ndef invoke():\n    return 'should do inference with your model here'\n\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0', port=8080)",
            "masked_code": "<line_mask>\napp = Flask(__name__)\n\n@app.route('/ping')\ndef ping():\n    return ''\n\n@app.route('/invocations')\ndef invoke():\n    return 'should do inference with your model here'\n\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0', port=8080)",
            "masked_line": "from flask import Flask, request",
            "answer": "Flask",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_291"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-05-02",
            "description": "The code generates a Bokeh plot with hexagonal tiles based on the data provided. Each tile is colored according to a specified color array. Additionally, the code defines a JavaScript callback function that changes the color of tiles when hovered over based on the ipc_class attribute of the data. Finally, the plot is displayed in an HTML file named \"hexbin.html\".",
            "code": "from bokeh.plotting import figure, show, output_file\nfrom bokeh.models import ColumnDataSource, CustomJS, HoverTool\n\ncolors_array = [\"green\", \"green\", \"blue\", \"blue\"]\nx_row = [0, 1, 2, 3]\ny_col = [1, 1, 1, 1]\nipc_array = ['A', 'B', 'A', 'B']\n\nsource = ColumnDataSource(data = dict(\n    x = x_row,\n    y = y_col,\n    color = colors_array,\n    ipc_class = ipc_array\n))\n\np = figure(plot_width = 800, plot_height = 800, title = \"Ipc to Square with colors\", match_aspect = True,\n           tools = \"wheel_zoom,reset,pan\", background_fill_color = '#440154')\np.grid.visible = False\np.hex_tile('x', 'y', source = source, fill_color = 'color')\n\n###################################\ncode = ''' \nfor (let i in cb_data.renderer.data_source.data['color'])\n    cb_data.renderer.data_source.data['color'][i] = colors[i];\n\nif (cb_data.index.indices != null) {\n    const hovered_index = cb_data.index.indices[0];\n    const hovered_ipc_class = cb_data.renderer.data_source.data['ipc_class'][hovered_index];\n    for (let i = 0; i < cb_data.renderer.data_source.data['ipc_class'].length; i++) {\n        if (cb_data.renderer.data_source.data['ipc_class'][i] == hovered_ipc_class)\n            cb_data.renderer.data_source.data['color'][i] = 'pink';\n    }\n}\ncb_data.renderer.data_source.change.emit();\n'''\n\nTOOLTIPS = [\n    (\"index\", \"$index\"),\n    (\"(x,y)\", \"(@x, @y)\"),\n    (\"ipc_class\", \"@ipc_class\")\n]\n\ncallback = CustomJS(args = dict(ipc_array = ipc_array, colors = colors_array), code = code)\nhover = HoverTool(tooltips = TOOLTIPS, callback = callback)\np.add_tools(hover)\n########################################\n\noutput_file(\"hexbin.html\")\n\nshow(p)",
            "masked_code": "from bokeh.plotting import figure, show, output_file\nfrom bokeh.models import ColumnDataSource, CustomJS, HoverTool\n\ncolors_array = [\"green\", \"green\", \"blue\", \"blue\"]\nx_row = [0, 1, 2, 3]\ny_col = [1, 1, 1, 1]\nipc_array = ['A', 'B', 'A', 'B']\n\nsource = ColumnDataSource(data = dict(\n    x = x_row,\n    y = y_col,\n    color = colors_array,\n    ipc_class = ipc_array\n))\n\np = figure(plot_width = 800, plot_height = 800, title = \"Ipc to Square with colors\", match_aspect = True,\n           tools = \"wheel_zoom,reset,pan\", background_fill_color = '#440154')\np.grid.visible = False\n<line_mask>\n\n###################################\ncode = ''' \nfor (let i in cb_data.renderer.data_source.data['color'])\n    cb_data.renderer.data_source.data['color'][i] = colors[i];\n\nif (cb_data.index.indices != null) {\n    const hovered_index = cb_data.index.indices[0];\n    const hovered_ipc_class = cb_data.renderer.data_source.data['ipc_class'][hovered_index];\n    for (let i = 0; i < cb_data.renderer.data_source.data['ipc_class'].length; i++) {\n        if (cb_data.renderer.data_source.data['ipc_class'][i] == hovered_ipc_class)\n            cb_data.renderer.data_source.data['color'][i] = 'pink';\n    }\n}\ncb_data.renderer.data_source.change.emit();\n'''\n\nTOOLTIPS = [\n    (\"index\", \"$index\"),\n    (\"(x,y)\", \"(@x, @y)\"),\n    (\"ipc_class\", \"@ipc_class\")\n]\n\ncallback = CustomJS(args = dict(ipc_array = ipc_array, colors = colors_array), code = code)\nhover = HoverTool(tooltips = TOOLTIPS, callback = callback)\np.add_tools(hover)\n########################################\n\noutput_file(\"hexbin.html\")\n\nshow(p)",
            "masked_line": "p.hex_tile('x', 'y', source = source, fill_color = 'color')",
            "answer": "hex_tile",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_292"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-04-08",
            "description": "This code generates a scatter plot using Bokeh library to visualize the count of subjects within different temperature ranges. The size and color of the scatter points represent the scaled count values. It also includes a color bar legend for reference.",
            "code": "import pandas as pd\nfrom bokeh.plotting import show, figure\nfrom bokeh.models import ColumnDataSource, LinearColorMapper, ColorBar, BasicTicker, PrintfTickFormatter, HoverTool\nfrom bokeh.palettes import Viridis256\nfrom bokeh.transform import transform\n\nscale = 10\nd = {'T_range': ['0-50', '0-50', '0-50', '0-50',\n                 '51-60', '51-60', '51-60', '51-60',\n                 '61-70', '61-70', '61-70', '61-70'],\n     'Subject': ['English', 'Maths', 'Chinese', 'Arts',\n                 'English', 'Maths', 'Chinese', 'Arts',\n                'English', 'Maths', 'Chinese', 'Arts'],\n     'count': [603, 240, 188, 89,\n               220, 118, 112, 43,\n              123, 2342, 32, 212],\n     'count_scaled': [603 / scale, 240 / scale, 188 / scale, 89 / scale,\n           220 / scale, 118 / scale, 112 / scale, 43 / scale,\n          123 / scale, 2342 / scale, 32 / scale, 212 / scale]}\n\ndf = pd.DataFrame(data = d)\nsource = ColumnDataSource(df)\np = figure(x_range = df['T_range'].unique(), y_range = df['Subject'].unique())\n\ncolor_mapper = LinearColorMapper(palette = Viridis256, low = df['count'].min(), high = df['count'].max())\ncolor_bar = ColorBar(color_mapper = color_mapper,\n                     location = (0, 0),\n                     ticker = BasicTicker())\np.add_layout(color_bar, 'right')\np.scatter(x = 'T_range', y = 'Subject', size = 'count_scaled', legend = None, fill_color = transform('count', color_mapper), source = source)\np.add_tools(HoverTool(tooltips = [('Count', '@count')]))\nshow(p)",
            "masked_code": "import pandas as pd\nfrom bokeh.plotting import show, figure\nfrom bokeh.models import ColumnDataSource, LinearColorMapper, ColorBar, BasicTicker, PrintfTickFormatter, HoverTool\nfrom bokeh.palettes import Viridis256\n<line_mask>\n\nscale = 10\nd = {'T_range': ['0-50', '0-50', '0-50', '0-50',\n                 '51-60', '51-60', '51-60', '51-60',\n                 '61-70', '61-70', '61-70', '61-70'],\n     'Subject': ['English', 'Maths', 'Chinese', 'Arts',\n                 'English', 'Maths', 'Chinese', 'Arts',\n                'English', 'Maths', 'Chinese', 'Arts'],\n     'count': [603, 240, 188, 89,\n               220, 118, 112, 43,\n              123, 2342, 32, 212],\n     'count_scaled': [603 / scale, 240 / scale, 188 / scale, 89 / scale,\n           220 / scale, 118 / scale, 112 / scale, 43 / scale,\n          123 / scale, 2342 / scale, 32 / scale, 212 / scale]}\n\ndf = pd.DataFrame(data = d)\nsource = ColumnDataSource(df)\np = figure(x_range = df['T_range'].unique(), y_range = df['Subject'].unique())\n\ncolor_mapper = LinearColorMapper(palette = Viridis256, low = df['count'].min(), high = df['count'].max())\ncolor_bar = ColorBar(color_mapper = color_mapper,\n                     location = (0, 0),\n                     ticker = BasicTicker())\np.add_layout(color_bar, 'right')\np.scatter(x = 'T_range', y = 'Subject', size = 'count_scaled', legend = None, fill_color = transform('count', color_mapper), source = source)\np.add_tools(HoverTool(tooltips = [('Count', '@count')]))\nshow(p)",
            "masked_line": "from bokeh.transform import transform",
            "answer": "transform",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_293"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-19",
            "description": "The code creates a Bokeh plot with circles on one figure and lines with circles on another figure. The tooltip functionality is added to the plot, and when hovering over the circles on the first figure, the corresponding lines and circles on the second figure are updated based on the hovered data points.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.layouts import gridplot, Row\nfrom bokeh.models import ColumnDataSource, CDSView, BooleanFilter, CustomJS, BoxSelectTool, HoverTool\nimport pandas as pd\n\ndata = {'x': [1, 2, 3],\n        'y':[1, 2, 3],\n        'xs':[[9, 8, 7], [6, 5, 4], [3, 2, 1]],\n        'ys':[[29, 28, 29], [27, 28, 27], [25, 25, 20]]}\nsource = ColumnDataSource(data)\nplot = figure(title = 'PLOT IN HOVER TOOLTIP', tools = '')\ncircles = plot.circle('x', 'y', size = 20, source = source)\n\nplot_tooltip = figure(name = 'plot_tooltip', plot_width = 200, plot_height = 200, x_axis_location = None, y_axis_location = None, title = None, tools = 'hover', tooltips = [(\"x\", \"@x\"), (\"y\", \"@y\")], toolbar_location = None)\nlines = plot_tooltip.line('x', 'y', source = ColumnDataSource({'x': [], 'y': []}))\ncircles2 = plot_tooltip.circle('x', 'y', source = ColumnDataSource({'x': [], 'y': []}))\n\ncode = \"\"\"  \nvar indices = cb_data.index['1d'].indices;\nif (indices.length > 0){\n    if(plot_tooltip.x_range.bounds == null)\n    {\n        Bokeh.documents[0].add_root(plot_tooltip)\n    }\n    const idx = indices[0]\n    lines.data_source.data['x'] = source.data['xs'][idx]\n    lines.data_source.data['y'] = source.data['ys'][idx]\n    lines.data_source.change.emit();\n\n    circles.data_source.data['x'] = source.data['xs'][idx]\n    circles.data_source.data['y'] = source.data['ys'][idx]\n    circles.data_source.change.emit();  \n\n    div = document.getElementsByClassName('bk-root')[1];\n    div.style = \"position:absolute; left:\" + cb_data.geometry['sx'] + \"px; top:\" + cb_data.geometry['sy'] + \"px;\";              \n} \"\"\"\n\ncallback = CustomJS(args = dict(source = source, lines = lines, circles = circles2, plot_tooltip = plot_tooltip), code = code)\n\nhover = HoverTool()\nhover.callback = callback\nhover.tooltips = None\nhover.renderers = [circles]\nplot.add_tools(hover)\n\nshow(plot)",
            "masked_code": "<line_mask>\nfrom bokeh.layouts import gridplot, Row\nfrom bokeh.models import ColumnDataSource, CDSView, BooleanFilter, CustomJS, BoxSelectTool, HoverTool\nimport pandas as pd\n\ndata = {'x': [1, 2, 3],\n        'y':[1, 2, 3],\n        'xs':[[9, 8, 7], [6, 5, 4], [3, 2, 1]],\n        'ys':[[29, 28, 29], [27, 28, 27], [25, 25, 20]]}\nsource = ColumnDataSource(data)\nplot = figure(title = 'PLOT IN HOVER TOOLTIP', tools = '')\ncircles = plot.circle('x', 'y', size = 20, source = source)\n\nplot_tooltip = figure(name = 'plot_tooltip', plot_width = 200, plot_height = 200, x_axis_location = None, y_axis_location = None, title = None, tools = 'hover', tooltips = [(\"x\", \"@x\"), (\"y\", \"@y\")], toolbar_location = None)\nlines = plot_tooltip.line('x', 'y', source = ColumnDataSource({'x': [], 'y': []}))\ncircles2 = plot_tooltip.circle('x', 'y', source = ColumnDataSource({'x': [], 'y': []}))\n\ncode = \"\"\"  \nvar indices = cb_data.index['1d'].indices;\nif (indices.length > 0){\n    if(plot_tooltip.x_range.bounds == null)\n    {\n        Bokeh.documents[0].add_root(plot_tooltip)\n    }\n    const idx = indices[0]\n    lines.data_source.data['x'] = source.data['xs'][idx]\n    lines.data_source.data['y'] = source.data['ys'][idx]\n    lines.data_source.change.emit();\n\n    circles.data_source.data['x'] = source.data['xs'][idx]\n    circles.data_source.data['y'] = source.data['ys'][idx]\n    circles.data_source.change.emit();  \n\n    div = document.getElementsByClassName('bk-root')[1];\n    div.style = \"position:absolute; left:\" + cb_data.geometry['sx'] + \"px; top:\" + cb_data.geometry['sy'] + \"px;\";              \n} \"\"\"\n\ncallback = CustomJS(args = dict(source = source, lines = lines, circles = circles2, plot_tooltip = plot_tooltip), code = code)\n\nhover = HoverTool()\nhover.callback = callback\nhover.tooltips = None\nhover.renderers = [circles]\nplot.add_tools(hover)\n\nshow(plot)",
            "masked_line": "from bokeh.plotting import figure, show",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_294"
        },
        {
            "dependency": "astropy",
            "version": "==3.1",
            "time": "2019-02-15",
            "description": "The code imports a FITS image of the HorseHead nebula, extracts header information and image data from the FITS file. It then uses the WCS class to obtain coordinate information and projection axes, creates axes using the EllipticalFrame class, adds the FITS image to the plot, and overlays a grid on the plot with gridlines in white color and dotted style.",
            "code": "import matplotlib.pyplot as plt\nfrom astropy.utils.data import get_pkg_data_filename\nfrom astropy.io import fits\nfrom astropy.wcs import WCS\nfrom astropy.visualization.wcsaxes.frame import EllipticalFrame\n\nimage_file = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\nimage_header = fits.open(image_file)[0].header  # extract header info\nimage_data = fits.getdata(image_file, ext=0)\n\n# use the WCS class to get coordinate info and projection axes to use\nwcs = WCS(image_header)\n\n# make the axes using the EllipticalFrame class\nax = plt.subplot(projection=wcs, frame_class=EllipticalFrame)\n\n# add the image\nim = ax.imshow(image_data, origin='lower')\n\n# add a grid\noverlay = ax.get_coords_overlay('fk5')\noverlay.grid(color='white', ls='dotted')",
            "masked_code": "import matplotlib.pyplot as plt\nfrom astropy.utils.data import get_pkg_data_filename\nfrom astropy.io import fits\nfrom astropy.wcs import WCS\nfrom astropy.visualization.wcsaxes.frame import EllipticalFrame\n\nimage_file = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\n<line_mask>\nimage_data = fits.getdata(image_file, ext=0)\n\n# use the WCS class to get coordinate info and projection axes to use\nwcs = WCS(image_header)\n\n# make the axes using the EllipticalFrame class\nax = plt.subplot(projection=wcs, frame_class=EllipticalFrame)\n\n# add the image\nim = ax.imshow(image_data, origin='lower')\n\n# add a grid\noverlay = ax.get_coords_overlay('fk5')\noverlay.grid(color='white', ls='dotted')",
            "masked_line": "image_header = fits.open(image_file)[0].header  # extract header info",
            "answer": "open",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_295"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.0.2",
            "time": "2019-02-15",
            "description": "This code creates a plot with an image of the HorseHead nebula from a FITS file. It extracts header information and image data from the file, uses the WCS class to get coordinate information and projection axes, creates axes using the EllipticalFrame class, adds the image to the plot, and overlays a grid with white dotted lines on the plot.",
            "code": "import matplotlib.pyplot as plt\nfrom astropy.utils.data import get_pkg_data_filename\nfrom astropy.io import fits\nfrom astropy.wcs import WCS\nfrom astropy.visualization.wcsaxes.frame import EllipticalFrame\n\nimage_file = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\nimage_header = fits.open(image_file)[0].header  # extract header info\nimage_data = fits.getdata(image_file, ext=0)\n\n# use the WCS class to get coordinate info and projection axes to use\nwcs = WCS(image_header)\n\n# make the axes using the EllipticalFrame class\nax = plt.subplot(projection=wcs, frame_class=EllipticalFrame)\n\n# add the image\nim = ax.imshow(image_data, origin='lower')\n\n# add a grid\noverlay = ax.get_coords_overlay('fk5')\noverlay.grid(color='white', ls='dotted')",
            "masked_code": "import matplotlib.pyplot as plt\nfrom astropy.utils.data import get_pkg_data_filename\nfrom astropy.io import fits\nfrom astropy.wcs import WCS\nfrom astropy.visualization.wcsaxes.frame import EllipticalFrame\n\nimage_file = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\nimage_header = fits.open(image_file)[0].header  # extract header info\nimage_data = fits.getdata(image_file, ext=0)\n\n# use the WCS class to get coordinate info and projection axes to use\nwcs = WCS(image_header)\n\n# make the axes using the EllipticalFrame class\nax = plt.subplot(projection=wcs, frame_class=EllipticalFrame)\n\n# add the image\nim = ax.imshow(image_data, origin='lower')\n\n# add a grid\n<line_mask>\noverlay.grid(color='white', ls='dotted')",
            "masked_line": "overlay = ax.get_coords_overlay('fk5')",
            "answer": "get_coords_overlay",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_296"
        },
        {
            "dependency": "dash",
            "version": "==1.6.0",
            "time": "2019-11-17",
            "description": "This code creates a Dash web application with two tabs. The first tab displays two dropdown menus where the options are defined by the values in the `myList` and `myDict` variables. The default values for the dropdown menus are set to the values of `default_category` and `default_index`. The second tab does not have any content. Users can switch between tabs by clicking on the tab headers. When the user selects a value in the first dropdown menu, the options in the second dropdown menu will update accordingly.",
            "code": "import dash\nimport dash_html_components as html\nimport dash_core_components as dcc\n\nexternal_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\n\nmyList = ['A', 'B']\nmyDict = {'A': [1,2,3],'B': [4,5,6] }\ndefault_category = 'A'\ndefault_index = 0\n\ntab1 = html.Div([\n    html.H3('Tab content 1'),\n    dcc.Dropdown(id='first-dropdown',\n                 options=[{'label':l, 'value':l} for l in myList],\n                 value = default_category\n    ),\n    dcc.Dropdown(id='second-dropdown',\n                 options=[{'label':l, 'value':l} for l in myDict[default_category]],\n                 value = myDict[default_category][default_index]\n    )\n])\n\ntab2 = html.Div([\n    html.H3('Tab content 2'),\n])    \n\napp.layout = html.Div([\n    html.H1('Dash Tabs component demo'),\n    dcc.Tabs(id=\"tabs-example\", value='tab-1-example', children=[\n        dcc.Tab(id=\"tab-1\", label='Tab One', value='tab-1-example'),\n        dcc.Tab(id=\"tab-2\", label='Tab Two', value='tab-2-example'),\n    ]),\n    html.Div(id='tabs-content-example',\n             children = tab1)\n])\n\n@app.callback(dash.dependencies.Output('tabs-content-example', 'children'),\n             [dash.dependencies.Input('tabs-example', 'value')])\ndef render_content(tab):\n    if tab == 'tab-1-example':\n        return tab1\n    elif tab == 'tab-2-example':\n        return tab2\n\n@app.callback(\n    [dash.dependencies.Output('second-dropdown', 'options'),\n     dash.dependencies.Output('second-dropdown', 'value')],\n    [dash.dependencies.Input('first-dropdown', 'value')])\ndef update_dropdown(value):\n    return [[ {'label': i, 'value': i} for i in myDict[value] ], myDict[value][default_index]]\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "import dash\nimport dash_html_components as html\nimport dash_core_components as dcc\n\nexternal_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\n\nmyList = ['A', 'B']\nmyDict = {'A': [1,2,3],'B': [4,5,6] }\ndefault_category = 'A'\ndefault_index = 0\n\ntab1 = html.Div([\n    html.H3('Tab content 1'),\n    dcc.Dropdown(id='first-dropdown',\n                 options=[{'label':l, 'value':l} for l in myList],\n                 value = default_category\n    ),\n    dcc.Dropdown(id='second-dropdown',\n                 options=[{'label':l, 'value':l} for l in myDict[default_category]],\n                 value = myDict[default_category][default_index]\n    )\n])\n\ntab2 = html.Div([\n    html.H3('Tab content 2'),\n])    \n\napp.layout = html.Div([\n    <line_mask>\n    dcc.Tabs(id=\"tabs-example\", value='tab-1-example', children=[\n        dcc.Tab(id=\"tab-1\", label='Tab One', value='tab-1-example'),\n        dcc.Tab(id=\"tab-2\", label='Tab Two', value='tab-2-example'),\n    ]),\n    html.Div(id='tabs-content-example',\n             children = tab1)\n])\n\n@app.callback(dash.dependencies.Output('tabs-content-example', 'children'),\n             [dash.dependencies.Input('tabs-example', 'value')])\ndef render_content(tab):\n    if tab == 'tab-1-example':\n        return tab1\n    elif tab == 'tab-2-example':\n        return tab2\n\n@app.callback(\n    [dash.dependencies.Output('second-dropdown', 'options'),\n     dash.dependencies.Output('second-dropdown', 'value')],\n    [dash.dependencies.Input('first-dropdown', 'value')])\ndef update_dropdown(value):\n    return [[ {'label': i, 'value': i} for i in myDict[value] ], myDict[value][default_index]]\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_line": "html.H1('Dash Tabs component demo'),",
            "answer": "Dash",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_297"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.4",
            "time": "2019-05-28",
            "description": "This code performs polynomial multiplication of two real-valued polynomials using Fast Fourier Transform (FFT).",
            "code": "from numpy.fft import rfft, irfft\ndef fftrealpolymul(arr_a, arr_b):  #fft based real-valued polynomial multiplication\n    L = len(arr_a) + len(arr_b)\n    a_f = rfft(arr_a, L)\n    b_f = rfft(arr_b, L)\n    return irfft(a_f * b_f)",
            "masked_code": "from numpy.fft import rfft, irfft\ndef fftrealpolymul(arr_a, arr_b):  #fft based real-valued polynomial multiplication\n    L = len(arr_a) + len(arr_b)\n    <line_mask>\n    b_f = rfft(arr_b, L)\n    return irfft(a_f * b_f)",
            "masked_line": "a_f = rfft(arr_a, L)",
            "answer": "rfft",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_298"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-04-05",
            "description": "This code defines a Config class that contains two functions, `func_a` and `func_b`, which display 'Func A' and 'Func B' respectively. There is also a static method `click_callback` that is called when an option is provided in the command-line. The main part of the code defines a Click command line interface using decorators like `@click.group()`, `@click.option()`, and `@click.pass_context`. It then executes a series of commands with different options and displays the Click and Python versions before executing each command.",
            "code": "import click\n\nclass Config:\n    def __init__(self, func_name):\n        self.func_name = func_name\n\n    def func_a(self):\n        click.echo('Func A')\n\n    def func_b(self):\n        click.echo('Func B')\n\n    @staticmethod\n    def click_callback(ctx, param, value):\n        getattr(ctx.obj, ctx.obj.func_name)()\n        return value\n\n\n@click.group()\n@click.option('-f', '--func-name', required=True)\n@click.pass_context\ndef group(ctx, func_name):\n    ctx.obj = Config(func_name)\n\n\n@group.command()\n@click.option('--my-option', '-o', callback=Config.click_callback)\ndef command(my_option):\n    click.echo('command: {}'.format(my_option))\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '-f func_a command -o optionA',\n        '-f func_b command -o optionB',\n        '-f func_a command -o ',\n        'command',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            group(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\nclass Config:\n    def __init__(self, func_name):\n        self.func_name = func_name\n\n    def func_a(self):\n        click.echo('Func A')\n\n    def func_b(self):\n        click.echo('Func B')\n\n    @staticmethod\n    def click_callback(ctx, param, value):\n        getattr(ctx.obj, ctx.obj.func_name)()\n        return value\n\n\n@click.group()\n<line_mask>\n@click.pass_context\ndef group(ctx, func_name):\n    ctx.obj = Config(func_name)\n\n\n@group.command()\n@click.option('--my-option', '-o', callback=Config.click_callback)\ndef command(my_option):\n    click.echo('command: {}'.format(my_option))\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '-f func_a command -o optionA',\n        '-f func_b command -o optionB',\n        '-f func_a command -o ',\n        'command',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            group(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.option('-f', '--func-name', required=True)",
            "answer": "option",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_299"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-03-01",
            "description": "The code defines a neural network model using a pretrained ResNet50 model as a base, with additional layers for flattening and dense classification. The model is configured with specific input shape and number of classes for classification. The code also includes the option to freeze some layers and customize the top layers for specific tasks. The summary of the model architecture is printed using the \"summary()\" method.",
            "code": "import tensorflow\n\nin_width, in_height, in_channels = 224, 224, 3\n\npretrained_resnet = tensorflow.keras.applications.ResNet50(\n    weights=\"imagenet\",\n    include_top=False,\n    input_shape=(in_width, in_height, in_channels),\n)\n\n# You can freeze some layers if you want, depends on your task\n# Make \"top\" (last 3 layers below) whatever fits your task as well\n\nmodel = tensorflow.keras.models.Sequential(\n    [\n        pretrained_resnet,\n        tensorflow.keras.layers.Flatten(),\n        tensorflow.keras.layers.Dense(1024, activation=\"relu\"),\n        tensorflow.keras.layers.Dense(10, activation=\"softmax\"),\n    ]\n)\n\nprint(model.summary())",
            "masked_code": "import tensorflow\n\nin_width, in_height, in_channels = 224, 224, 3\n\npretrained_resnet = tensorflow.keras.applications.ResNet50(\n    weights=\"imagenet\",\n    include_top=False,\n    input_shape=(in_width, in_height, in_channels),\n)\n\n# You can freeze some layers if you want, depends on your task\n# Make \"top\" (last 3 layers below) whatever fits your task as well\n\nmodel = tensorflow.keras.models.Sequential(\n    [\n        pretrained_resnet,\n        tensorflow.keras.layers.Flatten(),\n        <line_mask>\n        tensorflow.keras.layers.Dense(10, activation=\"softmax\"),\n    ]\n)\n\nprint(model.summary())",
            "masked_line": "tensorflow.keras.layers.Dense(1024, activation=\"relu\"),",
            "answer": "Dense",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_300"
        },
        {
            "dependency": "scikit-learn",
            "version": ">=0.23.1",
            "time": "2020-07-21",
            "description": "The code generates a confusion matrix for the predicted and true labels, displays it as a heatmap, and visualizes it with the labels 'business' and 'health'.",
            "code": "from sklearn.metrics import confusion_matrix\n\nlabels = ['business', 'health']\ncm = confusion_matrix(y_test, pred, labels)\nprint(cm)\nfig = plt.figure()\nax = fig.add_subplot(111)\ncax = ax.matshow(cm)\nplt.title('Confusion matrix of the classifier')\nfig.colorbar(cax)\nax.set_xticklabels([''] + labels)\nax.set_yticklabels([''] + labels)\nplt.xlabel('Predicted')\nplt.ylabel('True')\nplt.show()",
            "masked_code": "from sklearn.metrics import confusion_matrix\n\nlabels = ['business', 'health']\n<line_mask>\nprint(cm)\nfig = plt.figure()\nax = fig.add_subplot(111)\ncax = ax.matshow(cm)\nplt.title('Confusion matrix of the classifier')\nfig.colorbar(cax)\nax.set_xticklabels([''] + labels)\nax.set_yticklabels([''] + labels)\nplt.xlabel('Predicted')\nplt.ylabel('True')\nplt.show()",
            "masked_line": "cm = confusion_matrix(y_test, pred, labels)",
            "answer": "confusion_matrix",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_301"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-10-25",
            "description": "This code generates a square matrix with random values, then inverts the values below the main diagonal by multiplying them by -1.",
            "code": "from scipy.spatial.distance import squareform\n\ndef diag_inverted(n):\n    l = n*(n-1)//2\n    out = squareform(np.random.randn(l))\n    out[np.tri(len(out),k=-1,dtype=bool)] *= -1\n    return out",
            "masked_code": "from scipy.spatial.distance import squareform\n\ndef diag_inverted(n):\n    l = n*(n-1)//2\n    <line_mask>\n    out[np.tri(len(out),k=-1,dtype=bool)] *= -1\n    return out",
            "masked_line": "out = squareform(np.random.randn(l))",
            "answer": "squareform",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_302"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-09-21",
            "description": "The code processes a pandas Series which contains carbohydrate compositions in a specific format. It splits the string values in the Series based on certain characters, creates a DataFrame from the split values, pivots the DataFrame, renames columns, drops columns with all NaN values, and fills NaN values with zeros.",
            "code": "import pandas as pd\ns = pd.Series(['HexNAc(6)Hex(7)Fuc(1)NeuAc(3)', 'HexNAc(6)Hex(7)Fuc(1)NeuAc(3)',\n               'HexNAc(5)Hex(4)NeuAc(1)', 'HexNAc(6)Hex(7)'])\n\n(pd.DataFrame(s.str.split(')').explode().str.split('\\(', expand=True))\n   .pivot(columns=0, values=1)\n   .rename_axis(None, axis=1)\n   .dropna(how='all', axis=1)\n   .fillna(0, downcast='infer'))",
            "masked_code": "import pandas as pd\ns = pd.Series(['HexNAc(6)Hex(7)Fuc(1)NeuAc(3)', 'HexNAc(6)Hex(7)Fuc(1)NeuAc(3)',\n               'HexNAc(5)Hex(4)NeuAc(1)', 'HexNAc(6)Hex(7)'])\n\n<line_mask>\n   .pivot(columns=0, values=1)\n   .rename_axis(None, axis=1)\n   .dropna(how='all', axis=1)\n   .fillna(0, downcast='infer'))",
            "masked_line": "(pd.DataFrame(s.str.split(')').explode().str.split('\\(', expand=True))",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_303"
        },
        {
            "dependency": "ezdxf",
            "version": "==0.11",
            "time": "2019-11-20",
            "description": "The code creates two vectors representing the start and end points of an arc, based on the arc's start and end angles and radius.",
            "code": "from ezdxf.math import Vector\n\nstart_point = Vector.from_deg_angle(arc.dxf.start_angle, arc.dxf.radius)\nend_point = Vector.from_deg_angle(arc.dxf.end_angle, arc.dxf.radius)",
            "masked_code": "from ezdxf.math import Vector\n\n<line_mask>\nend_point = Vector.from_deg_angle(arc.dxf.end_angle, arc.dxf.radius)",
            "masked_line": "start_point = Vector.from_deg_angle(arc.dxf.start_angle, arc.dxf.radius)",
            "answer": "from_deg_angle",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_304"
        },
        {
            "dependency": "sklearn",
            "version": "==0.20.2",
            "time": "2019-01-18",
            "description": "The code fits a regression model using Gradient Boosting algorithm on the Boston housing dataset. It splits the data into training and testing sets, then fits the model with specified parameters. The mean squared error (MSE) is calculated using the model's predictions on the test data, and the feature importances are printed.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom sklearn import ensemble\nfrom sklearn import datasets\nfrom sklearn.utils import shuffle\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.compose import TransformedTargetRegressor #only in sklearn==0.20.2\n\n# #############################################################################\n# Load data\nboston = datasets.load_boston()\nX, y = shuffle(boston.data, boston.target, random_state=13)\nX = X.astype(np.float32)\noffset = int(X.shape[0] * 0.9)\nX_train, y_train = X[:offset], y[:offset]\nX_test, y_test = X[offset:], y[offset:]\n\n# #############################################################################\n# Fit regression model\nparams = {'n_estimators': 500, 'max_depth': 4, 'min_samples_split': 2,\n          'learning_rate': 0.01, 'loss': 'ls'}\n#clf = ensemble.GradientBoostingRegressor(**params)\nclf = TransformedTargetRegressor(regressor=GradientBoostingRegressor(**params),\n       func=np.log1p, inverse_func=np.expm1)\n\nclf.fit(X_train, y_train)\nmse = mean_squared_error(y_test, clf.predict(X_test))\nprint(\"MSE: %.4f\" % mse)\n\nprint(clf.regressor_.feature_importances_)",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom sklearn import ensemble\nfrom sklearn import datasets\nfrom sklearn.utils import shuffle\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.compose import TransformedTargetRegressor #only in sklearn==0.20.2\n\n# #############################################################################\n# Load data\nboston = datasets.load_boston()\nX, y = shuffle(boston.data, boston.target, random_state=13)\nX = X.astype(np.float32)\noffset = int(X.shape[0] * 0.9)\nX_train, y_train = X[:offset], y[:offset]\nX_test, y_test = X[offset:], y[offset:]\n\n# #############################################################################\n# Fit regression model\nparams = {'n_estimators': 500, 'max_depth': 4, 'min_samples_split': 2,\n          'learning_rate': 0.01, 'loss': 'ls'}\n#clf = ensemble.GradientBoostingRegressor(**params)\nclf = TransformedTargetRegressor(regressor=GradientBoostingRegressor(**params),\n       func=np.log1p, inverse_func=np.expm1)\n\nclf.fit(X_train, y_train)\n<line_mask>\nprint(\"MSE: %.4f\" % mse)\n\nprint(clf.regressor_.feature_importances_)",
            "masked_line": "mse = mean_squared_error(y_test, clf.predict(X_test))",
            "answer": "predict",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_305"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-31",
            "description": "This code generates an interactive Bokeh plot with circles that display tooltips containing images, descriptions, fonts, and locations when hovered over. The tooltips are updated dynamically based on the selected circle.",
            "code": "from bokeh.plotting import figure, output_file, show, ColumnDataSource\nfrom bokeh.models import TapTool, CustomJS, HoverTool, Div, Row\n\noutput_file(\"toolbar.html\")\n\nsource = ColumnDataSource(data = dict(\nx = [1, 2, 3, 3, 4],\ny = [2, 5, 8, 3, 6],\ndesc = ['A', 'B', 'C', 'D', 'E'],\nimgs = ['https://docs.bokeh.org/static/snake.jpg',\n        'https://docs.bokeh.org/static/snake2.png',\n        'https://dods.bokeh.org/static/snake3D.png',\n        'https://docs.bokeh.org/static/snake4_TheRevenge.png',\n        'https://docs.bokeh.org/static/snakebite.jpg'],\nfonts = ['italics',\n         'pre',\n         'bold',\n         'small',\n         'del' ]))\nTOOLTIPS = \"\"\"\n\n    \n        \n    \n    \n        @desc\n        [$index]\n    \n    \n        @fonts{safe}\n    \n    \n        Location\n        ($x, $y)\n    \n \"\"\"\n\np = figure(plot_width = 400, plot_height = 400, x_range = (0, 6), y_range = (1, 9),\n      title = \"Mouse over the dots\", tools = 'pan,wheel_zoom,save,reset,tap')\ncircles = p.circle('x', 'y', size = 20, source = source)\ndiv = Div(text = '', name = 'tooltip')\n\ncode = '''  if (cb_data.source.selected.indices.length > 0){\n                var selected_index = cb_data.source.selected.indices[0];\n                var tooltip = document.getElementById(\"tooltip\");\n\n                tooltip.style.display = 'block';\n                tooltip.style.left = Number(cb_data.geometries.sx) + Number(20) + 'px';\n                tooltip.style.top = Number(cb_data.geometries.sy) - Number(20) + 'px';\n\n                tp = tp.replace('@imgs', cb_data.source.data.imgs[selected_index]);\n                tp = tp.replace('@desc', cb_data.source.data.desc[selected_index]);\n                tp = tp.replace('@fonts{safe}', cb_data.source.data.fonts[selected_index]);\n                tp = tp.replace('$index', selected_index);\n                tp = tp.replace('$x', Math.round(cb_data.geometries.x));\n                tp = tp.replace('$y', Math.round(cb_data.geometries.y));\n                tooltip.innerHTML = tp;\n          } '''\np.select(TapTool).callback = CustomJS(args = {'circles': circles, 'plot': p, 'tp': TOOLTIPS}, code = code)\nsource.selected.js_on_change('indices', CustomJS(code = 'if (cb_obj.indices.length == 0) document.getElementById(\"tooltip\").style.display = \\\"none\\\"'))\nlayout = Row(p, div)\nshow(layout)",
            "masked_code": "from bokeh.plotting import figure, output_file, show, ColumnDataSource\n<line_mask>\n\noutput_file(\"toolbar.html\")\n\nsource = ColumnDataSource(data = dict(\nx = [1, 2, 3, 3, 4],\ny = [2, 5, 8, 3, 6],\ndesc = ['A', 'B', 'C', 'D', 'E'],\nimgs = ['https://docs.bokeh.org/static/snake.jpg',\n        'https://docs.bokeh.org/static/snake2.png',\n        'https://dods.bokeh.org/static/snake3D.png',\n        'https://docs.bokeh.org/static/snake4_TheRevenge.png',\n        'https://docs.bokeh.org/static/snakebite.jpg'],\nfonts = ['italics',\n         'pre',\n         'bold',\n         'small',\n         'del' ]))\nTOOLTIPS = \"\"\"\n\n    \n        \n    \n    \n        @desc\n        [$index]\n    \n    \n        @fonts{safe}\n    \n    \n        Location\n        ($x, $y)\n    \n \"\"\"\n\np = figure(plot_width = 400, plot_height = 400, x_range = (0, 6), y_range = (1, 9),\n      title = \"Mouse over the dots\", tools = 'pan,wheel_zoom,save,reset,tap')\ncircles = p.circle('x', 'y', size = 20, source = source)\ndiv = Div(text = '', name = 'tooltip')\n\ncode = '''  if (cb_data.source.selected.indices.length > 0){\n                var selected_index = cb_data.source.selected.indices[0];\n                var tooltip = document.getElementById(\"tooltip\");\n\n                tooltip.style.display = 'block';\n                tooltip.style.left = Number(cb_data.geometries.sx) + Number(20) + 'px';\n                tooltip.style.top = Number(cb_data.geometries.sy) - Number(20) + 'px';\n\n                tp = tp.replace('@imgs', cb_data.source.data.imgs[selected_index]);\n                tp = tp.replace('@desc', cb_data.source.data.desc[selected_index]);\n                tp = tp.replace('@fonts{safe}', cb_data.source.data.fonts[selected_index]);\n                tp = tp.replace('$index', selected_index);\n                tp = tp.replace('$x', Math.round(cb_data.geometries.x));\n                tp = tp.replace('$y', Math.round(cb_data.geometries.y));\n                tooltip.innerHTML = tp;\n          } '''\np.select(TapTool).callback = CustomJS(args = {'circles': circles, 'plot': p, 'tp': TOOLTIPS}, code = code)\nsource.selected.js_on_change('indices', CustomJS(code = 'if (cb_obj.indices.length == 0) document.getElementById(\"tooltip\").style.display = \\\"none\\\"'))\nlayout = Row(p, div)\nshow(layout)",
            "masked_line": "from bokeh.models import TapTool, CustomJS, HoverTool, Div, Row",
            "answer": "Row",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_306"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-17",
            "description": "The function `sliding_count` calculates the number of elements in array `a` that fall within each sliding window of size `window` moving through the range from `start` to `end`.\n\nThe function `alt` is an alternative method to achieve the same result as `sliding_count`, using numpy functions to determine the count of elements in each sliding window.",
            "code": "import numpy as np\n\ndef alt(a, end, window, start=0, step=1):\n    bin_starts = np.arange(start, end+1-window, step)\n    bin_ends = bin_starts + window\n    last_index = np.searchsorted(a, bin_ends, side='right')\n    first_index = np.searchsorted(a, bin_starts, side='left')\n    return  last_index - first_index\n\ndef sliding_count(a, end, window, start=0, step=1):\n    bins = [(x, x + window) for x in range(start, (end + 1) - window, step)]\n    counts = np.zeros(len(bins))\n    for i, rng in enumerate(bins):\n        count = len(a[np.where(np.logical_and(a>=rng[0], a<=rng[1]))])\n        counts[i] = count\n    return counts\n\na = np.array([1, 5, 8, 11, 14, 19])\nend = 20\nwindow = 10\n\nprint(sliding_count(a, end, window))\n# [3. 4. 3. 3. 4. 4. 3. 3. 3. 3. 3.]\n\nprint(alt(a, end, window))\n# [3 4 3 3 4 4 3 3 3 3 3]",
            "masked_code": "import numpy as np\n\ndef alt(a, end, window, start=0, step=1):\n    bin_starts = np.arange(start, end+1-window, step)\n    bin_ends = bin_starts + window\n    last_index = np.searchsorted(a, bin_ends, side='right')\n    first_index = np.searchsorted(a, bin_starts, side='left')\n    return  last_index - first_index\n\ndef sliding_count(a, end, window, start=0, step=1):\n    bins = [(x, x + window) for x in range(start, (end + 1) - window, step)]\n    counts = np.zeros(len(bins))\n    for i, rng in enumerate(bins):\n        <line_mask>\n        counts[i] = count\n    return counts\n\na = np.array([1, 5, 8, 11, 14, 19])\nend = 20\nwindow = 10\n\nprint(sliding_count(a, end, window))\n# [3. 4. 3. 3. 4. 4. 3. 3. 3. 3. 3.]\n\nprint(alt(a, end, window))\n# [3 4 3 3 4 4 3 3 3 3 3]",
            "masked_line": "count = len(a[np.where(np.logical_and(a>=rng[0], a<=rng[1]))])",
            "answer": "logical_and",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_307"
        },
        {
            "dependency": "rq",
            "version": "==0.10.0",
            "time": "2022-01-06",
            "description": "The code retrieves and prints the name of the first worker in a specific queue.",
            "code": "from redis import Redis\nfrom rq import Queue, Worker\n\n# Returns all workers registered in this connection\nredis = Redis(host='myredis.example.com', port=6379)\nworkers = Worker.all(connection=redis)\n\n# Returns all workers in this queue (new in version 0.10.0)\nqueue = Queue('queue_name')\nworkers = Worker.all(queue=queue)\nworker = workers[0]\nprint(worker.name)",
            "masked_code": "from redis import Redis\nfrom rq import Queue, Worker\n\n# Returns all workers registered in this connection\nredis = Redis(host='myredis.example.com', port=6379)\nworkers = Worker.all(connection=redis)\n\n# Returns all workers in this queue (new in version 0.10.0)\nqueue = Queue('queue_name')\n<line_mask>\nworker = workers[0]\nprint(worker.name)",
            "masked_line": "workers = Worker.all(queue=queue)",
            "answer": "all",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_308"
        },
        {
            "dependency": "pyspark",
            "version": "==2.2",
            "time": "2019-11-07",
            "description": "The code selects the second part of the path from the viewed_page column in a DataFrame using HiveContext, but it will not work with SQLContext.",
            "code": "from pyspark import SparkContext\nfrom pyspark.sql import HiveContext, SQLContext\n\nsc = SparkContext()\n\nsqlContext = SQLContext(sc)\nhivContext = HiveContext(sc)\n\nquery = 'SELECT split(parse_url(page.viewed_page, \"PATH\"), \"/\")[1] as path FROM df'\n\nhivContext.sql(query) # this will work\nsqlContext.sql(query) # this will not work",
            "masked_code": "from pyspark import SparkContext\nfrom pyspark.sql import HiveContext, SQLContext\n\n<line_mask>\n\nsqlContext = SQLContext(sc)\nhivContext = HiveContext(sc)\n\nquery = 'SELECT split(parse_url(page.viewed_page, \"PATH\"), \"/\")[1] as path FROM df'\n\nhivContext.sql(query) # this will work\nsqlContext.sql(query) # this will not work",
            "masked_line": "sc = SparkContext()",
            "answer": "SparkContext",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_309"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-05-23",
            "description": "The code initializes an array of length 10 with elements set to 0. Then it assigns 1 to the first and middle index, assigns 2 to the indices between the first and middle element, and assigns 0 to the indices after the middle element. Finally, it prints the resulting array.",
            "code": "import numpy as np\n\nn = 10\na = np.zeros(n)\na[np.r_[0,n//2]] = 1\na[np.r_[1:n//2]] = 2\na[np.r_[n//2+1:n]] = 0\n\nprint(a)\narray([1., 2., 2., 2., 2., 1., 0., 0., 0., 0.])",
            "masked_code": "import numpy as np\n\nn = 10\n<line_mask>\na[np.r_[0,n//2]] = 1\na[np.r_[1:n//2]] = 2\na[np.r_[n//2+1:n]] = 0\n\nprint(a)\narray([1., 2., 2., 2., 2., 1., 0., 0., 0., 0.])",
            "masked_line": "a = np.zeros(n)",
            "answer": "zeros",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_310"
        },
        {
            "dependency": "pytest",
            "version": "==4.6.2",
            "time": "2019-12-18",
            "description": "The code defines a function called foo that takes two arguments and returns the sum of the two arguments. It also includes multiple test functions that assert whether the function foo behaves as expected for different input values.",
            "code": "import pytest\n\n\ndef foo(a, b):\n    return a + b\n\n\ndef test_foo_1():\n    assert foo(1, 1) == 2\n\n\n@pytest.mark.must_pass\ndef test_foo_2():\n    assert foo(2, 2) == 6\n\n\ndef test_foo_3():\n    assert foo(3, 3) == 6\n\n\ndef test_foo_4():\n    assert foo(4, 4) == 8",
            "masked_code": "import pytest\n\n\ndef foo(a, b):\n    return a + b\n\n\ndef test_foo_1():\n    assert foo(1, 1) == 2\n\n\n<line_mask>\ndef test_foo_2():\n    assert foo(2, 2) == 6\n\n\ndef test_foo_3():\n    assert foo(3, 3) == 6\n\n\ndef test_foo_4():\n    assert foo(4, 4) == 8",
            "masked_line": "@pytest.mark.must_pass",
            "answer": "mark",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_311"
        },
        {
            "dependency": "spacy",
            "version": "==2.2.4",
            "time": "2020-04-18",
            "description": "This Python code initializes the English language processing pipeline using the spaCy library.",
            "code": "from spacy.lang.en import English\nnlp = English()",
            "masked_code": "from spacy.lang.en import English\n<line_mask>",
            "masked_line": "nlp = English()",
            "answer": "English",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_312"
        },
        {
            "dependency": "spacy",
            "version": "==2.1.0",
            "time": "2020-04-18",
            "description": "The code initializes an English language model for natural language processing using the spaCy library.",
            "code": "from spacy.lang.en import English\nnlp = English()",
            "masked_code": "<line_mask>\nnlp = English()",
            "masked_line": "from spacy.lang.en import English",
            "answer": "English",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_313"
        },
        {
            "dependency": "requests",
            "version": "==2.8.1",
            "time": "2019-04-22",
            "description": "The code sends a GET request to 'http://httpbin.org/redirect/3' and then prints out the URLs of any redirect responses received.",
            "code": "import requests\nresponse = requests.get('http://httpbin.org/redirect/3')\nfor resp in response.history:\n    print(resp.url)",
            "masked_code": "import requests\n<line_mask>\nfor resp in response.history:\n    print(resp.url)",
            "masked_line": "response = requests.get('http://httpbin.org/redirect/3')",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_314"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2019-03-05",
            "description": "This code calculates the 90th percentile pixel value for each image in a batch, and then creates a new set of images where each pixel value is set to 0 if it is not in the top 10% of pixel values in the original image.",
            "code": "import tensorflow as tf\n\nimages = ... # [N, W, H, C]\nn = tf.shape(images)[0]\nimages_flat = tf.reshape(images, [n, -1])\np = tf.contrib.distributions.percentile(images_flat, 90, axis=1, interpolation='higher')\nimages_top10 = tf.where(images >= tf.reshape(p, [n, 1, 1, 1]),\n                        images, tf.zeros_like(images))",
            "masked_code": "import tensorflow as tf\n\nimages = ... # [N, W, H, C]\nn = tf.shape(images)[0]\nimages_flat = tf.reshape(images, [n, -1])\n<line_mask>\nimages_top10 = tf.where(images >= tf.reshape(p, [n, 1, 1, 1]),\n                        images, tf.zeros_like(images))",
            "masked_line": "p = tf.contrib.distributions.percentile(images_flat, 90, axis=1, interpolation='higher')",
            "answer": "distributions",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_315"
        },
        {
            "dependency": "plotly",
            "version": "==3.7.0",
            "time": "2019-04-13",
            "description": "The code generates a 3D surface plot using Plotly library, displaying the data provided in the dictionary df3.",
            "code": "from plotly import offline\nfrom plotly import graph_objs as go\noffline.init_notebook_mode(connected=False)\n\ndf3 = {'x':[1, 2, 3, 4, 5],'y':[10, 20, 30, 40, 50],'z': [[5, 4, 3, 2, 1]]*5}\noffline.iplot(dict(data=[go.Surface(x=df3['x'], y=df3['y'], z=df3['z'])]))",
            "masked_code": "from plotly import offline\nfrom plotly import graph_objs as go\noffline.init_notebook_mode(connected=False)\n\ndf3 = {'x':[1, 2, 3, 4, 5],'y':[10, 20, 30, 40, 50],'z': [[5, 4, 3, 2, 1]]*5}\n<line_mask>",
            "masked_line": "offline.iplot(dict(data=[go.Surface(x=df3['x'], y=df3['y'], z=df3['z'])]))",
            "answer": "iplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_316"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-03-08",
            "description": "This code assigns fruits based on the given decisions to the variable daily_decision.",
            "code": "import numpy as np\ndaily_choices = np.array([['apple','orange'],['strawberry','orange'],['watermelon','apple']])\ndecisions = [0, 1, 0]\n\ndaily_decision = daily_choices[range(len(daily_choices)), decisions]\nprint(daily_decision)",
            "masked_code": "import numpy as np\n<line_mask>\ndecisions = [0, 1, 0]\n\ndaily_decision = daily_choices[range(len(daily_choices)), decisions]\nprint(daily_decision)",
            "masked_line": "daily_choices = np.array([['apple','orange'],['strawberry','orange'],['watermelon','apple']])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_317"
        },
        {
            "dependency": "numpy",
            "version": "==1.16.0",
            "time": "2019-02-06",
            "description": "The code generates an array of 10,000 standard normal random numbers using numpy and then identifies outliers in the array by comparing each element to the mean and standard deviation of the array. The outliers, which are values that are more than 3 standard deviations away from the mean, are then printed.",
            "code": "import numpy as np\n\ns = np.random.standard_normal(size=10000)\n\noutliers = s[(abs(s - s.mean())) > (3 * s.std())]\nprint(outliers)",
            "masked_code": "import numpy as np\n\n<line_mask>\n\noutliers = s[(abs(s - s.mean())) > (3 * s.std())]\nprint(outliers)",
            "masked_line": "s = np.random.standard_normal(size=10000)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_318"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-01-12",
            "description": "The code defines a command-line interface using the Click library in Python. It creates a CLI with two commands: \"init\" for initializing a project and \"run\" for running the main program. The \"run\" command has an optional \"--dryrun\" flag for running in read-only mode. The code also includes a section for executing the commands specified in the \"commands\" list, printing the Click version and Python version, and handling exceptions during command execution.",
            "code": "import click\nimport yaml\n\n@click.group(cls=LoadInitForCommands)\ndef cli():\n    \"\"\"\"\"\"\n\n@cli.command()\n@click.pass_context\ndef init(ctx):\n    print(\"Initialize project.\")\n\n\n@cli.command()\n@click.option(\"--dryrun\", type=bool, is_flag=True,\n              help=\"Run in read-only mode\")\n@click.pass_context\ndef run(ctx, dryrun):\n    print(\"Run main program here.\")\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'init',\n        'run --help',\n        'run',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split(), obj={})\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\nimport yaml\n\n@click.group(cls=LoadInitForCommands)\ndef cli():\n    \"\"\"\"\"\"\n\n@cli.command()\n@click.pass_context\ndef init(ctx):\n    print(\"Initialize project.\")\n\n\n@cli.command()\n@click.option(\"--dryrun\", type=bool, is_flag=True,\n              help=\"Run in read-only mode\")\n<line_mask>\ndef run(ctx, dryrun):\n    print(\"Run main program here.\")\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'init',\n        'run --help',\n        'run',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split(), obj={})\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.pass_context",
            "answer": "pass_context",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_319"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.0",
            "time": "2019-10-03",
            "description": "The code merges two dataframes on specific columns and returns a new dataframe with 'userid' and 'contentId' columns after dropping any duplicates and converting the values to integers.",
            "code": "import pandas as pd\nfrom numpy import nan\ndfp = pd.DataFrame({'contentId': {0: nan, 1: 2.0, 2: nan, 3: 4.0, 4: 5.0, 5: 6.0, 6: nan, 7: 8.0, 8: 9.0}, 'Categories': {0: '1', 1: '12;2', 2: '3', 3: '2', 4: '3;15', 5: '15', 6: '7', 7: '20', 8: '20;2'}})\ndfu = pd.DataFrame({'intrestcategories': {0: '12;2', 1: '3', 2: '15'}, 'userid': {0: 2, 1: 3, 2: 4}})\n\ndfp.Categories = dfp.Categories.str.split(';')\ndfp = dfp.explode('Categories')\n\ndfu.intrestcategories = dfu.intrestcategories.str.split(';')\ndfu = dfu.explode('intrestcategories')\n\ndfp.dropna().merge(dfu,left_on='Categories',right_on='intrestcategories')[['userid','contentId']].drop_duplicates().astype(int)",
            "masked_code": "import pandas as pd\nfrom numpy import nan\ndfp = pd.DataFrame({'contentId': {0: nan, 1: 2.0, 2: nan, 3: 4.0, 4: 5.0, 5: 6.0, 6: nan, 7: 8.0, 8: 9.0}, 'Categories': {0: '1', 1: '12;2', 2: '3', 3: '2', 4: '3;15', 5: '15', 6: '7', 7: '20', 8: '20;2'}})\ndfu = pd.DataFrame({'intrestcategories': {0: '12;2', 1: '3', 2: '15'}, 'userid': {0: 2, 1: 3, 2: 4}})\n\ndfp.Categories = dfp.Categories.str.split(';')\ndfp = dfp.explode('Categories')\n\n<line_mask>\ndfu = dfu.explode('intrestcategories')\n\ndfp.dropna().merge(dfu,left_on='Categories',right_on='intrestcategories')[['userid','contentId']].drop_duplicates().astype(int)",
            "masked_line": "dfu.intrestcategories = dfu.intrestcategories.str.split(';')",
            "answer": "split",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_320"
        },
        {
            "dependency": "APScheduler",
            "version": "==3.6.0",
            "time": "2019-04-10",
            "description": "The code sets up a background scheduler using apscheduler package to call the get_info function every 3 seconds. Inside the get_info function, it prints out the CPU times and memory information of a process using psutil library. Additionally, there is a loop running for 60 seconds that prints out a progress message every 10 seconds.",
            "code": "import psutil\n\nimport time\nimport os\n\nfrom apscheduler.schedulers.background import BackgroundScheduler\n\nprocess = psutil.Process()\n\ndef get_info():\n    print(process.cpu_times(), process.memory_info())\n\nif __name__ == '__main__':\n    scheduler = BackgroundScheduler()\n    scheduler.add_job(get_info, 'interval', seconds=3)\n    scheduler.start()\n\n    # run the code you want to measure here\n    # replace this nonsense loop\n    now = time.time()\n    finish = now + 60\n\n    while time.time() < finish:\n        print(\"Some progress message: {}\".format(time.time()))\n        time.sleep(10)",
            "masked_code": "import psutil\n\nimport time\nimport os\n\nfrom apscheduler.schedulers.background import BackgroundScheduler\n\nprocess = psutil.Process()\n\ndef get_info():\n    print(process.cpu_times(), process.memory_info())\n\nif __name__ == '__main__':\n    scheduler = BackgroundScheduler()\n    scheduler.add_job(get_info, 'interval', seconds=3)\n    <line_mask>\n\n    # run the code you want to measure here\n    # replace this nonsense loop\n    now = time.time()\n    finish = now + 60\n\n    while time.time() < finish:\n        print(\"Some progress message: {}\".format(time.time()))\n        time.sleep(10)",
            "masked_line": "scheduler.start()",
            "answer": "start",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_321"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-04-06",
            "description": "This code checks if there is a simple cycle containing a specific node starting from a given list of nodes.",
            "code": "import networkx as nx\n\ndef has_simple_cycle(l, start):\n    G = nx.DiGraph()\n    G.add_edges_from((v1, v2) for v1 in l for v2 in l if v1 != v2 and max(abs(v1[0] - v2[0]), abs(v1[1] - v2[1])) <= 1)\n    return any(start in c and len(c) > 2 for c in nx.simple_cycles(G))",
            "masked_code": "import networkx as nx\n\ndef has_simple_cycle(l, start):\n    G = nx.DiGraph()\n    <line_mask>\n    return any(start in c and len(c) > 2 for c in nx.simple_cycles(G))",
            "masked_line": "G.add_edges_from((v1, v2) for v1 in l for v2 in l if v1 != v2 and max(abs(v1[0] - v2[0]), abs(v1[1] - v2[1])) <= 1)",
            "answer": "add_edges_from",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_322"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-10-16",
            "description": "The code generates random samples based on the probabilities specified in the 2D array P.",
            "code": "import numpy as np\n\nP = np.array([[0,1/2,1/2],[1,0,0],[1/3,1/3,1/3]])\n\ndef rand_choice(c):\n  return np.random.choice(c.size, p=c)\n\nsamples = np.apply_along_axis(rand_choice, 1, P)",
            "masked_code": "import numpy as np\n\nP = np.array([[0,1/2,1/2],[1,0,0],[1/3,1/3,1/3]])\n\ndef rand_choice(c):\n  <line_mask>\n\nsamples = np.apply_along_axis(rand_choice, 1, P)",
            "masked_line": "return np.random.choice(c.size, p=c)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_323"
        },
        {
            "dependency": "tkcalendar",
            "version": "==1.5.0",
            "time": "2019-08-29",
            "description": "This code creates a tkinter window and adds two DateEntry widgets to it, one with custom date formatting and one with default date formatting. The window will remain open until the user closes it.",
            "code": "import tkinter as tk\nfrom tkcalendar import DateEntry\n\nwindow = tk.Tk()\n\nDateEntry(window, locale='en_US', date_pattern='mm/dd/y').pack()  # custom formatting\nDateEntry(window, locale='en_US').pack()  # default formatting\nwindow.mainloop()",
            "masked_code": "import tkinter as tk\nfrom tkcalendar import DateEntry\n\nwindow = tk.Tk()\n\nDateEntry(window, locale='en_US', date_pattern='mm/dd/y').pack()  # custom formatting\n<line_mask>\nwindow.mainloop()",
            "masked_line": "DateEntry(window, locale='en_US').pack()  # default formatting",
            "answer": "pack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_324"
        },
        {
            "dependency": "discord.py",
            "version": "==1.0",
            "time": "2019-03-24",
            "description": "This code allows the bot to join a voice channel and play an audio file '1.m4a' when the command !bb is triggered by a user in the server.",
            "code": "from discord import FFmpegPCMAudio\nfrom discord.utils import get\n\n@bot.command()\nasync def bb(ctx):\n    channel = ctx.message.author.voice.channel\n    if not channel:\n        await ctx.send(\"You are not connected to a voice channel\")\n        return\n    voice = get(bot.voice_clients, guild=ctx.guild)\n    if voice and voice.is_connected():\n        await voice.move_to(channel)\n    else:\n        voice = await channel.connect()\n    source = FFmpegPCMAudio('1.m4a')\n    player = voice.play(source)",
            "masked_code": "from discord import FFmpegPCMAudio\n<line_mask>\n\n@bot.command()\nasync def bb(ctx):\n    channel = ctx.message.author.voice.channel\n    if not channel:\n        await ctx.send(\"You are not connected to a voice channel\")\n        return\n    voice = get(bot.voice_clients, guild=ctx.guild)\n    if voice and voice.is_connected():\n        await voice.move_to(channel)\n    else:\n        voice = await channel.connect()\n    source = FFmpegPCMAudio('1.m4a')\n    player = voice.play(source)",
            "masked_line": "from discord.utils import get",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_325"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-06-14",
            "description": "The code generates a 1000x1000 matrix 'U' filled with random uniform numbers between 0 and 1. It then creates a symmetric matrix 'S' by taking the lower triangular part of 'U' and adding its transpose. Finally, it prints the histograms of the flattened 'S', the first row of 'S', and the first column of 'S'.",
            "code": "import numpy as np \n\nU = np.random.uniform(low=0, high=1.0, size=(1000, 1000))\nS = np.tril(U) + np.tril(U, -1).T\n\nprint(np.histogram(S.flatten()))\nprint(np.histogram(S[0,:]))\nprint(np.histogram(S[:,0]))",
            "masked_code": "import numpy as np \n\nU = np.random.uniform(low=0, high=1.0, size=(1000, 1000))\nS = np.tril(U) + np.tril(U, -1).T\n\n<line_mask>\nprint(np.histogram(S[0,:]))\nprint(np.histogram(S[:,0]))",
            "masked_line": "print(np.histogram(S.flatten()))",
            "answer": "histogram",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_326"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-08",
            "description": "This code uses NumPy to take elements from array A using the indices specified in array B and returns a new array with the selected elements.",
            "code": "np.take(A,B)\n# array([6, 8, 6, 6, 7])",
            "masked_code": "<line_mask>\n# array([6, 8, 6, 6, 7])",
            "masked_line": "np.take(A,B)",
            "answer": "take",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_327"
        },
        {
            "dependency": "bokeh",
            "version": "==1.3.0",
            "time": "2019-11-16",
            "description": "The code generates 3 plots with 2 lines each, where each line represents a random set of 10 data points. The plots are displayed in a single column layout without interactive tools merged.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.layouts import gridplot\nimport numpy as np\n\nplots = [figure() for i in range(3)]\nglyphs = [plot.line(np.arange(10), np.random.random(10)) for plot in plots for i in range(2)]\nshow(gridplot(children = plots, ncols = 1, merge_tools = False))",
            "masked_code": "from bokeh.plotting import figure, show\n<line_mask>\nimport numpy as np\n\nplots = [figure() for i in range(3)]\nglyphs = [plot.line(np.arange(10), np.random.random(10)) for plot in plots for i in range(2)]\nshow(gridplot(children = plots, ncols = 1, merge_tools = False))",
            "masked_line": "from bokeh.layouts import gridplot",
            "answer": "gridplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_328"
        },
        {
            "dependency": "keras",
            "version": "==2.2.4",
            "time": "2019-03-09",
            "description": "This code defines a neural network model with two branches - one branch takes an image input of size 64x64x1, applies convolutional and pooling layers, flattens the output, and passes it through a dense layer. The other branch takes a numerical input of size 7, applies dense layers with activation functions, and outputs another dense layer. The outputs of the two branches are then concatenated and passed through a final dense layer with softmax activation. The model is compiled using stochastic gradient descent and categorical crossentropy loss function with accuracy as the metric. Finally, the model is trained on dummy input data and the predictions are printed for sanity check.",
            "code": "from keras.layers import Conv2D, MaxPooling2D, Input, Dense, Flatten, concatenate\nfrom keras.models import Model\nimport numpy as np\n\nimg_input = Input(shape=(64, 64, 1))  ## branch 1 with image input\nx = Conv2D(64, (3, 3))(img_input)\nx = Conv2D(64, (3, 3))(x)\nx = MaxPooling2D((2, 2))(x)\nx = Flatten()(x)\nout_a = Dense(64)(x)\n\nnum_input = Input(shape=(7,))        ## branch 2 with numerical input\nx1 = Dense(8, activation='relu')(num_input)\nout_b = Dense(16, activation='relu')(x1)\n\nconcatenated = concatenate([out_a, out_b])    ## concatenate the two branches\nout = Dense(4, activation='softmax')(concatenated)\nmodel = Model([img_input, num_input], out)\nprint(model.summary())\nmodel.compile('sgd', 'categorical_crossentropy', ['accuracy'])\n\n### Just for sanity check\nX = [np.zeros((1,64,64,1)), np.zeros((1,7))]\ny = np.ones((1,4))\nmodel.fit(X, y)\nprint(model.predict(X))",
            "masked_code": "from keras.layers import Conv2D, MaxPooling2D, Input, Dense, Flatten, concatenate\nfrom keras.models import Model\nimport numpy as np\n\nimg_input = Input(shape=(64, 64, 1))  ## branch 1 with image input\nx = Conv2D(64, (3, 3))(img_input)\nx = Conv2D(64, (3, 3))(x)\nx = MaxPooling2D((2, 2))(x)\nx = Flatten()(x)\nout_a = Dense(64)(x)\n\nnum_input = Input(shape=(7,))        ## branch 2 with numerical input\nx1 = Dense(8, activation='relu')(num_input)\nout_b = Dense(16, activation='relu')(x1)\n\nconcatenated = concatenate([out_a, out_b])    ## concatenate the two branches\nout = Dense(4, activation='softmax')(concatenated)\nmodel = Model([img_input, num_input], out)\nprint(model.summary())\nmodel.compile('sgd', 'categorical_crossentropy', ['accuracy'])\n\n### Just for sanity check\nX = [np.zeros((1,64,64,1)), np.zeros((1,7))]\ny = np.ones((1,4))\n<line_mask>\nprint(model.predict(X))",
            "masked_line": "model.fit(X, y)",
            "answer": "fit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_329"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-08",
            "description": "The code generates a mesh grid from the given arrays of values and then multiplies the values along the specified axis to produce a final result.",
            "code": "import numpy as np\n\n\ndef mesh(values):\n    return np.array(np.meshgrid(*values)).T\n\nX = [1,2,3]\nY = [4,5,6,7]\n\nZ = mesh([X, Y])\n\nresult = np.multiply.reduce(Z, axis=2)\nprint(result)",
            "masked_code": "import numpy as np\n\n\ndef mesh(values):\n    return np.array(np.meshgrid(*values)).T\n\nX = [1,2,3]\nY = [4,5,6,7]\n\nZ = mesh([X, Y])\n\n<line_mask>\nprint(result)",
            "masked_line": "result = np.multiply.reduce(Z, axis=2)",
            "answer": "reduce",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_330"
        },
        {
            "dependency": "ezdxf",
            "version": "==0.10",
            "time": "2019-12-08",
            "description": "The code merges multiple DXF files into a single DXF file by importing all entities from the source files into the target file's modelspace and finalizing the import of required resources and dependencies. The resulting DXF file is then saved as 'merged.dxf'.",
            "code": "import ezdxf\nfrom ezdxf.addons import Importer\n\n\ndef merge(source, target):\n    importer = Importer(source, target)\n    # import all entities from source modelspace into target modelspace\n    importer.import_modelspace()\n    # import all required resources and dependencies\n    importer.finalize()\n\n\nbase_dxf = ezdxf.readfile('file1.dxf')\n\nfor filename in ('file2.dxf', 'file3.dxf'):\n    merge_dxf = ezdxf.readfile(filename)\n    merge(merge_dxf, base_dxf)\n\n# base_dxf.save()  # to save as file1.dxf\nbase_dxf.saveas('merged.dxf')",
            "masked_code": "import ezdxf\nfrom ezdxf.addons import Importer\n\n\ndef merge(source, target):\n    importer = Importer(source, target)\n    # import all entities from source modelspace into target modelspace\n    importer.import_modelspace()\n    # import all required resources and dependencies\n    importer.finalize()\n\n\nbase_dxf = ezdxf.readfile('file1.dxf')\n\nfor filename in ('file2.dxf', 'file3.dxf'):\n    merge_dxf = ezdxf.readfile(filename)\n    merge(merge_dxf, base_dxf)\n\n# base_dxf.save()  # to save as file1.dxf\n<line_mask>",
            "masked_line": "base_dxf.saveas('merged.dxf')",
            "answer": "saveas",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_331"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-10-06",
            "description": "The code creates a directed multigraph using NetworkX library in Python, with nodes labeled from 0 to 5 and edges connecting the nodes as specified in the code.",
            "code": "import networkx as nx\nnodes = [0, 1, 2, 3, 4, 5]\nedges = [(0,1), (1,0), (1, 0),(0, 1), (2, 3), (2, 3), (2, 3), (2, 3),\n         (4, 1), (4, 1), (4, 1), (4, 1), (4, 1), (4, 1), (4, 5), (5, 0)]\nG = nx.MultiDiGraph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)",
            "masked_code": "import networkx as nx\nnodes = [0, 1, 2, 3, 4, 5]\nedges = [(0,1), (1,0), (1, 0),(0, 1), (2, 3), (2, 3), (2, 3), (2, 3),\n         (4, 1), (4, 1), (4, 1), (4, 1), (4, 1), (4, 1), (4, 5), (5, 0)]\nG = nx.MultiDiGraph()\nG.add_nodes_from(nodes)\n<line_mask>",
            "masked_line": "G.add_edges_from(edges)",
            "answer": "add_edges_from",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_332"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-03-26",
            "description": "The code creates an undirected graph using the NetworkX library and adds edges from the list \"edges\". It then returns a list of sets where each set represents a connected component in the graph.",
            "code": "import networkx as nx\nG=nx.Graph()\nG.add_edges_from(edges)\nlist(nx.connected_components(G))",
            "masked_code": "import networkx as nx\nG=nx.Graph()\n<line_mask>\nlist(nx.connected_components(G))",
            "masked_line": "G.add_edges_from(edges)",
            "answer": "add_edges_from",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_333"
        },
        {
            "dependency": "scipy",
            "version": "==0.15.1",
            "time": "2019-03-22",
            "description": "The code performs zooming on a 3-dimensional randomly generated array using interpolation method from scipy.ndimage. The zoomed array's shape will have dimensions twice as large as the original array in the second and third axis.",
            "code": "from scipy.ndimage import interpolation\n\narr = np.random.randn(14,10,10)\nnew_arr = interpolation.zoom(arr,[1,2,2])\n\nprint(new_arr.shape)\n# (14, 20, 20)",
            "masked_code": "from scipy.ndimage import interpolation\n\narr = np.random.randn(14,10,10)\n<line_mask>\n\nprint(new_arr.shape)\n# (14, 20, 20)",
            "masked_line": "new_arr = interpolation.zoom(arr,[1,2,2])",
            "answer": "zoom",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_334"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-18",
            "description": "The code calculates the root of a function by solving a nonlinear equation using the fsolve function from the scipy.optimize module. The function takes in an array as an argument and returns the sum of f multiplied by the exponential function of -g*x minus a constant K. The code then computes the root of this function with an initial guess x0=1 and extra dimensions introduced for f and g.",
            "code": "import numpy as np\nimport scipy.optimize\n\nnp.random.seed(123)\n\nf = np.random.uniform(size=50)\ng = np.random.uniform(size=f.size)\nK = np.sum(f * np.exp(-g*np.pi))\n\ndef func(x, f, g, K):\n    return np.sum(f * np.exp(-g*x), axis=0) - K\n\n# The argument to the function is an array itself,\n# so we need to introduce extra dimensions for f, g.\nres = scipy.optimize.fsolve(func, x0=1, args=(f[:, None], g[:, None], K))",
            "masked_code": "import numpy as np\nimport scipy.optimize\n\n<line_mask>\n\nf = np.random.uniform(size=50)\ng = np.random.uniform(size=f.size)\nK = np.sum(f * np.exp(-g*np.pi))\n\ndef func(x, f, g, K):\n    return np.sum(f * np.exp(-g*x), axis=0) - K\n\n# The argument to the function is an array itself,\n# so we need to introduce extra dimensions for f, g.\nres = scipy.optimize.fsolve(func, x0=1, args=(f[:, None], g[:, None], K))",
            "masked_line": "np.random.seed(123)",
            "answer": "seed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_335"
        },
        {
            "dependency": "spacy",
            "version": ">=3.0",
            "time": "2022-03-16",
            "description": "The code initializes a spaCy language model, creates a document object with a list of tokens, and prints out the text and part-of-speech tags for each token in the document.",
            "code": "import spacy\nfrom spacy.tokens import Doc\nnlp = spacy.load(\"en_core_web_sm\")\n\nsent = [\"This\", \"is\", \"a\", \"sentence\"]\n\ndoc = Doc(nlp.vocab, sent)\nfor token in nlp(doc):\n    print(token.text, token.pos_)",
            "masked_code": "import spacy\nfrom spacy.tokens import Doc\nnlp = spacy.load(\"en_core_web_sm\")\n\nsent = [\"This\", \"is\", \"a\", \"sentence\"]\n\n<line_mask>\nfor token in nlp(doc):\n    print(token.text, token.pos_)",
            "masked_line": "doc = Doc(nlp.vocab, sent)",
            "answer": "nlp",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_336"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-04-27",
            "description": "This code defines a CLI (Command Line Interface) using the Click library in Python. It includes options such as opt1, opt2, opt3, opt4, and opt5, which are grouped into two different option groups. The CLI takes in user input from the command line, processes the input arguments, and prints out the argument-value pairs using the click.echo function. The code also includes a list of predefined commands to test the CLI functionality and print out the Click version and Python version before executing each command. If an exception occurs during command execution, it is caught and handled accordingly.",
            "code": "@click.command()\n@click.option('--opt1', cls=GroupedOptions, opt_group=1)\n@click.option('--opt2', cls=GroupedOptions, opt_group=1)\n@click.option('--opt3', cls=GroupedOptions, opt_group=1)\n@click.option('--opt4', cls=GroupedOptions, opt_group=2)\n@click.option('--opt5', cls=GroupedOptions, opt_group=2)\ndef cli(**kwargs):\n    for arg, value in kwargs.items():\n        click.echo(\"{}: {}\".format(arg, value))\n\nif __name__ == \"__main__\":\n    commands = (\n        '--opt1=x',\n        '--opt4=a',\n        '--opt4=a --opt5=b',\n        '--opt1=x --opt2=y --opt3=z --opt4=a --opt5=b',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "@click.command()\n@click.option('--opt1', cls=GroupedOptions, opt_group=1)\n@click.option('--opt2', cls=GroupedOptions, opt_group=1)\n@click.option('--opt3', cls=GroupedOptions, opt_group=1)\n@click.option('--opt4', cls=GroupedOptions, opt_group=2)\n<line_mask>\ndef cli(**kwargs):\n    for arg, value in kwargs.items():\n        click.echo(\"{}: {}\".format(arg, value))\n\nif __name__ == \"__main__\":\n    commands = (\n        '--opt1=x',\n        '--opt4=a',\n        '--opt4=a --opt5=b',\n        '--opt1=x --opt2=y --opt3=z --opt4=a --opt5=b',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.option('--opt5', cls=GroupedOptions, opt_group=2)",
            "answer": "option",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_337"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-04-12",
            "description": "This code creates a Bokeh plot with multiple lines that can be dynamically added and removed using a multi-select widget. The plot displays real-time data with timestamps on the x-axis and random data for each line on the y-axis.",
            "code": "from bokeh.models import ColumnDataSource, MultiSelect, Column\nfrom bokeh.plotting import figure, curdoc\nfrom datetime import datetime\nfrom random import randint\nfrom bokeh.palettes import Category10\n\nlines = ['line_{}'.format(i) for i in range(10)]\ndata = [{'time':[], item:[]} for item in lines]\nsources = [ColumnDataSource(item) for item in data]\n\nplot = figure(plot_width = 1200, x_axis_type = 'datetime')\n\ndef add_line(attr, old, new):\n    for line in new:\n        if not plot.select_one({\"name\": line}):\n            index = lines.index(line)\n            plot.line(x = 'time', y = line, color = Category10[10][index], name = line, source = sources[index])\n\nmultiselect = MultiSelect(title = 'Options', options = [(i, i) for i in lines], value = [''])\nmultiselect.on_change('value', add_line)\n\ndef update():\n    for line in lines:\n        if line in multiselect.value:\n            if plot.select({\"name\": line}):\n                sources[lines.index(line)].stream(eval('dict(time = [datetime.now()], ' + line + ' = [randint(5, 10)])'))\n\ncurdoc().add_root(Column(plot, multiselect))\ncurdoc().add_periodic_callback(update, 1000)",
            "masked_code": "from bokeh.models import ColumnDataSource, MultiSelect, Column\nfrom bokeh.plotting import figure, curdoc\nfrom datetime import datetime\nfrom random import randint\nfrom bokeh.palettes import Category10\n\nlines = ['line_{}'.format(i) for i in range(10)]\ndata = [{'time':[], item:[]} for item in lines]\nsources = [ColumnDataSource(item) for item in data]\n\nplot = figure(plot_width = 1200, x_axis_type = 'datetime')\n\ndef add_line(attr, old, new):\n    for line in new:\n        if not plot.select_one({\"name\": line}):\n            index = lines.index(line)\n            plot.line(x = 'time', y = line, color = Category10[10][index], name = line, source = sources[index])\n\nmultiselect = MultiSelect(title = 'Options', options = [(i, i) for i in lines], value = [''])\nmultiselect.on_change('value', add_line)\n\ndef update():\n    for line in lines:\n        if line in multiselect.value:\n            <line_mask>\n                sources[lines.index(line)].stream(eval('dict(time = [datetime.now()], ' + line + ' = [randint(5, 10)])'))\n\ncurdoc().add_root(Column(plot, multiselect))\ncurdoc().add_periodic_callback(update, 1000)",
            "masked_line": "if plot.select({\"name\": line}):",
            "answer": "select",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_338"
        },
        {
            "dependency": "networkx",
            "version": "==1.9.1",
            "time": "2019-04-04",
            "description": "The code creates a graph using the NetworkX library from a pandas DataFrame, where each row represents an edge between two nodes specified by 'item 1' and 'item 2' columns.",
            "code": "import networkx as nx\n\ndf0 = pd.DataFrame({'item 1': {0: 'Q', 1: 'R', 2: 'B', 3: 'A'},\n                    'item 2': {0: 'R', 1: 'P', 2: 'A', 3: 'C'}})\n\ng = nx.convert_matrix.from_pandas_edgelist(df0, source='item 1', target='item 2')",
            "masked_code": "import networkx as nx\n\ndf0 = pd.DataFrame({'item 1': {0: 'Q', 1: 'R', 2: 'B', 3: 'A'},\n                    'item 2': {0: 'R', 1: 'P', 2: 'A', 3: 'C'}})\n\n<line_mask>",
            "masked_line": "g = nx.convert_matrix.from_pandas_edgelist(df0, source='item 1', target='item 2')",
            "answer": "from_pandas_edgelist",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_339"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.13.1",
            "time": "2019-03-25",
            "description": "This code retrieves TensorFlow operations that support complex data types and prints their names. It filters out operations based on the allowed data types specified in the code and returns a sorted list of valid operations supporting complex data types. The code then prints the names of these operations.",
            "code": "import tensorflow as tf\n\ndef get_ops_with_dtypes(dtypes):\n    from tensorflow.python.framework import ops\n    valid_ops = []\n    dtype_enums = set(dtype.as_datatype_enum for dtype in dtypes)\n    reg_ops = ops.op_def_registry.get_registered_ops()\n    for op in reg_ops.values():\n        for attr in op.attr:\n            if (attr.type == 'type' and\n                any(t in dtype_enums for t in attr.allowed_values.list.type)):\n                valid_ops.append(op)\n                break\n    # Sort by name for convenience\n    return sorted(valid_ops, key=lambda op: op.name)\n\ncomplex_dtypes = [tf.complex64, tf.complex128]\ncomplex_ops = get_ops_with_dtypes(complex_dtypes)\n\n# Print one op\nprint(complex_ops[0])\n# name: \"AccumulateNV2\"\n# input_arg {\n#   name: \"inputs\"\n#   type_attr: \"T\"\n#   number_attr: \"N\"\n# }\n# output_arg {\n#   name: \"sum\"\n#   type_attr: \"T\"\n# }\n# attr {\n#   name: \"N\"\n#   type: \"int\"\n#   has_minimum: true\n#   minimum: 1\n# }\n# attr {\n#   name: \"T\"\n#   type: \"type\"\n#   allowed_values {\n#     list {\n#       type: DT_FLOAT\n#       type: DT_DOUBLE\n#       type: DT_INT32\n#       type: DT_UINT8\n#       type: DT_INT16\n#       type: DT_INT8\n#       type: DT_COMPLEX64\n#       type: DT_INT64\n#       type: DT_QINT8\n#       type: DT_QUINT8\n#       type: DT_QINT32\n#       type: DT_BFLOAT16\n#       type: DT_UINT16\n#       type: DT_COMPLEX128\n#       type: DT_HALF\n#       type: DT_UINT32\n#       type: DT_UINT64\n#     }\n#   }\n# }\n# attr {\n#   name: \"shape\"\n#   type: \"shape\"\n# }\n# is_aggregate: true\n# is_commutative: true\n\n# Print op names\nprint(*(op.name for op in complex_ops), sep='\\n')\n# AccumulateNV2\n# AccumulatorApplyGradient\n# AccumulatorTakeGradient\n# Acos\n# Acosh\n# Add\n# AddN\n# AddV2\n# Angle\n# ApplyAdaMax\n# ...",
            "masked_code": "import tensorflow as tf\n\ndef get_ops_with_dtypes(dtypes):\n    from tensorflow.python.framework import ops\n    valid_ops = []\n    dtype_enums = set(dtype.as_datatype_enum for dtype in dtypes)\n    reg_ops = ops.op_def_registry.get_registered_ops()\n    <line_mask>\n        for attr in op.attr:\n            if (attr.type == 'type' and\n                any(t in dtype_enums for t in attr.allowed_values.list.type)):\n                valid_ops.append(op)\n                break\n    # Sort by name for convenience\n    return sorted(valid_ops, key=lambda op: op.name)\n\ncomplex_dtypes = [tf.complex64, tf.complex128]\ncomplex_ops = get_ops_with_dtypes(complex_dtypes)\n\n# Print one op\nprint(complex_ops[0])\n# name: \"AccumulateNV2\"\n# input_arg {\n#   name: \"inputs\"\n#   type_attr: \"T\"\n#   number_attr: \"N\"\n# }\n# output_arg {\n#   name: \"sum\"\n#   type_attr: \"T\"\n# }\n# attr {\n#   name: \"N\"\n#   type: \"int\"\n#   has_minimum: true\n#   minimum: 1\n# }\n# attr {\n#   name: \"T\"\n#   type: \"type\"\n#   allowed_values {\n#     list {\n#       type: DT_FLOAT\n#       type: DT_DOUBLE\n#       type: DT_INT32\n#       type: DT_UINT8\n#       type: DT_INT16\n#       type: DT_INT8\n#       type: DT_COMPLEX64\n#       type: DT_INT64\n#       type: DT_QINT8\n#       type: DT_QUINT8\n#       type: DT_QINT32\n#       type: DT_BFLOAT16\n#       type: DT_UINT16\n#       type: DT_COMPLEX128\n#       type: DT_HALF\n#       type: DT_UINT32\n#       type: DT_UINT64\n#     }\n#   }\n# }\n# attr {\n#   name: \"shape\"\n#   type: \"shape\"\n# }\n# is_aggregate: true\n# is_commutative: true\n\n# Print op names\nprint(*(op.name for op in complex_ops), sep='\\n')\n# AccumulateNV2\n# AccumulatorApplyGradient\n# AccumulatorTakeGradient\n# Acos\n# Acosh\n# Add\n# AddN\n# AddV2\n# Angle\n# ApplyAdaMax\n# ...",
            "masked_line": "for op in reg_ops.values():",
            "answer": "values",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_340"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-02-19",
            "description": "The code calculates the angular power spectrum of a masked map using the Healpy library in Python.",
            "code": "import numpy as np\nimport healpy as hp\n\nmasked_map = np.where(mask, raw_map, hp.UNSEEN)\ncl = hp.anafast(masked_map)",
            "masked_code": "import numpy as np\nimport healpy as hp\n\n<line_mask>\ncl = hp.anafast(masked_map)",
            "masked_line": "masked_map = np.where(mask, raw_map, hp.UNSEEN)",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_341"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-02-15",
            "description": "The code is a Python script that utilizes the Click library to create a command-line interface. It defines a class Foo with a log method to print the arguments passed to it. The main function sets up the command-line interface, creates an instance of Foo with the provided arguments, and then calls the log method on the instance. The script also includes handling of various commands and exceptions.",
            "code": "import click\n\nclass Foo(object):\n    def __init__(self, *args):\n        self.args = args\n\n    def log(self):\n        print('self.args:', self.args)\n\n\npass_foo = click.make_pass_decorator(Foo)\n\n\n@click.group(cls=CommandAfterArgs)\n@click.argument('myargs', nargs=-1)\n@click.pass_context\ndef main(ctx, myargs):\n    ctx.obj = Foo(*myargs)\n    print(\"arguments: \", myargs)\n\n\n@main.command()\n@pass_foo\ndef log(foo):\n    foo.log()\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'arg1 arg2 log',\n        'log --help',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            main(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\nclass Foo(object):\n    def __init__(self, *args):\n        self.args = args\n\n    def log(self):\n        print('self.args:', self.args)\n\n\npass_foo = click.make_pass_decorator(Foo)\n\n\n<line_mask>\n@click.argument('myargs', nargs=-1)\n@click.pass_context\ndef main(ctx, myargs):\n    ctx.obj = Foo(*myargs)\n    print(\"arguments: \", myargs)\n\n\n@main.command()\n@pass_foo\ndef log(foo):\n    foo.log()\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'arg1 arg2 log',\n        'log --help',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            main(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.group(cls=CommandAfterArgs)",
            "answer": "group",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_342"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-05",
            "description": "The code splits an array A based on the differences of another array B. It returns a list of arrays where the elements of A are grouped together based on the consecutive values in B.",
            "code": "lst_of_array = np.split(A, np.where(np.diff(B) == 1)[0]+1)[{0:1,1:0}[B[0]]::2]\n\n# [array([ 1, -3,  0]),\n#  array([2, 7]),\n#  array([8]),\n#  array([18,  9])]",
            "masked_code": "<line_mask>\n\n# [array([ 1, -3,  0]),\n#  array([2, 7]),\n#  array([8]),\n#  array([18,  9])]",
            "masked_line": "lst_of_array = np.split(A, np.where(np.diff(B) == 1)[0]+1)[{0:1,1:0}[B[0]]::2]",
            "answer": "split",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_343"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.22",
            "time": "2019-12-18",
            "description": "The code trains a random forest classifier on the wine dataset to predict if a wine is of Class 2, calculates the ROC AUC score for the training set.",
            "code": "import matplotlib.pyplot as plt\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import plot_roc_curve\nfrom sklearn.datasets import load_wine\nfrom sklearn.model_selection import train_test_split\n\nX, y = load_wine(return_X_y=True)\ny = y == 2\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)\n\nrfc = RandomForestClassifier(n_estimators=10, random_state=42, oob_score=True)\nrfc.fit(X_train, y_train)\n\nfrom sklearn import metrics\npred_train = np.argmax(rfc.oob_decision_function_,axis=1)\nmetrics.roc_auc_score(y_train, pred_train)",
            "masked_code": "import matplotlib.pyplot as plt\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import plot_roc_curve\nfrom sklearn.datasets import load_wine\nfrom sklearn.model_selection import train_test_split\n\nX, y = load_wine(return_X_y=True)\ny = y == 2\n\n<line_mask>\n\nrfc = RandomForestClassifier(n_estimators=10, random_state=42, oob_score=True)\nrfc.fit(X_train, y_train)\n\nfrom sklearn import metrics\npred_train = np.argmax(rfc.oob_decision_function_,axis=1)\nmetrics.roc_auc_score(y_train, pred_train)",
            "masked_line": "X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)",
            "answer": "train_test_split",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_344"
        },
        {
            "dependency": "tensorflow",
            "version": "<1.13",
            "time": "2019-07-05",
            "description": "This code concatenates two sets of column indices, sorts them in ascending order, and returns the sorted column indices.",
            "code": "import tensorflow as tf\n\na = [[[1,1],[2,2],[3,3]],\n     [[4,4],[5,5],[6,6]],\n     [[7,7],[8,8],[9,9]]]\n\nb = [[[10,10],[11,11]],\n     [[12,12],[13,13]],\n     [[14,14],[15,15]]]\n\na_tf = tf.constant(a)\nb_tf = tf.constant(b)\n\na_tf_column = tf.range(a_tf.shape[1])*2\n# [0 2 4]\nb_tf_column = tf.range(b_tf.shape[1])*2+1\n# [1 3]\n\ncolumn_indices = tf.concat([a_tf_column,b_tf_column],axis=-1)\n# Before TF v1.13\ncolumn_indices = tf.contrib.framework.argsort(column_indices)\n## From TF v1.13\n# column_indices = tf.argsort(column_indices)\n\n# [0 3 1 4 2]",
            "masked_code": "import tensorflow as tf\n\na = [[[1,1],[2,2],[3,3]],\n     [[4,4],[5,5],[6,6]],\n     [[7,7],[8,8],[9,9]]]\n\nb = [[[10,10],[11,11]],\n     [[12,12],[13,13]],\n     [[14,14],[15,15]]]\n\na_tf = tf.constant(a)\n<line_mask>\n\na_tf_column = tf.range(a_tf.shape[1])*2\n# [0 2 4]\nb_tf_column = tf.range(b_tf.shape[1])*2+1\n# [1 3]\n\ncolumn_indices = tf.concat([a_tf_column,b_tf_column],axis=-1)\n# Before TF v1.13\ncolumn_indices = tf.contrib.framework.argsort(column_indices)\n## From TF v1.13\n# column_indices = tf.argsort(column_indices)\n\n# [0 3 1 4 2]",
            "masked_line": "b_tf = tf.constant(b)",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_345"
        },
        {
            "dependency": "pytest",
            "version": "==4.4.2",
            "time": "2019-06-12",
            "description": "This code defines two fixtures, `real_db_session` and `mocked_db_session`, that provide database sessions for testing purposes. The `db_session` fixture can be used with two different backend types - 'real' or 'mock'. The 'real' backend creates a session connected to a SQLite database with sample data, while the 'mock' backend uses a mock session for testing without interacting with a real database.",
            "code": "import pytest\nfrom unittest import mock\n\nfrom sqlalchemy import create_engine, Column, String, Integer\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nfrom alchemy_mock.mocking import UnifiedAlchemyMagicMock\n\nBase = declarative_base()\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n\n@pytest.fixture\ndef real_db_session():\n    engine = create_engine('sqlite:///real.db')\n\n    with engine.connect() as conn:\n        Session = sessionmaker(bind=conn)\n        Base.metadata.create_all(engine)\n        session = Session()\n\n        sample_item = Item(name='fizz')\n        session.add(sample_item)\n        session.commit()\n\n        yield session\n\n\n@pytest.fixture\ndef mocked_db_session():\n    session = UnifiedAlchemyMagicMock()\n    session.add(Item(name='fizz'))\n    return session\n\n\n@pytest.fixture(params=('real', 'mock'))\ndef db_session(request, real_db_session, mocked_db_session):\n    backend_type = request.param\n    if backend_type == 'real':\n        return real_db_session\n    elif backend_type == 'mock':\n        return mocked_db_session",
            "masked_code": "import pytest\nfrom unittest import mock\n\nfrom sqlalchemy import create_engine, Column, String, Integer\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nfrom alchemy_mock.mocking import UnifiedAlchemyMagicMock\n\nBase = declarative_base()\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n\n@pytest.fixture\ndef real_db_session():\n    engine = create_engine('sqlite:///real.db')\n\n    with engine.connect() as conn:\n        Session = sessionmaker(bind=conn)\n        Base.metadata.create_all(engine)\n        session = Session()\n\n        sample_item = Item(name='fizz')\n        session.add(sample_item)\n        session.commit()\n\n        yield session\n\n\n<line_mask>\ndef mocked_db_session():\n    session = UnifiedAlchemyMagicMock()\n    session.add(Item(name='fizz'))\n    return session\n\n\n@pytest.fixture(params=('real', 'mock'))\ndef db_session(request, real_db_session, mocked_db_session):\n    backend_type = request.param\n    if backend_type == 'real':\n        return real_db_session\n    elif backend_type == 'mock':\n        return mocked_db_session",
            "masked_line": "@pytest.fixture",
            "answer": "fixture",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_346"
        },
        {
            "dependency": "seaborn",
            "version": "==0.9.0",
            "time": "2019-05-07",
            "description": "This code creates a scatter plot using the Seaborn library, displaying the relationship between total bill and tip amount. The plot is colored based on the day of the week. The legend is customized to display the days of the week as labels.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ntips = sns.load_dataset(\"tips\")\ng = sns.scatterplot(x=\"total_bill\", y=\"tip\", hue=\"day\",\n                    data=tips, s=75,  edgecolor='k')\n\n# Assumes Seaborn 0.9.0\nlegend = g.legend_\n\n# Set legend title\nlegend.get_texts()[0].set_text('Day of Week')\n\nlabels=['Thursday', 'Friday', 'Saturday', 'Sunday']\n\n# Set legend labels\nfor i, label in enumerate(labels):\n    # i+1 because i=0 is the title, and i starts at 0\n    legend.get_texts()[i+1].set_text(label) \n\n# sns.plt.show() for me gives \"AttributeError: module 'seaborn' has no attribute 'plt'\"\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n<line_mask>\ng = sns.scatterplot(x=\"total_bill\", y=\"tip\", hue=\"day\",\n                    data=tips, s=75,  edgecolor='k')\n\n# Assumes Seaborn 0.9.0\nlegend = g.legend_\n\n# Set legend title\nlegend.get_texts()[0].set_text('Day of Week')\n\nlabels=['Thursday', 'Friday', 'Saturday', 'Sunday']\n\n# Set legend labels\nfor i, label in enumerate(labels):\n    # i+1 because i=0 is the title, and i starts at 0\n    legend.get_texts()[i+1].set_text(label) \n\n# sns.plt.show() for me gives \"AttributeError: module 'seaborn' has no attribute 'plt'\"\nplt.show()",
            "masked_line": "tips = sns.load_dataset(\"tips\")",
            "answer": "load_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_347"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.5",
            "time": "2019-05-04",
            "description": "The function calculates the square root of the product of the second and third elements in each pixel of an image array.",
            "code": "import numpy as np\nimg = np.random.random((100,100,3))\n\ndef original_function(img):\n  a = []\n  for row in img:\n      for col in row:\n          a.append(np.sqrt(np.prod(col[1:])))\n  adjusted = np.asarray(a).reshape((img.shape[0], img.shape[1]))\n\n  return adjusted\n\ndef improved_function(img):\n  return np.sqrt(np.prod(img[:,:,1:], axis=-1))",
            "masked_code": "import numpy as np\nimg = np.random.random((100,100,3))\n\ndef original_function(img):\n  a = []\n  for row in img:\n      for col in row:\n          <line_mask>\n  adjusted = np.asarray(a).reshape((img.shape[0], img.shape[1]))\n\n  return adjusted\n\ndef improved_function(img):\n  return np.sqrt(np.prod(img[:,:,1:], axis=-1))",
            "masked_line": "a.append(np.sqrt(np.prod(col[1:])))",
            "answer": "prod",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_348"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-17",
            "description": "The code creates a categorical heatmap and a bar chart using Bokeh library in Python. The categorical heatmap represents sales data for different categories in different stores over different months. The bar chart displays dummy category sales data. When a store and month are selected on the heatmap, the corresponding sales data for that store and month are updated on the bar chart.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.models import TapTool, CustomJS, ColumnDataSource, Row, ColorBar, LinearColorMapper, BasicTicker\nfrom bokeh.models.sources import ColumnDataSource\nfrom bokeh.transform import transform\nfrom bokeh.palettes import Viridis256\nimport random\n\nstores = [\"store 1\", \"store 2\", \"store 3\"]\nmonths = [\"january\", \"fabruary\", \"march\"]\nx = [\"store 1\", \"store 2\", \"store 3\", \"store 1\", \"store 2\", \"store 3\", \"store 1\", \"store 2\", \"store 3\"]\ny = [\"january\", \"january\", \"january\", \"fabruary\", \"fabruary\", \"fabruary\", \"march\", \"march\", \"march\"]\ncolors = [\"#0B486B\", \"#79BD9A\", \"#CFF09E\", \"#79BD9A\", \"#0B486B\", \"#79BD9A\", \"#CFF09E\", \"#79BD9A\", \"#0B486B\" ]\n\np1 = figure(title = \"Categorical Heatmap\", tools = \"tap\", toolbar_location = None,\n            x_range = stores, y_range = months)\np1.rect(x = x, y = y, color = colors, width = 1, height = 1)\n\ncategories = ['shoes', 'pants', 'suits']\ncategory_sales = {}\nfor store in stores:\n    category_sales[store] = {}\n    for month in months:\n        category_sales[store][month] = [random.choice([i for i in range(10000)]) for r in range(3)]\n\ndummy_category_sales = [1000, 1100, 1200]\ndata = {'x': categories, 'y': dummy_category_sales}\nsource = ColumnDataSource(data)\n\np2 = figure(x_range = categories)\nbars = p2.vbar(x = 'x', top = 'y', source = source, bottom = 0, width = 0.5)\nbars.visible = False\n\ncode = '''if (cb_data.source.selected.indices.length > 0){\n            bars.visible = true;\n            selected_index = cb_data.source.selected.indices[0];    \n            store = cb_data.source.data['x'][selected_index]\n            month = cb_data.source.data['y'][selected_index]\n\n            bars.data_source.data['y'] = category_sales[store][month]\n            bars.data_source.change.emit(); \n        }'''\n\np1.select_one(TapTool).callback = CustomJS(args = dict(bars = bars, category_sales = category_sales), code = code)\n\nplots = Row(p1, p2)\nshow(plots)",
            "masked_code": "<line_mask>\nfrom bokeh.models import TapTool, CustomJS, ColumnDataSource, Row, ColorBar, LinearColorMapper, BasicTicker\nfrom bokeh.models.sources import ColumnDataSource\nfrom bokeh.transform import transform\nfrom bokeh.palettes import Viridis256\nimport random\n\nstores = [\"store 1\", \"store 2\", \"store 3\"]\nmonths = [\"january\", \"fabruary\", \"march\"]\nx = [\"store 1\", \"store 2\", \"store 3\", \"store 1\", \"store 2\", \"store 3\", \"store 1\", \"store 2\", \"store 3\"]\ny = [\"january\", \"january\", \"january\", \"fabruary\", \"fabruary\", \"fabruary\", \"march\", \"march\", \"march\"]\ncolors = [\"#0B486B\", \"#79BD9A\", \"#CFF09E\", \"#79BD9A\", \"#0B486B\", \"#79BD9A\", \"#CFF09E\", \"#79BD9A\", \"#0B486B\" ]\n\np1 = figure(title = \"Categorical Heatmap\", tools = \"tap\", toolbar_location = None,\n            x_range = stores, y_range = months)\np1.rect(x = x, y = y, color = colors, width = 1, height = 1)\n\ncategories = ['shoes', 'pants', 'suits']\ncategory_sales = {}\nfor store in stores:\n    category_sales[store] = {}\n    for month in months:\n        category_sales[store][month] = [random.choice([i for i in range(10000)]) for r in range(3)]\n\ndummy_category_sales = [1000, 1100, 1200]\ndata = {'x': categories, 'y': dummy_category_sales}\nsource = ColumnDataSource(data)\n\np2 = figure(x_range = categories)\nbars = p2.vbar(x = 'x', top = 'y', source = source, bottom = 0, width = 0.5)\nbars.visible = False\n\ncode = '''if (cb_data.source.selected.indices.length > 0){\n            bars.visible = true;\n            selected_index = cb_data.source.selected.indices[0];    \n            store = cb_data.source.data['x'][selected_index]\n            month = cb_data.source.data['y'][selected_index]\n\n            bars.data_source.data['y'] = category_sales[store][month]\n            bars.data_source.change.emit(); \n        }'''\n\np1.select_one(TapTool).callback = CustomJS(args = dict(bars = bars, category_sales = category_sales), code = code)\n\nplots = Row(p1, p2)\nshow(plots)",
            "masked_line": "from bokeh.plotting import figure, show",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_349"
        },
        {
            "dependency": "Flask",
            "version": "==1.1.1",
            "time": "2020-01-21",
            "description": "The code sets up a Flask application with SQLAlchemy database integration, Flask Admin for administration interface, BasicAuth for authentication, and custom classes to handle authentication exceptions. It defines a Module class for database models and customizes ModelView and AdminIndexView classes to work with BasicAuth for authentication. Finally, it creates an admin interface with the Module model and custom authentication views.",
            "code": "from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_admin import Admin, AdminIndexView\nfrom flask_admin.contrib.sqla import ModelView\nfrom flask_basicauth import BasicAuth\nfrom werkzeug.exceptions import HTTPException\n\napp = Flask(__name__)\ndb = SQLAlchemy(app)\nbasic_auth = BasicAuth(app)\n\nclass Module(db.Model):\n  __tablename__='Modules'\n  name = db.Column(db.String(30), unique=True, nullable=False)\n\n\"\"\"\nThe following three classes are inherited from their respective base class,\nand are customized, to make flask_admin compatible with BasicAuth.\n\"\"\"\nclass AuthException(HTTPException):\n    def __init__(self, message):\n        super().__init__(message, Response(\n            \"You could not be authenticated. Please refresh the page.\", 401,\n            {'WWW-Authenticate': 'Basic realm=\"Login Required\"'} ))\n\nclass MyModelView(ModelView):\n    def is_accessible(self):\n        if not basic_auth.authenticate():\n            raise AuthException('Not authenticated.')\n        else:\n            return True\n    def inaccessible_callback(self, name, **kwargs):\n        return redirect(basic_auth.challenge())\n\nclass MyAdminIndexView(AdminIndexView):\n    def is_accessible(self):\n        if not basic_auth.authenticate():\n            raise AuthException('Not authenticated.')\n        else:\n            return True\n    def inaccessible_callback(self, name, **kwargs):\n        return redirect(basic_auth.challenge())\n\nadmin = Admin(app, index_view=MyAdminIndexView())\n\nadmin.add_view(MyModelView(Module, db.session))",
            "masked_code": "from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_admin import Admin, AdminIndexView\nfrom flask_admin.contrib.sqla import ModelView\nfrom flask_basicauth import BasicAuth\nfrom werkzeug.exceptions import HTTPException\n\napp = Flask(__name__)\ndb = SQLAlchemy(app)\nbasic_auth = BasicAuth(app)\n\nclass Module(db.Model):\n  __tablename__='Modules'\n  name = db.Column(db.String(30), unique=True, nullable=False)\n\n\"\"\"\nThe following three classes are inherited from their respective base class,\nand are customized, to make flask_admin compatible with BasicAuth.\n\"\"\"\nclass AuthException(HTTPException):\n    def __init__(self, message):\n        super().__init__(message, Response(\n            \"You could not be authenticated. Please refresh the page.\", 401,\n            {'WWW-Authenticate': 'Basic realm=\"Login Required\"'} ))\n\nclass MyModelView(ModelView):\n    def is_accessible(self):\n        if not basic_auth.authenticate():\n            raise AuthException('Not authenticated.')\n        else:\n            return True\n    def inaccessible_callback(self, name, **kwargs):\n        return redirect(basic_auth.challenge())\n\nclass MyAdminIndexView(AdminIndexView):\n    def is_accessible(self):\n        <line_mask>\n            raise AuthException('Not authenticated.')\n        else:\n            return True\n    def inaccessible_callback(self, name, **kwargs):\n        return redirect(basic_auth.challenge())\n\nadmin = Admin(app, index_view=MyAdminIndexView())\n\nadmin.add_view(MyModelView(Module, db.session))",
            "masked_line": "if not basic_auth.authenticate():",
            "answer": "authenticate",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_350"
        },
        {
            "dependency": "Flask-Admin",
            "version": "==1.5.4",
            "time": "2020-01-21",
            "description": "This code sets up a Flask web application with SQLAlchemy for database management, Flask-Admin for database administration, and Flask-BasicAuth for basic authentication. It defines a Module class with a name attribute, customizes classes to make Flask-Admin compatible with BasicAuth, and adds views for the Module class in the admin interface. Additionally, it handles authentication and redirects users to login if they are not authenticated.",
            "code": "from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_admin import Admin, AdminIndexView\nfrom flask_admin.contrib.sqla import ModelView\nfrom flask_basicauth import BasicAuth\nfrom werkzeug.exceptions import HTTPException\n\napp = Flask(__name__)\ndb = SQLAlchemy(app)\nbasic_auth = BasicAuth(app)\n\nclass Module(db.Model):\n  __tablename__='Modules'\n  name = db.Column(db.String(30), unique=True, nullable=False)\n\n\"\"\"\nThe following three classes are inherited from their respective base class,\nand are customized, to make flask_admin compatible with BasicAuth.\n\"\"\"\nclass AuthException(HTTPException):\n    def __init__(self, message):\n        super().__init__(message, Response(\n            \"You could not be authenticated. Please refresh the page.\", 401,\n            {'WWW-Authenticate': 'Basic realm=\"Login Required\"'} ))\n\nclass MyModelView(ModelView):\n    def is_accessible(self):\n        if not basic_auth.authenticate():\n            raise AuthException('Not authenticated.')\n        else:\n            return True\n    def inaccessible_callback(self, name, **kwargs):\n        return redirect(basic_auth.challenge())\n\nclass MyAdminIndexView(AdminIndexView):\n    def is_accessible(self):\n        if not basic_auth.authenticate():\n            raise AuthException('Not authenticated.')\n        else:\n            return True\n    def inaccessible_callback(self, name, **kwargs):\n        return redirect(basic_auth.challenge())\n\nadmin = Admin(app, index_view=MyAdminIndexView())\n\nadmin.add_view(MyModelView(Module, db.session))",
            "masked_code": "from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_admin import Admin, AdminIndexView\nfrom flask_admin.contrib.sqla import ModelView\nfrom flask_basicauth import BasicAuth\nfrom werkzeug.exceptions import HTTPException\n\napp = Flask(__name__)\ndb = SQLAlchemy(app)\nbasic_auth = BasicAuth(app)\n\nclass Module(db.Model):\n  __tablename__='Modules'\n  name = db.Column(db.String(30), unique=True, nullable=False)\n\n\"\"\"\nThe following three classes are inherited from their respective base class,\nand are customized, to make flask_admin compatible with BasicAuth.\n\"\"\"\nclass AuthException(HTTPException):\n    def __init__(self, message):\n        super().__init__(message, Response(\n            \"You could not be authenticated. Please refresh the page.\", 401,\n            {'WWW-Authenticate': 'Basic realm=\"Login Required\"'} ))\n\nclass MyModelView(ModelView):\n    def is_accessible(self):\n        if not basic_auth.authenticate():\n            raise AuthException('Not authenticated.')\n        else:\n            return True\n    def inaccessible_callback(self, name, **kwargs):\n        return redirect(basic_auth.challenge())\n\nclass MyAdminIndexView(AdminIndexView):\n    def is_accessible(self):\n        if not basic_auth.authenticate():\n            raise AuthException('Not authenticated.')\n        else:\n            return True\n    def inaccessible_callback(self, name, **kwargs):\n        return redirect(basic_auth.challenge())\n\n<line_mask>\n\nadmin.add_view(MyModelView(Module, db.session))",
            "masked_line": "admin = Admin(app, index_view=MyAdminIndexView())",
            "answer": "Admin",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_351"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-30",
            "description": "This code creates a data table with columns for dates and downloads, along with input fields for row index, column index, date, downloads, and cell contents. The code includes JavaScript functionality to display information about the selected cell in the table within the input fields.",
            "code": "from random import randint\nfrom datetime import date\nfrom bokeh.models import ColumnDataSource, TableColumn, DateFormatter, DataTable, CustomJS\nfrom bokeh.layouts import column\nfrom bokeh.models.widgets import TextInput\nfrom bokeh.plotting import curdoc\n\nsource = ColumnDataSource(dict(dates = [date(2014, 3, i + 1) for i in range(10)], downloads = [randint(0, 100) for i in range(10)]))\ncolumns = [TableColumn(field = \"dates\", title = \"Date\", formatter = DateFormatter()), TableColumn(field = \"downloads\", title = \"Downloads\")]\ndata_table = DataTable(source = source, columns = columns, width = 400, height = 280, editable = True, reorderable = False)\n\ntext_row = TextInput(value = None, title = \"Row index:\", width = 420)\ntext_column = TextInput(value = None, title = \"Column Index:\", width = 420)\ntext_date = TextInput(value = None, title = \"Date:\", width = 420)\ntext_downloads = TextInput(value = None, title = \"Downloads:\", width = 420)\ntest_cell = TextInput(value = None, title = \"Cell Contents:\", width = 420)\n\nsource_code = \"\"\"\nvar grid = document.getElementsByClassName('grid-canvas')[0].children;\nvar row, column = '';\n\nfor (var i = 0,max = grid.length; i < max; i++){\n    if (grid[i].outerHTML.includes('active')){\n        row = i;\n        for (var j = 0, jmax = grid[i].children.length; j < jmax; j++)\n            if(grid[i].children[j].outerHTML.includes('active')) \n                { column = j }\n    }\n}\ntext_row.value = String(row);\ntext_column.value = String(column);\ntext_date.value = String(new Date(source.data['dates'][row]));\ntext_downloads.value = String(source.data['downloads'][row]); \ntest_cell.value = column == 1 ? text_date.value : text_downloads.value; \"\"\"\n\ndef py_callback(attr, old, new):\n    source.selected.update(indices = [])\n\nsource.selected.on_change('indices', py_callback)\ncallback = CustomJS(args = dict(source = source, text_row = text_row, text_column = text_column, text_date = text_date, text_downloads = text_downloads, test_cell = test_cell), code = source_code)\nsource.selected.js_on_change('indices', callback)\ncurdoc().add_root(column(data_table, text_row, text_column, text_date, text_downloads, test_cell))",
            "masked_code": "from random import randint\nfrom datetime import date\nfrom bokeh.models import ColumnDataSource, TableColumn, DateFormatter, DataTable, CustomJS\nfrom bokeh.layouts import column\nfrom bokeh.models.widgets import TextInput\nfrom bokeh.plotting import curdoc\n\nsource = ColumnDataSource(dict(dates = [date(2014, 3, i + 1) for i in range(10)], downloads = [randint(0, 100) for i in range(10)]))\ncolumns = [TableColumn(field = \"dates\", title = \"Date\", formatter = DateFormatter()), TableColumn(field = \"downloads\", title = \"Downloads\")]\ndata_table = DataTable(source = source, columns = columns, width = 400, height = 280, editable = True, reorderable = False)\n\ntext_row = TextInput(value = None, title = \"Row index:\", width = 420)\ntext_column = TextInput(value = None, title = \"Column Index:\", width = 420)\ntext_date = TextInput(value = None, title = \"Date:\", width = 420)\ntext_downloads = TextInput(value = None, title = \"Downloads:\", width = 420)\ntest_cell = TextInput(value = None, title = \"Cell Contents:\", width = 420)\n\nsource_code = \"\"\"\nvar grid = document.getElementsByClassName('grid-canvas')[0].children;\nvar row, column = '';\n\nfor (var i = 0,max = grid.length; i < max; i++){\n    if (grid[i].outerHTML.includes('active')){\n        row = i;\n        for (var j = 0, jmax = grid[i].children.length; j < jmax; j++)\n            if(grid[i].children[j].outerHTML.includes('active')) \n                { column = j }\n    }\n}\ntext_row.value = String(row);\ntext_column.value = String(column);\ntext_date.value = String(new Date(source.data['dates'][row]));\ntext_downloads.value = String(source.data['downloads'][row]); \ntest_cell.value = column == 1 ? text_date.value : text_downloads.value; \"\"\"\n\ndef py_callback(attr, old, new):\n    source.selected.update(indices = [])\n\n<line_mask>\ncallback = CustomJS(args = dict(source = source, text_row = text_row, text_column = text_column, text_date = text_date, text_downloads = text_downloads, test_cell = test_cell), code = source_code)\nsource.selected.js_on_change('indices', callback)\ncurdoc().add_root(column(data_table, text_row, text_column, text_date, text_downloads, test_cell))",
            "masked_line": "source.selected.on_change('indices', py_callback)",
            "answer": "on_change",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_352"
        },
        {
            "dependency": "glom",
            "version": "==19.11.0",
            "time": "2020-02-14",
            "description": "The code retrieves the 'description' value from nested dictionaries within a specified dictionary and returns a list of these descriptions.",
            "code": "from glom import glom, Call, T, Iter\n\nd = { ... }  # put your example lines into this dictionary.\n\ndef get_desc(subdict):\n    return {k: v.get('description', None) \n            for k,v in subdict[1]['nestedStats']['entries'].items()}\n\nspec = (Call(list, args=(T.items(),) ), Iter().map(get_desc).all())\n\nresult = glom(d, spec)\n\nprint(result)",
            "masked_code": "from glom import glom, Call, T, Iter\n\nd = { ... }  # put your example lines into this dictionary.\n\ndef get_desc(subdict):\n    return {k: v.get('description', None) \n            for k,v in subdict[1]['nestedStats']['entries'].items()}\n\n<line_mask>\n\nresult = glom(d, spec)\n\nprint(result)",
            "masked_line": "spec = (Call(list, args=(T.items(),) ), Iter().map(get_desc).all())",
            "answer": "map",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_353"
        },
        {
            "dependency": "numba",
            "version": "==0.45.1",
            "time": "2019-08-16",
            "description": "The code defines a class called Counter that allows counting the occurrences of different floating-point numbers. The add method of the Counter class increments the occurrence count of a specified number. Finally, an instance of the Counter class is created, numbers are added to it, and the count dictionary is printed.",
            "code": "import numba\n\n@numba.jitclass([(\"cnts\", numba.types.DictType(numba.float64, numba.int64))])\nclass Counter:\n    def __init__(self):\n        self.cnts = numba.typed.Dict.empty(\n            key_type=numba.float64, value_type=numba.int64\n        )\n\n    def add(self, x):\n        if x not in self.cnts:\n            self.cnts[x] = 0\n        self.cnts[x] += 1\n\nc = Counter()\nc.add(1.1)\nc.add(1.1)\nc.add(0.5)\nprint(c.cnts)  # {1.1: 2, 0.5: 1}",
            "masked_code": "import numba\n\n@numba.jitclass([(\"cnts\", numba.types.DictType(numba.float64, numba.int64))])\nclass Counter:\n    def __init__(self):\n        <line_mask>\n            key_type=numba.float64, value_type=numba.int64\n        )\n\n    def add(self, x):\n        if x not in self.cnts:\n            self.cnts[x] = 0\n        self.cnts[x] += 1\n\nc = Counter()\nc.add(1.1)\nc.add(1.1)\nc.add(0.5)\nprint(c.cnts)  # {1.1: 2, 0.5: 1}",
            "masked_line": "self.cnts = numba.typed.Dict.empty(",
            "answer": "empty",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_354"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-07-06",
            "description": "The code creates a graph based on related IDs in a dataframe, where nodes are connected if they share a common related ID. It then assigns each node to a group based on the connected components in the graph.",
            "code": "import networkx as nx\nfrom itertools import combinations, chain\n\n#if necessary convert to lists \ndf['Related IDs'] = df['Related IDs'].apply(ast.literal_eval)\n\n#create edges (can only connect two nodes)\nL2_nested = [list(combinations(l,2)) for l in df['Related IDs']]\nL2 = list(chain.from_iterable(L2_nested))\nprint (L2)\n[('aaa', 'bbb'), ('aaa', 'ccc'), ('bbb', 'ccc'), \n ('ggg', 'hhh'), ('ggg', 'jjj'), ('hhh', 'jjj'), ('jjj', 'hhh')]\n\n#create the graph from the dataframe\nG=nx.Graph()\nG.add_edges_from(L2)\nconnected_comp = nx.connected_components(G)\n\n#create dict for common values\nnode2id = {x: cid for cid, c in enumerate(connected_comp) for x in c}\n\n#create groups by mapping first value of column Related IDs\ngroups = [node2id.get(x[0]) for x in df['Related IDs']]\nprint (groups)\n[0, 0, 1, 1, 1]",
            "masked_code": "import networkx as nx\nfrom itertools import combinations, chain\n\n#if necessary convert to lists \ndf['Related IDs'] = df['Related IDs'].apply(ast.literal_eval)\n\n#create edges (can only connect two nodes)\nL2_nested = [list(combinations(l,2)) for l in df['Related IDs']]\nL2 = list(chain.from_iterable(L2_nested))\nprint (L2)\n[('aaa', 'bbb'), ('aaa', 'ccc'), ('bbb', 'ccc'), \n ('ggg', 'hhh'), ('ggg', 'jjj'), ('hhh', 'jjj'), ('jjj', 'hhh')]\n\n#create the graph from the dataframe\nG=nx.Graph()\nG.add_edges_from(L2)\n<line_mask>\n\n#create dict for common values\nnode2id = {x: cid for cid, c in enumerate(connected_comp) for x in c}\n\n#create groups by mapping first value of column Related IDs\ngroups = [node2id.get(x[0]) for x in df['Related IDs']]\nprint (groups)\n[0, 0, 1, 1, 1]",
            "masked_line": "connected_comp = nx.connected_components(G)",
            "answer": "connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_355"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24",
            "time": "2019-05-10",
            "description": "This code generates a pandas DataFrame by taking the Cartesian product of two lists or arrays of values for 'id' and 'st' and creates columns named 'id' and 'st'.",
            "code": "from  itertools import product\n#pandas 0.24+\ndf = pd.DataFrame(product(id, st), columns = ['id','st'])\n#pandas below\n#df = pd.DataFrame(list(product(id, st)), columns = ['id','st'])",
            "masked_code": "from  itertools import product\n#pandas 0.24+\n<line_mask>\n#pandas below\n#df = pd.DataFrame(list(product(id, st)), columns = ['id','st'])",
            "masked_line": "df = pd.DataFrame(product(id, st), columns = ['id','st'])",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_356"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.1",
            "time": "2019-04-21",
            "description": "The code generates a new array by selecting specific elements from the original array 'a', based on the specified rows and columns indices.",
            "code": "import numpy as np\na=np.arange(2*3*5).reshape(2, 3, 5)\n\nrows = np.array([[0], [1]], dtype=np.intp)\ncols = np.array([[2, 3], [1, 2]], dtype=np.intp)\n\naa = np.stack(a[rows, :, cols]).swapaxes(1, 2)\n# array([[[ 2,  3],\n#         [ 7,  8],\n#         [12, 13]],\n\n#        [[16, 17],\n#         [21, 22],\n#         [26, 27]]])",
            "masked_code": "import numpy as np\n<line_mask>\n\nrows = np.array([[0], [1]], dtype=np.intp)\ncols = np.array([[2, 3], [1, 2]], dtype=np.intp)\n\naa = np.stack(a[rows, :, cols]).swapaxes(1, 2)\n# array([[[ 2,  3],\n#         [ 7,  8],\n#         [12, 13]],\n\n#        [[16, 17],\n#         [21, 22],\n#         [26, 27]]])",
            "masked_line": "a=np.arange(2*3*5).reshape(2, 3, 5)",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_357"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2019-03-09",
            "description": "This code identifies and filters out paths that do not contain any nodes from the list of important nodes.",
            "code": "import NetworkX as nx\nimportant_nodes=[]#list of important nodes    \npaths = nx.all_simple_paths(G, source, target)\npaths=list(paths)\n#This is pseudocode, next four lines could be done with list comprehension\nexclusive_paths=[]\nfor path in paths:\n    if important_nodes not in path:\n        exclusive_paths.append(path)",
            "masked_code": "import NetworkX as nx\nimportant_nodes=[]#list of important nodes    \n<line_mask>\npaths=list(paths)\n#This is pseudocode, next four lines could be done with list comprehension\nexclusive_paths=[]\nfor path in paths:\n    if important_nodes not in path:\n        exclusive_paths.append(path)",
            "masked_line": "paths = nx.all_simple_paths(G, source, target)",
            "answer": "all_simple_paths",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_358"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-07-25",
            "description": "The code merges two dataframes, df1 and df2, based on the common values in their respective columns 'col1' and 'col2', and then assigns corresponding values from df1 to the merged dataframe. Finally, it drops the 'index' column from the merged dataframe.",
            "code": "import pandas as pd\n\ndf1 = pd.DataFrame({'col1': [[\"a\",\"b\",\"c\"],[\"a\",\"b\"],[\"d\",\"e\"]]})\ndf2 = pd.DataFrame({'col2': [\"a\",\"b\",\"d\"]})\n\ndf1_flat = df1.col1.explode().reset_index()\ndf_merged = pd.merge(df1_flat,df2,left_on='col1',right_on='col2')\n\ndf_merged['col2'] = df1.loc[df_merged['index']].values\ndf_merged.drop('index',axis=1, inplace=True)",
            "masked_code": "import pandas as pd\n\ndf1 = pd.DataFrame({'col1': [[\"a\",\"b\",\"c\"],[\"a\",\"b\"],[\"d\",\"e\"]]})\ndf2 = pd.DataFrame({'col2': [\"a\",\"b\",\"d\"]})\n\n<line_mask>\ndf_merged = pd.merge(df1_flat,df2,left_on='col1',right_on='col2')\n\ndf_merged['col2'] = df1.loc[df_merged['index']].values\ndf_merged.drop('index',axis=1, inplace=True)",
            "masked_line": "df1_flat = df1.col1.explode().reset_index()",
            "answer": "explode",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_359"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.13.1",
            "time": "2019-06-21",
            "description": "This code generates random samples from a given set of values based on the specified probabilities. The code first sets up placeholders for values and probabilities, then uses the probabilities to generate logits. It then samples column indices based on the logits and gathers the actual values based on the sampled indices. Finally, it prints the result of the sampling operation.",
            "code": "import tensorflow as tf\n\nwith tf.Graph().as_default(), tf.Session() as sess:\n    tf.random.set_random_seed(0)\n    values = tf.placeholder(tf.float32, [None, 3])\n    probabilities = tf.placeholder(tf.float32, [None, 3])\n    # You can change the number of samples per row (or make it a placeholder)\n    num_samples = 1\n    # Use log to get log-probabilities or give logit values (pre-softmax) directly\n    logits = tf.log(probabilities)\n    # Sample column indices\n    col_idx = tf.random.categorical(logits, num_samples, dtype=tf.int32)\n    # Make row indices\n    num_rows = tf.shape(values)[0]\n    row_idx = tf.tile(tf.expand_dims(tf.range(num_rows), 1), (1, num_samples))\n    # Gather actual values\n    result = tf.gather_nd(values, tf.stack([row_idx, col_idx], axis=-1))\n    # Test\n    print(sess.run(result, feed_dict={\n        values: [[10., 20., 30.], [40., 50., 60.]],\n        # Can be actual or \"proportional\" probabilities not summing 1\n        probabilities: [[.1, .3, .6], [0., 4., 2.]]\n    }))\n    # [[30.]\n    #  [60.]]",
            "masked_code": "import tensorflow as tf\n\nwith tf.Graph().as_default(), tf.Session() as sess:\n    tf.random.set_random_seed(0)\n    values = tf.placeholder(tf.float32, [None, 3])\n    probabilities = tf.placeholder(tf.float32, [None, 3])\n    # You can change the number of samples per row (or make it a placeholder)\n    num_samples = 1\n    # Use log to get log-probabilities or give logit values (pre-softmax) directly\n    logits = tf.log(probabilities)\n    # Sample column indices\n    col_idx = tf.random.categorical(logits, num_samples, dtype=tf.int32)\n    # Make row indices\n    num_rows = tf.shape(values)[0]\n    row_idx = tf.tile(tf.expand_dims(tf.range(num_rows), 1), (1, num_samples))\n    # Gather actual values\n    <line_mask>\n    # Test\n    print(sess.run(result, feed_dict={\n        values: [[10., 20., 30.], [40., 50., 60.]],\n        # Can be actual or \"proportional\" probabilities not summing 1\n        probabilities: [[.1, .3, .6], [0., 4., 2.]]\n    }))\n    # [[30.]\n    #  [60.]]",
            "masked_line": "result = tf.gather_nd(values, tf.stack([row_idx, col_idx], axis=-1))",
            "answer": "stack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_360"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-20",
            "description": "This code calculates the total number of terms in the result of looping dot product of a matrix and its initial state matrix, as well as the total number of terms in the result of raising the initial state matrix to the power of N.",
            "code": "import numpy as np\nimport sympy as sy\n\ndef countterms(arr):\n    return np.sum([len(e.args) for e in arr.flat])\n\nN = 20\nw = sy.Symbol(\"w\");v = sy.Symbol(\"v\");p = sy.Symbol(\"p\");q = sy.Symbol(\"q\");c = 1;n = 1;nc = 1\nM = np.array([[w*p*q,w*q,0,0,0,0], \n              [0,0,v,0,0,0], \n              [0,0,0,nc,0,c], \n              [0,0,0,0,v,0], \n              [w,w,v,nc,0,c],\n              [0,0,0,n,0,1]])\nMi = M.copy()\n\nfor _ in range(N-1):\n    M = np.dot(M, Mi)\n\nMpow = np.linalg.matrix_power(Mi, N)\n\nprint(\"%d terms total in looped dot result\\n\" % countterms(M))\nprint(\"%d terms total in matrix_power result\\n\" % countterms(Mpow))",
            "masked_code": "import numpy as np\nimport sympy as sy\n\ndef countterms(arr):\n    return np.sum([len(e.args) for e in arr.flat])\n\nN = 20\nw = sy.Symbol(\"w\");v = sy.Symbol(\"v\");p = sy.Symbol(\"p\");q = sy.Symbol(\"q\");c = 1;n = 1;nc = 1\n<line_mask>\n              [0,0,v,0,0,0], \n              [0,0,0,nc,0,c], \n              [0,0,0,0,v,0], \n              [w,w,v,nc,0,c],\n              [0,0,0,n,0,1]])\nMi = M.copy()\n\nfor _ in range(N-1):\n    M = np.dot(M, Mi)\n\nMpow = np.linalg.matrix_power(Mi, N)\n\nprint(\"%d terms total in looped dot result\\n\" % countterms(M))\nprint(\"%d terms total in matrix_power result\\n\" % countterms(Mpow))",
            "masked_line": "M = np.array([[w*p*q,w*q,0,0,0,0],",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_361"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.1",
            "time": "2019-09-06",
            "description": "This code reads a CSV file into a pandas DataFrame with specified columns ('A', 'B', 'C', 'D') as the index.",
            "code": "import pandas as pd\ncsv = pd.read_csv(data, index_col=['A', 'B', 'C', 'D'], usecols=['A', 'B', 'C', 'D'])",
            "masked_code": "import pandas as pd\n<line_mask>",
            "masked_line": "csv = pd.read_csv(data, index_col=['A', 'B', 'C', 'D'], usecols=['A', 'B', 'C', 'D'])",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_362"
        },
        {
            "dependency": "bokeh",
            "version": "==1.3.0",
            "time": "2019-11-14",
            "description": "This code creates a Bokeh plot with multiple lines and allows the user to draw a line by clicking and dragging the mouse. The script updates the drawn line dynamically as the user moves the mouse and displays the distance and units of the drawn line in a separate HTML element.",
            "code": "import numpy as np\nfrom bokeh.plotting import figure, show\nfrom bokeh.models import ColumnDataSource, CustomJS, Div, Row\nfrom bokeh.events import *\n\nsource = ColumnDataSource({'x': [], 'y': []})\n\np = figure(plot_width = 900)\nlines = [p.line(np.arange(10), np.random.random(10)) for i in range(3)]\nlilne = p.line('x', 'y', line_color = 'red', line_dash = 'dashed', source = source)\ndiv = Div(text='')\n\ncallback_tap = '''\nif (true === Bokeh.drawing) {\n    Bokeh.drawing = false\n}\nelse {\n    if (!Bokeh.drawing) {\n        src.data = {'x':[], 'y':[]}        \n        src.change.emit()\n    }\n\n    src.data['x'].push(cb_obj.x)\n    src.data['y'].push(cb_obj.y)\n\n    Bokeh.drawing = true\n    Bokeh.sx_start = cb_obj.sx\n    Bokeh.x_start = cb_obj.x\n}'''\n\ncallback_mousemove = '''\nif (Bokeh.drawing) {  \n    if (src.data['x'].length > 1) {\n        src.data['x'].pop()\n        src.data['y'].pop()   \n    }\n\n    src.data['x'].push(cb_obj.x)\n    src.data['y'].push(cb_obj.y)\n    src.change.emit()\n\n    div.text = 'Distance: ' + Math.round(cb_obj.sx - Bokeh.sx_start) + ' px' + ' (' + (Math.round((cb_obj.x - Bokeh.x_start) * 100) / 100) + ' units)'\n}'''\n\np.js_on_event('tap', CustomJS(args = {'src': source}, code = callback_tap))\np.js_on_event('mousemove', CustomJS(args = {'src': source, 'div': div}, code = callback_mousemove))\n\nshow(Row(p, div))",
            "masked_code": "import numpy as np\nfrom bokeh.plotting import figure, show\n<line_mask>\nfrom bokeh.events import *\n\nsource = ColumnDataSource({'x': [], 'y': []})\n\np = figure(plot_width = 900)\nlines = [p.line(np.arange(10), np.random.random(10)) for i in range(3)]\nlilne = p.line('x', 'y', line_color = 'red', line_dash = 'dashed', source = source)\ndiv = Div(text='')\n\ncallback_tap = '''\nif (true === Bokeh.drawing) {\n    Bokeh.drawing = false\n}\nelse {\n    if (!Bokeh.drawing) {\n        src.data = {'x':[], 'y':[]}        \n        src.change.emit()\n    }\n\n    src.data['x'].push(cb_obj.x)\n    src.data['y'].push(cb_obj.y)\n\n    Bokeh.drawing = true\n    Bokeh.sx_start = cb_obj.sx\n    Bokeh.x_start = cb_obj.x\n}'''\n\ncallback_mousemove = '''\nif (Bokeh.drawing) {  \n    if (src.data['x'].length > 1) {\n        src.data['x'].pop()\n        src.data['y'].pop()   \n    }\n\n    src.data['x'].push(cb_obj.x)\n    src.data['y'].push(cb_obj.y)\n    src.change.emit()\n\n    div.text = 'Distance: ' + Math.round(cb_obj.sx - Bokeh.sx_start) + ' px' + ' (' + (Math.round((cb_obj.x - Bokeh.x_start) * 100) / 100) + ' units)'\n}'''\n\np.js_on_event('tap', CustomJS(args = {'src': source}, code = callback_tap))\np.js_on_event('mousemove', CustomJS(args = {'src': source, 'div': div}, code = callback_mousemove))\n\nshow(Row(p, div))",
            "masked_line": "from bokeh.models import ColumnDataSource, CustomJS, Div, Row",
            "answer": "ColumnDataSource",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_363"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.1.0",
            "time": "2019-06-21",
            "description": "The code generates a plot with no data points and displays the Mean Absolute Error (MAE) and Mean Squared Error (MSE) values as text in the plot.",
            "code": "import matplotlib.pyplot as plt\n\nmae, mse = 1, 1\nplt.plot()  # in your case : plt.plot(test_index, y_pred,color=\"goldenrod\")\nplt.text(.5, .5, 'MAE:{}\\nMSE:{}'.format(mae, mse))\nplt.tight_layout()\nplt.show(block=False)\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\n\nmae, mse = 1, 1\nplt.plot()  # in your case : plt.plot(test_index, y_pred,color=\"goldenrod\")\nplt.text(.5, .5, 'MAE:{}\\nMSE:{}'.format(mae, mse))\n<line_mask>\nplt.show(block=False)\nplt.show()",
            "masked_line": "plt.tight_layout()",
            "answer": "tight_layout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_364"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-04-26",
            "description": "This code defines a CLI application using the Click library in Python. It includes a custom class `MyClassWithAClickCommand` with a `cli` method that prints out the class name and the argument passed to it. The `ConversionCLI` class extends `click.MultiCommand` to define a multi-command CLI application and provides a way to list and get commands. The `convert` function is decorated with `@click.command` and uses the `ConversionCLI` class. The script then executes various commands with different arguments and prints out Click and Python versions along with the output of each command.",
            "code": "class MyClassWithAClickCommand:\n\n    @classmethod\n    @click.command(cls=ClsMethodClickCommand)\n    @click.argument('arg')\n    def cli(cls, arg):\n        click.echo('cls: {}'.format(cls.__name__))\n        click.echo('cli: {}'.format(arg))\n\n\nclass ConversionCLI(click.MultiCommand):\n    def list_commands(self, ctx):\n        return ['converter_x']\n\n    def get_command(self, ctx, name):\n        cmd = MyClassWithAClickCommand.cli\n        cmd._cls[0] = MyClassWithAClickCommand\n        return cmd\n\n\n@click.command(cls=ConversionCLI)\ndef convert():\n    \"\"\"Convert files using specified converter\"\"\"\n\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'converter_x an_arg',\n        'converter_x --help',\n        'converter_x',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            convert(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "class MyClassWithAClickCommand:\n\n    @classmethod\n    @click.command(cls=ClsMethodClickCommand)\n    <line_mask>\n    def cli(cls, arg):\n        click.echo('cls: {}'.format(cls.__name__))\n        click.echo('cli: {}'.format(arg))\n\n\nclass ConversionCLI(click.MultiCommand):\n    def list_commands(self, ctx):\n        return ['converter_x']\n\n    def get_command(self, ctx, name):\n        cmd = MyClassWithAClickCommand.cli\n        cmd._cls[0] = MyClassWithAClickCommand\n        return cmd\n\n\n@click.command(cls=ConversionCLI)\ndef convert():\n    \"\"\"Convert files using specified converter\"\"\"\n\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'converter_x an_arg',\n        'converter_x --help',\n        'converter_x',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            convert(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.argument('arg')",
            "answer": "argument",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_365"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-13",
            "description": "This code finds the indices of the elements in a 2D list where the value is equal to zero and returns a list of those indices.",
            "code": "import numpy as np\n\nboard = [[1, 2, 0],\n         [0, 0, 1],\n         [2, 0, 1]]\n\nresult = np.argwhere(np.array(board) == 0).tolist()",
            "masked_code": "import numpy as np\n\nboard = [[1, 2, 0],\n         [0, 0, 1],\n         [2, 0, 1]]\n\n<line_mask>",
            "masked_line": "result = np.argwhere(np.array(board) == 0).tolist()",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_366"
        },
        {
            "dependency": "bokeh",
            "version": "==1.3.0",
            "time": "2019-11-05",
            "description": "The code creates a bar graph showing the counts of different fruits for the years 2015, 2016, and 2017. Each fruit has a bar split into three sections representing the counts for each year. The graph allows hovering over each section to display additional information such as the fruit name and count for the specific year.",
            "code": "from bokeh.core.properties import value\nfrom bokeh.models import ColumnDataSource, CustomJSHover\nfrom bokeh.plotting import figure, show\n\nfruits = ['Apples', 'Pears', 'Nectarines', 'Plums', 'Grapes', 'Strawberries']\nyears = [\"2015\", \"2016\", \"2017\"]\ncolors = [\"#c9d9d3\", \"#718dbf\", \"#e84d60\"]\n\ndata = {'fruits' : fruits,\n        '2015'   : [2, 1, 4, 3, 2, 4],\n        '2016'   : [5, 3, 4, 2, 4, 6],\n        '2017'   : [3, 2, 4, 4, 5, 3]}\n\nsource = ColumnDataSource(data=data)\n\ntooltips= [(\"name\", \"$name\"), (\"count\", \"@$name\")]\n\np = figure(x_range=fruits, plot_height=350, title=\"Fruit Counts by Year\",\n           toolbar_location=None, tooltips=tooltips)\n\nrenderers = p.vbar_stack(years, x='fruits', width=0.9, color=colors, source=source,\n                         legend=[value(x) for x in years], name=years)\n\np.hover[0].tooltips.append(('info', '$name{custom}'))\np.hover[0].formatters = {'$name' : CustomJSHover(code = \"return special_vars.name + '_text'\")}\n\nshow(p)",
            "masked_code": "from bokeh.core.properties import value\nfrom bokeh.models import ColumnDataSource, CustomJSHover\nfrom bokeh.plotting import figure, show\n\nfruits = ['Apples', 'Pears', 'Nectarines', 'Plums', 'Grapes', 'Strawberries']\nyears = [\"2015\", \"2016\", \"2017\"]\ncolors = [\"#c9d9d3\", \"#718dbf\", \"#e84d60\"]\n\ndata = {'fruits' : fruits,\n        '2015'   : [2, 1, 4, 3, 2, 4],\n        '2016'   : [5, 3, 4, 2, 4, 6],\n        '2017'   : [3, 2, 4, 4, 5, 3]}\n\nsource = ColumnDataSource(data=data)\n\ntooltips= [(\"name\", \"$name\"), (\"count\", \"@$name\")]\n\np = figure(x_range=fruits, plot_height=350, title=\"Fruit Counts by Year\",\n           toolbar_location=None, tooltips=tooltips)\n\n<line_mask>\n                         legend=[value(x) for x in years], name=years)\n\np.hover[0].tooltips.append(('info', '$name{custom}'))\np.hover[0].formatters = {'$name' : CustomJSHover(code = \"return special_vars.name + '_text'\")}\n\nshow(p)",
            "masked_line": "renderers = p.vbar_stack(years, x='fruits', width=0.9, color=colors, source=source,",
            "answer": "vbar_stack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_367"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.4",
            "time": "2019-04-25",
            "description": "The code creates a matrix where each row contains k consecutive non-null values from a pandas DataFrame column 'values'. It fills the rest of the row with null values.",
            "code": "#!/usr/bin/env python3\n\nimport numpy as np\nimport pandas as pd\n\nnan = np.nan\n\ndf = pd.DataFrame([\n         nan, 1, 2, nan, nan, 33, 34, 90, \n         nan, 5, nan, 22, 70, nan, 672, \n         10, 73, 9, nan, 15], \n     columns=['values'])\n\nn = len(df)\nk = 5\nr = n - k + 1\n\nmat = np.tile([1] * k + [0] * r, r)[:-r].reshape(r, n)\n\nmat = np.apply_along_axis(lambda row: np.where(row, df['values'], row), 1, mat)\n\nprint(mat)",
            "masked_code": "#!/usr/bin/env python3\n\nimport numpy as np\nimport pandas as pd\n\nnan = np.nan\n\ndf = pd.DataFrame([\n         nan, 1, 2, nan, nan, 33, 34, 90, \n         nan, 5, nan, 22, 70, nan, 672, \n         10, 73, 9, nan, 15], \n     columns=['values'])\n\nn = len(df)\nk = 5\nr = n - k + 1\n\n<line_mask>\n\nmat = np.apply_along_axis(lambda row: np.where(row, df['values'], row), 1, mat)\n\nprint(mat)",
            "masked_line": "mat = np.tile([1] * k + [0] * r, r)[:-r].reshape(r, n)",
            "answer": "tile",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_368"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2019-04-12",
            "description": "This code takes user input of numbers, stores them in a list, calculates the sum, length, and mean of the numbers in the list, and then prints out these calculations. The code stops when the user inputs 'done'.",
            "code": "from numpy import mean\nlist = []\nwhile True:\n    try:\n        n = input('Enter a number: ')\n        list.append(int(n))\n    except:\n        if n!='done':\n            print('Invalid input') \n    if n == 'done':\n        break\n\nprint(sum(list))\nprint(len(list))\nprint(mean(list))",
            "masked_code": "from numpy import mean\nlist = []\nwhile True:\n    try:\n        n = input('Enter a number: ')\n        list.append(int(n))\n    except:\n        if n!='done':\n            print('Invalid input') \n    if n == 'done':\n        break\n\nprint(sum(list))\nprint(len(list))\n<line_mask>",
            "masked_line": "print(mean(list))",
            "answer": "mean",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_369"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-04-11",
            "description": "The code defines a command-line interface using the Click library in Python. It creates a group called 'g' with two subcommands 'c1' and 'c2'. The 'c1' command prints \"C1\" and raises an exception if the \"--throw\" option is provided. The 'c2' command invokes 'c1' and then prints \"C2\", also raising an exception if the \"--throw\" option is provided. The code also includes a loop that prints the version of Click and Python, then executes the defined commands with various options, catching and handling exceptions.",
            "code": "import click\n\nclass CLICommandInvoker(click.Command):\n    def invoke(self, ctx):\n        return invoke_with_catch(self, ctx, click.Command.invoke)\n\n\nclass CLIGroupInvoker(click.Group):\n    def invoke(self, ctx):\n        return invoke_with_catch(self, ctx, click.Group.invoke)\n\n\n@click.group(cls=CLIGroupInvoker)\ndef g():\n    pass\n\n@g.command(cls=CLICommandInvoker)\n@click.option(\"--throw\", is_flag=True)\ndef c1(throw):\n    click.echo(\"C1\")\n    if throw:\n        raise Exception('Throwing in C1')\n\n@g.command(cls=CLICommandInvoker)\n@click.option(\"--throw\", is_flag=True)\n@click.pass_context\ndef c2(ctx, throw):\n    invoke_with_catch(ctx, c1, click.Context.invoke)\n    click.echo(\"C2\")\n    if throw:\n        raise Exception('Throwing in C2')\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'c1',\n        'c1 --throw',\n        'c2',\n        'c2 --throw',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            g(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\nclass CLICommandInvoker(click.Command):\n    def invoke(self, ctx):\n        return invoke_with_catch(self, ctx, click.Command.invoke)\n\n\nclass CLIGroupInvoker(click.Group):\n    def invoke(self, ctx):\n        return invoke_with_catch(self, ctx, click.Group.invoke)\n\n\n@click.group(cls=CLIGroupInvoker)\ndef g():\n    pass\n\n@g.command(cls=CLICommandInvoker)\n@click.option(\"--throw\", is_flag=True)\ndef c1(throw):\n    click.echo(\"C1\")\n    if throw:\n        raise Exception('Throwing in C1')\n\n@g.command(cls=CLICommandInvoker)\n@click.option(\"--throw\", is_flag=True)\n<line_mask>\ndef c2(ctx, throw):\n    invoke_with_catch(ctx, c1, click.Context.invoke)\n    click.echo(\"C2\")\n    if throw:\n        raise Exception('Throwing in C2')\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'c1',\n        'c1 --throw',\n        'c2',\n        'c2 --throw',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            g(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.pass_context",
            "answer": "pass_context",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_370"
        },
        {
            "dependency": "pytest",
            "version": "==5.3.1",
            "time": "2019-11-30",
            "description": "The code defines a custom pytest plugin that allows users to set a minimum number of tests to pass using the '--minpass' option. It tracks the number of passed tests during the session and checks if the actual number of passed tests meets the specified minimum requirement. If not, it generates an error message displaying the expected and actual number of passed tests.",
            "code": "import pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption('--minpass', type=int, default=0, help='minimum amount of tests to pass')\n\n\ndef pytest_sessionstart(session):\n    session.count_passed = 0\n\n\n@pytest.hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    result = outcome.get_result()\n\n    if result.when == 'call' and result.passed:\n        item.session.count_passed += 1\n\n\ndef pytest_sessionfinish(session, exitstatus):\n    min_passed = session.config.getoption('minpass')\n    if session.count_passed < min_passed:\n        session.exitstatus = 127\n        reporter = session.config.pluginmanager.get_plugin('terminalreporter')\n        reporter.section('Session errors', sep='-', red=True, bold=True)\n        reporter.line(f'Not enough successful tests - expected at least {min_passed} to pass, passed {session.count_passed}')",
            "masked_code": "import pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption('--minpass', type=int, default=0, help='minimum amount of tests to pass')\n\n\ndef pytest_sessionstart(session):\n    session.count_passed = 0\n\n\n<line_mask>\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    result = outcome.get_result()\n\n    if result.when == 'call' and result.passed:\n        item.session.count_passed += 1\n\n\ndef pytest_sessionfinish(session, exitstatus):\n    min_passed = session.config.getoption('minpass')\n    if session.count_passed < min_passed:\n        session.exitstatus = 127\n        reporter = session.config.pluginmanager.get_plugin('terminalreporter')\n        reporter.section('Session errors', sep='-', red=True, bold=True)\n        reporter.line(f'Not enough successful tests - expected at least {min_passed} to pass, passed {session.count_passed}')",
            "masked_line": "@pytest.hookimpl(tryfirst=True, hookwrapper=True)",
            "answer": "hookimpl",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_371"
        },
        {
            "dependency": "dash",
            "version": "==1.6.0",
            "time": "2019-11-21",
            "description": "This code creates a Dash web application that allows users to select days and generates a scatter plot of tips data based on the selected days. The scatter plot displays the relationship between total bill and tip amount colored by the day of the week.",
            "code": "import dash\nimport dash_html_components as html\nimport dash_core_components as dcc\nimport seaborn as sns\nimport plotly.express as px\n\nexternal_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']\n\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\n\ntips = sns.load_dataset(\"tips\")\nall_days = ['Thur', 'Fri', 'Sat', 'Sun']\n\napp.layout = html.Div([\n    html.P('select days'),\n    dcc.Dropdown(\n        id='days',\n        options= [{'label': k, 'value':k} for k in all_days],\n        value = None,\n        multi=True),\n    dcc.Graph(id=\"graph\")\n])\n\ndef plot_tips(data=tips, days=None):\n    if days is not None:\n        data=data[data.day.isin(days)]\n        fig = px.scatter(data, x='total_bill', y='tip', color='day')\n    else:\n        data=data[data.day.isin(all_days)]\n        fig = px.scatter(data, x='total_bill', y='tip', color='day')\n    return (fig)\n\n@app.callback(\n    dash.dependencies.Output('graph', \"figure\"),\n    [dash.dependencies.Input('days', 'value') ] )\ndef make_figure(days):\n    fig = plot_tips(data = tips, days= days)\n    return (fig)\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "import dash\nimport dash_html_components as html\nimport dash_core_components as dcc\nimport seaborn as sns\nimport plotly.express as px\n\nexternal_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']\n\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\n\ntips = sns.load_dataset(\"tips\")\nall_days = ['Thur', 'Fri', 'Sat', 'Sun']\n\napp.layout = html.Div([\n    <line_mask>\n    dcc.Dropdown(\n        id='days',\n        options= [{'label': k, 'value':k} for k in all_days],\n        value = None,\n        multi=True),\n    dcc.Graph(id=\"graph\")\n])\n\ndef plot_tips(data=tips, days=None):\n    if days is not None:\n        data=data[data.day.isin(days)]\n        fig = px.scatter(data, x='total_bill', y='tip', color='day')\n    else:\n        data=data[data.day.isin(all_days)]\n        fig = px.scatter(data, x='total_bill', y='tip', color='day')\n    return (fig)\n\n@app.callback(\n    dash.dependencies.Output('graph', \"figure\"),\n    [dash.dependencies.Input('days', 'value') ] )\ndef make_figure(days):\n    fig = plot_tips(data = tips, days= days)\n    return (fig)\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_line": "html.P('select days'),",
            "answer": "P",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_372"
        },
        {
            "dependency": "bokeh",
            "version": "==1.3.0",
            "time": "2019-10-21",
            "description": "The code generates a Bokeh plot with a line representing time and value data. The plot is updated every second with a random value within the range of 5 to 10.",
            "code": "from bokeh.plotting import figure, curdoc\nfrom datetime import datetime\nimport random\n\nplot = figure(plot_width = 1200, x_axis_type = 'datetime', tools = 'pan,box_select,crosshair,reset,save,wheel_zoom')\nline = plot.line(x = 'time', y = 'value', line_color = 'black', source = dict(time = [datetime.now()], value = [random.randint(5, 10)]))\n\ndef update(): \n    line.data_source.stream(dict(time = [datetime.now()], value = [random.randint(5, 10)]))\n\ncurdoc().add_root(plot)\ncurdoc().add_periodic_callback(update, 1000)",
            "masked_code": "from bokeh.plotting import figure, curdoc\nfrom datetime import datetime\nimport random\n\nplot = figure(plot_width = 1200, x_axis_type = 'datetime', tools = 'pan,box_select,crosshair,reset,save,wheel_zoom')\nline = plot.line(x = 'time', y = 'value', line_color = 'black', source = dict(time = [datetime.now()], value = [random.randint(5, 10)]))\n\ndef update(): \n    line.data_source.stream(dict(time = [datetime.now()], value = [random.randint(5, 10)]))\n\ncurdoc().add_root(plot)\n<line_mask>",
            "masked_line": "curdoc().add_periodic_callback(update, 1000)",
            "answer": "curdoc",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_373"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-08-30",
            "description": "This code defines a class TrackedSession that tracks instances of tf.Session. It allows the user to create, close, and retrieve a list of open sessions. The get_open_sessions method returns a list of open sessions for a specific graph or the default graph if none is provided.",
            "code": "import tensorflow as tf\nimport collections\n\nclass TrackedSession(tf.Session):\n    _sessions = collections.defaultdict(list)\n    def __init__(self, target='', graph=None, config=None):\n        super(tf.Session, self).__init__(target=target, graph=graph, config=config)\n        TrackedSession._sessions[self.graph].append(self)\n    def close(self):\n        super(tf.Session, self).close()\n        TrackedSession._sessions[self.graph].remove(self)\n    @classmethod\n    def get_open_sessions(cls, g=None):\n        g = g or tf.get_default_graph()\n        return list(cls._sessions[g])\n\nprint(TrackedSession.get_open_sessions())\n# []\nsess1 = TrackedSession()\nprint(TrackedSession.get_open_sessions())\n# [<__main__.TrackedSession object at 0x000001D75B0C77F0>]\nsess2 = TrackedSession()\nprint(TrackedSession.get_open_sessions())\n# [<__main__.TrackedSession object at 0x000001D75B0C77F0>, <__main__.TrackedSession object at 0x000001D75B0C7A58>]\nsess1.close()\nprint(TrackedSession.get_open_sessions())\n# [<__main__.TrackedSession object at 0x000001D75B0C7A58>]\nsess2.close()\nprint(TrackedSession.get_open_sessions())\n# []",
            "masked_code": "import tensorflow as tf\nimport collections\n\nclass TrackedSession(tf.Session):\n    _sessions = collections.defaultdict(list)\n    def __init__(self, target='', graph=None, config=None):\n        super(tf.Session, self).__init__(target=target, graph=graph, config=config)\n        TrackedSession._sessions[self.graph].append(self)\n    def close(self):\n        super(tf.Session, self).close()\n        TrackedSession._sessions[self.graph].remove(self)\n    @classmethod\n    def get_open_sessions(cls, g=None):\n        <line_mask>\n        return list(cls._sessions[g])\n\nprint(TrackedSession.get_open_sessions())\n# []\nsess1 = TrackedSession()\nprint(TrackedSession.get_open_sessions())\n# [<__main__.TrackedSession object at 0x000001D75B0C77F0>]\nsess2 = TrackedSession()\nprint(TrackedSession.get_open_sessions())\n# [<__main__.TrackedSession object at 0x000001D75B0C77F0>, <__main__.TrackedSession object at 0x000001D75B0C7A58>]\nsess1.close()\nprint(TrackedSession.get_open_sessions())\n# [<__main__.TrackedSession object at 0x000001D75B0C7A58>]\nsess2.close()\nprint(TrackedSession.get_open_sessions())\n# []",
            "masked_line": "g = g or tf.get_default_graph()",
            "answer": "get_default_graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_374"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-07-13",
            "description": "This function generates a Poisson distribution plot using the mean of a specified column from a pandas dataframe. It creates random Poisson data based on the mean value, then plots the Poisson probability mass function with X on the x-axis and P(X|) on the y-axis.",
            "code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_poisson(df, col='open', n_pts=100):\n    lm = df[col].mean() #get the mean value of your data\n    poisdata = np.random.poisson(lm, n_pts)\n    plt.hist(poisdata, density=True, alpha=0.5)\n    plt.xlabel(\"X\")\n    plt.ylabel(\"P(X|\\mu)\")\n    plt.title(\"Poisson PMF\")\n    plt.show()",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_poisson(df, col='open', n_pts=100):\n    lm = df[col].mean() #get the mean value of your data\n    <line_mask>\n    plt.hist(poisdata, density=True, alpha=0.5)\n    plt.xlabel(\"X\")\n    plt.ylabel(\"P(X|\\mu)\")\n    plt.title(\"Poisson PMF\")\n    plt.show()",
            "masked_line": "poisdata = np.random.poisson(lm, n_pts)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_375"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.1.1",
            "time": "2019-07-13",
            "description": "This function generates a Poisson distribution plot based on the provided dataframe column data, showing the probability mass function of the distribution. The mean of the column data is calculated and used to generate random Poisson data points, which are then visualized as a histogram.",
            "code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_poisson(df, col='open', n_pts=100):\n    lm = df[col].mean() #get the mean value of your data\n    poisdata = np.random.poisson(lm, n_pts)\n    plt.hist(poisdata, density=True, alpha=0.5)\n    plt.xlabel(\"X\")\n    plt.ylabel(\"P(X|\\mu)\")\n    plt.title(\"Poisson PMF\")\n    plt.show()",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_poisson(df, col='open', n_pts=100):\n    lm = df[col].mean() #get the mean value of your data\n    poisdata = np.random.poisson(lm, n_pts)\n    plt.hist(poisdata, density=True, alpha=0.5)\n    plt.xlabel(\"X\")\n    plt.ylabel(\"P(X|\\mu)\")\n    plt.title(\"Poisson PMF\")\n    <line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_376"
        },
        {
            "dependency": "pynput",
            "version": ">=1.5.0",
            "time": "2019-11-04",
            "description": "The code simulates pressing the play/pause media key on the keyboard using the pynput library.",
            "code": "from pynput.keyboard import Controller, KeyCode\n\n\ndef main():\n    keyboard = Controller()\n\n    print('Pausing/Resuming... ')\n\n    keyboard.press(KeyCode.from_vk(0xB3))  # Play/Pause\n\nif __name__ == \"__main__\":\n    main()",
            "masked_code": "from pynput.keyboard import Controller, KeyCode\n\n\ndef main():\n    keyboard = Controller()\n\n    print('Pausing/Resuming... ')\n\n    <line_mask>\n\nif __name__ == \"__main__\":\n    main()",
            "masked_line": "keyboard.press(KeyCode.from_vk(0xB3))  # Play/Pause",
            "answer": "from_vk",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_377"
        },
        {
            "dependency": "XlsxWriter",
            "version": ">=1.1.7",
            "time": "2019-06-11",
            "description": "This code creates a new Excel workbook with a line chart and inserts the chart into the worksheet. Data is written to column A and added as a series to the chart.",
            "code": "import xlsxwriter\n\nworkbook = xlsxwriter.Workbook('chart.xlsx')\nworksheet = workbook.add_worksheet()\n\nchart = workbook.add_chart({'type': 'line'})\n\nworksheet.write_column('A1', [2, 4, 6, 8, 10])\n\nchart.add_series({'values': '=Sheet1!$A$1:$A$5'})\n\nworksheet.insert_chart('A7', chart, {'object_position': 3})\n\nworkbook.close()",
            "masked_code": "import xlsxwriter\n\n<line_mask>\nworksheet = workbook.add_worksheet()\n\nchart = workbook.add_chart({'type': 'line'})\n\nworksheet.write_column('A1', [2, 4, 6, 8, 10])\n\nchart.add_series({'values': '=Sheet1!$A$1:$A$5'})\n\nworksheet.insert_chart('A7', chart, {'object_position': 3})\n\nworkbook.close()",
            "masked_line": "workbook = xlsxwriter.Workbook('chart.xlsx')",
            "answer": "Workbook",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_378"
        },
        {
            "dependency": "Flask",
            "version": "==1.0.2",
            "time": "2019-04-18",
            "description": "This code defines a simple Flask web application that, when accessed via a web browser, returns the headers of the HTTP request as a string in the format \"header_name: header_value\".",
            "code": "from flask import Flask, request\napp = Flask(__name__)\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return \"\".join(list(map(lambda i: f\"{i[0]}: {i[1]}\", request.headers.items()))) + \"\"\"\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    app.run()",
            "masked_code": "from flask import Flask, request\napp = Flask(__name__)\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return \"\".join(list(map(lambda i: f\"{i[0]}: {i[1]}\", request.headers.items()))) + \"\"\"\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    <line_mask>",
            "masked_line": "app.run()",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_379"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-13",
            "description": "This code creates a single-channel dummy image array of shape (48, 48, 1) and then concatenates it three times along the last axis to create a three-channel image array of shape (48, 48, 3).",
            "code": "import numpy as np\na = np.zeros((2304), dtype = np.uint8) #Just a dummy array representing a single pic\nsingle_channel = a.reshape(48, 48, 1)\n\nresult = np.concatenate([single_channel,single_channel,single_channel], axis = -1)\nprint(result.shape) #(48, 48, 3)",
            "masked_code": "import numpy as np\n<line_mask>\nsingle_channel = a.reshape(48, 48, 1)\n\nresult = np.concatenate([single_channel,single_channel,single_channel], axis = -1)\nprint(result.shape) #(48, 48, 3)",
            "masked_line": "a = np.zeros((2304), dtype = np.uint8) #Just a dummy array representing a single pic",
            "answer": "zeros",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_380"
        },
        {
            "dependency": "numpy",
            "version": "==1.16.1",
            "time": "2019-11-21",
            "description": "The code saves two randomly generated 10x10 float64 arrays into a compressed bytes object and then loads the arrays back from the buffer, printing the arrays 'a' and 'b'. Finally, it closes the buffer.",
            "code": "import numpy\nimport io\n\n# Arrays\na = numpy.random.uniform(size=(10,10)) # dtype is float64\nb = numpy.random.uniform(size=(10,10)) # dtype is float64\n\n# Create bytes object\nbuf = io.BytesIO()\n\n# Save the arrays into the buffer\nnumpy.savez_compressed(buf, a=a, b=b)\nbuf.seek(0)\n\nab = numpy.load(buf)\nprint(ab['a'])\nprint(ab['b'])\n\n# Closed the buffer\nbuf.close()",
            "masked_code": "import numpy\nimport io\n\n# Arrays\na = numpy.random.uniform(size=(10,10)) # dtype is float64\nb = numpy.random.uniform(size=(10,10)) # dtype is float64\n\n# Create bytes object\nbuf = io.BytesIO()\n\n# Save the arrays into the buffer\nnumpy.savez_compressed(buf, a=a, b=b)\nbuf.seek(0)\n\n<line_mask>\nprint(ab['a'])\nprint(ab['b'])\n\n# Closed the buffer\nbuf.close()",
            "masked_line": "ab = numpy.load(buf)",
            "answer": "load",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_381"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.2.x",
            "time": "2019-10-26",
            "description": "This code generates a stacked plot of random data over time and adjusts the x-axis ticks to show major ticks at each unique year and bimonthly minor ticks. The major ticks have a specified format and aesthetics are adjusted for both major and minor ticks.",
            "code": "import matplotlib.ticker as ticker\n#generate some random data\nidx= pd.date_range(start='2016-01-01', end='2020-02-01',freq='m')\ndf=pd.DataFrame({'rand1':np.random.random(len(idx)),\n                 'rand2': np.random.random(len(idx)),\n                 'rand3': np.random.random(len(idx))},index=idx)\n#stack plot\nfig, axs = plt.subplots(figsize=(20,18),constrained_layout=True)\naxs.stackplot(df.index,df.rand1,df.rand2,df.rand3)\n\n#Adjust ticks\naxs.set_xticks(pd.to_datetime(idx.year.unique().astype(str)), minor=False)\naxs.xaxis.set_major_formatter(ticker.FixedFormatter(idx.year.unique().astype(str)))\n\n#create bimonthly minor ticks\nmonths=pd.date_range(start=idx[0], end=idx[-1],freq='2M')\naxs.set_xticks(pd.to_datetime(months), minor=True)\naxs.xaxis.set_minor_formatter(ticker.FixedFormatter(months.month.astype(str)))\n\n#adjust major ticks aesthetics\naxs.tick_params(axis='x',which='major',length=5,width=1.5, pad=4, labelsize=14)",
            "masked_code": "import matplotlib.ticker as ticker\n#generate some random data\nidx= pd.date_range(start='2016-01-01', end='2020-02-01',freq='m')\ndf=pd.DataFrame({'rand1':np.random.random(len(idx)),\n                 'rand2': np.random.random(len(idx)),\n                 'rand3': np.random.random(len(idx))},index=idx)\n#stack plot\nfig, axs = plt.subplots(figsize=(20,18),constrained_layout=True)\naxs.stackplot(df.index,df.rand1,df.rand2,df.rand3)\n\n#Adjust ticks\naxs.set_xticks(pd.to_datetime(idx.year.unique().astype(str)), minor=False)\naxs.xaxis.set_major_formatter(ticker.FixedFormatter(idx.year.unique().astype(str)))\n\n#create bimonthly minor ticks\nmonths=pd.date_range(start=idx[0], end=idx[-1],freq='2M')\naxs.set_xticks(pd.to_datetime(months), minor=True)\n<line_mask>\n\n#adjust major ticks aesthetics\naxs.tick_params(axis='x',which='major',length=5,width=1.5, pad=4, labelsize=14)",
            "masked_line": "axs.xaxis.set_minor_formatter(ticker.FixedFormatter(months.month.astype(str)))",
            "answer": "FixedFormatter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_382"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-09-16",
            "description": "The code generates 500 random float numbers from an exponential distribution and then scales the numbers using min-max scaling to the specified feature range.",
            "code": "import numpy as np\nfrom sklearn.preprocessing import minmax_scale\n# define the number of parameters to generate \nnumber_of_params = 500\n# generate random floats from an exponential distribution\nx = np.random.exponential(scale=1.0, size=number_of_params)\n# min-max scaler\nx = minmax_scale(x, feature_range=(2**-15, 2**15), axis=0, copy=True)",
            "masked_code": "import numpy as np\nfrom sklearn.preprocessing import minmax_scale\n# define the number of parameters to generate \nnumber_of_params = 500\n# generate random floats from an exponential distribution\n<line_mask>\n# min-max scaler\nx = minmax_scale(x, feature_range=(2**-15, 2**15), axis=0, copy=True)",
            "masked_line": "x = np.random.exponential(scale=1.0, size=number_of_params)",
            "answer": "exponential",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_383"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-09-07",
            "description": "The code filters the time ranges between Adjusted_Down and Adjusted_Up columns in a DataFrame and calculates the count of time values between 9 AM and 9 PM.",
            "code": "from datetime import time\ns = df.apply(lambda row: pd.date_range(row['Adjusted_Down'], row['Adjusted_Up'], freq='T'), axis=1).explode()\ns.dt.time.between(time(9), time(21)).sum()",
            "masked_code": "from datetime import time\n<line_mask>\ns.dt.time.between(time(9), time(21)).sum()",
            "masked_line": "s = df.apply(lambda row: pd.date_range(row['Adjusted_Down'], row['Adjusted_Up'], freq='T'), axis=1).explode()",
            "answer": "date_range",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_384"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-08-18",
            "description": "This code creates a pandas DataFrame with three rows and two columns, with specific values in each cell.",
            "code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({\"R1\": [8,2], \"R2\": [-21,-24], \"R3\": [-9,46]})",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n<line_mask>",
            "masked_line": "df = pd.DataFrame({\"R1\": [8,2], \"R2\": [-21,-24], \"R3\": [-9,46]})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_385"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-08-15",
            "description": "The code creates a black image with dimensions 400x400 pixels. It then counts the number of pixels with a specific color intensity (150,150,150) in the image. It identifies pixels with the desired color intensity and draws them onto a mask. Finally, it applies the mask to change the color of the identified pixels to (36,255,12).",
            "code": "import numpy as np\n\n# Create black image\nimage = np.zeros((400,400,3), dtype=np.uint8)\nimage[300:400,300:400] = (150,150,150)\n\n# Count number of pixels of specific color intensity\ncount = np.count_nonzero((image == [150, 150, 150]).all(axis = 2))\nprint(count)\n\n# Find pixels of desired color intensity and draw onto mask\nmask = (image == [150.,150.,150.]).all(axis=2)\n\n# Apply the mask to change the pixels\nimage[mask] = [36,255,12]",
            "masked_code": "import numpy as np\n\n# Create black image\nimage = np.zeros((400,400,3), dtype=np.uint8)\nimage[300:400,300:400] = (150,150,150)\n\n# Count number of pixels of specific color intensity\n<line_mask>\nprint(count)\n\n# Find pixels of desired color intensity and draw onto mask\nmask = (image == [150.,150.,150.]).all(axis=2)\n\n# Apply the mask to change the pixels\nimage[mask] = [36,255,12]",
            "masked_line": "count = np.count_nonzero((image == [150, 150, 150]).all(axis = 2))",
            "answer": "count_nonzero",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_386"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==1.1.15",
            "time": "2019-06-13",
            "description": "This code defines a SQLAlchemy model for a table named \"patch\" with columns id, major, and minor. It also includes a hybrid property called \"patch\" that combines the major and minor columns. It creates example patch objects and adds them to the database if the table is empty. Finally, it queries the patches from the database and prints them.",
            "code": "from sqlalchemy import create_engine, Column, Integer, func\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.sql.functions import concat\n\nengine = create_engine('postgresql://localhost:5432/postgres', echo=True)\nBase = declarative_base(bind=engine)\n\n\nclass Patch(Base):\n\n    __tablename__ = \"patch\"\n\n    id = Column(Integer, primary_key=True)\n    major = Column(Integer, nullable=False)\n    minor = Column(Integer, nullable=False)\n\n    @hybrid_property\n    def patch(self) -> str:\n        return f'{self.major}.{self.minor}'\n\n    @patch.expression\n    def patch(self):\n        return self.major.op(\",\")(self.minor)\n\n    def __repr__(self):\n        return f\"Patch object {self.id} {self.patch}\"\n\n\nBase.metadata.create_all()\nSession = sessionmaker(bind=engine)\nsession = Session()\n\nif __name__ == \"__main__\":\n    if session.query(Patch).count() == 0:\n        example_patches = [Patch(major=major, minor=minor) for major in range(3) for minor in range(3)]\n        session.add_all(example_patches)\n        session.commit()\n\n    patches = session.query(Patch).order_by(Patch.patch).all()\n    print(patches)",
            "masked_code": "from sqlalchemy import create_engine, Column, Integer, func\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.sql.functions import concat\n\nengine = create_engine('postgresql://localhost:5432/postgres', echo=True)\nBase = declarative_base(bind=engine)\n\n\nclass Patch(Base):\n\n    __tablename__ = \"patch\"\n\n    id = Column(Integer, primary_key=True)\n    major = Column(Integer, nullable=False)\n    minor = Column(Integer, nullable=False)\n\n    @hybrid_property\n    def patch(self) -> str:\n        return f'{self.major}.{self.minor}'\n\n    @patch.expression\n    def patch(self):\n        return self.major.op(\",\")(self.minor)\n\n    def __repr__(self):\n        return f\"Patch object {self.id} {self.patch}\"\n\n\nBase.metadata.create_all()\n<line_mask>\nsession = Session()\n\nif __name__ == \"__main__\":\n    if session.query(Patch).count() == 0:\n        example_patches = [Patch(major=major, minor=minor) for major in range(3) for minor in range(3)]\n        session.add_all(example_patches)\n        session.commit()\n\n    patches = session.query(Patch).order_by(Patch.patch).all()\n    print(patches)",
            "masked_line": "Session = sessionmaker(bind=engine)",
            "answer": "sessionmaker",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_387"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-06-11",
            "description": "This code defines a command line function called version_cmd that takes in optional arguments '--long' and '--check', and when called, it echoes the values of these arguments.",
            "code": "import click\n\ndef importable_command(*args, **kwargs):\n    def decorator(f):\n        return click.decorators.command(*args, **kwargs)(f)\n    return decorator\n\n\n@importable_command('version')\n@click.option('--long')\n@click.option('--check')\ndef version_cmd(long, check):\n    click.echo('version long: {}'.format(long))\n    click.echo('version check: {}'.format(check))",
            "masked_code": "import click\n\ndef importable_command(*args, **kwargs):\n    def decorator(f):\n        return click.decorators.command(*args, **kwargs)(f)\n    return decorator\n\n\n@importable_command('version')\n@click.option('--long')\n<line_mask>\ndef version_cmd(long, check):\n    click.echo('version long: {}'.format(long))\n    click.echo('version check: {}'.format(check))",
            "masked_line": "@click.option('--check')",
            "answer": "option",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_388"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2020-12-17",
            "description": "The code generates a grouped bar chart comparing the letter counts between two lists. It creates dictionaries with letter counts for each list, ensures that both dictionaries have the same keys by adding missing letters with count=0, sorts the dictionaries alphabetically, and then plots the data in a grouped bar chart using matplotlib.",
            "code": "import numpy as np                # v 1.19.2\nimport matplotlib.pyplot as plt   # v 3.3.2\n\nfirst_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"a\", \"b\", \"c\", \"a\", \"b\", \"n\"]\nsecond_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"e\", \"d\", \"c\", \"e\", \"q\"]\n\n# Create dictionaries from lists with this format: 'letter':count\ndict1 = dict(zip(*np.unique(first_list, return_counts=True)))\ndict2 = dict(zip(*np.unique(second_list, return_counts=True)))\n\n# Add missing letters with count=0 to each dictionary so that keys in\n# each dictionary are identical\nonly_in_set1 = set(dict1)-set(dict2)\nonly_in_set2 = set(dict2)-set(dict1)\ndict1.update(dict(zip(only_in_set2, [0]*len(only_in_set2))))\ndict2.update(dict(zip(only_in_set1, [0]*len(only_in_set1))))\n\n# Sort dictionaries alphabetically\ndict1 = dict(sorted(dict1.items()))\ndict2 = dict(sorted(dict2.items()))\n\n# Create grouped bar chart\nxticks = np.arange(len(dict1))\nbar_width = 0.3\nfig, ax = plt.subplots(figsize=(9, 5))\nax.bar(xticks-bar_width/2, dict1.values(), bar_width,\n       color='blue', alpha=0.5, label='first_list')\nax.bar(xticks+bar_width/2, dict2.values(), bar_width,\n       color='red', alpha=0.5, label='second_list')\n\n# Set annotations, x-axis ticks and tick labels\nax.set_ylabel('Counts')\nax.set_title('Letter counts grouped by list')\nax.set_xticks(xticks)\nax.set_xticklabels(dict1.keys())\nax.legend(frameon=False)\nplt.show()",
            "masked_code": "import numpy as np                # v 1.19.2\nimport matplotlib.pyplot as plt   # v 3.3.2\n\nfirst_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"a\", \"b\", \"c\", \"a\", \"b\", \"n\"]\nsecond_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"e\", \"d\", \"c\", \"e\", \"q\"]\n\n# Create dictionaries from lists with this format: 'letter':count\n<line_mask>\ndict2 = dict(zip(*np.unique(second_list, return_counts=True)))\n\n# Add missing letters with count=0 to each dictionary so that keys in\n# each dictionary are identical\nonly_in_set1 = set(dict1)-set(dict2)\nonly_in_set2 = set(dict2)-set(dict1)\ndict1.update(dict(zip(only_in_set2, [0]*len(only_in_set2))))\ndict2.update(dict(zip(only_in_set1, [0]*len(only_in_set1))))\n\n# Sort dictionaries alphabetically\ndict1 = dict(sorted(dict1.items()))\ndict2 = dict(sorted(dict2.items()))\n\n# Create grouped bar chart\nxticks = np.arange(len(dict1))\nbar_width = 0.3\nfig, ax = plt.subplots(figsize=(9, 5))\nax.bar(xticks-bar_width/2, dict1.values(), bar_width,\n       color='blue', alpha=0.5, label='first_list')\nax.bar(xticks+bar_width/2, dict2.values(), bar_width,\n       color='red', alpha=0.5, label='second_list')\n\n# Set annotations, x-axis ticks and tick labels\nax.set_ylabel('Counts')\nax.set_title('Letter counts grouped by list')\nax.set_xticks(xticks)\nax.set_xticklabels(dict1.keys())\nax.legend(frameon=False)\nplt.show()",
            "masked_line": "dict1 = dict(zip(*np.unique(first_list, return_counts=True)))",
            "answer": "unique",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_389"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2020-12-17",
            "description": "This code creates grouped bar chart showing the counts of each letter in two lists, 'first_list' and 'second_list'. The code first creates dictionaries from the lists with the format 'letter': count, then adds missing letters with count=0 to each dictionary to make sure the keys are identical in both dictionaries. Finally, it sorts the dictionaries alphabetically and creates a grouped bar chart with annotations, x-axis ticks, and tick labels to visualize the letter counts in each list.",
            "code": "import numpy as np                # v 1.19.2\nimport matplotlib.pyplot as plt   # v 3.3.2\n\nfirst_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"a\", \"b\", \"c\", \"a\", \"b\", \"n\"]\nsecond_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"e\", \"d\", \"c\", \"e\", \"q\"]\n\n# Create dictionaries from lists with this format: 'letter':count\ndict1 = dict(zip(*np.unique(first_list, return_counts=True)))\ndict2 = dict(zip(*np.unique(second_list, return_counts=True)))\n\n# Add missing letters with count=0 to each dictionary so that keys in\n# each dictionary are identical\nonly_in_set1 = set(dict1)-set(dict2)\nonly_in_set2 = set(dict2)-set(dict1)\ndict1.update(dict(zip(only_in_set2, [0]*len(only_in_set2))))\ndict2.update(dict(zip(only_in_set1, [0]*len(only_in_set1))))\n\n# Sort dictionaries alphabetically\ndict1 = dict(sorted(dict1.items()))\ndict2 = dict(sorted(dict2.items()))\n\n# Create grouped bar chart\nxticks = np.arange(len(dict1))\nbar_width = 0.3\nfig, ax = plt.subplots(figsize=(9, 5))\nax.bar(xticks-bar_width/2, dict1.values(), bar_width,\n       color='blue', alpha=0.5, label='first_list')\nax.bar(xticks+bar_width/2, dict2.values(), bar_width,\n       color='red', alpha=0.5, label='second_list')\n\n# Set annotations, x-axis ticks and tick labels\nax.set_ylabel('Counts')\nax.set_title('Letter counts grouped by list')\nax.set_xticks(xticks)\nax.set_xticklabels(dict1.keys())\nax.legend(frameon=False)\nplt.show()",
            "masked_code": "import numpy as np                # v 1.19.2\nimport matplotlib.pyplot as plt   # v 3.3.2\n\nfirst_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"a\", \"b\", \"c\", \"a\", \"b\", \"n\"]\nsecond_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"e\", \"d\", \"c\", \"e\", \"q\"]\n\n# Create dictionaries from lists with this format: 'letter':count\ndict1 = dict(zip(*np.unique(first_list, return_counts=True)))\ndict2 = dict(zip(*np.unique(second_list, return_counts=True)))\n\n# Add missing letters with count=0 to each dictionary so that keys in\n# each dictionary are identical\nonly_in_set1 = set(dict1)-set(dict2)\nonly_in_set2 = set(dict2)-set(dict1)\ndict1.update(dict(zip(only_in_set2, [0]*len(only_in_set2))))\ndict2.update(dict(zip(only_in_set1, [0]*len(only_in_set1))))\n\n# Sort dictionaries alphabetically\ndict1 = dict(sorted(dict1.items()))\ndict2 = dict(sorted(dict2.items()))\n\n# Create grouped bar chart\nxticks = np.arange(len(dict1))\nbar_width = 0.3\nfig, ax = plt.subplots(figsize=(9, 5))\nax.bar(xticks-bar_width/2, dict1.values(), bar_width,\n       color='blue', alpha=0.5, label='first_list')\nax.bar(xticks+bar_width/2, dict2.values(), bar_width,\n       color='red', alpha=0.5, label='second_list')\n\n# Set annotations, x-axis ticks and tick labels\nax.set_ylabel('Counts')\nax.set_title('Letter counts grouped by list')\n<line_mask>\nax.set_xticklabels(dict1.keys())\nax.legend(frameon=False)\nplt.show()",
            "masked_line": "ax.set_xticks(xticks)",
            "answer": "set_xticks",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_390"
        },
        {
            "dependency": "numpy",
            "version": "==1.9.3",
            "time": "2019-05-04",
            "description": "The function calculates a modified Heaviside step function that returns 0.5 when the input is close to zero, and the actual Heaviside step function value otherwise.",
            "code": "import numpy as np\ndef heaviside_close(x1, x2):\n    closeCheck = np.isclose(x1, np.zeros_like(x1))\n    heavisideBare = np.heaviside(x1, 0.0)\n    zeroVal = np.where(closeCheck, x2, 0.0)-np.where(closeCheck, heavisideBare, np.zeros_like(heavisideBare))\n    result = heavisideBare+zeroVal\n    return result\nprint(heaviside_close(np.asarray([-1., -0.1, 1e-20, 0.1, 1.]), 0.5))\n# >>> [0.  0.  0.5 1.  1. ]\nprint(np.heaviside(np.asarray([-1., -0.1, 1e-20, 0.1, 1.]), 0.5))\n# >>> [0.  0.  1.  1.  1. ]",
            "masked_code": "import numpy as np\ndef heaviside_close(x1, x2):\n    closeCheck = np.isclose(x1, np.zeros_like(x1))\n    <line_mask>\n    zeroVal = np.where(closeCheck, x2, 0.0)-np.where(closeCheck, heavisideBare, np.zeros_like(heavisideBare))\n    result = heavisideBare+zeroVal\n    return result\nprint(heaviside_close(np.asarray([-1., -0.1, 1e-20, 0.1, 1.]), 0.5))\n# >>> [0.  0.  0.5 1.  1. ]\nprint(np.heaviside(np.asarray([-1., -0.1, 1e-20, 0.1, 1.]), 0.5))\n# >>> [0.  0.  1.  1.  1. ]",
            "masked_line": "heavisideBare = np.heaviside(x1, 0.0)",
            "answer": "heaviside",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_391"
        },
        {
            "dependency": "sphinx",
            "version": ">=1.8.2",
            "time": "2019-04-18",
            "description": "The code defines a custom Sphinx napoleon configuration with specific settings for parameter and return type annotations. It then creates a Google style docstring with custom sections for writes and parameters, and prints the formatted docstring using the configured settings.",
            "code": "from sphinxcontrib.napoleon import Config\nfrom sphinxcontrib.napoleon import GoogleDocstring\n\nconfig = Config(napoleon_use_param=True, napoleon_use_rtype=True, napoleon_custom_sections=('Writes', 'Parameters'))\ndocstring=\"\"\"This is an example of Google style with a custom section.\n\nArgs:\n    param1: This is the first param.\n    param2: This is a second parpytham.\n\nReturns:\n    This is a description of what is returned.\n\nRaises:\n    KeyErr\n\nWrites:\n    write1: This is writting things !\n\n\"\"\"\n\nprint(GoogleDocstring(docstring, config))",
            "masked_code": "from sphinxcontrib.napoleon import Config\nfrom sphinxcontrib.napoleon import GoogleDocstring\n\n<line_mask>\ndocstring=\"\"\"This is an example of Google style with a custom section.\n\nArgs:\n    param1: This is the first param.\n    param2: This is a second parpytham.\n\nReturns:\n    This is a description of what is returned.\n\nRaises:\n    KeyErr\n\nWrites:\n    write1: This is writting things !\n\n\"\"\"\n\nprint(GoogleDocstring(docstring, config))",
            "masked_line": "config = Config(napoleon_use_param=True, napoleon_use_rtype=True, napoleon_custom_sections=('Writes', 'Parameters'))",
            "answer": "Config",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_392"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-30",
            "description": "This code creates a Bokeh web application that displays a streaming circle plot. The plot updates every second with randomly generated data points, including x and y coordinates and colors. The data acquisition process continuously adds new data points to the plot every 5 seconds.",
            "code": "import random, time\nfrom tornado.ioloop import IOLoop\nfrom bokeh.server.server import Server\nfrom bokeh.application import Application\nfrom bokeh.application.handlers.function import FunctionHandler\nfrom bokeh.plotting import figure, ColumnDataSource\nfrom threading import Thread\n\nclass BokehApp():\n    plot_data = []\n    last_data_length = None\n\n    def __init__(self):\n        thread = Thread(target = self.startDataAcquisition)\n        thread.start()\n\n        io_loop = IOLoop.current()\n        server = Server(applications = {'/myapp': Application(FunctionHandler(self.make_document))}, io_loop = io_loop, port = 5001)\n        server.start()\n        server.show('/myapp')\n        io_loop.start()\n\n    def startDataAcquisition(self):\n        while True:\n            self.plot_data.append({'x': [random.random()], 'y': [random.random()], 'color': [random.choice(['red', 'blue', 'green'])]})\n            time.sleep(5)\n\n    def make_document(self, doc):\n        source = ColumnDataSource({'x': [], 'y': [], 'color': []})\n        fig = figure(title = 'Streaming Circle Plot!', sizing_mode = 'scale_both')\n        fig.circle(source = source, x = 'x', y = 'y', color = 'color', size = 10)\n\n        def update():\n            if self.last_data_length is not None and self.last_data_length != len(self.plot_data):\n                source.stream(self.plot_data[-1])\n            self.last_data_length = len(self.plot_data)\n\n        doc.add_root(fig)\n        doc.add_periodic_callback(update, 1000)\n\nif __name__ == '__main__':\n    app = BokehApp()",
            "masked_code": "import random, time\nfrom tornado.ioloop import IOLoop\nfrom bokeh.server.server import Server\nfrom bokeh.application import Application\nfrom bokeh.application.handlers.function import FunctionHandler\nfrom bokeh.plotting import figure, ColumnDataSource\nfrom threading import Thread\n\nclass BokehApp():\n    plot_data = []\n    last_data_length = None\n\n    def __init__(self):\n        thread = Thread(target = self.startDataAcquisition)\n        thread.start()\n\n        io_loop = IOLoop.current()\n        server = Server(applications = {'/myapp': Application(FunctionHandler(self.make_document))}, io_loop = io_loop, port = 5001)\n        server.start()\n        <line_mask>\n        io_loop.start()\n\n    def startDataAcquisition(self):\n        while True:\n            self.plot_data.append({'x': [random.random()], 'y': [random.random()], 'color': [random.choice(['red', 'blue', 'green'])]})\n            time.sleep(5)\n\n    def make_document(self, doc):\n        source = ColumnDataSource({'x': [], 'y': [], 'color': []})\n        fig = figure(title = 'Streaming Circle Plot!', sizing_mode = 'scale_both')\n        fig.circle(source = source, x = 'x', y = 'y', color = 'color', size = 10)\n\n        def update():\n            if self.last_data_length is not None and self.last_data_length != len(self.plot_data):\n                source.stream(self.plot_data[-1])\n            self.last_data_length = len(self.plot_data)\n\n        doc.add_root(fig)\n        doc.add_periodic_callback(update, 1000)\n\nif __name__ == '__main__':\n    app = BokehApp()",
            "masked_line": "server.show('/myapp')",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_393"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-16",
            "description": "The code creates a dictionary \"dfs\" and splits a DataFrame \"df\" based on the condition that the column 'C' is not null. It then further splits the DataFrame based on the values in column 'A' that have a difference of more than 10, and stores the split DataFrames in the dictionary \"dfs\" with incremental keys generated from itertools.count().",
            "code": "from itertools import count\n\nc = count()\ndfs = {}\n\nc_valid = df['C'].notnull()\ndfs[next(c)] = df[c_valid]\n\nsplit_indices = np.where(df.loc[~c_valid, 'A'].diff() > 10)[0]\nfor df_split in np.split(df[~c_valid], split_indices):\n    dfs[next(c)] = df_split",
            "masked_code": "from itertools import count\n\nc = count()\ndfs = {}\n\nc_valid = df['C'].notnull()\ndfs[next(c)] = df[c_valid]\n\nsplit_indices = np.where(df.loc[~c_valid, 'A'].diff() > 10)[0]\n<line_mask>\n    dfs[next(c)] = df_split",
            "masked_line": "for df_split in np.split(df[~c_valid], split_indices):",
            "answer": "split",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_394"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-13",
            "description": "The code updates the 'value1' and 'value2' columns in a DataFrame based on a condition defined by the 'id' column and a list of ids to filter.",
            "code": "import numpy as np\n\nmask = df['id'].isin(id_list)\nvalue_array = np.vstack((value1_list, value2_list)).T\ndf.loc[mask, ['value1', 'value2']] = value_array\n\nprint(df)\n#    id  value1  value2\n# 0  24     100     125\n# 1  26     200     175\n# 2  28     300     165\n# 3  30       4       8",
            "masked_code": "import numpy as np\n\nmask = df['id'].isin(id_list)\n<line_mask>\ndf.loc[mask, ['value1', 'value2']] = value_array\n\nprint(df)\n#    id  value1  value2\n# 0  24     100     125\n# 1  26     200     175\n# 2  28     300     165\n# 3  30       4       8",
            "masked_line": "value_array = np.vstack((value1_list, value2_list)).T",
            "answer": "vstack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_395"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-10-29",
            "description": "The code prints a 10x10 matrix filled with ones using TensorFlow.",
            "code": "import tensorflow as tf\n\ntf.print(tf.ones([10, 10]))",
            "masked_code": "import tensorflow as tf\n\n<line_mask>",
            "masked_line": "tf.print(tf.ones([10, 10]))",
            "answer": "print",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_396"
        },
        {
            "dependency": "pandas",
            "version": "==0.25",
            "time": "2019-08-22",
            "description": "The code creates a DataFrame with columns 'SalesOrg Code', 'Reporting Country', 'Sold-To Country Code', and 'Sold-To Country Name'. It also defines a set called country_set containing the ISO 3166-1 alpha-2 country codes.",
            "code": "import numpy as np\nimport pandas as pd\n\ndf_mapping = pd.DataFrame({'SalesOrg Code':['0001','0002','0002','0002','0002'],\n                           'Reporting Country':['Spain','UK','UK','UK','Netherlands'],\n                           'Sold-To Country Code':[np.nan,'IE','FR','IT','Ex:'],\n                           'Sold-To Country Name':[np.nan,'Ireland','France','Italy','NOT: FR IE IT']})\n\ncountry_set = {\"AF\", \"AX\", \"AL\", \"DZ\", \"AS\", \"AD\", \"AO\", \"AI\", \"AQ\", \"AG\", \"AR\",\n\"AM\", \"AW\", \"AU\", \"AT\", \"AZ\", \"BS\", \"BH\", \"BD\", \"BB\", \"BY\", \"BE\",\n\"BZ\", \"BJ\", \"BM\", \"BT\", \"BO\", \"BQ\", \"BA\", \"BW\", \"BV\", \"BR\", \"IO\",\n\"BN\", \"BG\", \"BF\", \"BI\", \"CV\", \"KH\", \"CM\", \"CA\", \"KY\", \"CF\", \"TD\",\n\"CL\", \"CN\", \"CX\", \"CC\", \"CO\", \"KM\", \"CG\", \"CD\", \"CK\", \"CR\", \"CI\",\n\"HR\", \"CU\", \"CW\", \"CY\", \"CZ\", \"DK\", \"DJ\", \"DM\", \"DO\", \"EC\", \"EG\",\n\"SV\", \"GQ\", \"ER\", \"EE\", \"ET\", \"FK\", \"FO\", \"FJ\", \"FI\", \"FR\", \"GF\",\n\"PF\", \"TF\", \"GA\", \"GM\", \"GE\", \"DE\", \"GH\", \"GI\", \"GR\", \"GL\", \"GD\",\n\"GP\", \"GU\", \"GT\", \"GG\", \"GN\", \"GW\", \"GY\", \"HT\", \"HM\", \"VA\", \"HN\",\n\"HK\", \"HU\", \"IS\", \"IN\", \"ID\", \"IR\", \"IQ\", \"IE\", \"IM\", \"IL\", \"IT\",\n\"JM\", \"JP\", \"JE\", \"JO\", \"KZ\", \"KE\", \"KI\", \"KP\", \"KR\", \"KW\", \"KG\",\n\"LA\", \"LV\", \"LB\", \"LS\", \"LR\", \"LY\", \"LI\", \"LT\", \"LU\", \"MO\", \"MK\",\n\"MG\", \"MW\", \"MY\", \"MV\", \"ML\", \"MT\", \"MH\", \"MQ\", \"MR\", \"MU\", \"YT\",\n\"MX\", \"FM\", \"MD\", \"MC\", \"MN\", \"ME\", \"MS\", \"MA\", \"MZ\", \"MM\", \"NA\",\n\"NR\", \"NP\", \"NL\", \"NC\", \"NZ\", \"NI\", \"NE\", \"NG\", \"NU\", \"NF\", \"MP\",\n\"NO\", \"OM\", \"PK\", \"PW\", \"PS\", \"PA\", \"PG\", \"PY\", \"PE\", \"PH\", \"PN\",\n\"PL\", \"PT\", \"PR\", \"QA\", \"RE\", \"RO\", \"RU\", \"RW\", \"BL\", \"SH\", \"KN\",\n\"LC\", \"MF\", \"PM\", \"VC\", \"WS\", \"SM\", \"ST\", \"SA\", \"SN\", \"RS\", \"SC\",\n\"SL\", \"SG\", \"SX\", \"SK\", \"SI\", \"SB\", \"SO\", \"ZA\", \"GS\", \"SS\", \"ES\",\n\"LK\", \"SD\", \"SR\", \"SJ\", \"SZ\", \"SE\", \"CH\", \"SY\", \"TW\", \"TJ\", \"TZ\",\n\"TH\", \"TL\", \"TG\", \"TK\", \"TO\", \"TT\", \"TN\", \"TR\", \"TM\", \"TC\", \"TV\",\n\"UG\", \"UA\", \"AE\", \"GB\", \"US\", \"UM\", \"UY\", \"UZ\", \"VU\", \"VE\", \"VN\",\n\"VG\", \"VI\", \"WF\", \"EH\", \"YE\", \"ZM\", \"ZW\"}",
            "masked_code": "import numpy as np\nimport pandas as pd\n\n<line_mask>\n                           'Reporting Country':['Spain','UK','UK','UK','Netherlands'],\n                           'Sold-To Country Code':[np.nan,'IE','FR','IT','Ex:'],\n                           'Sold-To Country Name':[np.nan,'Ireland','France','Italy','NOT: FR IE IT']})\n\ncountry_set = {\"AF\", \"AX\", \"AL\", \"DZ\", \"AS\", \"AD\", \"AO\", \"AI\", \"AQ\", \"AG\", \"AR\",\n\"AM\", \"AW\", \"AU\", \"AT\", \"AZ\", \"BS\", \"BH\", \"BD\", \"BB\", \"BY\", \"BE\",\n\"BZ\", \"BJ\", \"BM\", \"BT\", \"BO\", \"BQ\", \"BA\", \"BW\", \"BV\", \"BR\", \"IO\",\n\"BN\", \"BG\", \"BF\", \"BI\", \"CV\", \"KH\", \"CM\", \"CA\", \"KY\", \"CF\", \"TD\",\n\"CL\", \"CN\", \"CX\", \"CC\", \"CO\", \"KM\", \"CG\", \"CD\", \"CK\", \"CR\", \"CI\",\n\"HR\", \"CU\", \"CW\", \"CY\", \"CZ\", \"DK\", \"DJ\", \"DM\", \"DO\", \"EC\", \"EG\",\n\"SV\", \"GQ\", \"ER\", \"EE\", \"ET\", \"FK\", \"FO\", \"FJ\", \"FI\", \"FR\", \"GF\",\n\"PF\", \"TF\", \"GA\", \"GM\", \"GE\", \"DE\", \"GH\", \"GI\", \"GR\", \"GL\", \"GD\",\n\"GP\", \"GU\", \"GT\", \"GG\", \"GN\", \"GW\", \"GY\", \"HT\", \"HM\", \"VA\", \"HN\",\n\"HK\", \"HU\", \"IS\", \"IN\", \"ID\", \"IR\", \"IQ\", \"IE\", \"IM\", \"IL\", \"IT\",\n\"JM\", \"JP\", \"JE\", \"JO\", \"KZ\", \"KE\", \"KI\", \"KP\", \"KR\", \"KW\", \"KG\",\n\"LA\", \"LV\", \"LB\", \"LS\", \"LR\", \"LY\", \"LI\", \"LT\", \"LU\", \"MO\", \"MK\",\n\"MG\", \"MW\", \"MY\", \"MV\", \"ML\", \"MT\", \"MH\", \"MQ\", \"MR\", \"MU\", \"YT\",\n\"MX\", \"FM\", \"MD\", \"MC\", \"MN\", \"ME\", \"MS\", \"MA\", \"MZ\", \"MM\", \"NA\",\n\"NR\", \"NP\", \"NL\", \"NC\", \"NZ\", \"NI\", \"NE\", \"NG\", \"NU\", \"NF\", \"MP\",\n\"NO\", \"OM\", \"PK\", \"PW\", \"PS\", \"PA\", \"PG\", \"PY\", \"PE\", \"PH\", \"PN\",\n\"PL\", \"PT\", \"PR\", \"QA\", \"RE\", \"RO\", \"RU\", \"RW\", \"BL\", \"SH\", \"KN\",\n\"LC\", \"MF\", \"PM\", \"VC\", \"WS\", \"SM\", \"ST\", \"SA\", \"SN\", \"RS\", \"SC\",\n\"SL\", \"SG\", \"SX\", \"SK\", \"SI\", \"SB\", \"SO\", \"ZA\", \"GS\", \"SS\", \"ES\",\n\"LK\", \"SD\", \"SR\", \"SJ\", \"SZ\", \"SE\", \"CH\", \"SY\", \"TW\", \"TJ\", \"TZ\",\n\"TH\", \"TL\", \"TG\", \"TK\", \"TO\", \"TT\", \"TN\", \"TR\", \"TM\", \"TC\", \"TV\",\n\"UG\", \"UA\", \"AE\", \"GB\", \"US\", \"UM\", \"UY\", \"UZ\", \"VU\", \"VE\", \"VN\",\n\"VG\", \"VI\", \"WF\", \"EH\", \"YE\", \"ZM\", \"ZW\"}",
            "masked_line": "df_mapping = pd.DataFrame({'SalesOrg Code':['0001','0002','0002','0002','0002'],",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_397"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-30",
            "description": "The code generates a Bokeh plot containing a Select widget to choose a date, and based on the selected date, it dynamically generates a Select widget to choose a level. The selected date and level are displayed in a Div element. The level options are randomly generated, but it suggests replacing them with levels read from a CSV file. The code employs callback functions to update the displayed information when the Select widgets' values are changed.",
            "code": "from bokeh.plotting import curdoc, show\nfrom bokeh.models import Select, Column, Div\nfrom datetime import datetime, timedelta\nimport numpy as np\n\nday_start = datetime(2019, 3, 15)\nday_step = timedelta(days = 1)\ndates = [str(day_start + (i * day_step)) for i in range(0, 6)]\n\ncurrent_date = None\nselect_data = Select(title = 'Select a date', value = '', options = [''] + dates)\ninfo = Div(text = 'Selected date: ')\nlayout = Column(info, select_data)\n\ndef update_info(attr, old, new):\n    prefix = info.text.split(', level:')\n    if len(prefix) > 1:\n        info.text = prefix[0] + ', level: {}'.format(new)\n    else:\n        info.text = info.text + ', level: {}'.format(new)\n\ndef update_layout(attr, old, new):\n    info.text = ('Selected date: {}'.format(new))\n    global current_date\n    if current_date is not None:\n        layout.children.remove(layout.children[2])  # index 0 == info, index 1 == select_data, so we need to remove index 1 = dynamic_select\n\n    levels = np.arange(np.random.randint(1, 4), np.random.randint(5, 7))  # replace this random levels with levels that you read from your csv file\n    dynamic_select = Select(title = 'Select a level for date: {}'.format(new), value = '', options = [''] + [str(value) for value in levels])\n    dynamic_select.on_change('value', update_info)\n    layout.children.append(dynamic_select)\n    current_date = new\n\nselect_data.on_change('value', update_layout)\n\ncurdoc().add_root(layout)",
            "masked_code": "from bokeh.plotting import curdoc, show\nfrom bokeh.models import Select, Column, Div\nfrom datetime import datetime, timedelta\nimport numpy as np\n\nday_start = datetime(2019, 3, 15)\nday_step = timedelta(days = 1)\ndates = [str(day_start + (i * day_step)) for i in range(0, 6)]\n\ncurrent_date = None\nselect_data = Select(title = 'Select a date', value = '', options = [''] + dates)\ninfo = Div(text = 'Selected date: ')\nlayout = Column(info, select_data)\n\ndef update_info(attr, old, new):\n    prefix = info.text.split(', level:')\n    if len(prefix) > 1:\n        info.text = prefix[0] + ', level: {}'.format(new)\n    else:\n        info.text = info.text + ', level: {}'.format(new)\n\ndef update_layout(attr, old, new):\n    info.text = ('Selected date: {}'.format(new))\n    global current_date\n    if current_date is not None:\n        layout.children.remove(layout.children[2])  # index 0 == info, index 1 == select_data, so we need to remove index 1 = dynamic_select\n\n    levels = np.arange(np.random.randint(1, 4), np.random.randint(5, 7))  # replace this random levels with levels that you read from your csv file\n    dynamic_select = Select(title = 'Select a level for date: {}'.format(new), value = '', options = [''] + [str(value) for value in levels])\n    dynamic_select.on_change('value', update_info)\n    <line_mask>\n    current_date = new\n\nselect_data.on_change('value', update_layout)\n\ncurdoc().add_root(layout)",
            "masked_line": "layout.children.append(dynamic_select)",
            "answer": "children",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_398"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.4",
            "time": "2019-03-28",
            "description": "This code creates a numpy array containing the elements 0, 1, 2, and 3. It then prints out the elements of the array, converts the array to a python list, and prints the array as a list. Lastly, it converts the array back to a numpy array and prints it along with its type. It also prints out the element at index 0 and 1 of the numpy array.",
            "code": "import numpy as np\n\na = np.array([0, 1, 2, 3])\nprint(a[0]) # 0\n\nfor x in a:\n    print(x) # 0 1 2 3\n\n# you can call list() to convert to a python list\nprint(list(a))\n\n# you can also call the built-in numpy array method\nprint(a.tolist())\n\na = np.array(a)\nprint(a, type(a)) # [0 1 2 3] \nprint(a[0]) # 0\nprint(a[1]) # 1",
            "masked_code": "import numpy as np\n\n<line_mask>\nprint(a[0]) # 0\n\nfor x in a:\n    print(x) # 0 1 2 3\n\n# you can call list() to convert to a python list\nprint(list(a))\n\n# you can also call the built-in numpy array method\nprint(a.tolist())\n\na = np.array(a)\nprint(a, type(a)) # [0 1 2 3] \nprint(a[0]) # 0\nprint(a[1]) # 1",
            "masked_line": "a = np.array([0, 1, 2, 3])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_399"
        },
        {
            "dependency": "numpy",
            "version": "==1.17.0",
            "time": "2019-10-04",
            "description": "This code assigns values from the 'values' array to a new array 'result' based on the indices provided in the 'indices' array. The result is a 2D array where the values are assigned at the specified indices.",
            "code": "import numpy as np\n\nindices = np.array([0, 1, 1, 0, 0, 1, 0])\nvalues = np.array([1, 2, 3, 4, 5, 6, 7])\n\nresult = np.zeros((len(indices), 2))\n\nresult[np.arange(len(indices)), indices] = values\n\nprint(result)",
            "masked_code": "import numpy as np\n\nindices = np.array([0, 1, 1, 0, 0, 1, 0])\nvalues = np.array([1, 2, 3, 4, 5, 6, 7])\n\nresult = np.zeros((len(indices), 2))\n\n<line_mask>\n\nprint(result)",
            "masked_line": "result[np.arange(len(indices)), indices] = values",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_400"
        },
        {
            "dependency": "networkx",
            "version": "==1.9.1",
            "time": "2019-09-16",
            "description": "The code generates all pairwise combinations of nodes in connected subgraphs of a given graph, excluding nodes labeled with digits, and then it combines these subgraphs into a new graph and visualizes it using a spring layout.",
            "code": "import itertools\n\nsubgraphs = []\n\nfor cc in nx.connected_component_subgraphs(G):\n    # collect all nodes in the connected subgraph that aren't labeled with digits\n    nodes = [a for a in cc.nodes if not str(a).isdigit()]\n    Subgraph = nx.Graph()\n    Subgraph.add_nodes_from(nodes)\n    # generate all pairwise combinations for these nodes and add as edges:\n    Subgraph.add_edges_from(itertools.combinations(nodes, 2))\n\n    subgraphs.append(Subgraph)\n\n# optional:    \n# combine all subgraphs into a new graph\nG_new = nx.compose(*subgraphs)\n\npos = nx.spring_layout(G_new)\nnx.draw_networkx(G_new, pos)",
            "masked_code": "import itertools\n\nsubgraphs = []\n\n<line_mask>\n    # collect all nodes in the connected subgraph that aren't labeled with digits\n    nodes = [a for a in cc.nodes if not str(a).isdigit()]\n    Subgraph = nx.Graph()\n    Subgraph.add_nodes_from(nodes)\n    # generate all pairwise combinations for these nodes and add as edges:\n    Subgraph.add_edges_from(itertools.combinations(nodes, 2))\n\n    subgraphs.append(Subgraph)\n\n# optional:    \n# combine all subgraphs into a new graph\nG_new = nx.compose(*subgraphs)\n\npos = nx.spring_layout(G_new)\nnx.draw_networkx(G_new, pos)",
            "masked_line": "for cc in nx.connected_component_subgraphs(G):",
            "answer": "connected_component_subgraphs",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_401"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-06-11",
            "description": "This code reads an Excel file from an Azure blob storage trigger function, extracts data using pandas into a DataFrame, and logs the DataFrame information.",
            "code": "import logging\n\nimport azure.functions as func\n\nimport pandas as pd\nimport xlrd\n\ndef main(myblob: func.InputStream):\n    logging.info(f\"Python blob trigger function processed blob \\n\"\n                 f\"Name: {myblob.name}\\n\"\n                 f\"Blob Size: {myblob.length} bytes\")\n    book = xlrd.open_workbook(file_contents=myblob.read())\n    df = pd.read_excel(book)\n    logging.info(f\"{df}\")",
            "masked_code": "import logging\n\nimport azure.functions as func\n\nimport pandas as pd\nimport xlrd\n\ndef main(myblob: func.InputStream):\n    logging.info(f\"Python blob trigger function processed blob \\n\"\n                 f\"Name: {myblob.name}\\n\"\n                 f\"Blob Size: {myblob.length} bytes\")\n    book = xlrd.open_workbook(file_contents=myblob.read())\n    <line_mask>\n    logging.info(f\"{df}\")",
            "masked_line": "df = pd.read_excel(book)",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_402"
        },
        {
            "dependency": "xlrd",
            "version": ">=1.0.0",
            "time": "2019-06-11",
            "description": "This code reads an Excel file from a Azure blob storage triggered by a blob upload event, logs information about the uploaded blob, opens the Excel file using xlrd, and then reads the Excel file into a pandas DataFrame.",
            "code": "import logging\n\nimport azure.functions as func\n\nimport pandas as pd\nimport xlrd\n\ndef main(myblob: func.InputStream):\n    logging.info(f\"Python blob trigger function processed blob \\n\"\n                 f\"Name: {myblob.name}\\n\"\n                 f\"Blob Size: {myblob.length} bytes\")\n    book = xlrd.open_workbook(file_contents=myblob.read())\n    df = pd.read_excel(book)\n    logging.info(f\"{df}\")",
            "masked_code": "import logging\n\nimport azure.functions as func\n\nimport pandas as pd\nimport xlrd\n\ndef main(myblob: func.InputStream):\n    logging.info(f\"Python blob trigger function processed blob \\n\"\n                 f\"Name: {myblob.name}\\n\"\n                 f\"Blob Size: {myblob.length} bytes\")\n    <line_mask>\n    df = pd.read_excel(book)\n    logging.info(f\"{df}\")",
            "masked_line": "book = xlrd.open_workbook(file_contents=myblob.read())",
            "answer": "open_workbook",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_403"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-29",
            "description": "This code generates a line plot using Bokeh library to visualize the scores over time for different categories ('name') in the test data. Each category is assigned a unique color and represented by a separate line. The x-axis represents the dates and the y-axis represents the scores. Each line is labeled with the corresponding category name.",
            "code": "import pandas as pd\nimport datetime\nimport bokeh.plotting as bp\nfrom bokeh.palettes import Category10\n\ntest_data = {'name': ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'],\n             'date': [datetime.date(2010, 1, 1),\n                      datetime.date(2010, 2, 1),\n                      datetime.date(2010, 3, 1),\n                      datetime.date(2010, 1, 1),\n                      datetime.date(2010, 2, 1),\n                      datetime.date(2010, 3, 1),\n                      datetime.date(2010, 1, 1),\n                      datetime.date(2010, 2, 1),\n                      datetime.date(2010, 3, 1), ],\n             'score': [100, 200, 300, 150, 400, 600, 150, 250, 400]}\n\nplot_df = pd.DataFrame(test_data)\ngby = plot_df.groupby('name')\nnames = list(gby.groups.keys())\npalette = Category10[len(names)]\n\nplot_df['color'] = [palette[names.index(x)] for i, sdf in gby for x in sdf['name']]\n\nplot = bp.figure(x_axis_type = 'datetime')\ngby.apply(lambda d: plot.line('date', 'score', line_color = d['color'].unique()[0], line_width = 3, legend = d['name'].unique()[0], source = d))\n\nbp.show(plot)",
            "masked_code": "import pandas as pd\nimport datetime\nimport bokeh.plotting as bp\nfrom bokeh.palettes import Category10\n\ntest_data = {'name': ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'],\n             'date': [datetime.date(2010, 1, 1),\n                      datetime.date(2010, 2, 1),\n                      datetime.date(2010, 3, 1),\n                      datetime.date(2010, 1, 1),\n                      datetime.date(2010, 2, 1),\n                      datetime.date(2010, 3, 1),\n                      datetime.date(2010, 1, 1),\n                      datetime.date(2010, 2, 1),\n                      datetime.date(2010, 3, 1), ],\n             'score': [100, 200, 300, 150, 400, 600, 150, 250, 400]}\n\nplot_df = pd.DataFrame(test_data)\ngby = plot_df.groupby('name')\nnames = list(gby.groups.keys())\npalette = Category10[len(names)]\n\nplot_df['color'] = [palette[names.index(x)] for i, sdf in gby for x in sdf['name']]\n\nplot = bp.figure(x_axis_type = 'datetime')\ngby.apply(lambda d: plot.line('date', 'score', line_color = d['color'].unique()[0], line_width = 3, legend = d['name'].unique()[0], source = d))\n\n<line_mask>",
            "masked_line": "bp.show(plot)",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_404"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-04-05",
            "description": "This code assigns a value of 1 to the \"col2\" column in the dataframe \"df\" if the corresponding value in the \"col1\" column is one of ('a', 'b', 'c', 'd', 'e'), otherwise it assigns a value of 0.",
            "code": "import numpy as np\ndf[\"col2\"] = np.where(df[\"col1\"].isin(('a','b', 'c', 'd', 'e')), 1, 0)",
            "masked_code": "import numpy as np\n<line_mask>",
            "masked_line": "df[\"col2\"] = np.where(df[\"col1\"].isin(('a','b', 'c', 'd', 'e')), 1, 0)",
            "answer": "isin",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_405"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.4",
            "time": "2019-03-29",
            "description": "This code calculates the determinant and sign-determinant of a 2x2 matrix, and then attempts to find the inverse of the matrix. If the matrix is singular (non-invertible), it prints \"inversion failed\".",
            "code": "import numpy as np\nmatrix=np.array([[5.,10.],[2.,4.]])\nprint(np.linalg.det(matrix))\nprint(np.linalg.slogdet(matrix))\n\ntry:\n    invmatrix=np.linalg.inv(matrix)\n\nexcept np.linalg.LinAlgError:\n    print(\"inversion failed\")",
            "masked_code": "import numpy as np\nmatrix=np.array([[5.,10.],[2.,4.]])\nprint(np.linalg.det(matrix))\nprint(np.linalg.slogdet(matrix))\n\ntry:\n    <line_mask>\n\nexcept np.linalg.LinAlgError:\n    print(\"inversion failed\")",
            "masked_line": "invmatrix=np.linalg.inv(matrix)",
            "answer": "inv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_406"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-01-03",
            "description": "This code performs 2D interpolation on the given data points (a, b, c) at specific x and y coordinates to estimate the z value at a desired x_interp and y_interp coordinate.",
            "code": "import numpy as np\nfrom scipy.interpolate import interp2d\n\n# Original data (e.g. measurements)\na = [3, 1, -2, -3, -3]\nb = [2, -7, -14, -30, -39]\nc = [46, 22, 5, -2, -8]\n\nx = [0, 10, 20]             # x-coordinates\ny = [0, 10, 20, 30, 40]     # y-coordinates\n\n# Organise data in matrix\nz = np.vstack([a, b, c]).T\n\n# Create interpolation function\nf_z = interp2d(x, y, z)\n\n# Desired x/y values\nx_interp = 5\ny_interp = 5\n\n# Collect interpolated z-value\nz_interp = f_z(x_interp, y_interp)\nprint(z_interp)  # (result: [-0.25])",
            "masked_code": "import numpy as np\nfrom scipy.interpolate import interp2d\n\n# Original data (e.g. measurements)\na = [3, 1, -2, -3, -3]\nb = [2, -7, -14, -30, -39]\nc = [46, 22, 5, -2, -8]\n\nx = [0, 10, 20]             # x-coordinates\ny = [0, 10, 20, 30, 40]     # y-coordinates\n\n# Organise data in matrix\nz = np.vstack([a, b, c]).T\n\n# Create interpolation function\n<line_mask>\n\n# Desired x/y values\nx_interp = 5\ny_interp = 5\n\n# Collect interpolated z-value\nz_interp = f_z(x_interp, y_interp)\nprint(z_interp)  # (result: [-0.25])",
            "masked_line": "f_z = interp2d(x, y, z)",
            "answer": "interp2d",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_407"
        },
        {
            "dependency": "beautifulsoup4",
            "version": "==4.8.1",
            "time": "2019-12-07",
            "description": "The code diagnoses the given text data using Beautiful Soup library in Python.",
            "code": "data = '''text'''\n\nfrom bs4 import BeautifulSoup\nfrom bs4.diagnose import diagnose\n\ndiagnose(data)",
            "masked_code": "data = '''text'''\n\nfrom bs4 import BeautifulSoup\n<line_mask>\n\ndiagnose(data)",
            "masked_line": "from bs4.diagnose import diagnose",
            "answer": "diagnose",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_408"
        },
        {
            "dependency": "dash",
            "version": "==1.6.0",
            "time": "2019-11-20",
            "description": "This code creates a web application using Dash framework that displays a scatter plot graph based on data from two CSV files. Users can select different datasets, x-axis and y-axis values to customize the graph visualization.",
            "code": "import dash\nimport dash_table\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport plotly.graph_objs as go\nimport pandas as pd\nimport json\n\napp = dash.Dash(__name__)\n\ndf1 = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/solar.csv')\ndf2 = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/finance-charts-apple.csv')\n\ndict_main = {'df1': df1, 'df2': df2}\ndata = list(dict_main.keys())\nchannels = dict_main[data[0]]\n\napp.layout = html.Div([\n        dcc.Graph(id='Main-Graph',\n            figure=go.Figure(\n                data=[go.Scatter(x=data, y=channels)]\n        )),\n        html.Div([\n            dcc.Dropdown(\n                id='data-dropdown',\n                options=[{'label': label, 'value': label} for label in data],\n                value=list(dict_main.keys())[0],\n                multi=False,\n                searchable=False)],\n            style={'width': '33%', 'display': 'inline-block'}),\n        html.Div([\n            dcc.Dropdown(\n                id='x-axis-dropdown',\n                multi=False)],\n            style={'width': '33%', 'display': 'inline-block'}),\n        html.Div([\n            dcc.Dropdown(\n                id='y-axis-dropdown',\n                multi=False)],\n            style={'width': '33%', 'display': 'inline-block'}),        \n])\n\n@app.callback(\n    [dash.dependencies.Output('x-axis-dropdown', 'options'),\n     dash.dependencies.Output('y-axis-dropdown', 'options')],\n    [dash.dependencies.Input('data-dropdown', 'value')]\n)\ndef update_date_dropdown(selected):\n    if selected:\n        fields = [{'label': i, 'value': i} for i in dict_main[selected]]\n        return [fields, fields]\n\n@app.callback(\n    dash.dependencies.Output('Main-Graph', 'figure'),\n    [dash.dependencies.Input('data-dropdown', 'value'),\n     dash.dependencies.Input('x-axis-dropdown', 'value'),\n     dash.dependencies.Input('y-axis-dropdown', 'value')],\n    [dash.dependencies.State('Main-Graph', 'figure')])\ndef updateGraph(df_name, x_field, y_field, data):\n    source = data['data']\n    df = dict_main[df_name]\n\n    if x_field and y_field and x_field in df.columns and y_field in df.columns:\n        new_source = [{'x': df[x_field].tolist(), 'y': df[y_field].tolist()}]\n        source = new_source\n    return {\n        'data': source,\n        'layout': data['layout']\n    }\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "import dash\nimport dash_table\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport plotly.graph_objs as go\nimport pandas as pd\nimport json\n\napp = dash.Dash(__name__)\n\ndf1 = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/solar.csv')\ndf2 = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/finance-charts-apple.csv')\n\ndict_main = {'df1': df1, 'df2': df2}\ndata = list(dict_main.keys())\nchannels = dict_main[data[0]]\n\napp.layout = html.Div([\n        dcc.Graph(id='Main-Graph',\n            figure=go.Figure(\n                data=[go.Scatter(x=data, y=channels)]\n        )),\n        html.Div([\n            <line_mask>\n                id='data-dropdown',\n                options=[{'label': label, 'value': label} for label in data],\n                value=list(dict_main.keys())[0],\n                multi=False,\n                searchable=False)],\n            style={'width': '33%', 'display': 'inline-block'}),\n        html.Div([\n            dcc.Dropdown(\n                id='x-axis-dropdown',\n                multi=False)],\n            style={'width': '33%', 'display': 'inline-block'}),\n        html.Div([\n            dcc.Dropdown(\n                id='y-axis-dropdown',\n                multi=False)],\n            style={'width': '33%', 'display': 'inline-block'}),        \n])\n\n@app.callback(\n    [dash.dependencies.Output('x-axis-dropdown', 'options'),\n     dash.dependencies.Output('y-axis-dropdown', 'options')],\n    [dash.dependencies.Input('data-dropdown', 'value')]\n)\ndef update_date_dropdown(selected):\n    if selected:\n        fields = [{'label': i, 'value': i} for i in dict_main[selected]]\n        return [fields, fields]\n\n@app.callback(\n    dash.dependencies.Output('Main-Graph', 'figure'),\n    [dash.dependencies.Input('data-dropdown', 'value'),\n     dash.dependencies.Input('x-axis-dropdown', 'value'),\n     dash.dependencies.Input('y-axis-dropdown', 'value')],\n    [dash.dependencies.State('Main-Graph', 'figure')])\ndef updateGraph(df_name, x_field, y_field, data):\n    source = data['data']\n    df = dict_main[df_name]\n\n    if x_field and y_field and x_field in df.columns and y_field in df.columns:\n        new_source = [{'x': df[x_field].tolist(), 'y': df[y_field].tolist()}]\n        source = new_source\n    return {\n        'data': source,\n        'layout': data['layout']\n    }\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_line": "dcc.Dropdown(",
            "answer": "Dropdown",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_409"
        },
        {
            "dependency": "rasterio",
            "version": "==1.0.21",
            "time": "2019-09-17",
            "description": "The code opens and reads a remote compressed GeoTIFF file using the rasterio library.",
            "code": "import rasterio as rio\n\nds = rio.open('/vsigzip//vsicurl/http://localhost:8000/example.tif.gz')",
            "masked_code": "import rasterio as rio\n\n<line_mask>",
            "masked_line": "ds = rio.open('/vsigzip//vsicurl/http://localhost:8000/example.tif.gz')",
            "answer": "open",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_410"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2019-09-01",
            "description": "The code generates a fake image using a Generative Adversarial Network (GAN) implemented in TensorFlow. It starts by creating a generator model, which takes a random noise vector as input and outputs a generated image. The model consists of several layers including dense, batch normalization, leaky ReLU, and transpose convolution layers. After generating an image using the model, it initializes a TensorFlow session, runs the session to generate the image, and then displays the generated image using matplotlib.",
            "code": "from __future__ import absolute_import, division, print_function, unicode_literals\n\nimport tensorflow as tf \ntf.__version__\n\nimport glob\nimport imageio\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\nimport PIL\nfrom tensorflow.keras import layers\nimport time\n\ndef make_generator_model():\n    model = tf.keras.Sequential()\n    model.add(layers.Dense(7*7*256, use_bias=False, input_shape=(100,)))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n    model.add(layers.Reshape((7, 7, 256)))\n\n    assert model.output_shape == (None, 7, 7, 256) # Note: None is the batch size\n\n    model.add(layers.Conv2DTranspose(128, (5, 5), strides=(1, 1), padding='same', use_bias=False))\n    assert model.output_shape == (None, 7, 7, 128)\n\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Conv2DTranspose(64, (5, 5), strides=(2, 2), padding='same', use_bias=False))\n    assert model.output_shape == (None, 14, 14, 64)\n\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Conv2DTranspose(1, (5, 5), strides=(2, 2), padding='same', use_bias=False, activation='tanh'))\n    assert model.output_shape == (None, 28, 28, 1)\n\n    return model\n\ngenerator = make_generator_model()\n\nnoise = tf.random.normal([1, 100])\ngenerated_image = generator(noise, training=False)\n\nwith tf.Session() as sess:\n  sess.run(tf.global_variables_initializer())\n  generated_image = sess.run(generated_image)\nplt.imshow(generated_image[0, :, :, 0], cmap='gray')",
            "masked_code": "from __future__ import absolute_import, division, print_function, unicode_literals\n\nimport tensorflow as tf \ntf.__version__\n\nimport glob\nimport imageio\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\nimport PIL\nfrom tensorflow.keras import layers\nimport time\n\ndef make_generator_model():\n    model = tf.keras.Sequential()\n    model.add(layers.Dense(7*7*256, use_bias=False, input_shape=(100,)))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n    model.add(layers.Reshape((7, 7, 256)))\n\n    assert model.output_shape == (None, 7, 7, 256) # Note: None is the batch size\n\n    model.add(layers.Conv2DTranspose(128, (5, 5), strides=(1, 1), padding='same', use_bias=False))\n    assert model.output_shape == (None, 7, 7, 128)\n\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Conv2DTranspose(64, (5, 5), strides=(2, 2), padding='same', use_bias=False))\n    assert model.output_shape == (None, 14, 14, 64)\n\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Conv2DTranspose(1, (5, 5), strides=(2, 2), padding='same', use_bias=False, activation='tanh'))\n    assert model.output_shape == (None, 28, 28, 1)\n\n    return model\n\ngenerator = make_generator_model()\n\n<line_mask>\ngenerated_image = generator(noise, training=False)\n\nwith tf.Session() as sess:\n  sess.run(tf.global_variables_initializer())\n  generated_image = sess.run(generated_image)\nplt.imshow(generated_image[0, :, :, 0], cmap='gray')",
            "masked_line": "noise = tf.random.normal([1, 100])",
            "answer": "normal",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_411"
        },
        {
            "dependency": "pandas",
            "version": "==1.1",
            "time": "2020-08-30",
            "description": "The code reads JSON data from a string and stores it in a new dataframe.",
            "code": "from io import StringIO\nnewdf = pd.read_json(StringIO(temp))",
            "masked_code": "from io import StringIO\n<line_mask>",
            "masked_line": "newdf = pd.read_json(StringIO(temp))",
            "answer": "read_json",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_412"
        },
        {
            "dependency": "pytest",
            "version": "==7.1.1",
            "time": "2022-04-19",
            "description": "The code defines fixtures f1_a and f1_b that return strings \"a\" and \"b\" respectively. Fixture f1 returns the value of either f1_a or f1_b based on the parameter passed. Fixture f2 takes parameters and ids, and returns a tuple consisting of the value from f1 and the parameter. Finally, there are two test functions test_f1 and test_f2 that assert the values returned by f1 and f2 fixtures respectively.",
            "code": "from pytest import fixture\n\n@fixture()\ndef f1_a(request):\n    return \"a\"\n\n@fixture()\ndef f1_b(request):\n    return \"b\"\n\n\n@fixture(params=[\"a\", \"b\"])\ndef f1(request):\n    return request.getfixturevalue(f\"f1_{request.param}\")\n\n\nparams = [('a', 1), ('a', 2), ('b', 10), ('b', 20)]\n\n\n@fixture(params=params, ids=[str(x) for x in params])\ndef f2(request):\n    return request.getfixturevalue(f\"f1_{request.param[0]}\"), request.param\n    \ndef test_f2(f2):\n    assert f2\n\ndef test_f1(f1):\n    assert f1",
            "masked_code": "from pytest import fixture\n\n@fixture()\ndef f1_a(request):\n    return \"a\"\n\n@fixture()\ndef f1_b(request):\n    return \"b\"\n\n\n@fixture(params=[\"a\", \"b\"])\ndef f1(request):\n    return request.getfixturevalue(f\"f1_{request.param}\")\n\n\nparams = [('a', 1), ('a', 2), ('b', 10), ('b', 20)]\n\n\n<line_mask>\ndef f2(request):\n    return request.getfixturevalue(f\"f1_{request.param[0]}\"), request.param\n    \ndef test_f2(f2):\n    assert f2\n\ndef test_f1(f1):\n    assert f1",
            "masked_line": "@fixture(params=params, ids=[str(x) for x in params])",
            "answer": "fixture",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_413"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-03-10",
            "description": "The code configures the GPU memory allocation for TensorFlow to use a fraction of the available memory per process (0.2) and allows the GPU memory to grow as needed during runtime.",
            "code": "from tensorflow.compat.v1 import ConfigProto\nfrom tensorflow.compat.v1 import InteractiveSession\n\nconfig = ConfigProto()\nconfig.gpu_options.per_process_gpu_memory_fraction = 0.2\nconfig.gpu_options.allow_growth = True\nsession = InteractiveSession(config=config)",
            "masked_code": "from tensorflow.compat.v1 import ConfigProto\n<line_mask>\n\nconfig = ConfigProto()\nconfig.gpu_options.per_process_gpu_memory_fraction = 0.2\nconfig.gpu_options.allow_growth = True\nsession = InteractiveSession(config=config)",
            "masked_line": "from tensorflow.compat.v1 import InteractiveSession",
            "answer": "InteractiveSession",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_414"
        },
        {
            "dependency": "julia",
            "version": "==1.5",
            "time": "2020-10-29",
            "description": "This code activates a Julia environment located at the specified path.",
            "code": "from julia import Pkg\nPkg.activate(\"/home/user/.julia/environments/v1.5\") #use the correct path",
            "masked_code": "from julia import Pkg\n<line_mask>",
            "masked_line": "Pkg.activate(\"/home/user/.julia/environments/v1.5\") #use the correct path",
            "answer": "activate",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_415"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.5.5.64",
            "time": "2022-12-02",
            "description": "This Python code is designed to load a video file, display the video frames in memory, and allow the user to control the playback of the video using keyboard inputs. The code loads the video file, reads all the frames to memory, and then allows the user to play, pause, move to the next frame, move to the previous frame, or exit the video playback. The user can interact with the video playback using specific key inputs, such as spacebar for play/pause, 'a' for previous frame, 'd' for next frame, and 'q' to exit. Additionally, the code includes error handling for invalid key inputs.",
            "code": "import cv2\nimport numpy as np\nimport datetime\nimport os\nimport sys\n\n# import the video\nvideoFile = sys.argv[1];\n\n# load capture\ncap = cv2.VideoCapture(videoFile)\nif (cap.isOpened()== False): \n  print(\"Error opening video stream or file\")\n\n# prepare view\nview_name = \"Video in memory\"\ntotal_frames = cap.get(cv2.CAP_PROP_FRAME_COUNT)\ncv2.namedWindow(view_name)\ncv2.createTrackbar('S',view_name, 0,int(total_frames)-1, lambda x:x)\ncv2.setTrackbarPos('S',view_name,0)\n\n# read the entire video to memory\nprint(\"[INFO] loading frames to memory\")\nall_frames = []\nwhile(cap.isOpened()):\n    frame_exists, frame = cap.read()\n    if frame_exists == True:\n        all_frames.append(frame)\n    else:\n        break\n\n# When everything done, release the video capture object\ncap.release()\nprint(\"[INFO] load compelte\");\n\n# set default play state to pause\nstatus = 'pause'\nprevious_status = 'pause'\nframe_idx = 0\nwhile True:\n    try:\n        if frame_idx==total_frames-1:\n            frame_idx=0\n\n        frame = all_frames[frame_idx]\n        cv2.imshow(view_name,frame)\n\n        # event handling\n        keyPress = cv2.waitKey(1)\n        if keyPress & 0xFF == ord(' '):\n            status = 'play_pause_click'\n        elif keyPress & 0xFF == ord('a'):\n            status = 'prev_frame'\n        elif keyPress & 0xFF == ord('d'):\n            status = 'next_frame'\n        elif keyPress & 0xFF == -1:\n            status = status\n        elif keyPress & 0xFF == ord('q'):\n            status = 'exit'\n\n        if (status == 'play_pause_click' and previous_status == 'play_pause_click'):\n            status = 'pause'\n            previous_status = 'pause'\n        if (status == 'play_pause_click'):\n            status = 'play'\n            previous_status = 'play_pause_click'\n\n        if status == 'play':\n            frame_idx += 1\n            cv2.setTrackbarPos('S',view_name,frame_idx)\n            continue\n        if status == 'pause':\n            frame_idx = cv2.getTrackbarPos('S',view_name)\n        if status=='prev_frame':\n            frame_idx-=1\n            frame_idx = max(0, frame_idx)\n            cv2.setTrackbarPos('S',view_name,frame_idx)\n            status='pause'\n        if status=='next_frame':\n            frame_idx+=1\n            cv2.setTrackbarPos('S',view_name,frame_idx)\n            status='pause'\n        if status == 'exit':\n            break\n\n    except KeyError:\n        print(\"Invalid Key was pressed\")\n \n# Closes the generated window\ncv2.destroyWindow(view_name)",
            "masked_code": "import cv2\nimport numpy as np\nimport datetime\nimport os\nimport sys\n\n# import the video\nvideoFile = sys.argv[1];\n\n# load capture\ncap = cv2.VideoCapture(videoFile)\nif (cap.isOpened()== False): \n  print(\"Error opening video stream or file\")\n\n# prepare view\nview_name = \"Video in memory\"\ntotal_frames = cap.get(cv2.CAP_PROP_FRAME_COUNT)\ncv2.namedWindow(view_name)\ncv2.createTrackbar('S',view_name, 0,int(total_frames)-1, lambda x:x)\ncv2.setTrackbarPos('S',view_name,0)\n\n# read the entire video to memory\nprint(\"[INFO] loading frames to memory\")\nall_frames = []\nwhile(cap.isOpened()):\n    frame_exists, frame = cap.read()\n    if frame_exists == True:\n        all_frames.append(frame)\n    else:\n        break\n\n# When everything done, release the video capture object\ncap.release()\nprint(\"[INFO] load compelte\");\n\n# set default play state to pause\nstatus = 'pause'\nprevious_status = 'pause'\nframe_idx = 0\nwhile True:\n    try:\n        if frame_idx==total_frames-1:\n            frame_idx=0\n\n        frame = all_frames[frame_idx]\n        cv2.imshow(view_name,frame)\n\n        # event handling\n        keyPress = cv2.waitKey(1)\n        if keyPress & 0xFF == ord(' '):\n            status = 'play_pause_click'\n        elif keyPress & 0xFF == ord('a'):\n            status = 'prev_frame'\n        elif keyPress & 0xFF == ord('d'):\n            status = 'next_frame'\n        elif keyPress & 0xFF == -1:\n            status = status\n        elif keyPress & 0xFF == ord('q'):\n            status = 'exit'\n\n        if (status == 'play_pause_click' and previous_status == 'play_pause_click'):\n            status = 'pause'\n            previous_status = 'pause'\n        if (status == 'play_pause_click'):\n            status = 'play'\n            previous_status = 'play_pause_click'\n\n        if status == 'play':\n            frame_idx += 1\n            cv2.setTrackbarPos('S',view_name,frame_idx)\n            continue\n        if status == 'pause':\n            frame_idx = cv2.getTrackbarPos('S',view_name)\n        if status=='prev_frame':\n            frame_idx-=1\n            frame_idx = max(0, frame_idx)\n            <line_mask>\n            status='pause'\n        if status=='next_frame':\n            frame_idx+=1\n            cv2.setTrackbarPos('S',view_name,frame_idx)\n            status='pause'\n        if status == 'exit':\n            break\n\n    except KeyError:\n        print(\"Invalid Key was pressed\")\n \n# Closes the generated window\ncv2.destroyWindow(view_name)",
            "masked_line": "cv2.setTrackbarPos('S',view_name,frame_idx)",
            "answer": "setTrackbarPos",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_416"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-03-30",
            "description": "The code creates a bipartite graph using the NetworkX library in Python. Nodes from the first set are integers 1 to 6, while nodes from the second set are strings 'a' to 'k'. The code also adds edges between the nodes based on predefined connections. Finally, it visualizes the bipartite graph with specific node colors and labels using matplotlib.",
            "code": "import networkx as nx\n\nB = nx.Graph()\nB.add_nodes_from([1, 2, 3, 4, 5, 6], bipartite=0)\nB.add_nodes_from(['a', 'b', 'c', 'j', 'k'], bipartite=1)\nB.add_edges_from([(1, 'a'), (1, 'b'), (2, 'b'), (2, 'c'), (3, 'c'), (4, 'a'), \n                  (2, 'b'), (3, 'a'), (5, 'k'), (6, 'k'), (6, 'j')])\n\n\nrcParams['figure.figsize'] = 12, 6\nnx.draw(B, node_color='lightblue', \n        with_labels=True)",
            "masked_code": "import networkx as nx\n\n<line_mask>\nB.add_nodes_from([1, 2, 3, 4, 5, 6], bipartite=0)\nB.add_nodes_from(['a', 'b', 'c', 'j', 'k'], bipartite=1)\nB.add_edges_from([(1, 'a'), (1, 'b'), (2, 'b'), (2, 'c'), (3, 'c'), (4, 'a'), \n                  (2, 'b'), (3, 'a'), (5, 'k'), (6, 'k'), (6, 'j')])\n\n\nrcParams['figure.figsize'] = 12, 6\nnx.draw(B, node_color='lightblue', \n        with_labels=True)",
            "masked_line": "B = nx.Graph()",
            "answer": "Graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_417"
        },
        {
            "dependency": "pytest",
            "version": "==5.4.2",
            "time": "2020-05-11",
            "description": "This code defines a test function that uses the pytest library to test the square function from the squares module against expected square values for different input values.",
            "code": "import pytest\nfrom squares import *\n\n@pytest.mark.parametrize(\"test_input, expected\", [(1,1), (2,4), (3,9), (4,16)])\ndef test_squares(test_input, expected):\n  assert square(test_input) == expected",
            "masked_code": "import pytest\nfrom squares import *\n\n<line_mask>\ndef test_squares(test_input, expected):\n  assert square(test_input) == expected",
            "masked_line": "@pytest.mark.parametrize(\"test_input, expected\", [(1,1), (2,4), (3,9), (4,16)])",
            "answer": "parametrize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_418"
        },
        {
            "dependency": "click",
            "version": "==7.x",
            "time": "2020-11-07",
            "description": "This code defines a command-line interface using the Click library in Python. It defines a main function that takes two options \"--foo\" and \"--bar\" and calls another function some_func(bar) to print the value of the \"--foo\" option.",
            "code": "# test2.py\nimport click\n\n\ndef some_func(bar):\n    c = click.get_current_context()\n    foo = c.params[\"foo\"]\n    print(f\"The value of foo is: {foo}\")\n\n\n@click.command()\n@click.option(\"--foo\")\n@click.option(\"--bar\")\ndef main(foo, bar):\n    some_func(bar)\n\n\nif __name__ == \"__main__\":\n    main()",
            "masked_code": "# test2.py\nimport click\n\n\ndef some_func(bar):\n    c = click.get_current_context()\n    foo = c.params[\"foo\"]\n    print(f\"The value of foo is: {foo}\")\n\n\n@click.command()\n<line_mask>\n@click.option(\"--bar\")\ndef main(foo, bar):\n    some_func(bar)\n\n\nif __name__ == \"__main__\":\n    main()",
            "masked_line": "@click.option(\"--foo\")",
            "answer": "option",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_419"
        },
        {
            "dependency": "networkx",
            "version": "==1.9.1",
            "time": "2020-05-01",
            "description": "The code creates an undirected version of a graph G and then finds all connected subgraphs within this undirected graph.",
            "code": "UG = G.to_undirected()\nsubgraphs = list(nx.connected_component_subgraphs(UG))",
            "masked_code": "UG = G.to_undirected()\n<line_mask>",
            "masked_line": "subgraphs = list(nx.connected_component_subgraphs(UG))",
            "answer": "connected_component_subgraphs",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_420"
        },
        {
            "dependency": "botocore",
            "version": "==1.19.57",
            "time": "2021-01-21",
            "description": "This code initializes a session using the botocore library in Python.",
            "code": "from botocore.session import Session\n\nsession = Session()",
            "masked_code": "from botocore.session import Session\n\n<line_mask>",
            "masked_line": "session = Session()",
            "answer": "Session",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_421"
        },
        {
            "dependency": "discord.py",
            "version": "==1.5",
            "time": "2020-10-06",
            "description": "The code creates a Discord bot that subscribes to the privileged members intent and uses a command prefix of \"!\".",
            "code": "import discord\nfrom discord.ext import commands\n\nintents = discord.Intents.default()\nintents.members = True  # Subscribe to the privileged members intent.\nbot = commands.Bot(command_prefix='!', intents=intents)",
            "masked_code": "import discord\nfrom discord.ext import commands\n\n<line_mask>\nintents.members = True  # Subscribe to the privileged members intent.\nbot = commands.Bot(command_prefix='!', intents=intents)",
            "masked_line": "intents = discord.Intents.default()",
            "answer": "Intents",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_422"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-07-14",
            "description": "The code generates node embeddings for a graph using the node2vec algorithm with specific parameters. The embeddings are then saved in a file named \"embedding.emb\".",
            "code": "import networkx as nx\nG=nx.Graph();\nG=nx.read_edgelist(\"edges.txt\") # edges.txt contains the edge list of your graph\n\n# help to draw https://networkx.github.io/documentation/networkx-1.9/examples/drawing/labels_and_colors.html\nnx.draw(G,with_labels = True,node_color='b',node_size=500);\n\nfrom node2vec import Node2Vec\n# Generate walks\nnode2vec = Node2Vec(G, dimensions=2, walk_length=20, num_walks=10,workers=4)\n# Learn embeddings \nmodel = node2vec.fit(window=10, min_count=1)\n#model.wv.most_similar('1')\nmodel.wv.save_word2vec_format(\"embedding.emb\") #save the embedding in file embedding.emb",
            "masked_code": "import networkx as nx\n<line_mask>\nG=nx.read_edgelist(\"edges.txt\") # edges.txt contains the edge list of your graph\n\n# help to draw https://networkx.github.io/documentation/networkx-1.9/examples/drawing/labels_and_colors.html\nnx.draw(G,with_labels = True,node_color='b',node_size=500);\n\nfrom node2vec import Node2Vec\n# Generate walks\nnode2vec = Node2Vec(G, dimensions=2, walk_length=20, num_walks=10,workers=4)\n# Learn embeddings \nmodel = node2vec.fit(window=10, min_count=1)\n#model.wv.most_similar('1')\nmodel.wv.save_word2vec_format(\"embedding.emb\") #save the embedding in file embedding.emb",
            "masked_line": "G=nx.Graph();",
            "answer": "Graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_423"
        },
        {
            "dependency": "discord.py",
            "version": "==1.3.3",
            "time": "2020-06-19",
            "description": "This code creates a Discord bot that listens for messages starting with \"$WhoAmI\", then responds with the name of the message author.",
            "code": "import discord\n\nclient = discord.Client()\n\n@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        return\n    if message.content.startswith('$WhoAmI'):\n        await message.channel.send('You are {}'.format(message.author.name))\n\nclient.run('token')",
            "masked_code": "import discord\n\n<line_mask>\n\n@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        return\n    if message.content.startswith('$WhoAmI'):\n        await message.channel.send('You are {}'.format(message.author.name))\n\nclient.run('token')",
            "masked_line": "client = discord.Client()",
            "answer": "Client",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_424"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-05-22",
            "description": "This code generates a random undirected graph similar to an Erds-Rnyi graph, ensuring that the resulting graph is connected by randomly selecting edges and adding them to the graph based on a given probability.",
            "code": "def gnp_random_connected_graph(n, p):\n    \"\"\"\n    Generates a random undirected graph, similarly to an Erds-Rnyi \n    graph, but enforcing that the resulting graph is conneted\n    \"\"\"\n    edges = combinations(range(n), 2)\n    G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return nx.complete_graph(n, create_using=G)\n    for _, node_edges in groupby(edges, key=lambda x: x[0]):\n        node_edges = list(node_edges)\n        random_edge = random.choice(node_edges)\n        G.add_edge(*random_edge)\n        for e in node_edges:\n            if random.random() < p:\n                G.add_edge(*e)\n    return G",
            "masked_code": "def gnp_random_connected_graph(n, p):\n    \"\"\"\n    Generates a random undirected graph, similarly to an Erds-Rnyi \n    graph, but enforcing that the resulting graph is conneted\n    \"\"\"\n    edges = combinations(range(n), 2)\n    G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return nx.complete_graph(n, create_using=G)\n    for _, node_edges in groupby(edges, key=lambda x: x[0]):\n        node_edges = list(node_edges)\n        random_edge = random.choice(node_edges)\n        G.add_edge(*random_edge)\n        for e in node_edges:\n            if random.random() < p:\n                <line_mask>\n    return G",
            "masked_line": "G.add_edge(*e)",
            "answer": "add_edge",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_425"
        },
        {
            "dependency": "dash",
            "version": "==1.20.0",
            "time": "2020-05-15",
            "description": "This code generates a Dash web application that contains a button labeled \"Download csv\". When the button is clicked, it triggers a callback function that generates a CSV file from a DataFrame and allows the user to download it with the name \"some_name.csv\".",
            "code": "import dash\nimport dash_html_components as html\nimport dash_core_components as dcc\nimport numpy as np\nimport pandas as pd\nfrom dash.dependencies import Output, Input\n\n# Generate some example data.\ndata = np.column_stack((np.arange(10), np.arange(10) * 2))\ndf = pd.DataFrame(columns=[\"a column\", \"another column\"], data=data)\n# Create app.\napp = dash.Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([html.Button(\"Download csv\", id=\"btn\"), dcc.Download(id=\"download\")])\n\n@app.callback(Output(\"download\", \"data\"), [Input(\"btn\", \"n_clicks\")])\ndef generate_csv(n_nlicks):\n    return dcc.send_data_frame(df.to_csv, filename=\"some_name.csv\")\n\nif __name__ == '__main__':\n    app.run_server()",
            "masked_code": "import dash\nimport dash_html_components as html\nimport dash_core_components as dcc\nimport numpy as np\nimport pandas as pd\n<line_mask>\n\n# Generate some example data.\ndata = np.column_stack((np.arange(10), np.arange(10) * 2))\ndf = pd.DataFrame(columns=[\"a column\", \"another column\"], data=data)\n# Create app.\napp = dash.Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([html.Button(\"Download csv\", id=\"btn\"), dcc.Download(id=\"download\")])\n\n@app.callback(Output(\"download\", \"data\"), [Input(\"btn\", \"n_clicks\")])\ndef generate_csv(n_nlicks):\n    return dcc.send_data_frame(df.to_csv, filename=\"some_name.csv\")\n\nif __name__ == '__main__':\n    app.run_server()",
            "masked_line": "from dash.dependencies import Output, Input",
            "answer": "Input",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_426"
        },
        {
            "dependency": "discord.py",
            "version": ">1.5.0",
            "time": "2020-10-12",
            "description": "The code sets up a Discord client with the ability to receive notifications when a new member joins a server and sends a welcome message to the new member.",
            "code": "import discord\n\nintents = discord.Intents.default()\nintents.members = True\n\nclient = discord.Client(intents=intents)\n\n@client.event\nasync def on_member_join(member):\n    await member.send(\"Welcome!\")",
            "masked_code": "import discord\n\nintents = discord.Intents.default()\nintents.members = True\n\n<line_mask>\n\n@client.event\nasync def on_member_join(member):\n    await member.send(\"Welcome!\")",
            "masked_line": "client = discord.Client(intents=intents)",
            "answer": "Client",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_427"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-04-13",
            "description": "The code creates a graph from a list of edges and then creates a dictionary where each node in the graph is a key and the value is a list of its neighboring nodes.",
            "code": "import networkx as nx\n\nG = nx.from_edgelist([s.split('-') for s in Edges])\n\ngraph = dict()\nfor node in G.nodes():\n    graph[node] = list(nx.neighbors(G, node))",
            "masked_code": "import networkx as nx\n\nG = nx.from_edgelist([s.split('-') for s in Edges])\n\ngraph = dict()\nfor node in G.nodes():\n    <line_mask>",
            "masked_line": "graph[node] = list(nx.neighbors(G, node))",
            "answer": "neighbors",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_428"
        },
        {
            "dependency": "numpy",
            "version": ">=1.10",
            "time": "2020-06-25",
            "description": "This code performs linear interpolation to estimate the values of y corresponding to the given x values using the provided x and y data points.",
            "code": "import numpy as np\nfrom numba import njit\n\n@njit\ndef interp_nb(x_vals, x, y):\n    return np.interp(xvals, x, y)\n\nx = np.linspace(0, 2*np.pi, 10)\ny = np.sin(x)\nxvals = np.linspace(0, 2*np.pi, 50)\n\ny_interp = interp_nb(xvals, x, y)\n\nplt.figure(figsize=(10,6))\nplt.plot(x, y, 'o')\nplt.plot(xvals, y_interp, '-x')",
            "masked_code": "import numpy as np\nfrom numba import njit\n\n@njit\ndef interp_nb(x_vals, x, y):\n    return np.interp(xvals, x, y)\n\nx = np.linspace(0, 2*np.pi, 10)\ny = np.sin(x)\n<line_mask>\n\ny_interp = interp_nb(xvals, x, y)\n\nplt.figure(figsize=(10,6))\nplt.plot(x, y, 'o')\nplt.plot(xvals, y_interp, '-x')",
            "masked_line": "xvals = np.linspace(0, 2*np.pi, 50)",
            "answer": "linspace",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_429"
        },
        {
            "dependency": "scipy",
            "version": "==1.7.1",
            "time": "2021-09-27",
            "description": "The code generates a dendrogram using hierarchical clustering on the given data points and then creates a scatter plot of the data points with colors assigned based on clustering from the dendrogram. The colors are manually assigned by analyzing the dendrogram as the code failed to retrieve colors from the dendrogram directly.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.cluster.hierarchy import linkage, dendrogram\n\n# DATA EXAMPLE\nx = np.array([[ 5, 3],\n              [10,15],\n              [15,12],\n              [24,10],\n              [30,30],\n              [85,70],\n              [71,80]])\n\n# DENDROGRAM\nplt.figure()\nplt.subplot(121)\nz = linkage(x, 'single')\nd = dendrogram(z)\n\n# COLORED PLOT\n# This is what I would like to achieve. Colors are assigned manually by looking\n# at the dendrogram, because I failed to get it from d['color_list'] (it refers \n# to links, not observations)\nplt.subplot(122)\n\n#NEW CODE\nplt.scatter(x[d['leaves'],0],x[d['leaves'],1], color=d['leaves_color_list'])",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\n<line_mask>\n\n# DATA EXAMPLE\nx = np.array([[ 5, 3],\n              [10,15],\n              [15,12],\n              [24,10],\n              [30,30],\n              [85,70],\n              [71,80]])\n\n# DENDROGRAM\nplt.figure()\nplt.subplot(121)\nz = linkage(x, 'single')\nd = dendrogram(z)\n\n# COLORED PLOT\n# This is what I would like to achieve. Colors are assigned manually by looking\n# at the dendrogram, because I failed to get it from d['color_list'] (it refers \n# to links, not observations)\nplt.subplot(122)\n\n#NEW CODE\nplt.scatter(x[d['leaves'],0],x[d['leaves'],1], color=d['leaves_color_list'])",
            "masked_line": "from scipy.cluster.hierarchy import linkage, dendrogram",
            "answer": "dendrogram",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_430"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-05-20",
            "description": "The code contracts the edge between the node 'Group B' and its predecessor in the graph 'G', and then visualizes the contracted graph with nodes in light green color, size 1500, labeled, and with arrows.",
            "code": "parent = next(G.predecessors('Group B'))\nG = nx.contracted_edge(parent, 'Group B')\n\nplt.figure(figsize=(6,6))\nnx.draw(G, pos=pos,\n        node_color='lightgreen', \n        node_size=1500,\n        with_labels=True, \n        arrows=True)",
            "masked_code": "parent = next(G.predecessors('Group B'))\nG = nx.contracted_edge(parent, 'Group B')\n\nplt.figure(figsize=(6,6))\n<line_mask>\n        node_color='lightgreen', \n        node_size=1500,\n        with_labels=True, \n        arrows=True)",
            "masked_line": "nx.draw(G, pos=pos,",
            "answer": "draw",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_431"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-07-27",
            "description": "This code generates a random graph with 100 nodes and a probability of connection between nodes of 0.05, then it visualizes the graph using a spring layout with node labels, light blue node color, and node size of 400.",
            "code": "from matplotlib import pyplot as plt\n\nG = nx.fast_gnp_random_graph(100, .05)\nplt.figure(figsize=(10,6))\npos = nx.spring_layout(G, k=0.8)\nnx.draw(G, pos , with_labels = True, width=0.4, \n        node_color='lightblue', node_size=400)",
            "masked_code": "from matplotlib import pyplot as plt\n\nG = nx.fast_gnp_random_graph(100, .05)\nplt.figure(figsize=(10,6))\npos = nx.spring_layout(G, k=0.8)\n<line_mask>\n        node_color='lightblue', node_size=400)",
            "masked_line": "nx.draw(G, pos , with_labels = True, width=0.4,",
            "answer": "draw",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_432"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2020-05-20",
            "description": "The code assigns a 3x3 numpy array 'a' with values from 1 to 9, and creates a 3x3x3 numpy array 'b' filled with the value 255. The values of the first channel of 'b' are then replaced by the values of 'a'.",
            "code": "import numpy as np\na = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nb = np.full((3, 3, 3), 255)\nb[:, :, 0] = a",
            "masked_code": "import numpy as np\na = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n<line_mask>\nb[:, :, 0] = a",
            "masked_line": "b = np.full((3, 3, 3), 255)",
            "answer": "full",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_433"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-05-19",
            "description": "The code creates a 9x9 block diagonal matrix where each block is a 3x3 matrix consisting of repeated values from the original 3x3 matrix x.",
            "code": "\"\"\"\n>>> print(answer)\n[[0 1 2 0 0 0 0 0 0]\n [0 1 2 0 0 0 0 0 0]\n [0 1 2 0 0 0 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 0 0 0 6 7 8]\n [0 0 0 0 0 0 6 7 8]\n [0 0 0 0 0 0 6 7 8]]\n\"\"\"\nfrom scipy.linalg import block_diag\nimport numpy as np\n\nx = np.arange(9).reshape(3, 3)\nanswer = block_diag(*np.array_split(x.repeat(3, axis=0), 3))",
            "masked_code": "\"\"\"\n>>> print(answer)\n[[0 1 2 0 0 0 0 0 0]\n [0 1 2 0 0 0 0 0 0]\n [0 1 2 0 0 0 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 0 0 0 6 7 8]\n [0 0 0 0 0 0 6 7 8]\n [0 0 0 0 0 0 6 7 8]]\n\"\"\"\nfrom scipy.linalg import block_diag\nimport numpy as np\n\nx = np.arange(9).reshape(3, 3)\n<line_mask>",
            "masked_line": "answer = block_diag(*np.array_split(x.repeat(3, axis=0), 3))",
            "answer": "block_diag",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_434"
        },
        {
            "dependency": "stumpy",
            "version": "==1.8.0",
            "time": "2020-12-10",
            "description": "The code utilizes the stumpy library to perform matrix profile analysis on a time series data set T with a window size of 50 and without normalizing the data.",
            "code": "import stumpy\n\nmp = stumpy.stump(T, m=50, normalize=False)  # Gives the same output as above",
            "masked_code": "import stumpy\n\n<line_mask>",
            "masked_line": "mp = stumpy.stump(T, m=50, normalize=False)  # Gives the same output as above",
            "answer": "stump",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_435"
        },
        {
            "dependency": "pandas",
            "version": ">=1.0",
            "time": "2020-12-23",
            "description": "The code creates a DataFrame with columns of different data types (integer, float, boolean, and object) containing various values including missing values, and writes this DataFrame to a CSV file named 'MixedTypes.csv'. It then reads the CSV file back into a new DataFrame 'df', replicating the behavior of reading and writing CSV files with mixed data types and missing values.",
            "code": "import pandas as pd\nimport numpy as np\n\ndftemp = pd.DataFrame({'dt_col': ['1/1/2020',np.nan,'1/3/2020','1/4/2020'], 'int_col':[4,np.nan,3,1],\n                      'float_col':[0.0,1.0,np.nan,4.5],'bool_col':[True, False, False, True],'text_col':['a','b',None,'d']})\n\n#Write to CSV (to be read back in to fully simulate CSV behavior with missing values etc.)\ndftemp.to_csv('MixedTypes.csv', index=False)\n\nlst_cols = ['int_col','float_col','bool_col','text_col']\nlst_dtypes = ['Int16','float','bool','object']\ndict_types = dict(zip(lst_cols,lst_dtypes))\n\n#Unoptimized DataFrame    \ndf = pd.read_csv('MixedTypes.csv')\ndf",
            "masked_code": "import pandas as pd\nimport numpy as np\n\ndftemp = pd.DataFrame({'dt_col': ['1/1/2020',np.nan,'1/3/2020','1/4/2020'], 'int_col':[4,np.nan,3,1],\n                      'float_col':[0.0,1.0,np.nan,4.5],'bool_col':[True, False, False, True],'text_col':['a','b',None,'d']})\n\n#Write to CSV (to be read back in to fully simulate CSV behavior with missing values etc.)\ndftemp.to_csv('MixedTypes.csv', index=False)\n\nlst_cols = ['int_col','float_col','bool_col','text_col']\nlst_dtypes = ['Int16','float','bool','object']\ndict_types = dict(zip(lst_cols,lst_dtypes))\n\n#Unoptimized DataFrame    \n<line_mask>\ndf",
            "masked_line": "df = pd.read_csv('MixedTypes.csv')",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_436"
        },
        {
            "dependency": "pyreadstat",
            "version": "==1.0.3",
            "time": "2020-11-01",
            "description": "The code reads a .sav file using the pyreadstat library and returns the data and metadata from the file.",
            "code": "import pyreadstat\n\nfpath = \"path/to/file.sav\" \ndf, meta = pyreadstat.read_file_multiprocessing(pyreadstat.read_sav, fpath)",
            "masked_code": "import pyreadstat\n\nfpath = \"path/to/file.sav\" \n<line_mask>",
            "masked_line": "df, meta = pyreadstat.read_file_multiprocessing(pyreadstat.read_sav, fpath)",
            "answer": "read_file_multiprocessing",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_437"
        },
        {
            "dependency": "datatable",
            "version": ">=0.10.0",
            "time": "2020-08-14",
            "description": "The code creates a datatable frame with a column 'a' containing values 'a', 'b', 'c', empty string, 'd', and 'e', and then updates the values in column 'a' to None where the value is an empty string.",
            "code": "import datatable as dt\nmydt = dt.Frame(a=['a','b','c','','d','e'])\nmydt[dt.f.a == '', dt.update(a = None)]",
            "masked_code": "import datatable as dt\n<line_mask>\nmydt[dt.f.a == '', dt.update(a = None)]",
            "masked_line": "mydt = dt.Frame(a=['a','b','c','','d','e'])",
            "answer": "Frame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_438"
        },
        {
            "dependency": "panel",
            "version": "==0.13.1",
            "time": "2022-09-29",
            "description": "This code creates a dropdown menu of unique provider names from a DataFrame and allows users to query the DataFrame based on the selected provider.",
            "code": "import pandas as pd\nimport panel as pn\npn.extension()\n\n# Dataframe\ndf = pd.DataFrame({\n    'CcyPair':['EUR/USD', 'AUD/USD' ,'USD/JPY'], \n    'Requester':['Client1', 'Client2' ,'Client3'],\n    'Provider':['LP1', 'LP2' ,'LP3']\n})\n\n# Dropdown\nproviders = list(df.Provider.unique())\nselect_widget = pn.widgets.Select(options=providers)\n\n# Query dataframe based on value in Provider dropdown\n@pn.depends(select_widget)\ndef query(x):\n    filtered_df = pn.widgets.DataFrame(df[df.Provider==x])\n    return filtered_df\n        \n# Display Output\npn.Column(select_widget, query)",
            "masked_code": "import pandas as pd\nimport panel as pn\npn.extension()\n\n# Dataframe\ndf = pd.DataFrame({\n    'CcyPair':['EUR/USD', 'AUD/USD' ,'USD/JPY'], \n    'Requester':['Client1', 'Client2' ,'Client3'],\n    'Provider':['LP1', 'LP2' ,'LP3']\n})\n\n# Dropdown\nproviders = list(df.Provider.unique())\nselect_widget = pn.widgets.Select(options=providers)\n\n# Query dataframe based on value in Provider dropdown\n<line_mask>\ndef query(x):\n    filtered_df = pn.widgets.DataFrame(df[df.Provider==x])\n    return filtered_df\n        \n# Display Output\npn.Column(select_widget, query)",
            "masked_line": "@pn.depends(select_widget)",
            "answer": "depends",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_439"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-05-17",
            "description": "The code formats the columns of a pandas DataFrame based on specific conditions and a custom formatter function. The formatted output is then written to a LaTeX file named \"test_table.tex\" with specific column names and formatting conditions.",
            "code": "from functools import partial\n\nimport pandas as pd\nimport numpy as np\n\n\ndef bold_formatter(x, value, num_decimals=2):\n    \"\"\"Format a number in bold when (almost) identical to a given value.\n    \n    Args:\n        x: Input number.\n        \n        value: Value to compare x with.\n        \n        num_decimals: Number of decimals to use for output format.\n\n    Returns:\n        String converted output.\n\n    \"\"\"\n    # Consider values equal, when rounded results are equal\n    # otherwise, it may look surprising in the table where they seem identical\n    if round(x, num_decimals) == round(value, num_decimals):\n        return f\"{{\\\\bfseries\\\\num{{{x:.{num_decimals}f}}}}}\"\n    else:\n        return f\"\\\\num{{{x:.{num_decimals}f}}}\"\n\n\ndf = pd.DataFrame(np.array([[1.123456, 2.123456, 3.123456, 4.123456],\n                            [11.123456, 22.123456, 33.123456, 44.123456],\n                            [111.123456, 222.123456, 333.123456, 444.123456],]),\n                   columns=['a', 'b', 'c', 'd'])\n\ncol_names = ['a in \\\\si{\\\\meter}',\n             'b in \\\\si{\\\\volt}',\n             'c in \\\\si{\\\\seconds}',\n             'd']\n\n# Colums to format with maximum condition and 2 floating decimals\nmax_columns_2f = ['a']\n\n# Colums to format with minimum condition and 2 floating decimals\nmin_columns_2f = ['b', 'c']\n\n# Colums to format with minimum condition and 4 floating decimals\nmin_columns_4f= ['d']\n\nfmts_max_2f = {column: partial(bold_formatter, value=df[column].max(), num_decimals=2) for column in max_columns_2f}\nfmts_min_2f = {column: partial(bold_formatter, value=df[column].min(), num_decimals=2) for column in min_columns_2f}\nfmts_min_4f = {column: partial(bold_formatter, value=df[column].min(), num_decimals=4) for column in min_columns_4f}\n\nfmts = dict(**fmts_max_2f, **fmts_min_2f, **fmts_min_4f)\n\nwith open(\"test_table.tex\", \"w\") as fh:\n    df.to_latex(buf=fh,\n                index=False,\n                header=col_names,\n                formatters=fmts,\n                escape=False)",
            "masked_code": "from functools import partial\n\nimport pandas as pd\nimport numpy as np\n\n\ndef bold_formatter(x, value, num_decimals=2):\n    \"\"\"Format a number in bold when (almost) identical to a given value.\n    \n    Args:\n        x: Input number.\n        \n        value: Value to compare x with.\n        \n        num_decimals: Number of decimals to use for output format.\n\n    Returns:\n        String converted output.\n\n    \"\"\"\n    # Consider values equal, when rounded results are equal\n    # otherwise, it may look surprising in the table where they seem identical\n    if round(x, num_decimals) == round(value, num_decimals):\n        return f\"{{\\\\bfseries\\\\num{{{x:.{num_decimals}f}}}}}\"\n    else:\n        return f\"\\\\num{{{x:.{num_decimals}f}}}\"\n\n\n<line_mask>\n                            [11.123456, 22.123456, 33.123456, 44.123456],\n                            [111.123456, 222.123456, 333.123456, 444.123456],]),\n                   columns=['a', 'b', 'c', 'd'])\n\ncol_names = ['a in \\\\si{\\\\meter}',\n             'b in \\\\si{\\\\volt}',\n             'c in \\\\si{\\\\seconds}',\n             'd']\n\n# Colums to format with maximum condition and 2 floating decimals\nmax_columns_2f = ['a']\n\n# Colums to format with minimum condition and 2 floating decimals\nmin_columns_2f = ['b', 'c']\n\n# Colums to format with minimum condition and 4 floating decimals\nmin_columns_4f= ['d']\n\nfmts_max_2f = {column: partial(bold_formatter, value=df[column].max(), num_decimals=2) for column in max_columns_2f}\nfmts_min_2f = {column: partial(bold_formatter, value=df[column].min(), num_decimals=2) for column in min_columns_2f}\nfmts_min_4f = {column: partial(bold_formatter, value=df[column].min(), num_decimals=4) for column in min_columns_4f}\n\nfmts = dict(**fmts_max_2f, **fmts_min_2f, **fmts_min_4f)\n\nwith open(\"test_table.tex\", \"w\") as fh:\n    df.to_latex(buf=fh,\n                index=False,\n                header=col_names,\n                formatters=fmts,\n                escape=False)",
            "masked_line": "df = pd.DataFrame(np.array([[1.123456, 2.123456, 3.123456, 4.123456],",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_440"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.1.2",
            "time": "2021-05-14",
            "description": "The code creates a figure with two subplots, each containing a plot of a line. It then adds a fancy arrow patch connecting a point in the first subplot to a point in the second subplot, and displays the figure.",
            "code": "from matplotlib import patches, pyplot as plt\n\nfig = plt.figure()\n\n# First subplot\nax1 = fig.add_subplot(121)\nplt.plot([0, 1], [0, 1])\n\n# Second subplot\nax2 = fig.add_subplot(122)\nplt.plot([0, 1], [0, 1])\n\n# Add line from one subplot to the other\nxyA = [0.5, 1.0]\nax1.plot(*xyA, \"o\")\nxyB = [0.75, 0.25]\nax2.plot(*xyB, \"o\")\ntransFigure = fig.transFigure.inverted()\ncoord1 = transFigure.transform(ax1.transData.transform(xyA))\ncoord2 = transFigure.transform(ax2.transData.transform(xyB))\narrow = patches.FancyArrowPatch(\n    coord1,  # posA\n    coord2,  # posB\n    shrinkA=0,  # so tail is exactly on posA (default shrink is 2)\n    shrinkB=0,  # so head is exactly on posB (default shrink is 2)\n    transform=fig.transFigure,\n    color=\"black\",\n    arrowstyle=\"-|>\",  # \"normal\" arrow\n    mutation_scale=30,  # controls arrow head size\n    linewidth=3,\n)\nfig.patches.append(arrow)\n\n# Show figure\nplt.show()",
            "masked_code": "from matplotlib import patches, pyplot as plt\n\nfig = plt.figure()\n\n# First subplot\nax1 = fig.add_subplot(121)\nplt.plot([0, 1], [0, 1])\n\n# Second subplot\nax2 = fig.add_subplot(122)\nplt.plot([0, 1], [0, 1])\n\n# Add line from one subplot to the other\nxyA = [0.5, 1.0]\nax1.plot(*xyA, \"o\")\nxyB = [0.75, 0.25]\nax2.plot(*xyB, \"o\")\ntransFigure = fig.transFigure.inverted()\ncoord1 = transFigure.transform(ax1.transData.transform(xyA))\ncoord2 = transFigure.transform(ax2.transData.transform(xyB))\narrow = patches.FancyArrowPatch(\n    coord1,  # posA\n    coord2,  # posB\n    shrinkA=0,  # so tail is exactly on posA (default shrink is 2)\n    shrinkB=0,  # so head is exactly on posB (default shrink is 2)\n    transform=fig.transFigure,\n    color=\"black\",\n    arrowstyle=\"-|>\",  # \"normal\" arrow\n    mutation_scale=30,  # controls arrow head size\n    linewidth=3,\n)\n<line_mask>\n\n# Show figure\nplt.show()",
            "masked_line": "fig.patches.append(arrow)",
            "answer": "append",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_441"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-06-19",
            "description": "The code defines a neural network model using TensorFlow with multiple dense layers. It then defines a custom loss function based on the weights of certain layers in the model and adds this custom loss to the model. Finally, it prints the summary of the model and the added losses.",
            "code": "import tensorflow as tf\n\nprint('TensorFlow:', tf.__version__)\n\ninp = tf.keras.Input(shape=[10])\nx = tf.keras.layers.Dense(16)(inp)\nx = tf.keras.layers.Dense(32)(x)\nx = tf.keras.layers.Dense(4)(x)\nout = tf.keras.layers.Dense(1)(x)\n\nmodel = tf.keras.Model(inputs=[inp], outputs=[out])\nmodel.summary()\n\n\ndef custom_loss(weight_a, weight_b):\n    def _custom_loss():\n        # This can include any arbitrary logic\n        loss = tf.norm(weight_a) + tf.norm(weight_b)\n        return loss\n    return _custom_loss\n\nweight_a = model.layers[2].kernel\nweight_b = model.layers[3].kernel\n\nmodel.add_loss(custom_loss(weight_a, weight_b))\n\n\nprint('\\nlosses:', model.losses)",
            "masked_code": "import tensorflow as tf\n\nprint('TensorFlow:', tf.__version__)\n\ninp = tf.keras.Input(shape=[10])\nx = tf.keras.layers.Dense(16)(inp)\nx = tf.keras.layers.Dense(32)(x)\nx = tf.keras.layers.Dense(4)(x)\nout = tf.keras.layers.Dense(1)(x)\n\nmodel = tf.keras.Model(inputs=[inp], outputs=[out])\nmodel.summary()\n\n\ndef custom_loss(weight_a, weight_b):\n    def _custom_loss():\n        # This can include any arbitrary logic\n        loss = tf.norm(weight_a) + tf.norm(weight_b)\n        return loss\n    return _custom_loss\n\nweight_a = model.layers[2].kernel\nweight_b = model.layers[3].kernel\n\n<line_mask>\n\n\nprint('\\nlosses:', model.losses)",
            "masked_line": "model.add_loss(custom_loss(weight_a, weight_b))",
            "answer": "add_loss",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_442"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-05-11",
            "description": "The code creates two directed graphs (g1 and g2) from pandas dataframes (df1 and df2). The nodes in each graph are labeled with descriptions, priorities, and graph names based on the data in the dataframes.",
            "code": "df1 = df1.drop('To',1).join(df1.To.str.replace(' ','').str.split(',').explode())\ndf2 = df2.drop('To',1).join(df2.To.str.replace(' ','').str.split(',').explode())\n\ng1 = nx.from_pandas_edgelist(df1.iloc[:-1,[0,3]].astype(int), \n                             source='From', target='To', create_using=nx.DiGraph)\ng2 = nx.from_pandas_edgelist(df2.iloc[:-1,[0,3]].astype(int), \n                             source='From', target='To', create_using=nx.DiGraph)\n\ndf1_node_ix = df1.assign(graph='graph1').set_index('From').rename_axis('nodes')\nnx.set_node_attributes(g1, values=df1_node_ix.description.to_dict(), \n                       name='description')\nnx.set_node_attributes(g1, values=df1_node_ix.priority.to_dict(), \n                       name='priority')\nnx.set_node_attributes(g1, values=df1_node_ix.graph.to_dict(), \n                       name='graph')\n\ndf2_node_ix = df2.assign(graph='graph2').set_index('From').rename_axis('nodes')\nnx.set_node_attributes(g2, values=df2_node_ix.description.to_dict(), \n                       name='description')\nnx.set_node_attributes(g2, values=df2_node_ix.priority.to_dict(), \n                       name='priority')\nnx.set_node_attributes(g2, values=df2_node_ix.graph.to_dict(), \n                       name='graph')",
            "masked_code": "df1 = df1.drop('To',1).join(df1.To.str.replace(' ','').str.split(',').explode())\ndf2 = df2.drop('To',1).join(df2.To.str.replace(' ','').str.split(',').explode())\n\ng1 = nx.from_pandas_edgelist(df1.iloc[:-1,[0,3]].astype(int), \n                             source='From', target='To', create_using=nx.DiGraph)\ng2 = nx.from_pandas_edgelist(df2.iloc[:-1,[0,3]].astype(int), \n                             source='From', target='To', create_using=nx.DiGraph)\n\ndf1_node_ix = df1.assign(graph='graph1').set_index('From').rename_axis('nodes')\nnx.set_node_attributes(g1, values=df1_node_ix.description.to_dict(), \n                       name='description')\nnx.set_node_attributes(g1, values=df1_node_ix.priority.to_dict(), \n                       name='priority')\nnx.set_node_attributes(g1, values=df1_node_ix.graph.to_dict(), \n                       name='graph')\n\ndf2_node_ix = df2.assign(graph='graph2').set_index('From').rename_axis('nodes')\n<line_mask>\n                       name='description')\nnx.set_node_attributes(g2, values=df2_node_ix.priority.to_dict(), \n                       name='priority')\nnx.set_node_attributes(g2, values=df2_node_ix.graph.to_dict(), \n                       name='graph')",
            "masked_line": "nx.set_node_attributes(g2, values=df2_node_ix.description.to_dict(),",
            "answer": "set_node_attributes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_443"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.5.1",
            "time": "2021-02-02",
            "description": "The code reads an image file, converts it to grayscale, uses a GPU to detect objects in the image using a cascade classifier, and prints the first detected object's information if any object is detected.",
            "code": "import cv2\n\nimg = cv2.imread('./img_sample.jpg')\ncascade = cv2.cuda_CascadeClassifier.create('./cascade_file.xml')\ngray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\ncuFrame = cv2.cuda_GpuMat(gray_img)\nresult = cascade.detectMultiScale(cuFrame).download() # download() gets the result as UMat\n\nif result is not None:\n    print(result[0])",
            "masked_code": "import cv2\n\nimg = cv2.imread('./img_sample.jpg')\ncascade = cv2.cuda_CascadeClassifier.create('./cascade_file.xml')\n<line_mask>\ncuFrame = cv2.cuda_GpuMat(gray_img)\nresult = cascade.detectMultiScale(cuFrame).download() # download() gets the result as UMat\n\nif result is not None:\n    print(result[0])",
            "masked_line": "gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)",
            "answer": "cvtColor",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_444"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-04-05",
            "description": "The code creates a sparse matrix from a given dense matrix 'a' and stores it in 'a_sp', using Compressed Sparse Row (CSR) format. It then creates a dense array 'b'.",
            "code": "from scipy.sparse import csr_matrix\n\na = np.array([[0, 0, 4, 0],\n              [0, 5, 0, 3],\n              [1, 2, 0, 0]])\n\na_sp = csr_matrix(a, dtype=np.int8)\nb = np.array([1,2,3])",
            "masked_code": "from scipy.sparse import csr_matrix\n\na = np.array([[0, 0, 4, 0],\n              [0, 5, 0, 3],\n              [1, 2, 0, 0]])\n\n<line_mask>\nb = np.array([1,2,3])",
            "masked_line": "a_sp = csr_matrix(a, dtype=np.int8)",
            "answer": "csr_matrix",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_445"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2020-03-07",
            "description": "The code merges two dataframes by exploding a column called 'websites', and then groups the data by 'id' while aggregating unique website values for each id.",
            "code": "a = df_a.explode('websites') #requires pandas version 0.25+\nb = df_b.explode('websites') #requires pandas version 0.25+\nout = pd.concat((a,b)).groupby('id')['websites'].apply(pd.unique).reset_index()\n#or out = pd.concat((a,b)).groupby('id')['websites'].agg(set).reset_index()\nprint(out)",
            "masked_code": "a = df_a.explode('websites') #requires pandas version 0.25+\nb = df_b.explode('websites') #requires pandas version 0.25+\n<line_mask>\n#or out = pd.concat((a,b)).groupby('id')['websites'].agg(set).reset_index()\nprint(out)",
            "masked_line": "out = pd.concat((a,b)).groupby('id')['websites'].apply(pd.unique).reset_index()",
            "answer": "apply",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_446"
        },
        {
            "dependency": "scipy",
            "version": "==1.4.1",
            "time": "2020-03-06",
            "description": "This code calculates the numerical solution of a first-order differential equation using the scipy.integrate.solve_ivp function. The differential equation being solved is y' = -a*y, where a is a constant. The initial condition is y(0) = 5, and the solution is computed for the time interval [0, 10]. The printed output is the solution of the differential equation at different time points.",
            "code": "from scipy.integrate import solve_ivp\n\ndef ydot(t,y,a): return -a*y\n\nsol=solve_ivp(ydot,[0,10],[5],args=(8,))\nprint(sol.y)",
            "masked_code": "from scipy.integrate import solve_ivp\n\ndef ydot(t,y,a): return -a*y\n\n<line_mask>\nprint(sol.y)",
            "masked_line": "sol=solve_ivp(ydot,[0,10],[5],args=(8,))",
            "answer": "solve_ivp",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_447"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-07-01",
            "description": "This code reads data from a text file, creates a grid graph based on the data, removes nodes from the graph where the corresponding value in the data is not equal to 0, rotates the coordinates of the nodes, and visualizes the graph using matplotlib with specific node colors, sizes, and widths.",
            "code": "from matplotlib import pyplot as plt\nimport numpy as np\nimport networkx as nx\n\n# lines to 2d array\nwith open('myfile.txt') as f:\n    a = np.array([list(map(int,i.split())) for i in f.readlines()])\n\n# define grid graph according to the shape of a\nG = nx.grid_2d_graph(*a.shape)\n\n# remove those nodes where the corresponding value is != 0\nfor val,node in zip(a.ravel(), sorted(G.nodes())):\n    if val!=0:\n        G.remove_node(node)\n\nplt.figure(figsize=(9,9))\n# coordinate rotation\npos = {(x,y):(y,-x) for x,y in G.nodes()}\nnx.draw(G, pos=pos, \n        node_color='grey',\n        width = 4,\n        node_size=400)",
            "masked_code": "from matplotlib import pyplot as plt\nimport numpy as np\nimport networkx as nx\n\n# lines to 2d array\nwith open('myfile.txt') as f:\n    a = np.array([list(map(int,i.split())) for i in f.readlines()])\n\n# define grid graph according to the shape of a\nG = nx.grid_2d_graph(*a.shape)\n\n# remove those nodes where the corresponding value is != 0\nfor val,node in zip(a.ravel(), sorted(G.nodes())):\n    if val!=0:\n        G.remove_node(node)\n\nplt.figure(figsize=(9,9))\n# coordinate rotation\n<line_mask>\nnx.draw(G, pos=pos, \n        node_color='grey',\n        width = 4,\n        node_size=400)",
            "masked_line": "pos = {(x,y):(y,-x) for x,y in G.nodes()}",
            "answer": "nodes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_448"
        },
        {
            "dependency": "gensim",
            "version": "==4.0",
            "time": "2020-12-21",
            "description": "The code loads a pre-trained word embeddings model from a binary file and then saves it in a different file format.",
            "code": "from gensim.models import KeyedVectors\nkv_model = KeyedVectors.load_word2vec_format('GoogleNews-vectors-negative300.bin', binary=True) \nkv_model.save('GoogleNews-vectors-negative300.kv')",
            "masked_code": "from gensim.models import KeyedVectors\n<line_mask>\nkv_model.save('GoogleNews-vectors-negative300.kv')",
            "masked_line": "kv_model = KeyedVectors.load_word2vec_format('GoogleNews-vectors-negative300.bin', binary=True)",
            "answer": "load_word2vec_format",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_449"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1",
            "time": "2020-01-30",
            "description": "This code defines a 2x2 constant tensor \"x\" using TensorFlow, and then prints the tensor using the Keras backend.",
            "code": "import tensorflow as tf\ntf.__version__  #2.1.0\n\nx = tf.constant([[1.0, 2.0], [3.0, 4.0]])\ntf.keras.backend.print_tensor(x)",
            "masked_code": "import tensorflow as tf\ntf.__version__  #2.1.0\n\n<line_mask>\ntf.keras.backend.print_tensor(x)",
            "masked_line": "x = tf.constant([[1.0, 2.0], [3.0, 4.0]])",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_450"
        },
        {
            "dependency": "scipy",
            "version": "==1.4.1",
            "time": "2020-06-08",
            "description": "Calculate the pairwise euclidean distance between all vectors in the input series and convert the result into a square matrix.",
            "code": "from scipy.spatial.distance import pdist, squareform\nsquareform(pdist(series))",
            "masked_code": "<line_mask>\nsquareform(pdist(series))",
            "masked_line": "from scipy.spatial.distance import pdist, squareform",
            "answer": "squareform",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_451"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-09-05",
            "description": "Assigns tooltips to the DataFrame \"foo\" based on the values in the DataFrame \"tooltips_df\".",
            "code": "import pandas as pd\n\nfoo = pd.DataFrame({\n    'temp': ['message1', 'message2', 'message3'],\n    'var2': [1, 2, 3],\n    'col3': [4, 5, 6]\n})\n\n# Setup a DataFrame with corresponding hover values\ntooltips_df = pd.DataFrame({\n    'temp': ['i am message 1', 'i am foo', 'i am lala'],\n    'var2': ' another random message',\n    'col3': 'more random messages'\n})\n\n# Assign tooltips\nfoo.style.set_tooltips(tooltips_df)",
            "masked_code": "import pandas as pd\n\nfoo = pd.DataFrame({\n    'temp': ['message1', 'message2', 'message3'],\n    'var2': [1, 2, 3],\n    'col3': [4, 5, 6]\n})\n\n# Setup a DataFrame with corresponding hover values\ntooltips_df = pd.DataFrame({\n    'temp': ['i am message 1', 'i am foo', 'i am lala'],\n    'var2': ' another random message',\n    'col3': 'more random messages'\n})\n\n# Assign tooltips\n<line_mask>",
            "masked_line": "foo.style.set_tooltips(tooltips_df)",
            "answer": "set_tooltips",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_452"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2020-05-05",
            "description": "The code creates an Embedding layer in a Keras model with input shape (3,) and vocabulary size of 1 mapping to a vector size of 2, then compiles the model using rmsprop optimizer and mean squared error loss function. Finally, it predicts the output based on the input array and prints the output array and its shape.",
            "code": "from keras.models import Model\nfrom keras.layers import Embedding, Input\nimport numpy as np\n\nip = Input(shape = (3,))\nemb = Embedding(1, 2, trainable=True, mask_zero=True)(ip)\n\nmodel = Model(ip, emb)\ninput_array = np.array([[5, 3, 1], [1, 2, 3]])\n\nmodel.compile(\"rmsprop\", \"mse\")\n\noutput_array = model.predict(input_array)\n\nprint(output_array)\n\nprint(output_array.shape)\n\nmodel.summary()",
            "masked_code": "from keras.models import Model\nfrom keras.layers import Embedding, Input\nimport numpy as np\n\n<line_mask>\nemb = Embedding(1, 2, trainable=True, mask_zero=True)(ip)\n\nmodel = Model(ip, emb)\ninput_array = np.array([[5, 3, 1], [1, 2, 3]])\n\nmodel.compile(\"rmsprop\", \"mse\")\n\noutput_array = model.predict(input_array)\n\nprint(output_array)\n\nprint(output_array.shape)\n\nmodel.summary()",
            "masked_line": "ip = Input(shape = (3,))",
            "answer": "Input",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_453"
        },
        {
            "dependency": "click",
            "version": "==7.0",
            "time": "2020-02-09",
            "description": "This Python code defines a CLI (Command Line Interface) tool for managing a database. It includes commands to create and drop objects such as tables, views, and users. The 'create' group has commands to create tables and views, while the 'drop' group has commands to drop tables and users. The 'drop' user' command also takes an optional username parameter.",
            "code": "import click\n\n@click.group()\ndef cli():\n    \"\"\"DB Manager CLI\"\"\"\n\n@cli.group()\ndef create():\n    \"\"\"create objects\"\"\"\n\n@create.command()\ndef table():\n    click.echo('create table command')\n\n@create.command()\ndef view():\n    click.echo('create view command')\n\n@cli.group()\ndef drop():\n    \"\"\"create objects\"\"\"\n\n@drop.command()\ndef table():\n    click.echo('drop table command')\n\n@drop.command()\n@click.option('--username')\ndef user(username):\n    click.echo('drop user command: {}'.format(username))\n\nif __name__ == \"__main__\":\n    cli()",
            "masked_code": "import click\n\n@click.group()\ndef cli():\n    \"\"\"DB Manager CLI\"\"\"\n\n@cli.group()\ndef create():\n    \"\"\"create objects\"\"\"\n\n@create.command()\ndef table():\n    click.echo('create table command')\n\n@create.command()\ndef view():\n    click.echo('create view command')\n\n@cli.group()\ndef drop():\n    \"\"\"create objects\"\"\"\n\n@drop.command()\ndef table():\n    <line_mask>\n\n@drop.command()\n@click.option('--username')\ndef user(username):\n    click.echo('drop user command: {}'.format(username))\n\nif __name__ == \"__main__\":\n    cli()",
            "masked_line": "click.echo('drop table command')",
            "answer": "echo",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_454"
        },
        {
            "dependency": "pytest",
            "version": "==5.0.0",
            "time": "2020-06-30",
            "description": "The code raises a SystemExit exception to exit the program after running pytest's main method.",
            "code": "import pytest\n\nif __name__ == \"__main__\":\n    raise SystemExit(pytest.main())",
            "masked_code": "import pytest\n\nif __name__ == \"__main__\":\n    <line_mask>",
            "masked_line": "raise SystemExit(pytest.main())",
            "answer": "main",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_455"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.2.5",
            "time": "2020-04-22",
            "description": "The code creates a 3D plot of a parametric curve by calculating the values of x, y, and z based on a given parameter theta. The plot includes markers at specified points along the curve and displays a legend with labels for different sections of the curve.",
            "code": "import matplotlib as mpl\nfrom mpl_toolkits.mplot3d import Axes3D\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nplt.rcParams['legend.fontsize'] = 10\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\n# Prepare arrays x, y, z\ntheta = np.linspace(-4 * np.pi, 4 * np.pi, 100)\nz = np.linspace(-2, 2, 100)\nr = z**2 + 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\n\nl = ax.plot(x, y, z, marker='o', label='parametric curve both ends', markevery=[0,-1])\nl = ax.plot(x+1, y+1, z, 'r', marker='o', label='parametric curve one end', markevery=[0])\nax.legend()\n\nplt.show()\nplt.close()",
            "masked_code": "import matplotlib as mpl\nfrom mpl_toolkits.mplot3d import Axes3D\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nplt.rcParams['legend.fontsize'] = 10\n\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\n# Prepare arrays x, y, z\ntheta = np.linspace(-4 * np.pi, 4 * np.pi, 100)\nz = np.linspace(-2, 2, 100)\nr = z**2 + 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\n\nl = ax.plot(x, y, z, marker='o', label='parametric curve both ends', markevery=[0,-1])\nl = ax.plot(x+1, y+1, z, 'r', marker='o', label='parametric curve one end', markevery=[0])\nax.legend()\n\nplt.show()\n<line_mask>",
            "masked_line": "plt.close()",
            "answer": "close",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_456"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11",
            "time": "2020-10-06",
            "description": "The code generates sinusoidal sample data, creates a DataFrame from the data, and plots the data in various subplots including a 3D scatter plot and histogram plots for each frequency.",
            "code": "import pandas as pd\nimport numpy as np  # for sample data\n\n# sinusoidal sample data\nsample_length = range(1, 3+1)\nrads = np.arange(0, 2*np.pi, 0.01)\ndata = np.array([np.sin(t*rads) for t in sample_length])\ndf = pd.DataFrame(data.T, index=pd.Series(rads.tolist(), name='radians'), columns=[f'freq: {i}x' for i in sample_length])\n\n# plot the figures and correctly use the ax parameter\nfig = plt.figure(figsize=(10,10))\nax1 = fig.add_subplot(3, 2, 1, projection='3d')\nax1.scatter3D(df['freq: 1x'], df['freq: 2x'], df['freq: 3x'], color='green', s=5)\n\nax2 = fig.add_subplot(3, 2, 2)\nsns.histplot(df['freq: 1x'], ax=ax2)\nax2.set_title(\"Extent_0 Distribution\")\n\nax3 = fig.add_subplot(3, 2, 4)\nsns.histplot(df['freq: 2x'], ax=ax3)\nax3.set_title(\"Extent_1 Distribution\")\n\nax4 = fig.add_subplot(3, 2, 6)\nsns.histplot(df['freq: 3x'], ax=ax4)\nax4.set_title(\"Extent_2 Distribution\")\n\nfig.tight_layout()",
            "masked_code": "import pandas as pd\nimport numpy as np  # for sample data\n\n# sinusoidal sample data\nsample_length = range(1, 3+1)\nrads = np.arange(0, 2*np.pi, 0.01)\ndata = np.array([np.sin(t*rads) for t in sample_length])\ndf = pd.DataFrame(data.T, index=pd.Series(rads.tolist(), name='radians'), columns=[f'freq: {i}x' for i in sample_length])\n\n# plot the figures and correctly use the ax parameter\nfig = plt.figure(figsize=(10,10))\nax1 = fig.add_subplot(3, 2, 1, projection='3d')\nax1.scatter3D(df['freq: 1x'], df['freq: 2x'], df['freq: 3x'], color='green', s=5)\n\nax2 = fig.add_subplot(3, 2, 2)\nsns.histplot(df['freq: 1x'], ax=ax2)\nax2.set_title(\"Extent_0 Distribution\")\n\nax3 = fig.add_subplot(3, 2, 4)\n<line_mask>\nax3.set_title(\"Extent_1 Distribution\")\n\nax4 = fig.add_subplot(3, 2, 6)\nsns.histplot(df['freq: 3x'], ax=ax4)\nax4.set_title(\"Extent_2 Distribution\")\n\nfig.tight_layout()",
            "masked_line": "sns.histplot(df['freq: 2x'], ax=ax3)",
            "answer": "histplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_457"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.2",
            "time": "2020-12-16",
            "description": "The code creates a custom colormap using green and red colors, then sets the color for missing values to black, and finally assigns a specific color value to represent NaN values.",
            "code": "from matplotlib.colors import ListedColormap\n\nmatplotlib.__version__\n# '3.3.3' \n\ncm = ListedColormap(['green','red'])\ncm.set_bad(color=\"black\")\n\ncm(np.nan)\n# (0.0, 0.0, 0.0, 1.0)",
            "masked_code": "from matplotlib.colors import ListedColormap\n\nmatplotlib.__version__\n# '3.3.3' \n\n<line_mask>\ncm.set_bad(color=\"black\")\n\ncm(np.nan)\n# (0.0, 0.0, 0.0, 1.0)",
            "masked_line": "cm = ListedColormap(['green','red'])",
            "answer": "ListedColormap",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_458"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2020-09-22",
            "description": "The code generates a random 2x10 tensor using TensorFlow, then creates random indices and selects values from the tensor based on these indices. The selected values are stored in a new tensor using two different methods: one by looping through each row and selecting values, and the other by using the tf.gather function with specified axis and batch_dims. Finally, it prints the original tensor, the new tensor generated using the loop method, and the new tensor generated using the tf.gather function.",
            "code": "import tensorflow as tf\n\n# for version 1.x\n#tf.enable_eager_execution()\n\ntensor = tf.random.normal((2, 10))\nindices = tf.random.uniform(shape=[2, 10], minval=0, maxval=4, dtype=tf.int32)\n\nliste = []\nfor i in range(tensor.shape[0]):\n        liste.append(tf.gather(tensor[i,:], indices[i,:5]))\n\nnew_tensor = tf.stack(liste)\n\nprint('tensor: ')\nprint(tensor)\n\nprint('new_tensor: ')\nprint(new_tensor)\n\nnew_tensor_v2 = tf.gather(tensor, axis=-1, indices=indices[:, :5], batch_dims=1)\nprint('new_tensor_v2: ')\nprint(new_tensor_v2)",
            "masked_code": "import tensorflow as tf\n\n# for version 1.x\n#tf.enable_eager_execution()\n\ntensor = tf.random.normal((2, 10))\n<line_mask>\n\nliste = []\nfor i in range(tensor.shape[0]):\n        liste.append(tf.gather(tensor[i,:], indices[i,:5]))\n\nnew_tensor = tf.stack(liste)\n\nprint('tensor: ')\nprint(tensor)\n\nprint('new_tensor: ')\nprint(new_tensor)\n\nnew_tensor_v2 = tf.gather(tensor, axis=-1, indices=indices[:, :5], batch_dims=1)\nprint('new_tensor_v2: ')\nprint(new_tensor_v2)",
            "masked_line": "indices = tf.random.uniform(shape=[2, 10], minval=0, maxval=4, dtype=tf.int32)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_459"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-08-29",
            "description": "Find the longest simple cycle in the graph G.",
            "code": "max(nx.simple_cycles(G), key=len)\n# ['E', 'D', 'A']",
            "masked_code": "<line_mask>\n# ['E', 'D', 'A']",
            "masked_line": "max(nx.simple_cycles(G), key=len)",
            "answer": "simple_cycles",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_460"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-07-31",
            "description": "This code defines a function create_ST_layer that creates a neural network model with convolutional and pooling layers followed by dense layers. The model takes an input image with shape (64, 128, 3) and outputs a prediction with 6 classes. The model architecture includes convolutional layers with ReLU activation, max pooling layers, and dense layers with ReLU activation. The function returns the constructed model.",
            "code": "import tensorflow as tf\nfrom tensorflow.keras.models import Sequential, Model\nfrom tensorflow.keras.layers import Conv2D, Flatten, MaxPooling2D, Dense, Input, Reshape, Concatenate, GlobalAveragePooling2D, BatchNormalization, Dropout, Activation, GlobalMaxPooling2D\nfrom tensorflow.keras.utils import Sequence\n\ndef create_ST_layer(input_shape = (64, 128, 3)):\n    input_img = Input(shape=input_shape)\n    model = Conv2D(48, kernel_size=(5, 5), input_shape = input_shape, strides = (1, 1), activation = \"relu\")(input_img)\n    model = MaxPooling2D(pool_size=(2, 2), strides = (2, 2))(model)\n    model = Conv2D(32, kernel_size=(5, 5), strides = (1, 1), activation = \"relu\")(model)\n    model = MaxPooling2D(pool_size=(2, 2), strides = (2, 2))(model)\n    model = Dense(50, activation = \"relu\")(model)\n    model = Dense(6)(model)\n    model = tf.keras.Model(inputs=input_img, outputs= model)\n    return model\n\nmodel = create_ST_layer()\nmodel.summary()",
            "masked_code": "import tensorflow as tf\nfrom tensorflow.keras.models import Sequential, Model\nfrom tensorflow.keras.layers import Conv2D, Flatten, MaxPooling2D, Dense, Input, Reshape, Concatenate, GlobalAveragePooling2D, BatchNormalization, Dropout, Activation, GlobalMaxPooling2D\nfrom tensorflow.keras.utils import Sequence\n\ndef create_ST_layer(input_shape = (64, 128, 3)):\n    input_img = Input(shape=input_shape)\n    model = Conv2D(48, kernel_size=(5, 5), input_shape = input_shape, strides = (1, 1), activation = \"relu\")(input_img)\n    model = MaxPooling2D(pool_size=(2, 2), strides = (2, 2))(model)\n    model = Conv2D(32, kernel_size=(5, 5), strides = (1, 1), activation = \"relu\")(model)\n    model = MaxPooling2D(pool_size=(2, 2), strides = (2, 2))(model)\n    model = Dense(50, activation = \"relu\")(model)\n    model = Dense(6)(model)\n    <line_mask>\n    return model\n\nmodel = create_ST_layer()\nmodel.summary()",
            "masked_line": "model = tf.keras.Model(inputs=input_img, outputs= model)",
            "answer": "Model",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_461"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-07-27",
            "description": "The code generates a set of nodes connected to the source node in a graph using the edge depth-first search algorithm with reverse orientation.",
            "code": "from itertools import chain \nsource = 4120882840\n\n*n, _ = zip(*(nx.edge_dfs(G, source, orientation='reverse')))\nprint(set(chain.from_iterable(n)))\n{4120874720, 4120871840, 4121480930, 4120874920, 4121480780, \n 4121482000, 4120871830, 4120882840}",
            "masked_code": "from itertools import chain \nsource = 4120882840\n\n<line_mask>\nprint(set(chain.from_iterable(n)))\n{4120874720, 4120871840, 4121480930, 4120874920, 4121480780, \n 4121482000, 4120871830, 4120882840}",
            "masked_line": "*n, _ = zip(*(nx.edge_dfs(G, source, orientation='reverse')))",
            "answer": "edge_dfs",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_462"
        },
        {
            "dependency": "networkx",
            "version": "==1.11",
            "time": "2020-07-16",
            "description": "The function of the provided Python code is to create a Barabasi-Albert graph with 300 nodes and average degree 2, detect communities within the graph using the Louvain algorithm, and visualize the graph with nodes colored based on their community partitions.",
            "code": "from community import community_louvain\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nG = nx.barabasi_albert_graph(300, 2)\n\n# compute the best partition\npartition = community_louvain.best_partition(G)\ncmap = cm.get_cmap('viridis', max(partition.values()) + 1)\n\nplt.figure(figsize=(12,8))\n# draw the graph\npos = nx.circular_layout(G)\n# color the nodes according to their partition\ncmap = cm.get_cmap('viridis', max(partition.values()) + 1)\nnx.draw_networkx_nodes(G, pos, partition.keys(), node_size=100,\n                       cmap=cmap, node_color=list(partition.values()))\nedge_colors = [partition[edge[0]] for edge in G.edges()]\nnx.draw_networkx_edges(G, \n                       pos, \n                       alpha=0.5,\n                      edge_color=edge_colors)\nplt.box(False)",
            "masked_code": "from community import community_louvain\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nG = nx.barabasi_albert_graph(300, 2)\n\n# compute the best partition\npartition = community_louvain.best_partition(G)\ncmap = cm.get_cmap('viridis', max(partition.values()) + 1)\n\nplt.figure(figsize=(12,8))\n# draw the graph\n<line_mask>\n# color the nodes according to their partition\ncmap = cm.get_cmap('viridis', max(partition.values()) + 1)\nnx.draw_networkx_nodes(G, pos, partition.keys(), node_size=100,\n                       cmap=cmap, node_color=list(partition.values()))\nedge_colors = [partition[edge[0]] for edge in G.edges()]\nnx.draw_networkx_edges(G, \n                       pos, \n                       alpha=0.5,\n                      edge_color=edge_colors)\nplt.box(False)",
            "masked_line": "pos = nx.circular_layout(G)",
            "answer": "circular_layout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_463"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-06-08",
            "description": "The code initializes an undirected graph G and adds weighted edges from a list w_edges to the graph.",
            "code": "G = nx.Graph()\nG.add_weighted_edges_from(w_edges)",
            "masked_code": "<line_mask>\nG.add_weighted_edges_from(w_edges)",
            "masked_line": "G = nx.Graph()",
            "answer": "Graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_464"
        },
        {
            "dependency": "dash",
            "version": "==1.11.0",
            "time": "2020-04-24",
            "description": "The code displays the current time on a webpage using the Dash framework in Python. It includes a callback function that updates the displayed time every second.",
            "code": "import datetime\nimport dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output\n\napp = dash.Dash()\n\ndef serve_layout():\n    return html.Div([\n        dcc.Interval(id=\"time_trigger\", interval=1000),\n        html.H1('The time is: ' + str(datetime.datetime.now()), id=\"header\")])\n\napp.layout = serve_layout\n\n\n@app.callback(\n    Output(\"header\", \"children\"),\n    [Input(\"time_trigger\", \"n_intervals\")]\n)\ndef connect_to_date_sync_service(n_interval):\n    return \"Interval is triggered {} times\".format(n_interval)\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "import datetime\nimport dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output\n\napp = dash.Dash()\n\ndef serve_layout():\n    return html.Div([\n        dcc.Interval(id=\"time_trigger\", interval=1000),\n        html.H1('The time is: ' + str(datetime.datetime.now()), id=\"header\")])\n\napp.layout = serve_layout\n\n\n@app.callback(\n    Output(\"header\", \"children\"),\n    <line_mask>\n)\ndef connect_to_date_sync_service(n_interval):\n    return \"Interval is triggered {} times\".format(n_interval)\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_line": "[Input(\"time_trigger\", \"n_intervals\")]",
            "answer": "Input",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_465"
        },
        {
            "dependency": "boto3",
            "version": "==1.18",
            "time": "2021-07-20",
            "description": "The code creates a test suite using the unittest module and performs testing on the functionality of AWS services such as SNS (Simple Notification Service) and SQS (Simple Queue Service) using the boto3 library. The test cases involve creating topics, queues, subscriptions, publishing messages, receiving messages, and asserting the correctness of the message content. Additionally, it includes a test case for stubbing the SNS client to simulate responses for testing purposes.",
            "code": "from moto import mock_sns, mock_sqs\nimport unittest\nimport boto3\nimport json\nfrom botocore.stub import Stubber\n\n\nclass TestBoto3(unittest.TestCase):\n\n    @mock_sns\n    @mock_sqs\n    def test_fanout(self):\n        region_name = \"eu-west-1\"\n        topic_name = \"test_fanout\"\n        sns, sqs = boto3.client(\"sns\", region_name=region_name), boto3.client(\"sqs\", region_name=region_name)\n\n        topic_arn = sns.create_topic(Name=topic_name)[\"TopicArn\"]\n        sqs_url = sqs.create_queue(QueueName='test')[\"QueueUrl\"]\n        sqs_arn = sqs.get_queue_attributes(QueueUrl=sqs_url)[\"Attributes\"][\"QueueArn\"]\n\n        sns.subscribe(TopicArn=topic_arn, Protocol='sqs', Endpoint=sqs_arn)\n        sns.subscribe(TopicArn=topic_arn, Protocol='sms', Endpoint=\"+12223334444\")\n\n        sns.publish(TopicArn=topic_arn, Message=\"test\")\n        sns.publish(PhoneNumber=\"+12223334444\", Message=\"sms test\")\n\n        message = sqs.receive_message(QueueUrl=sqs_url, MaxNumberOfMessages=10)[\"Messages\"]\n        sqs.delete_message(QueueUrl=sqs_url, ReceiptHandle=message[0][\"ReceiptHandle\"])\n\n        self.assertEqual(len(message), 2)\n        self.assertEqual(json.loads(message[0][\"Body\"])[\"Message\"], 'test')\n        self.assertEqual(json.loads(message[1][\"Body\"])[\"Message\"], 'sms test')\n\n    def test_stubber_sms(self):\n        sns = boto3.client(\"sns\")\n        stubber = Stubber(sns)\n\n        stubber.add_response(method='publish', service_response={\"MessageId\": '1'}, expected_params={'PhoneNumber':\"+12223334444\", 'Message':\"my message\"})\n        with stubber:\n            response = sns.publish(PhoneNumber=\"+12223334444\", Message=\"my message\")\n            # Or use your method and pass boto3 sns client as argument\n            self.assertEqual(response, {\"MessageId\": '1'})\n            stubber.assert_no_pending_responses()\n\nif __name__ == '__main__':\n    unittest.main()",
            "masked_code": "from moto import mock_sns, mock_sqs\nimport unittest\nimport boto3\nimport json\nfrom botocore.stub import Stubber\n\n\nclass TestBoto3(unittest.TestCase):\n\n    @mock_sns\n    @mock_sqs\n    def test_fanout(self):\n        region_name = \"eu-west-1\"\n        topic_name = \"test_fanout\"\n        sns, sqs = boto3.client(\"sns\", region_name=region_name), boto3.client(\"sqs\", region_name=region_name)\n\n        topic_arn = sns.create_topic(Name=topic_name)[\"TopicArn\"]\n        sqs_url = sqs.create_queue(QueueName='test')[\"QueueUrl\"]\n        sqs_arn = sqs.get_queue_attributes(QueueUrl=sqs_url)[\"Attributes\"][\"QueueArn\"]\n\n        sns.subscribe(TopicArn=topic_arn, Protocol='sqs', Endpoint=sqs_arn)\n        sns.subscribe(TopicArn=topic_arn, Protocol='sms', Endpoint=\"+12223334444\")\n\n        sns.publish(TopicArn=topic_arn, Message=\"test\")\n        sns.publish(PhoneNumber=\"+12223334444\", Message=\"sms test\")\n\n        message = sqs.receive_message(QueueUrl=sqs_url, MaxNumberOfMessages=10)[\"Messages\"]\n        sqs.delete_message(QueueUrl=sqs_url, ReceiptHandle=message[0][\"ReceiptHandle\"])\n\n        self.assertEqual(len(message), 2)\n        self.assertEqual(json.loads(message[0][\"Body\"])[\"Message\"], 'test')\n        self.assertEqual(json.loads(message[1][\"Body\"])[\"Message\"], 'sms test')\n\n    def test_stubber_sms(self):\n        sns = boto3.client(\"sns\")\n        stubber = Stubber(sns)\n\n        stubber.add_response(method='publish', service_response={\"MessageId\": '1'}, expected_params={'PhoneNumber':\"+12223334444\", 'Message':\"my message\"})\n        with stubber:\n            <line_mask>\n            # Or use your method and pass boto3 sns client as argument\n            self.assertEqual(response, {\"MessageId\": '1'})\n            stubber.assert_no_pending_responses()\n\nif __name__ == '__main__':\n    unittest.main()",
            "masked_line": "response = sns.publish(PhoneNumber=\"+12223334444\", Message=\"my message\")",
            "answer": "publish",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_466"
        },
        {
            "dependency": "botocore",
            "version": "==1.21.0",
            "time": "2021-07-20",
            "description": "The code is creating mock SNS and SQS services using Moto library for unit testing purposes. It sets up a test case to demonstrate fanout messaging functionality, where a message is published to an SNS topic and then forwarded to SQS and SMS subscribers. It also includes a test case using Stubber to simulate an SMS message publishing scenario and verify the response.",
            "code": "from moto import mock_sns, mock_sqs\nimport unittest\nimport boto3\nimport json\nfrom botocore.stub import Stubber\n\n\nclass TestBoto3(unittest.TestCase):\n\n    @mock_sns\n    @mock_sqs\n    def test_fanout(self):\n        region_name = \"eu-west-1\"\n        topic_name = \"test_fanout\"\n        sns, sqs = boto3.client(\"sns\", region_name=region_name), boto3.client(\"sqs\", region_name=region_name)\n\n        topic_arn = sns.create_topic(Name=topic_name)[\"TopicArn\"]\n        sqs_url = sqs.create_queue(QueueName='test')[\"QueueUrl\"]\n        sqs_arn = sqs.get_queue_attributes(QueueUrl=sqs_url)[\"Attributes\"][\"QueueArn\"]\n\n        sns.subscribe(TopicArn=topic_arn, Protocol='sqs', Endpoint=sqs_arn)\n        sns.subscribe(TopicArn=topic_arn, Protocol='sms', Endpoint=\"+12223334444\")\n\n        sns.publish(TopicArn=topic_arn, Message=\"test\")\n        sns.publish(PhoneNumber=\"+12223334444\", Message=\"sms test\")\n\n        message = sqs.receive_message(QueueUrl=sqs_url, MaxNumberOfMessages=10)[\"Messages\"]\n        sqs.delete_message(QueueUrl=sqs_url, ReceiptHandle=message[0][\"ReceiptHandle\"])\n\n        self.assertEqual(len(message), 2)\n        self.assertEqual(json.loads(message[0][\"Body\"])[\"Message\"], 'test')\n        self.assertEqual(json.loads(message[1][\"Body\"])[\"Message\"], 'sms test')\n\n    def test_stubber_sms(self):\n        sns = boto3.client(\"sns\")\n        stubber = Stubber(sns)\n\n        stubber.add_response(method='publish', service_response={\"MessageId\": '1'}, expected_params={'PhoneNumber':\"+12223334444\", 'Message':\"my message\"})\n        with stubber:\n            response = sns.publish(PhoneNumber=\"+12223334444\", Message=\"my message\")\n            # Or use your method and pass boto3 sns client as argument\n            self.assertEqual(response, {\"MessageId\": '1'})\n            stubber.assert_no_pending_responses()\n\nif __name__ == '__main__':\n    unittest.main()",
            "masked_code": "from moto import mock_sns, mock_sqs\nimport unittest\nimport boto3\nimport json\nfrom botocore.stub import Stubber\n\n\nclass TestBoto3(unittest.TestCase):\n\n    @mock_sns\n    @mock_sqs\n    def test_fanout(self):\n        region_name = \"eu-west-1\"\n        topic_name = \"test_fanout\"\n        sns, sqs = boto3.client(\"sns\", region_name=region_name), boto3.client(\"sqs\", region_name=region_name)\n\n        topic_arn = sns.create_topic(Name=topic_name)[\"TopicArn\"]\n        sqs_url = sqs.create_queue(QueueName='test')[\"QueueUrl\"]\n        sqs_arn = sqs.get_queue_attributes(QueueUrl=sqs_url)[\"Attributes\"][\"QueueArn\"]\n\n        sns.subscribe(TopicArn=topic_arn, Protocol='sqs', Endpoint=sqs_arn)\n        sns.subscribe(TopicArn=topic_arn, Protocol='sms', Endpoint=\"+12223334444\")\n\n        sns.publish(TopicArn=topic_arn, Message=\"test\")\n        sns.publish(PhoneNumber=\"+12223334444\", Message=\"sms test\")\n\n        message = sqs.receive_message(QueueUrl=sqs_url, MaxNumberOfMessages=10)[\"Messages\"]\n        sqs.delete_message(QueueUrl=sqs_url, ReceiptHandle=message[0][\"ReceiptHandle\"])\n\n        self.assertEqual(len(message), 2)\n        self.assertEqual(json.loads(message[0][\"Body\"])[\"Message\"], 'test')\n        self.assertEqual(json.loads(message[1][\"Body\"])[\"Message\"], 'sms test')\n\n    def test_stubber_sms(self):\n        sns = boto3.client(\"sns\")\n        <line_mask>\n\n        stubber.add_response(method='publish', service_response={\"MessageId\": '1'}, expected_params={'PhoneNumber':\"+12223334444\", 'Message':\"my message\"})\n        with stubber:\n            response = sns.publish(PhoneNumber=\"+12223334444\", Message=\"my message\")\n            # Or use your method and pass boto3 sns client as argument\n            self.assertEqual(response, {\"MessageId\": '1'})\n            stubber.assert_no_pending_responses()\n\nif __name__ == '__main__':\n    unittest.main()",
            "masked_line": "stubber = Stubber(sns)",
            "answer": "Stubber",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_467"
        },
        {
            "dependency": "numba",
            "version": ">=0.48",
            "time": "2020-03-12",
            "description": "The code generates all combinations of elements in a given 2D list, raises each combination to the power of 3, and then multiplies all elements in each combination together using the Numba library for just-in-time compilation. Finally, it prints the results of these multiplications.",
            "code": "import numpy as np\nfrom itertools import product\nfrom functools import reduce\nfrom operator import mul\nfrom numba import njit, prange\n\nlst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\narr = np.array(lst)\nn = 3\nflat = np.ravel(arr).tolist()\ngen = np.array([list(a) for a in product(flat, repeat=n)])\n\n@njit\ndef mul_wrapper(x, y):\n    return mul(x, y)\n\n@njit\ndef mtp(gen):\n    results = np.empty(gen.shape[0])\n    for i in prange(gen.shape[0]):\n        results[i] = reduce(mul_wrapper, gen[i], None)\n    return results\n\nprint(mtp(gen))",
            "masked_code": "import numpy as np\nfrom itertools import product\nfrom functools import reduce\nfrom operator import mul\nfrom numba import njit, prange\n\nlst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\narr = np.array(lst)\nn = 3\nflat = np.ravel(arr).tolist()\ngen = np.array([list(a) for a in product(flat, repeat=n)])\n\n@njit\ndef mul_wrapper(x, y):\n    return mul(x, y)\n\n@njit\ndef mtp(gen):\n    results = np.empty(gen.shape[0])\n    <line_mask>\n        results[i] = reduce(mul_wrapper, gen[i], None)\n    return results\n\nprint(mtp(gen))",
            "masked_line": "for i in prange(gen.shape[0]):",
            "answer": "prange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_468"
        },
        {
            "dependency": "requests",
            "version": "==2.4.2",
            "time": "2020-09-22",
            "description": "The code sends a POST request to httpbin.org/post with the JSON data {'test': 'foo'} as the request body.",
            "code": "requests.post('http://httpbin.org/post', json={'test': 'foo'})",
            "masked_code": "<line_mask>",
            "masked_line": "requests.post('http://httpbin.org/post', json={'test': 'foo'})",
            "answer": "post",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_469"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.1.1",
            "time": "2020-06-29",
            "description": "This code generates a Barabsi-Albert graph with 2000 nodes and each new node attaches to 3 existing nodes. It then calculates the degree frequency distribution of the generated graph and plots it in a log-log scale showing the relationship between degree and frequency.",
            "code": "import networkx as nx\nimport matplotlib.pyplot as plt\n\nn = 2000\nm = 3\nG_barabasi = nx.barabasi_albert_graph(n,m)\n\ndegree_freq = nx.degree_histogram(G_barabasi)\ndegrees = range(len(degree_freq))\nplt.figure(figsize=(12, 8)) \nplt.loglog(degrees[m:], degree_freq[m:],'go-') \nplt.xlabel('Degree')\nplt.ylabel('Frequency')",
            "masked_code": "import networkx as nx\nimport matplotlib.pyplot as plt\n\nn = 2000\nm = 3\nG_barabasi = nx.barabasi_albert_graph(n,m)\n\ndegree_freq = nx.degree_histogram(G_barabasi)\ndegrees = range(len(degree_freq))\nplt.figure(figsize=(12, 8)) \nplt.loglog(degrees[m:], degree_freq[m:],'go-') \n<line_mask>\nplt.ylabel('Frequency')",
            "masked_line": "plt.xlabel('Degree')",
            "answer": "xlabel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_470"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-06-29",
            "description": "This code generates a Barabsi-Albert model network with 2000 nodes and each new node attaches to 3 existing nodes. It then calculates the degree frequency of the network and plots a log-log graph showing the relationship between degree and frequency.",
            "code": "import networkx as nx\nimport matplotlib.pyplot as plt\n\nn = 2000\nm = 3\nG_barabasi = nx.barabasi_albert_graph(n,m)\n\ndegree_freq = nx.degree_histogram(G_barabasi)\ndegrees = range(len(degree_freq))\nplt.figure(figsize=(12, 8)) \nplt.loglog(degrees[m:], degree_freq[m:],'go-') \nplt.xlabel('Degree')\nplt.ylabel('Frequency')",
            "masked_code": "import networkx as nx\nimport matplotlib.pyplot as plt\n\nn = 2000\nm = 3\n<line_mask>\n\ndegree_freq = nx.degree_histogram(G_barabasi)\ndegrees = range(len(degree_freq))\nplt.figure(figsize=(12, 8)) \nplt.loglog(degrees[m:], degree_freq[m:],'go-') \nplt.xlabel('Degree')\nplt.ylabel('Frequency')",
            "masked_line": "G_barabasi = nx.barabasi_albert_graph(n,m)",
            "answer": "barabasi_albert_graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_471"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2020-11-20",
            "description": "This code generates a scatter plot using matplotlib with markers sized based on the count of observations in a dataset. The dataset used is the 'titanic' dataset from seaborn, containing categorical variables 'who' and 'embark_town'. The code calculates the count of observations, computes marker sizes based on the count, and creates a scatter plot with additional formatting such as gridlines and tick parameters.",
            "code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport seaborn as sns              # v 0.11.0\n\n# Import seaborn sample dataset stored as a pandas dataframe and select\n# the categorical variables to plot\ndf = sns.load_dataset('titanic')\nx = 'who'  # contains 3 unique values: 'child', 'man', 'woman'\ny = 'embark_town'  # contains 3 unique values: 'Southampton', 'Queenstown', 'Cherbourg'\n\n# Compute the counts of observations\ndf_counts = df.groupby([x, y]).size().reset_index()\ndf_counts.columns.values[df_counts.columns == 0] = 'count'\n\n# Compute a size variable for the markers so that they have a good size regardless\n# of the total count and the number of unique values in each categorical variable\nscale = 500*df_counts['count'].size\nsize = df_counts['count']/df_counts['count'].sum()*scale\n\n# Create matplotlib scatter plot with additional formatting\nfig, ax = plt.subplots(figsize=(8,6))\nax.scatter(x, y, size, data=df_counts, zorder=2)\nax.grid(color='grey', linestyle='--', alpha=0.4, zorder=1)\nax.tick_params(length=0)\nax.set_frame_on(False)\nax.margins(.3)",
            "masked_code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport seaborn as sns              # v 0.11.0\n\n# Import seaborn sample dataset stored as a pandas dataframe and select\n# the categorical variables to plot\ndf = sns.load_dataset('titanic')\nx = 'who'  # contains 3 unique values: 'child', 'man', 'woman'\ny = 'embark_town'  # contains 3 unique values: 'Southampton', 'Queenstown', 'Cherbourg'\n\n# Compute the counts of observations\ndf_counts = df.groupby([x, y]).size().reset_index()\ndf_counts.columns.values[df_counts.columns == 0] = 'count'\n\n# Compute a size variable for the markers so that they have a good size regardless\n# of the total count and the number of unique values in each categorical variable\nscale = 500*df_counts['count'].size\nsize = df_counts['count']/df_counts['count'].sum()*scale\n\n# Create matplotlib scatter plot with additional formatting\n<line_mask>\nax.scatter(x, y, size, data=df_counts, zorder=2)\nax.grid(color='grey', linestyle='--', alpha=0.4, zorder=1)\nax.tick_params(length=0)\nax.set_frame_on(False)\nax.margins(.3)",
            "masked_line": "fig, ax = plt.subplots(figsize=(8,6))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_472"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2020-11-20",
            "description": "This code generates a scatter plot using matplotlib to visualize the relationship between two categorical variables in the 'titanic' dataset. The size of the markers in the plot is adjusted based on the count of observations for each category combination. Formatting options such as grid lines, tick parameters, frame visibility, and margins are also applied to enhance the visualization.",
            "code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport seaborn as sns              # v 0.11.0\n\n# Import seaborn sample dataset stored as a pandas dataframe and select\n# the categorical variables to plot\ndf = sns.load_dataset('titanic')\nx = 'who'  # contains 3 unique values: 'child', 'man', 'woman'\ny = 'embark_town'  # contains 3 unique values: 'Southampton', 'Queenstown', 'Cherbourg'\n\n# Compute the counts of observations\ndf_counts = df.groupby([x, y]).size().reset_index()\ndf_counts.columns.values[df_counts.columns == 0] = 'count'\n\n# Compute a size variable for the markers so that they have a good size regardless\n# of the total count and the number of unique values in each categorical variable\nscale = 500*df_counts['count'].size\nsize = df_counts['count']/df_counts['count'].sum()*scale\n\n# Create matplotlib scatter plot with additional formatting\nfig, ax = plt.subplots(figsize=(8,6))\nax.scatter(x, y, size, data=df_counts, zorder=2)\nax.grid(color='grey', linestyle='--', alpha=0.4, zorder=1)\nax.tick_params(length=0)\nax.set_frame_on(False)\nax.margins(.3)",
            "masked_code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport seaborn as sns              # v 0.11.0\n\n# Import seaborn sample dataset stored as a pandas dataframe and select\n# the categorical variables to plot\ndf = sns.load_dataset('titanic')\nx = 'who'  # contains 3 unique values: 'child', 'man', 'woman'\ny = 'embark_town'  # contains 3 unique values: 'Southampton', 'Queenstown', 'Cherbourg'\n\n# Compute the counts of observations\n<line_mask>\ndf_counts.columns.values[df_counts.columns == 0] = 'count'\n\n# Compute a size variable for the markers so that they have a good size regardless\n# of the total count and the number of unique values in each categorical variable\nscale = 500*df_counts['count'].size\nsize = df_counts['count']/df_counts['count'].sum()*scale\n\n# Create matplotlib scatter plot with additional formatting\nfig, ax = plt.subplots(figsize=(8,6))\nax.scatter(x, y, size, data=df_counts, zorder=2)\nax.grid(color='grey', linestyle='--', alpha=0.4, zorder=1)\nax.tick_params(length=0)\nax.set_frame_on(False)\nax.margins(.3)",
            "masked_line": "df_counts = df.groupby([x, y]).size().reset_index()",
            "answer": "groupby",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_473"
        },
        {
            "dependency": "scipy",
            "version": "==0.13.0",
            "time": "2020-02-07",
            "description": "The code optimizes the 'function' by finding the values of x that minimize it, subject to the constraint that the sum of (x * [5, 3, 8, 6]) should equal to 11.",
            "code": "from scipy.optimize import fmin_slsqp\nimport numpy as np\n\n\ndef zero_equation(x):\n    return (x*np.array([5,3,8,6])).sum()-11\n\n\ndef function(x):\n    return x[0]+x[1]+x[2]+x[3]\n\n\nb = (0,1)\nbounds = (b,b,b,b)\nstarting_parameters = np.array([0,0,0,1])\nresult = fmin_slsqp(function, x0=starting_parameters , bounds=bounds ,eqcons=[zero_equation])",
            "masked_code": "from scipy.optimize import fmin_slsqp\nimport numpy as np\n\n\ndef zero_equation(x):\n    return (x*np.array([5,3,8,6])).sum()-11\n\n\ndef function(x):\n    return x[0]+x[1]+x[2]+x[3]\n\n\nb = (0,1)\nbounds = (b,b,b,b)\nstarting_parameters = np.array([0,0,0,1])\n<line_mask>",
            "masked_line": "result = fmin_slsqp(function, x0=starting_parameters , bounds=bounds ,eqcons=[zero_equation])",
            "answer": "fmin_slsqp",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_474"
        },
        {
            "dependency": "Shady",
            "version": ">=1.12",
            "time": "2020-09-23",
            "description": "The code defines a custom color transformation function called PhotoNegative, which calculates the negative of the input color by subtracting each RGB component from 1.0. This transformation is then applied to a stimulus in a Shady world.",
            "code": "import Shady;  Shady.RequireShadyVersion('1.12')\n\nShady.AddCustomColorTransformation(\"\"\"\n\n    vec4 PhotoNegative(vec4 color)\n    {\n        color.rgb = 1.0 - color.rgb;\n        return color;\n    }\n\n\"\"\")\nw = Shady.World()\ns = w.Stimulus(Shady.EXAMPLE_MEDIA.alien1, frame=Shady.Integral(16))\ns.colorTransformation = Shady.COLORTRANS.PhotoNegative",
            "masked_code": "<line_mask>\n\nShady.AddCustomColorTransformation(\"\"\"\n\n    vec4 PhotoNegative(vec4 color)\n    {\n        color.rgb = 1.0 - color.rgb;\n        return color;\n    }\n\n\"\"\")\nw = Shady.World()\ns = w.Stimulus(Shady.EXAMPLE_MEDIA.alien1, frame=Shady.Integral(16))\ns.colorTransformation = Shady.COLORTRANS.PhotoNegative",
            "masked_line": "import Shady;  Shady.RequireShadyVersion('1.12')",
            "answer": "RequireShadyVersion",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_475"
        },
        {
            "dependency": "rq",
            "version": "==1.5.0",
            "time": "2020-07-31",
            "description": "The code creates a job queue using Redis and RQ, enqueues a job that runs a randomly failing task with a maximum of 3 retries, and enqueues another job that depends on the completion of the randomly failing job.",
            "code": "from redis import Redis\nfrom rq import Queue, Retry\nfrom somewhere import randomly_failing_task, dependent_task\n\njob_queue = Queue(connection=Redis())\nrandomly_failing_job = job_queue.enqueue(randomly_failing_task, retry=Retry(max=3))\ndependent_job = job_queue.enqueue(dependent_task, depends_on=randomly_failing_job)",
            "masked_code": "from redis import Redis\nfrom rq import Queue, Retry\nfrom somewhere import randomly_failing_task, dependent_task\n\njob_queue = Queue(connection=Redis())\n<line_mask>\ndependent_job = job_queue.enqueue(dependent_task, depends_on=randomly_failing_job)",
            "masked_line": "randomly_failing_job = job_queue.enqueue(randomly_failing_task, retry=Retry(max=3))",
            "answer": "Retry",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_476"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-08-26",
            "description": "The code creates a directed graph from a pandas DataFrame with columns 'Manager ID' and 'Employee ID', and then finds the descendants of each employee in the graph. It then creates a new DataFrame with columns 'Manager' and 'Employee', where each row represents the manager and their descendants. Any empty values are replaced with NaN.",
            "code": "import networkx as nx\n\nG = nx.from_pandas_edgelist(\n    df, 'Manager ID', 'Employee Id', create_using=nx.DiGraph())\n\ns = [','.join(map(str, nx.descendants(G, i))) for i in df['Employee Id']]\nd = pd.DataFrame({'Manager': df['Employee Id'].tolist(), 'Employee': s}).replace('', np.nan)",
            "masked_code": "import networkx as nx\n\nG = nx.from_pandas_edgelist(\n    <line_mask>\n\ns = [','.join(map(str, nx.descendants(G, i))) for i in df['Employee Id']]\nd = pd.DataFrame({'Manager': df['Employee Id'].tolist(), 'Employee': s}).replace('', np.nan)",
            "masked_line": "df, 'Manager ID', 'Employee Id', create_using=nx.DiGraph())",
            "answer": "DiGraph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_477"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-06-23",
            "description": "This code generates subplots for visualizing strongly connected components of a graph. It first identifies all the strongly connected components of the graph G. Then, it creates a grid of subplots based on the number of components and a specified number of columns. For each component, it extracts a subgraph and visualizes it using networkx library, with nodes colored in light blue and labels displayed. If there are less components than the total number of subplots, empty subplots are created without any content.",
            "code": "from itertools import zip_longest\nfrom matplotlib import pyplot as plt\nfrom math import ceil\n\ncomps = list(nx.strongly_connected_components(G))\nn_cols = 2\n\nfig, axes = plt.subplots(nrows=int(ceil(len(comps)/n_cols)), \n                         ncols=n_cols, \n                         figsize=(15,8))\n\nfor comp, ax in zip_longest(comps, axes.flatten()):\n    if comp is None:\n        plt.box(False)\n        plt.axis('off')\n        continue\n    G_sub = G.subgraph(comp)\n    nx.draw(G_sub, with_labels=True, node_color='lightblue', node_size=500, ax=ax)",
            "masked_code": "from itertools import zip_longest\nfrom matplotlib import pyplot as plt\nfrom math import ceil\n\ncomps = list(nx.strongly_connected_components(G))\nn_cols = 2\n\nfig, axes = plt.subplots(nrows=int(ceil(len(comps)/n_cols)), \n                         ncols=n_cols, \n                         figsize=(15,8))\n\nfor comp, ax in zip_longest(comps, axes.flatten()):\n    if comp is None:\n        plt.box(False)\n        plt.axis('off')\n        continue\n    G_sub = G.subgraph(comp)\n    <line_mask>",
            "masked_line": "nx.draw(G_sub, with_labels=True, node_color='lightblue', node_size=500, ax=ax)",
            "answer": "draw",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_478"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.2",
            "time": "2020-11-13",
            "description": "This code sets the locale to Spanish (Spain) and then converts a list of date strings into a DatetimeIndex object using the pandas library.",
            "code": "import locale\nimport pandas as pd\n\nlocale.setlocale(locale.LC_ALL,'es_ES') \n\npd.to_datetime(['29 oct. 2020', '29 oct 2020'])\n# DatetimeIndex(['2020-10-29', '2020-10-29'], dtype='datetime64[ns]', freq=None)",
            "masked_code": "import locale\nimport pandas as pd\n\nlocale.setlocale(locale.LC_ALL,'es_ES') \n\n<line_mask>\n# DatetimeIndex(['2020-10-29', '2020-10-29'], dtype='datetime64[ns]', freq=None)",
            "masked_line": "pd.to_datetime(['29 oct. 2020', '29 oct 2020'])",
            "answer": "to_datetime",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_479"
        },
        {
            "dependency": "transformers",
            "version": "==3.1.0",
            "time": "2020-10-08",
            "description": "The code performs zero-shot classification on the given sequence using a pre-trained model. It takes a sequence as input and predicts the most relevant label(s) from the provided candidate labels along with their corresponding scores.",
            "code": "# pip install transformers==3.1.0  # pip install in terminal\nfrom transformers import pipeline\n\nclassifier = pipeline(\"zero-shot-classification\")\n\nsequence = \"Hi, I welcome you to this event\"\ncandidate_labels = [\"greeting\", \"insult\", \"congratulation\"]\n\nclassifier(sequence, candidate_labels)\n\n# output: {'sequence': 'Hi, I welcome you to this event',\n# 'labels': ['greeting', 'congratulation', 'insult'],\n# 'scores': [0.9001138210296631, 0.09858417510986328, 0.001302019809372723]}",
            "masked_code": "# pip install transformers==3.1.0  # pip install in terminal\nfrom transformers import pipeline\n\nclassifier = pipeline(\"zero-shot-classification\")\n\nsequence = \"Hi, I welcome you to this event\"\ncandidate_labels = [\"greeting\", \"insult\", \"congratulation\"]\n\n<line_mask>\n\n# output: {'sequence': 'Hi, I welcome you to this event',\n# 'labels': ['greeting', 'congratulation', 'insult'],\n# 'scores': [0.9001138210296631, 0.09858417510986328, 0.001302019809372723]}",
            "masked_line": "classifier(sequence, candidate_labels)",
            "answer": "classifier",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_480"
        },
        {
            "dependency": "dash",
            "version": "==1.20.0",
            "time": "2020-08-14",
            "description": "This code sets up a Dash application with a DataTable displaying data and a button for downloading the data in CSV format. The data displayed in the DataTable is generated with values multiplied by 10. When the \"Download\" button is clicked, the data in the DataTable is converted into a pandas DataFrame and then downloaded as a CSV file named \"some_data.csv\".",
            "code": "import dash\nimport dash_html_components as html\nimport dash_core_components as dcc\nimport pandas as pd\nfrom dash.dependencies import Output, Input, State\nfrom dash_table import DataTable\n\ndt = DataTable(columns=[{\"id\": v, \"name\": v} for v in range(5)], data=[{v: v * 10 for v in range(5)}], id=\"table\")\napp = dash.Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([dt, html.Button(\"Download\", id=\"btn\"), dcc.Download(id=\"download\")])\n\n@app.callback(Output(\"download\", \"data\"), [Input(\"btn\", \"n_clicks\")], [State(\"table\", \"data\")])\ndef download_table(n_clicks, data):\n    df = pd.DataFrame.from_records(data)\n    return dcc.send_data_frame(df.to_csv, \"some_data.csv\", index=False)\n\nif __name__ == \"__main__\":\n    app.run_server()",
            "masked_code": "import dash\nimport dash_html_components as html\nimport dash_core_components as dcc\nimport pandas as pd\nfrom dash.dependencies import Output, Input, State\nfrom dash_table import DataTable\n\ndt = DataTable(columns=[{\"id\": v, \"name\": v} for v in range(5)], data=[{v: v * 10 for v in range(5)}], id=\"table\")\napp = dash.Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([dt, html.Button(\"Download\", id=\"btn\"), dcc.Download(id=\"download\")])\n\n@app.callback(Output(\"download\", \"data\"), [Input(\"btn\", \"n_clicks\")], [State(\"table\", \"data\")])\ndef download_table(n_clicks, data):\n    df = pd.DataFrame.from_records(data)\n    return dcc.send_data_frame(df.to_csv, \"some_data.csv\", index=False)\n\nif __name__ == \"__main__\":\n    <line_mask>",
            "masked_line": "app.run_server()",
            "answer": "run_server",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_481"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-04-08",
            "description": "The code generates a figure with two subplots. The first subplot displays the distribution of the 'train' data using Seaborn. The second subplot displays a Q-Q plot of the 'train' data using SciPy.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\n\ntrain = [1,2,2,3,3,3,4,4,4,5,6]*2\n\nfig, ax = plt.subplots(1,2)\n\n#Distribution from seaborn\nsns.distplot(train, ax=ax[0]);\n\n#QQ-plot plot from stats\nstats.probplot(train, plot=ax[1])",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\n\ntrain = [1,2,2,3,3,3,4,4,4,5,6]*2\n\nfig, ax = plt.subplots(1,2)\n\n#Distribution from seaborn\nsns.distplot(train, ax=ax[0]);\n\n#QQ-plot plot from stats\n<line_mask>",
            "masked_line": "stats.probplot(train, plot=ax[1])",
            "answer": "probplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_482"
        },
        {
            "dependency": "django",
            "version": "==3.1.7",
            "time": "2021-03-31",
            "description": "This code defines a custom signup form class that extends the default SignupForm provided by Django allauth. The custom form includes fields for first name, last name, age, phone number, address, and gender. Additionally, it implements custom signup logic to save the user's input data to the User model in the database.",
            "code": "from django import forms\nfrom allauth.account.forms import SignupForm\nfrom .models import User\n\nclass MyCustomSignupForm(SignupForm):\n\n    def __init__(self, *args, **kwargs):\n        super(MyCustomSignupForm, self).__init__(*args, **kwargs)\n        first_name = forms.CharField(max_length=30, label='First Name')\n        last_name = forms.CharField(max_length=30, label='Last Name')\n        age = forms.CharField(max_length=30, label='Age')\n        phone = forms.CharField(max_length=30, label='Phone Number')\n        address = forms.CharField(max_length=30, label='Address')\n        gender = forms.CharField(max_length=30,label = 'Gender')\n\n    # Put in custom signup logic\n    def custom_signup(self, request, user):\n        # Set the user's type from the form reponse\n        user.first_name = self.cleaned_data['first_name']\n        user.last_name = self.cleaned_data['last_name']\n        user.age = self.cleaned_data['age']\n        user.phone = self.cleaned_data['phone']\n        user.address = self.cleaned_data['address']\n        user.gender = self.cleaned_data['gender']\n\n        # Save the user's type to their database record\n        user.save()",
            "masked_code": "from django import forms\nfrom allauth.account.forms import SignupForm\nfrom .models import User\n\nclass MyCustomSignupForm(SignupForm):\n\n    def __init__(self, *args, **kwargs):\n        super(MyCustomSignupForm, self).__init__(*args, **kwargs)\n        <line_mask>\n        last_name = forms.CharField(max_length=30, label='Last Name')\n        age = forms.CharField(max_length=30, label='Age')\n        phone = forms.CharField(max_length=30, label='Phone Number')\n        address = forms.CharField(max_length=30, label='Address')\n        gender = forms.CharField(max_length=30,label = 'Gender')\n\n    # Put in custom signup logic\n    def custom_signup(self, request, user):\n        # Set the user's type from the form reponse\n        user.first_name = self.cleaned_data['first_name']\n        user.last_name = self.cleaned_data['last_name']\n        user.age = self.cleaned_data['age']\n        user.phone = self.cleaned_data['phone']\n        user.address = self.cleaned_data['address']\n        user.gender = self.cleaned_data['gender']\n\n        # Save the user's type to their database record\n        user.save()",
            "masked_line": "first_name = forms.CharField(max_length=30, label='First Name')",
            "answer": "CharField",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_483"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-05-21",
            "description": "The code calculates the shortest path length between pairs of nodes in a given list and prints the results in a dictionary format.",
            "code": "from itertools import combinations\n\nH = nx.to_undirected(G)\n\nnodelist = [0,6,7,8]\npaths = {}\nfor nodes in combinations(nodelist, r=2):\n    paths[nodes] = nx.shortest_path_length(H, *nodes)\n\nprint(paths)\n# {(0, 6): 4, (0, 7): 3, (0, 8): 2, (6, 7): 1, (6, 8): 2, (7, 8): 1}",
            "masked_code": "from itertools import combinations\n\nH = nx.to_undirected(G)\n\nnodelist = [0,6,7,8]\npaths = {}\nfor nodes in combinations(nodelist, r=2):\n    <line_mask>\n\nprint(paths)\n# {(0, 6): 4, (0, 7): 3, (0, 8): 2, (6, 7): 1, (6, 8): 2, (7, 8): 1}",
            "masked_line": "paths[nodes] = nx.shortest_path_length(H, *nodes)",
            "answer": "shortest_path_length",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_484"
        },
        {
            "dependency": "bokeh",
            "version": "==2.0.1",
            "time": "2020-05-04",
            "description": "This code creates a Bokeh plot with a circle glyph, allows for user interaction by printing the indices of selected points when they are clicked on.",
            "code": "from bokeh import plotting as bplt\nfrom bokeh import layouts as blayouts\nfrom bokeh import models as bmodels\nfrom bokeh import io as bio\n\nfig = bplt.figure(tools=\"tap\")\n\nsource = bmodels.ColumnDataSource(dict(x=[0,1], y=[0,1]))\n\nr = fig.circle('x', 'y', source=source, size=10, color='#000000',\n        # set visual properties for selected glyphs\n                    selection_color=\"#2bff00\",\n\n                    # set visual properties for non-selected glyphs\n                    nonselection_fill_alpha=1.0,\n                    nonselection_fill_color=\"#000000\")\n\ndef handler(attr, old, new):\n    print('attr: {} old: {} new: {}'.format(attr, old, new))\n\n# r.data_source.on_change('selected', handler)\nr.data_source.selected.on_change('indices', handler)\n\nbio.curdoc().add_root(blayouts.layout([[fig]]))",
            "masked_code": "from bokeh import plotting as bplt\nfrom bokeh import layouts as blayouts\nfrom bokeh import models as bmodels\nfrom bokeh import io as bio\n\nfig = bplt.figure(tools=\"tap\")\n\nsource = bmodels.ColumnDataSource(dict(x=[0,1], y=[0,1]))\n\n<line_mask>\n        # set visual properties for selected glyphs\n                    selection_color=\"#2bff00\",\n\n                    # set visual properties for non-selected glyphs\n                    nonselection_fill_alpha=1.0,\n                    nonselection_fill_color=\"#000000\")\n\ndef handler(attr, old, new):\n    print('attr: {} old: {} new: {}'.format(attr, old, new))\n\n# r.data_source.on_change('selected', handler)\nr.data_source.selected.on_change('indices', handler)\n\nbio.curdoc().add_root(blayouts.layout([[fig]]))",
            "masked_line": "r = fig.circle('x', 'y', source=source, size=10, color='#000000',",
            "answer": "circle",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_485"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-09-21",
            "description": "The code sets up a TensorFlow session with GPU options to allow memory growth, and then initializes a Sequential classifier.",
            "code": "import tensorflow as tf\ngpuoptions = tf.compat.v1.GPUOptions(allow_growth=True)\nsession = tf.compat.v1.Session(config=tf.compat.v1.ConfigProto(gpu_options=gpuoptions))\nK.set_session(session)\nclassifier = Sequential()",
            "masked_code": "import tensorflow as tf\ngpuoptions = tf.compat.v1.GPUOptions(allow_growth=True)\n<line_mask>\nK.set_session(session)\nclassifier = Sequential()",
            "masked_line": "session = tf.compat.v1.Session(config=tf.compat.v1.ConfigProto(gpu_options=gpuoptions))",
            "answer": "ConfigProto",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_486"
        },
        {
            "dependency": "scipy",
            "version": ">=1.9",
            "time": "2022-02-02",
            "description": "This code uses the differential evolution optimization algorithm to minimize the Rosenbrock function within the given bounds. The maplike_fun function is defined to handle the function evaluation for the population of parameters x.",
            "code": "from scipy.optimize import rosen, differential_evolution\nbounds=[(0, 10), (0, 10)]\n\ndef maplike_fun(func, x):\n    # x.shape == (S, N), where S is the size of the population and N\n    # is the number of parameters. This is where you'd call out from\n    # Python to COMSOL, instead of the following line.\n    return func(x.T)\n\nres = differential_evolution(rosen, bounds, workers=maplike_fun, polish=False, updating='deferred')",
            "masked_code": "from scipy.optimize import rosen, differential_evolution\nbounds=[(0, 10), (0, 10)]\n\ndef maplike_fun(func, x):\n    # x.shape == (S, N), where S is the size of the population and N\n    # is the number of parameters. This is where you'd call out from\n    # Python to COMSOL, instead of the following line.\n    return func(x.T)\n\n<line_mask>",
            "masked_line": "res = differential_evolution(rosen, bounds, workers=maplike_fun, polish=False, updating='deferred')",
            "answer": "differential_evolution",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_487"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2020-12-15",
            "description": "This code generates a random time series data with 'demand', 'stock', and 'origin' columns, using a date range as the index. It then creates a bar plot using pandas, with custom tick labels displaying the day of the week for each date.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random time series with the date as index\n# In your case where you are importing your dataset from excel you\n# would assign your date column to the df index like this:\nrng = np.random.default_rng(123)\ndays = 7\ndf = pd.DataFrame(dict(demand = rng.uniform(100, size=days),\n                       stock = rng.uniform(100, size=days),\n                       origin = np.random.choice(list('ABCD'), days)),\n                  index = pd.date_range(start='2020-12-14', freq='D', periods=days))\n\n# Create pandas bar plot\nfig, ax = plt.subplots(figsize=(10,5))\ndf.plot.bar(ax=ax, color=['tab:blue', 'tab:orange'])\n\n# Assign ticks with custom tick labels\n# Date format codes for xticklabels:\n# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\nplt.xticks(ax.get_xticks(), [ts.strftime('%A') for ts in df.index], rotation=0)\nplt.legend(frameon=False)\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random time series with the date as index\n# In your case where you are importing your dataset from excel you\n# would assign your date column to the df index like this:\n<line_mask>\ndays = 7\ndf = pd.DataFrame(dict(demand = rng.uniform(100, size=days),\n                       stock = rng.uniform(100, size=days),\n                       origin = np.random.choice(list('ABCD'), days)),\n                  index = pd.date_range(start='2020-12-14', freq='D', periods=days))\n\n# Create pandas bar plot\nfig, ax = plt.subplots(figsize=(10,5))\ndf.plot.bar(ax=ax, color=['tab:blue', 'tab:orange'])\n\n# Assign ticks with custom tick labels\n# Date format codes for xticklabels:\n# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\nplt.xticks(ax.get_xticks(), [ts.strftime('%A') for ts in df.index], rotation=0)\nplt.legend(frameon=False)\nplt.show()",
            "masked_line": "rng = np.random.default_rng(123)",
            "answer": "default_rng",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_488"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2020-12-15",
            "description": "The code generates a random time series data with dates as index, where each day consists of demand, stock, and origin information. It then creates a bar plot using pandas to visually represent the data, with custom tick labels showing the day of the week.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random time series with the date as index\n# In your case where you are importing your dataset from excel you\n# would assign your date column to the df index like this:\nrng = np.random.default_rng(123)\ndays = 7\ndf = pd.DataFrame(dict(demand = rng.uniform(100, size=days),\n                       stock = rng.uniform(100, size=days),\n                       origin = np.random.choice(list('ABCD'), days)),\n                  index = pd.date_range(start='2020-12-14', freq='D', periods=days))\n\n# Create pandas bar plot\nfig, ax = plt.subplots(figsize=(10,5))\ndf.plot.bar(ax=ax, color=['tab:blue', 'tab:orange'])\n\n# Assign ticks with custom tick labels\n# Date format codes for xticklabels:\n# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\nplt.xticks(ax.get_xticks(), [ts.strftime('%A') for ts in df.index], rotation=0)\nplt.legend(frameon=False)\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random time series with the date as index\n# In your case where you are importing your dataset from excel you\n# would assign your date column to the df index like this:\nrng = np.random.default_rng(123)\ndays = 7\n<line_mask>\n                       stock = rng.uniform(100, size=days),\n                       origin = np.random.choice(list('ABCD'), days)),\n                  index = pd.date_range(start='2020-12-14', freq='D', periods=days))\n\n# Create pandas bar plot\nfig, ax = plt.subplots(figsize=(10,5))\ndf.plot.bar(ax=ax, color=['tab:blue', 'tab:orange'])\n\n# Assign ticks with custom tick labels\n# Date format codes for xticklabels:\n# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\nplt.xticks(ax.get_xticks(), [ts.strftime('%A') for ts in df.index], rotation=0)\nplt.legend(frameon=False)\nplt.show()",
            "masked_line": "df = pd.DataFrame(dict(demand = rng.uniform(100, size=days),",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_489"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2020-12-15",
            "description": "The code generates a random time series with specified columns and assigns the date as the index of the DataFrame. It then creates a bar plot using pandas to visualize the data, with custom tick labels for the dates in the x-axis.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random time series with the date as index\n# In your case where you are importing your dataset from excel you\n# would assign your date column to the df index like this:\nrng = np.random.default_rng(123)\ndays = 7\ndf = pd.DataFrame(dict(demand = rng.uniform(100, size=days),\n                       stock = rng.uniform(100, size=days),\n                       origin = np.random.choice(list('ABCD'), days)),\n                  index = pd.date_range(start='2020-12-14', freq='D', periods=days))\n\n# Create pandas bar plot\nfig, ax = plt.subplots(figsize=(10,5))\ndf.plot.bar(ax=ax, color=['tab:blue', 'tab:orange'])\n\n# Assign ticks with custom tick labels\n# Date format codes for xticklabels:\n# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\nplt.xticks(ax.get_xticks(), [ts.strftime('%A') for ts in df.index], rotation=0)\nplt.legend(frameon=False)\nplt.show()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create a random time series with the date as index\n# In your case where you are importing your dataset from excel you\n# would assign your date column to the df index like this:\nrng = np.random.default_rng(123)\ndays = 7\ndf = pd.DataFrame(dict(demand = rng.uniform(100, size=days),\n                       stock = rng.uniform(100, size=days),\n                       origin = np.random.choice(list('ABCD'), days)),\n                  index = pd.date_range(start='2020-12-14', freq='D', periods=days))\n\n# Create pandas bar plot\n<line_mask>\ndf.plot.bar(ax=ax, color=['tab:blue', 'tab:orange'])\n\n# Assign ticks with custom tick labels\n# Date format codes for xticklabels:\n# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\nplt.xticks(ax.get_xticks(), [ts.strftime('%A') for ts in df.index], rotation=0)\nplt.legend(frameon=False)\nplt.show()",
            "masked_line": "fig, ax = plt.subplots(figsize=(10,5))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_490"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.4",
            "time": "2020-11-16",
            "description": "This code generates an array of 50 random integers chosen from the range 1 to 20, using NumPy's random choice function. It sets the random seed to 42 for reproducibility.",
            "code": "import numpy as np\n\nnp.random.seed(42)  # for reproducibility\n\nresult = np.random.choice(np.arange(1, 21), 50)\nprint(result)",
            "masked_code": "import numpy as np\n\n<line_mask>\n\nresult = np.random.choice(np.arange(1, 21), 50)\nprint(result)",
            "masked_line": "np.random.seed(42)  # for reproducibility",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_491"
        },
        {
            "dependency": "plotly",
            "version": "==4.10.0",
            "time": "2020-09-13",
            "description": "This code creates a polar line plot using Plotly Express, displaying the values of 'r' along the 'theta' axis. The plot is then filled to create a closed shape and the layout is updated to customize the polar axes tick values and labels. Finally, the plot is displayed.",
            "code": "import plotly.express as px\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    r=[1, 5, 2, 2, 3],\n    theta=['processing cost', 'mechanical properties', 'chemical stability', 'thermal stability', 'device integration']))\n\nfig = px.line_polar(df, r='r', theta='theta', line_close=True)\nfig.update_traces(fill='toself')\n\nfig.update_layout(\n    polar = dict(\n        radialaxis = dict(tickvals=[0,1,2,3,4,5], showticklabels=True, ticks=''),\n        angularaxis = dict(showticklabels=True, ticks='')\n    )\n)\n\nfig.show()",
            "masked_code": "import plotly.express as px\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    r=[1, 5, 2, 2, 3],\n    theta=['processing cost', 'mechanical properties', 'chemical stability', 'thermal stability', 'device integration']))\n\nfig = px.line_polar(df, r='r', theta='theta', line_close=True)\n<line_mask>\n\nfig.update_layout(\n    polar = dict(\n        radialaxis = dict(tickvals=[0,1,2,3,4,5], showticklabels=True, ticks=''),\n        angularaxis = dict(showticklabels=True, ticks='')\n    )\n)\n\nfig.show()",
            "masked_line": "fig.update_traces(fill='toself')",
            "answer": "update_traces",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_492"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.1",
            "time": "2020-08-09",
            "description": "The code merges two randomly generated DataFrames based on a common column 'Numbers' using multiprocessing to speed up the process.",
            "code": "import concurrent.futures as cf\nimport multiprocessing\nimport random\nfrom collections import deque\n\nimport numpy as np\nimport pandas as pd\n\n\ndef merge_dfs(df1, df2):\n    return pd.merge(\n        df1, df2, on='Numbers', how='left'\n    )\n\n\ndef multiproc(df1, df2):\n    cpus = multiprocessing.cpu_count()\n    procs = deque()\n    df1_splits = np.array_split(df1, cpus)\n    df2_splits = np.array_split(df2, cpus)\n\n    with cf.ProcessPoolExecutor(max_workers=cpus) as executor:\n        for df1_slice, df2_slice in zip(df1_splits, df2_splits):\n            procs.append(\n                executor.submit(merge_dfs, df1_slice, df2_slice)\n            )\n\n    return (future.result() for future in cf.as_completed(procs))\n\n\ndef create_random_df():\n    return pd.DataFrame({\n        'Numbers': [n for n in range(1000)],\n        'Random Numbers': [random.randint(1, 9999) for _ in range(1000)],\n    })\n\n\nif __name__ == '__main__':\n\n    df1 = create_random_df()\n    df2 = create_random_df()\n\n    results = multiproc(df1, df2)\n\n    df3 = pd.DataFrame()\n    for df_slice in results:\n        df3 = df3.append(df_slice)\n    df3 = df3.sort_values(by='Numbers').reset_index(drop=True).copy()\n\n    print(df3)",
            "masked_code": "import concurrent.futures as cf\nimport multiprocessing\nimport random\nfrom collections import deque\n\nimport numpy as np\nimport pandas as pd\n\n\ndef merge_dfs(df1, df2):\n    return pd.merge(\n        df1, df2, on='Numbers', how='left'\n    )\n\n\ndef multiproc(df1, df2):\n    cpus = multiprocessing.cpu_count()\n    procs = deque()\n    df1_splits = np.array_split(df1, cpus)\n    <line_mask>\n\n    with cf.ProcessPoolExecutor(max_workers=cpus) as executor:\n        for df1_slice, df2_slice in zip(df1_splits, df2_splits):\n            procs.append(\n                executor.submit(merge_dfs, df1_slice, df2_slice)\n            )\n\n    return (future.result() for future in cf.as_completed(procs))\n\n\ndef create_random_df():\n    return pd.DataFrame({\n        'Numbers': [n for n in range(1000)],\n        'Random Numbers': [random.randint(1, 9999) for _ in range(1000)],\n    })\n\n\nif __name__ == '__main__':\n\n    df1 = create_random_df()\n    df2 = create_random_df()\n\n    results = multiproc(df1, df2)\n\n    df3 = pd.DataFrame()\n    for df_slice in results:\n        df3 = df3.append(df_slice)\n    df3 = df3.sort_values(by='Numbers').reset_index(drop=True).copy()\n\n    print(df3)",
            "masked_line": "df2_splits = np.array_split(df2, cpus)",
            "answer": "array_split",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_493"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.0",
            "time": "2020-08-09",
            "description": "This code merges two randomly generated DataFrames on the 'Numbers' column using a multiprocessing approach, splitting the DataFrames into multiple slices and merging them concurrently on multiple CPU cores. The final merged DataFrame is sorted by the 'Numbers' column and printed to the console.",
            "code": "import concurrent.futures as cf\nimport multiprocessing\nimport random\nfrom collections import deque\n\nimport numpy as np\nimport pandas as pd\n\n\ndef merge_dfs(df1, df2):\n    return pd.merge(\n        df1, df2, on='Numbers', how='left'\n    )\n\n\ndef multiproc(df1, df2):\n    cpus = multiprocessing.cpu_count()\n    procs = deque()\n    df1_splits = np.array_split(df1, cpus)\n    df2_splits = np.array_split(df2, cpus)\n\n    with cf.ProcessPoolExecutor(max_workers=cpus) as executor:\n        for df1_slice, df2_slice in zip(df1_splits, df2_splits):\n            procs.append(\n                executor.submit(merge_dfs, df1_slice, df2_slice)\n            )\n\n    return (future.result() for future in cf.as_completed(procs))\n\n\ndef create_random_df():\n    return pd.DataFrame({\n        'Numbers': [n for n in range(1000)],\n        'Random Numbers': [random.randint(1, 9999) for _ in range(1000)],\n    })\n\n\nif __name__ == '__main__':\n\n    df1 = create_random_df()\n    df2 = create_random_df()\n\n    results = multiproc(df1, df2)\n\n    df3 = pd.DataFrame()\n    for df_slice in results:\n        df3 = df3.append(df_slice)\n    df3 = df3.sort_values(by='Numbers').reset_index(drop=True).copy()\n\n    print(df3)",
            "masked_code": "import concurrent.futures as cf\nimport multiprocessing\nimport random\nfrom collections import deque\n\nimport numpy as np\nimport pandas as pd\n\n\ndef merge_dfs(df1, df2):\n    return pd.merge(\n        df1, df2, on='Numbers', how='left'\n    )\n\n\ndef multiproc(df1, df2):\n    cpus = multiprocessing.cpu_count()\n    procs = deque()\n    df1_splits = np.array_split(df1, cpus)\n    df2_splits = np.array_split(df2, cpus)\n\n    with cf.ProcessPoolExecutor(max_workers=cpus) as executor:\n        for df1_slice, df2_slice in zip(df1_splits, df2_splits):\n            procs.append(\n                executor.submit(merge_dfs, df1_slice, df2_slice)\n            )\n\n    return (future.result() for future in cf.as_completed(procs))\n\n\ndef create_random_df():\n    return pd.DataFrame({\n        'Numbers': [n for n in range(1000)],\n        'Random Numbers': [random.randint(1, 9999) for _ in range(1000)],\n    })\n\n\nif __name__ == '__main__':\n\n    df1 = create_random_df()\n    df2 = create_random_df()\n\n    results = multiproc(df1, df2)\n\n    df3 = pd.DataFrame()\n    for df_slice in results:\n        <line_mask>\n    df3 = df3.sort_values(by='Numbers').reset_index(drop=True).copy()\n\n    print(df3)",
            "masked_line": "df3 = df3.append(df_slice)",
            "answer": "append",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_494"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-07-27",
            "description": "This code calculates the number of nonzero elements in the array resulting from comparing two arrays element-wise.",
            "code": "import tensorflow as tf\n\ny_actual = [[1,2],[3,4]]\ny_prediction = [[1,0],[3,4]]\n\nprint(tf.math.count_nonzero(tf.equal(y_actual,y_prediction)))",
            "masked_code": "import tensorflow as tf\n\ny_actual = [[1,2],[3,4]]\ny_prediction = [[1,0],[3,4]]\n\n<line_mask>",
            "masked_line": "print(tf.math.count_nonzero(tf.equal(y_actual,y_prediction)))",
            "answer": "math",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_495"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-06-03",
            "description": "The code converts the array 'a' into a one-hot encoded matrix with 23 classes.",
            "code": "import tensorflow as tf\nimport numpy as np\na = np.array([3, 2, 4, 1, 8, 3, 7, 11])\ntf.keras.utils.to_categorical(a, num_classes=23)",
            "masked_code": "import tensorflow as tf\nimport numpy as np\na = np.array([3, 2, 4, 1, 8, 3, 7, 11])\n<line_mask>",
            "masked_line": "tf.keras.utils.to_categorical(a, num_classes=23)",
            "answer": "to_categorical",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_496"
        },
        {
            "dependency": "scipy",
            "version": "==0.15.1",
            "time": "2020-05-09",
            "description": "This code reads in an image in grayscale where blobs are assumed to be at pixel value 255 and background at pixel value 0. It then fills any holes within the blobs in the image and saves the resulting image as 'out.png'.",
            "code": "import numpy as np\nimport cv2\nfrom scipy.ndimage.morphology import binary_fill_holes\n\n# Read in image as grayscale and assuming blobs are at 255 and background at 0\nim = cv2.imread('boxes.png',0)\n\ncv2.imwrite('out.png', (binary_fill_holes(im)*255).astype(np.uint8))",
            "masked_code": "import numpy as np\nimport cv2\n<line_mask>\n\n# Read in image as grayscale and assuming blobs are at 255 and background at 0\nim = cv2.imread('boxes.png',0)\n\ncv2.imwrite('out.png', (binary_fill_holes(im)*255).astype(np.uint8))",
            "masked_line": "from scipy.ndimage.morphology import binary_fill_holes",
            "answer": "binary_fill_holes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_497"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-05-01",
            "description": "This code calculates the eccentricity of each node in a graph G, finds the maximum eccentricity value, and then identifies the nodes that have that maximum eccentricity value as potential extremities.",
            "code": "ecc = nx.eccentricity(G)\ndiam = max(ecc.values())\nextrema_cand = [node for node, length in ecc.items() if length==diam]",
            "masked_code": "ecc = nx.eccentricity(G)\ndiam = max(ecc.values())\n<line_mask>",
            "masked_line": "extrema_cand = [node for node, length in ecc.items() if length==diam]",
            "answer": "items",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_498"
        },
        {
            "dependency": "tf-model-official",
            "version": "==2.5.0",
            "time": "2021-06-20",
            "description": "The code predicts ratings for user 1 with item IDs 1, 2, 3, 4, and 5 using a pre-trained model that has been modified to remove the loss and metric layers.",
            "code": "from tensorflow.keras import Model\nimport tensorflow as tf\n\ninputUserIds = keras_model.input['user_id']\ninputItemIds = keras_model.input['item_id']\n# Cut off the unnecessary parts of the model for predictions.\n# Specifically, we're removing the loss and metric layers in the architecture.\n# Note: we are not training a new model, just taking the parts of the model we need.\noutputs = keras_model.get_layer('rating').output\nnewModel = Model(inputs=[inputUserIds, inputItemIds], outputs=outputs)\n\n## Make predictions for user 1 with items ids 1, 2, 3, 4, 5\n# Make a user. Each row will be user_id 1. The shape of this tensor is (5,1)\nuserIds = tf.constant([1, 1, 1, 1, 1])[:, tf.newaxis]\n# Make a tensor of items. Each row will be different item ids. The shape of this tensor is (5,1)\nitemIds = tf.constant([1,2,3,4,5])[:, tf.newaxis]\n\n# Make preds. This predicts for user id 1 and items ids 1,2,3,4,5.\npreds = newModel.predict(x=[userIds, itemIds])",
            "masked_code": "from tensorflow.keras import Model\nimport tensorflow as tf\n\ninputUserIds = keras_model.input['user_id']\ninputItemIds = keras_model.input['item_id']\n# Cut off the unnecessary parts of the model for predictions.\n# Specifically, we're removing the loss and metric layers in the architecture.\n# Note: we are not training a new model, just taking the parts of the model we need.\noutputs = keras_model.get_layer('rating').output\nnewModel = Model(inputs=[inputUserIds, inputItemIds], outputs=outputs)\n\n## Make predictions for user 1 with items ids 1, 2, 3, 4, 5\n# Make a user. Each row will be user_id 1. The shape of this tensor is (5,1)\nuserIds = tf.constant([1, 1, 1, 1, 1])[:, tf.newaxis]\n# Make a tensor of items. Each row will be different item ids. The shape of this tensor is (5,1)\nitemIds = tf.constant([1,2,3,4,5])[:, tf.newaxis]\n\n# Make preds. This predicts for user id 1 and items ids 1,2,3,4,5.\n<line_mask>",
            "masked_line": "preds = newModel.predict(x=[userIds, itemIds])",
            "answer": "predict",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_499"
        },
        {
            "dependency": "pandas",
            "version": "==1.x",
            "time": "2020-03-06",
            "description": "The code retrieves data from a nested JSON structure, normalizes it into a DataFrame, and concatenates the results into a single DataFrame. It then outputs information about the DataFrame.",
            "code": "# for older versions of pandas import json_normalize like so:\n# from pandas.io.json import json_normalize\n\n# use this for pandas version 1.x\nfrom pandas import json_normalize\nframes = []\n\nfor idx in range(len(a)):\n    for estate in (a[idx][\"_embedded\"][\"estates\"]):\n        frames.append(json_normalize(estate))\n\ndf_estates = pd.concat(frames)\ndf_estates.info()",
            "masked_code": "# for older versions of pandas import json_normalize like so:\n# from pandas.io.json import json_normalize\n\n# use this for pandas version 1.x\n<line_mask>\nframes = []\n\nfor idx in range(len(a)):\n    for estate in (a[idx][\"_embedded\"][\"estates\"]):\n        frames.append(json_normalize(estate))\n\ndf_estates = pd.concat(frames)\ndf_estates.info()",
            "masked_line": "from pandas import json_normalize",
            "answer": "json_normalize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_500"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-03-25",
            "description": "The code loads a pre-trained Keras model saved in a .h5 file using TensorFlow, prints a summary of the loaded model, and then prints a summary of each layer in the model.",
            "code": "import tensorflow as tf\nprint('Running Tensorflow version {}'.format(tf.__version__)) # Tensorflow 2.1.0\n\nmodel_path = '/content/keras_model.h5'\n\nloaded_model = tf.keras.models.load_model(model_path)\nloaded_model.summary()\n\ninp = loaded_model.input   \nlayer_summary = [layer.summary() for layer in loaded_model.layers]",
            "masked_code": "import tensorflow as tf\nprint('Running Tensorflow version {}'.format(tf.__version__)) # Tensorflow 2.1.0\n\nmodel_path = '/content/keras_model.h5'\n\n<line_mask>\nloaded_model.summary()\n\ninp = loaded_model.input   \nlayer_summary = [layer.summary() for layer in loaded_model.layers]",
            "masked_line": "loaded_model = tf.keras.models.load_model(model_path)",
            "answer": "load_model",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_501"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.4.1",
            "time": "2020-03-13",
            "description": "This code saves a checkpoint of the current session, then writes the graph in a pbtxt file, and finally creates a frozen graph by combining the checkpoint and the pbtxt file.",
            "code": "import vggish_input\nfrom tensorflow.python.tools import freeze_graph\ndef save(sess, directory, filename, saver):\n    \"\"\"\n    This function saves a checkpoint, based on the current session\n    \"\"\"\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    filepath = os.path.join(directory, filename)\n    saver.save(sess, filepath)\n    return filepath\n\ndef save_as_pb(sess, directory, filename, saver):\n    \"\"\"\n    This function saves a checkpoint, then writes the graph in a pbtxt, and then              makes a frozen graph with the chekpoint and the pbtxt\n    \"\"\"\n\n    # Save checkpoint to freeze graph later\n    ckpt_filepath = save(sess, directory=directory, filename=filename, saver=saver)\n    pbtxt_filename = filename + '.pbtxt'\n    pbtxt_filepath = os.path.join(directory, pbtxt_filename)\n    pb_filepath = os.path.join(directory, filename + '.pb')\n\n    # This will only save the graph but the variables will not be saved.\n    tf.train.write_graph(graph_or_graph_def=sess.graph_def, logdir=directory, name=pbtxt_filename, as_text=True)\n\n    # Freeze graph, combining the checkpoint and \n    freeze_graph.freeze_graph(input_graph=pbtxt_filepath, input_saver='', input_binary=False, input_checkpoint=ckpt_filepath, output_node_names=vggish_params.OUTPUT_TENSOR_NAME.split(':')[0], restore_op_name='save/restore_all', filename_tensor_name='save/Const:0', output_graph=pb_filepath, clear_devices=True, initializer_nodes='')\n\n    return pb_filepath",
            "masked_code": "import vggish_input\nfrom tensorflow.python.tools import freeze_graph\ndef save(sess, directory, filename, saver):\n    \"\"\"\n    This function saves a checkpoint, based on the current session\n    \"\"\"\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    filepath = os.path.join(directory, filename)\n    saver.save(sess, filepath)\n    return filepath\n\ndef save_as_pb(sess, directory, filename, saver):\n    \"\"\"\n    This function saves a checkpoint, then writes the graph in a pbtxt, and then              makes a frozen graph with the chekpoint and the pbtxt\n    \"\"\"\n\n    # Save checkpoint to freeze graph later\n    ckpt_filepath = save(sess, directory=directory, filename=filename, saver=saver)\n    pbtxt_filename = filename + '.pbtxt'\n    pbtxt_filepath = os.path.join(directory, pbtxt_filename)\n    pb_filepath = os.path.join(directory, filename + '.pb')\n\n    # This will only save the graph but the variables will not be saved.\n    tf.train.write_graph(graph_or_graph_def=sess.graph_def, logdir=directory, name=pbtxt_filename, as_text=True)\n\n    # Freeze graph, combining the checkpoint and \n    <line_mask>\n\n    return pb_filepath",
            "masked_line": "freeze_graph.freeze_graph(input_graph=pbtxt_filepath, input_saver='', input_binary=False, input_checkpoint=ckpt_filepath, output_node_names=vggish_params.OUTPUT_TENSOR_NAME.split(':')[0], restore_op_name='save/restore_all', filename_tensor_name='save/Const:0', output_graph=pb_filepath, clear_devices=True, initializer_nodes='')",
            "answer": "freeze_graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_502"
        },
        {
            "dependency": "StyleFrame",
            "version": "==2.0.5",
            "time": "2020-01-02",
            "description": "This code reads an Excel file and creates a StyleFrame object. It filters out cells that have a white or 'FFFFFFFF' background color and replaces them with NaN values. Finally, it prints the cleaned StyleFrame object.",
            "code": "from StyleFrame import StyleFrame, utils\n\ndef only_cells_with_colored_background(cell):\n    return cell if cell.style.bg_color not in {utils.colors.white, 'FFFFFFFF'} else np.nan\n\nsf = StyleFrame.read_excel('test.xlsx', read_style=True, skip_blank_lines=False)\nsf = StyleFrame(sf.applymap(only_cells_with_colored_background).dropna(axis=(0, 1),\n                how='all'))\nprint(sf)",
            "masked_code": "from StyleFrame import StyleFrame, utils\n\ndef only_cells_with_colored_background(cell):\n    return cell if cell.style.bg_color not in {utils.colors.white, 'FFFFFFFF'} else np.nan\n\nsf = StyleFrame.read_excel('test.xlsx', read_style=True, skip_blank_lines=False)\n<line_mask>\n                how='all'))\nprint(sf)",
            "masked_line": "sf = StyleFrame(sf.applymap(only_cells_with_colored_background).dropna(axis=(0, 1),",
            "answer": "dropna",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_503"
        },
        {
            "dependency": "discord.py",
            "version": "==1.5.1",
            "time": "2020-10-20",
            "description": "The code initializes a Discord bot with all intents enabled and a specified command prefix.",
            "code": "from discord import Intents\nfrom discord.ext.commands import Bot\n\nintent = Intents().all()\n\nbot = Bot(command_prefix='prefix', intents=intent)\n\n... # Some code under this line",
            "masked_code": "from discord import Intents\nfrom discord.ext.commands import Bot\n\n<line_mask>\n\nbot = Bot(command_prefix='prefix', intents=intent)\n\n... # Some code under this line",
            "masked_line": "intent = Intents().all()",
            "answer": "all",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_504"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.5",
            "time": "2020-07-05",
            "description": "This code converts a list of strings representing dates in the format day/month/year into datetime objects in the format year-month-day.",
            "code": "import pandas as pd\n\ns = pd.Series([\"15/01/1967\", \"14/01/1968\", \"12/01/1969\"])\n\npd.to_datetime(s, format='%d/%m/%Y')\n\n# 0   1967-01-15\n# 1   1968-01-14\n# 2   1969-01-12\n# dtype: datetime64[ns]",
            "masked_code": "import pandas as pd\n\n<line_mask>\n\npd.to_datetime(s, format='%d/%m/%Y')\n\n# 0   1967-01-15\n# 1   1968-01-14\n# 2   1969-01-12\n# dtype: datetime64[ns]",
            "masked_line": "s = pd.Series([\"15/01/1967\", \"14/01/1968\", \"12/01/1969\"])",
            "answer": "Series",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_505"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-03-23",
            "description": "The code creates tensors with complex values and performs inverse FFT (Fast Fourier Transform) operations on the concatenated tensors for verification purposes.",
            "code": "import tensorflow as tf\nprint('TensorFlow Version : {}'.format(tf.__version__)) # Using TensorFlow 2.1.0\n\nBATCH_SIZE = 64\n\nnol = tf.zeros([BATCH_SIZE,1,12],tf.complex64)\npv = tf.fill([BATCH_SIZE,1,8],3+3j)\npv = tf.cast(pv,dtype=tf.complex64)\n\n#Assuming your data X based on your error\nx = tf.zeros([BATCH_SIZE,1,32],tf.complex64)\n\n# Verification 1\ntf.signal.ifft(tf.concat([nol,x,pv,nol],axis=-1)) \n\n# Verification 2\ntf.keras.layers.Lambda(lambda x : tf.signal.ifft(tf.concat([nol,x,pv,nol],axis=-1)), output_shape=(1,64))(x)",
            "masked_code": "import tensorflow as tf\nprint('TensorFlow Version : {}'.format(tf.__version__)) # Using TensorFlow 2.1.0\n\nBATCH_SIZE = 64\n\nnol = tf.zeros([BATCH_SIZE,1,12],tf.complex64)\n<line_mask>\npv = tf.cast(pv,dtype=tf.complex64)\n\n#Assuming your data X based on your error\nx = tf.zeros([BATCH_SIZE,1,32],tf.complex64)\n\n# Verification 1\ntf.signal.ifft(tf.concat([nol,x,pv,nol],axis=-1)) \n\n# Verification 2\ntf.keras.layers.Lambda(lambda x : tf.signal.ifft(tf.concat([nol,x,pv,nol],axis=-1)), output_shape=(1,64))(x)",
            "masked_line": "pv = tf.fill([BATCH_SIZE,1,8],3+3j)",
            "answer": "fill",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_506"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-03-17",
            "description": "The code loads a pre-trained model from a file, skips compiling the model to retain the optimizer state, and then fits the model on new data for further training.",
            "code": "from tensorflow.python.keras.models import load_model #Tensorflow 2.0\n\nnew_model.compile(loss='categorical_crossentropy', optimizer=opt,metrics=['accuracy'])\nnew_model = load_model(filepath, compile=False) #compile=False allows you to load saved optimizer state\n\nnew_model.fit(...) # Fit on new data, leveraging training on old data",
            "masked_code": "from tensorflow.python.keras.models import load_model #Tensorflow 2.0\n\n<line_mask>\nnew_model = load_model(filepath, compile=False) #compile=False allows you to load saved optimizer state\n\nnew_model.fit(...) # Fit on new data, leveraging training on old data",
            "masked_line": "new_model.compile(loss='categorical_crossentropy', optimizer=opt,metrics=['accuracy'])",
            "answer": "compile",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_507"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.2.1",
            "time": "2020-06-04",
            "description": "This code generates a heatmap showing the Spearman correlation between two lists of values provided for A and B, respectively.",
            "code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\nsns.heatmap(corr, annot = True)\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\nsns.heatmap(corr, annot = True)\n\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_508"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.4",
            "time": "2020-06-04",
            "description": "The code generates a heatmap to visualize the Spearman correlation between two lists of values (A and B) in a DataFrame using pandas, seaborn, and matplotlib in Python.",
            "code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\nsns.heatmap(corr, annot = True)\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\n<line_mask>\n\nplt.show()",
            "masked_line": "sns.heatmap(corr, annot = True)",
            "answer": "corr",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_509"
        },
        {
            "dependency": "seaborn",
            "version": "==0.10.1",
            "time": "2020-06-04",
            "description": "This code generates a heatmap visualization of the Spearman correlation between two lists of values A and B.",
            "code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\nsns.heatmap(corr, annot = True)\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\n<line_mask>\n\nplt.show()",
            "masked_line": "sns.heatmap(corr, annot = True)",
            "answer": "heatmap",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_510"
        },
        {
            "dependency": "reportlab",
            "version": "==3.5.36",
            "time": "2020-11-16",
            "description": "The code generates a PDF document with a table containing data in multiple rows and columns. The table has specific styles like font size, grid lines, alignment, and padding. The PDF document has a page title and date displayed at the top.",
            "code": "from reportlab.lib.units import cm\nfrom reportlab.lib.pagesizes import A4, landscape\nfrom reportlab.platypus import Table, TableStyle\nfrom reportlab.platypus import SimpleDocTemplate\nfrom reportlab.lib import colors\n\ndef func(canvas, doc):\n    canvas.saveState()\n\n    canvas.setFont(\"Helvetica\", 12)\n    (width, height) = landscape(A4)\n    canvas.drawCentredString(width / 2.0, height - 1.2 * cm, \"PAGE TITLE\")\n    canvas.drawRightString(width - 1 * cm, height - 1.2 * cm, \"01/01/2021\")\n\n    canvas.restoreState()\n    return func\n\ndef create_pdf():\n    story = []\n    data = [['Data1', 'Data2', 'Data3', 'Data4', 'Data5', 'Data6', 'Data7', 'Data8', 'Data9', 'Data10'],\n            ['0.2', '-0.1', '0', '0', '-0.5', '0.6','0.2', '-0.1', '0', '0']]*200\n\n    colwidths = (70)\n    rowheights = (12)\n\n    t = Table(data, colwidths, rowheights)\n\n    GRID_STYLE = TableStyle(\n        [('FONTSIZE', (0, 0), (-1, -1), 5),\n         ('GRID', (0, 0), (-1, -1), 0.5, colors.black),\n         ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n         ('LEFTPADDING', (0, 0), (-1, -1), 0),\n         ('RIGHTPADDING', (0, 0), (-1, -1), 0),\n         ('TOPPADDING', (0, 0), (-1, -1), 0),\n         ('BOTTOMPADDING', (0, 0), (-1, -1), 2),\n         ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),\n         ('SIZE', (0, 0), (-1, -1), 8),\n         ('LEADING', (0, 0), (-1, -1), 8.2),\n         ]\n    )\n\n    t.setStyle(GRID_STYLE)\n    story.append(t)\n\n    doc = SimpleDocTemplate('mydoc.pdf', pagesize=landscape(A4), topMargin=50)\n    doc.build(story, onFirstPage=func, onLaterPages=func)\n\n    # ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    create_pdf()  # Printing the pdf",
            "masked_code": "from reportlab.lib.units import cm\nfrom reportlab.lib.pagesizes import A4, landscape\nfrom reportlab.platypus import Table, TableStyle\nfrom reportlab.platypus import SimpleDocTemplate\nfrom reportlab.lib import colors\n\ndef func(canvas, doc):\n    canvas.saveState()\n\n    canvas.setFont(\"Helvetica\", 12)\n    (width, height) = landscape(A4)\n    canvas.drawCentredString(width / 2.0, height - 1.2 * cm, \"PAGE TITLE\")\n    canvas.drawRightString(width - 1 * cm, height - 1.2 * cm, \"01/01/2021\")\n\n    canvas.restoreState()\n    return func\n\ndef create_pdf():\n    story = []\n    data = [['Data1', 'Data2', 'Data3', 'Data4', 'Data5', 'Data6', 'Data7', 'Data8', 'Data9', 'Data10'],\n            ['0.2', '-0.1', '0', '0', '-0.5', '0.6','0.2', '-0.1', '0', '0']]*200\n\n    colwidths = (70)\n    rowheights = (12)\n\n    t = Table(data, colwidths, rowheights)\n\n    GRID_STYLE = TableStyle(\n        [('FONTSIZE', (0, 0), (-1, -1), 5),\n         ('GRID', (0, 0), (-1, -1), 0.5, colors.black),\n         ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n         ('LEFTPADDING', (0, 0), (-1, -1), 0),\n         ('RIGHTPADDING', (0, 0), (-1, -1), 0),\n         ('TOPPADDING', (0, 0), (-1, -1), 0),\n         ('BOTTOMPADDING', (0, 0), (-1, -1), 2),\n         ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),\n         ('SIZE', (0, 0), (-1, -1), 8),\n         ('LEADING', (0, 0), (-1, -1), 8.2),\n         ]\n    )\n\n    t.setStyle(GRID_STYLE)\n    story.append(t)\n\n    <line_mask>\n    doc.build(story, onFirstPage=func, onLaterPages=func)\n\n    # ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    create_pdf()  # Printing the pdf",
            "masked_line": "doc = SimpleDocTemplate('mydoc.pdf', pagesize=landscape(A4), topMargin=50)",
            "answer": "SimpleDocTemplate",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_511"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.1",
            "time": "2020-03-21",
            "description": "The code checks if each element in the array 'a' is equal to the unique integers in 'a' and returns a boolean array for each unique integer.",
            "code": "import numpy as np\na=np.array([[1, 2, 3, 3], [1, 1, 2, 1], [3, 2, 2, 3], [1, 3, 3, 2]])\n\n[a==i.astype(int) for i in np.unique(a)]",
            "masked_code": "import numpy as np\na=np.array([[1, 2, 3, 3], [1, 1, 2, 1], [3, 2, 2, 3], [1, 3, 3, 2]])\n\n<line_mask>",
            "masked_line": "[a==i.astype(int) for i in np.unique(a)]",
            "answer": "unique",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_512"
        },
        {
            "dependency": "spacy",
            "version": "==3.0",
            "time": "2021-03-20",
            "description": "The code detects the language of the input text using a language detector implemented in the spacy library.",
            "code": "import spacy\nfrom spacy.language import Language\nfrom spacy_langdetect import LanguageDetector\n\ndef get_lang_detector(nlp, name):\n    return LanguageDetector()\n\nnlp = spacy.load(\"en_core_web_sm\")\nLanguage.factory(\"language_detector\", func=get_lang_detector)\nnlp.add_pipe('language_detector', last=True)\ntext = 'This is an english text.'\ndoc = nlp(text)\nprint(doc._.language)",
            "masked_code": "import spacy\nfrom spacy.language import Language\nfrom spacy_langdetect import LanguageDetector\n\ndef get_lang_detector(nlp, name):\n    return LanguageDetector()\n\n<line_mask>\nLanguage.factory(\"language_detector\", func=get_lang_detector)\nnlp.add_pipe('language_detector', last=True)\ntext = 'This is an english text.'\ndoc = nlp(text)\nprint(doc._.language)",
            "masked_line": "nlp = spacy.load(\"en_core_web_sm\")",
            "answer": "load",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_513"
        },
        {
            "dependency": "transformers",
            "version": "==3.0.2",
            "time": "2021-10-11",
            "description": "The code performs feature extraction on a list of sentences using the DistilRoBERTa-base model and tokenizer.",
            "code": "from transformers import pipeline\n\nfeature_extraction = pipeline('feature-extraction', model=\"distilroberta-base\", tokenizer=\"distilroberta-base\")\nfeatures = feature_extraction([\"Hello I'm a single sentence\",\n                               \"And another sentence\",\n                               \"And the very very last one\"])",
            "masked_code": "<line_mask>\n\nfeature_extraction = pipeline('feature-extraction', model=\"distilroberta-base\", tokenizer=\"distilroberta-base\")\nfeatures = feature_extraction([\"Hello I'm a single sentence\",\n                               \"And another sentence\",\n                               \"And the very very last one\"])",
            "masked_line": "from transformers import pipeline",
            "answer": "pipeline",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_514"
        },
        {
            "dependency": "pyarrow",
            "version": "==10.0.1",
            "time": "2023-01-11",
            "description": "This code converts a CSV file ('box.csv') to a pandas DataFrame, then parses and converts the 'SETTLEMENTDATE' column to datetime format. It creates a new column 'Date' with only the date part of 'SETTLEMENTDATE'. Next, it converts the DataFrame to a pyarrow table and writes it to a Parquet dataset ('nem.parquet') with partitioning based on the 'Date' column. If there are existing matching data, it deletes them before writing the new data.",
            "code": "import pandas as pd\nimport pyarrow as pa\nimport pyarrow.parquet as pq\n\n\ndf = pd.read_csv('box.csv',parse_dates=True)\ndf['SETTLEMENTDATE'] = pd.to_datetime(df['SETTLEMENTDATE'])\ndf['Date'] = df['SETTLEMENTDATE'].dt.date\n\n# convert to pyarrow table\ndf_pa = pa.Table.from_pandas(df)\n\npq.write_to_dataset(df_pa,\n  root_path = 'nem.parquet',\n  partition_cols = ['Date'],\n  basename_template = \"part-{i}.parquet\",\n  existing_data_behavior = 'delete_matching')",
            "masked_code": "import pandas as pd\nimport pyarrow as pa\nimport pyarrow.parquet as pq\n\n\ndf = pd.read_csv('box.csv',parse_dates=True)\ndf['SETTLEMENTDATE'] = pd.to_datetime(df['SETTLEMENTDATE'])\ndf['Date'] = df['SETTLEMENTDATE'].dt.date\n\n# convert to pyarrow table\ndf_pa = pa.Table.from_pandas(df)\n\n<line_mask>\n  root_path = 'nem.parquet',\n  partition_cols = ['Date'],\n  basename_template = \"part-{i}.parquet\",\n  existing_data_behavior = 'delete_matching')",
            "masked_line": "pq.write_to_dataset(df_pa,",
            "answer": "write_to_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_515"
        },
        {
            "dependency": "openmdao",
            "version": ">=3.6.0",
            "time": "2021-02-06",
            "description": "The code defines a custom OpenMDAO component called VectorChain, which takes in a vector size and step size as options. It sets up inputs and outputs for an array of data, with the ability to pass an index as a float. The compute method updates the output array based on the input array and specified step size, with modifications to the data array based on certain conditions. Finally, the code sets up a Problem instance with three instances of VectorChain connected in a chain, runs the model, and lists the outputs.",
            "code": "import numpy as np\nimport openmdao.api as om\n\n\nclass VectorChain(om.ExplicitComponent): \n\n    def initialize(self):\n        self.options.declare('vec_size', types=int)\n        self.options.declare('step_size', types=int)\n\n    def setup(self): \n        vec_size = self.options['vec_size']\n        step_size = self.options['vec_size']\n\n        # this is the index of the last valid value in the data array\n        self.add_input('in_idx', shape=1, val=0) \n        # NOTE: though this could be done as a discrete variable, \n        # that will confuse OpenMDAO's derivative system, so just pass it as a float. \n\n        # actual data array\n        self.add_input('in_vec', shape=vec_size, val=np.zeros(vec_size))\n\n        self.add_output('out_idx', shape=1)\n        self.add_output('out_vec', shape=vec_size)\n\n        # NOTES: You do **NOT** define derivatives wrt the idx variable!! \n        self.declare_partials('out_vec', 'in_vec', method='CS')\n\n    def compute(self, inputs, outputs): \n\n        in_vec = inputs['in_vec']\n        out_vec = outputs['out_vec']\n        \n        out_vec[:] = in_vec.copy()\n\n        # always use the first two entries to\n        # indicate the start/end of the valid data\n        i_start_idx = int(inputs['in_idx'])\n        i_end_idx = i_start_idx + self.options['step_size']\n        i_size = i_end_idx - i_start_idx\n\n        if i_start_idx == 0: \n            out_vec[0] = 1 # get the counting started\n            i_start_idx = 1\n\n        # note: careful to account for the open end of the  \n        # interval when computing the end_idx value\n        # print(self.pathname)\n        for i in range(i_start_idx,i_start_idx+self.options['step_size']): \n            out_vec[i] = out_vec[i-1] + 1\n\n        o_end_idx = i_start_idx + i_size\n\n        outputs['out_idx'] = o_end_idx\n\n\nif __name__ == \"__main__\": \n\n    p = om.Problem()\n\n    VEC_SIZE = 12\n    STEP_SIZE = 3\n\n    c0 = p.model.add_subsystem('c0', VectorChain(vec_size=VEC_SIZE, step_size=STEP_SIZE))\n    c1 = p.model.add_subsystem('c1', VectorChain(vec_size=VEC_SIZE, step_size=STEP_SIZE))\n    c2 = p.model.add_subsystem('c2', VectorChain(vec_size=VEC_SIZE, step_size=STEP_SIZE))\n\n    p.model.connect('c0.out_idx', 'c1.in_idx')\n    p.model.connect('c0.out_vec', 'c1.in_vec')\n\n    p.model.connect('c1.out_idx', 'c2.in_idx')\n    p.model.connect('c1.out_vec', 'c2.in_vec')\n\n\n    p.setup()\n\n    p.run_model()\n\n    p.model.list_outputs(print_arrays=True)",
            "masked_code": "import numpy as np\nimport openmdao.api as om\n\n\nclass VectorChain(om.ExplicitComponent): \n\n    def initialize(self):\n        self.options.declare('vec_size', types=int)\n        self.options.declare('step_size', types=int)\n\n    def setup(self): \n        vec_size = self.options['vec_size']\n        step_size = self.options['vec_size']\n\n        # this is the index of the last valid value in the data array\n        self.add_input('in_idx', shape=1, val=0) \n        # NOTE: though this could be done as a discrete variable, \n        # that will confuse OpenMDAO's derivative system, so just pass it as a float. \n\n        # actual data array\n        self.add_input('in_vec', shape=vec_size, val=np.zeros(vec_size))\n\n        self.add_output('out_idx', shape=1)\n        self.add_output('out_vec', shape=vec_size)\n\n        # NOTES: You do **NOT** define derivatives wrt the idx variable!! \n        self.declare_partials('out_vec', 'in_vec', method='CS')\n\n    def compute(self, inputs, outputs): \n\n        in_vec = inputs['in_vec']\n        out_vec = outputs['out_vec']\n        \n        out_vec[:] = in_vec.copy()\n\n        # always use the first two entries to\n        # indicate the start/end of the valid data\n        i_start_idx = int(inputs['in_idx'])\n        i_end_idx = i_start_idx + self.options['step_size']\n        i_size = i_end_idx - i_start_idx\n\n        if i_start_idx == 0: \n            out_vec[0] = 1 # get the counting started\n            i_start_idx = 1\n\n        # note: careful to account for the open end of the  \n        # interval when computing the end_idx value\n        # print(self.pathname)\n        for i in range(i_start_idx,i_start_idx+self.options['step_size']): \n            out_vec[i] = out_vec[i-1] + 1\n\n        o_end_idx = i_start_idx + i_size\n\n        outputs['out_idx'] = o_end_idx\n\n\nif __name__ == \"__main__\": \n\n    p = om.Problem()\n\n    VEC_SIZE = 12\n    STEP_SIZE = 3\n\n    c0 = p.model.add_subsystem('c0', VectorChain(vec_size=VEC_SIZE, step_size=STEP_SIZE))\n    c1 = p.model.add_subsystem('c1', VectorChain(vec_size=VEC_SIZE, step_size=STEP_SIZE))\n    c2 = p.model.add_subsystem('c2', VectorChain(vec_size=VEC_SIZE, step_size=STEP_SIZE))\n\n    p.model.connect('c0.out_idx', 'c1.in_idx')\n    p.model.connect('c0.out_vec', 'c1.in_vec')\n\n    p.model.connect('c1.out_idx', 'c2.in_idx')\n    p.model.connect('c1.out_vec', 'c2.in_vec')\n\n\n    p.setup()\n\n    <line_mask>\n\n    p.model.list_outputs(print_arrays=True)",
            "masked_line": "p.run_model()",
            "answer": "run_model",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_516"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4.0",
            "time": "2021-09-02",
            "description": "This code generates a figure with multiple subplots arranged in a grid layout. Each subplot contains a scatter plot with random data. The figure has a main title and each subplot has a title, x-axis label, and y-axis label. The number of rows and columns for the subplots can be adjusted.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# random data. Make sure these are the correct size if changing number of subplots\nx_vals = np.random.rand(4, 10)\ny_vals = np.random.rand(2, 10)\ny_labels = ['k0', 'k1']  \n\n# change rows/cols accordingly\nrows = 4\ncols = 2\n\nfig = plt.figure(figsize=(15,25), constrained_layout=True)\nfig.suptitle('Figure title')\n\n# create rows x 1 subfigs\nsubfigs = fig.subfigures(nrows=rows, ncols=1)\n\nfor row, subfig in enumerate(subfigs):\n    subfig.suptitle(f'Subplot row title {row}')\n\n    # create 1 x cols subplots per subfig\n    axs = subfig.subplots(nrows=1, ncols=cols)\n    for col, ax in enumerate(axs):\n        ax.scatter(x_vals[row], y_vals[col])\n        ax.set_title(\"Subplot ax title\")\n        ax.set_xlabel('Loss')\n        ax.set_ylabel(y_labels[col])",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# random data. Make sure these are the correct size if changing number of subplots\nx_vals = np.random.rand(4, 10)\ny_vals = np.random.rand(2, 10)\ny_labels = ['k0', 'k1']  \n\n# change rows/cols accordingly\nrows = 4\ncols = 2\n\nfig = plt.figure(figsize=(15,25), constrained_layout=True)\n<line_mask>\n\n# create rows x 1 subfigs\nsubfigs = fig.subfigures(nrows=rows, ncols=1)\n\nfor row, subfig in enumerate(subfigs):\n    subfig.suptitle(f'Subplot row title {row}')\n\n    # create 1 x cols subplots per subfig\n    axs = subfig.subplots(nrows=1, ncols=cols)\n    for col, ax in enumerate(axs):\n        ax.scatter(x_vals[row], y_vals[col])\n        ax.set_title(\"Subplot ax title\")\n        ax.set_xlabel('Loss')\n        ax.set_ylabel(y_labels[col])",
            "masked_line": "fig.suptitle('Figure title')",
            "answer": "suptitle",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_517"
        },
        {
            "dependency": "numpy",
            "version": ">=1.20",
            "time": "2021-08-22",
            "description": "The code creates a sliding window view of array 'a' with a shape of (2,2) on Windows platform.",
            "code": "windows = np.lib.stride_tricks.sliding_window_view(a, (2,2))\nprint(windows)",
            "masked_code": "<line_mask>\nprint(windows)",
            "masked_line": "windows = np.lib.stride_tricks.sliding_window_view(a, (2,2))",
            "answer": "sliding_window_view",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_518"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-04-06",
            "description": "This code generates a swarmplot using the seaborn library with the 'tips' dataset. It also calculates the mean total bill for each day and adds it to the swarmplot as black X markers. Finally, it sets the x and y limits of the plot and displays the plot.",
            "code": "import seaborn as sns\n\nsns.set_theme(style=\"whitegrid\")\ntips = sns.load_dataset(\"tips\")\nax = sns.swarmplot(x=\"day\", y=\"total_bill\", data=tips)\ndf_means = tips.groupby(\"day\")[\"total_bill\"].agg(\"mean\").reset_index()\nxlim = ax.get_xlim()\nylim = ax.get_ylim()\nsns.scatterplot(x=\"day\", y=\"total_bill\", marker='X', color='black', s=100, zorder=3, ax=ax, legend=False, data=df_means)\nax.set_xlim(xlim)\nax.set_ylim(ylim)\nplt.show()",
            "masked_code": "import seaborn as sns\n\nsns.set_theme(style=\"whitegrid\")\n<line_mask>\nax = sns.swarmplot(x=\"day\", y=\"total_bill\", data=tips)\ndf_means = tips.groupby(\"day\")[\"total_bill\"].agg(\"mean\").reset_index()\nxlim = ax.get_xlim()\nylim = ax.get_ylim()\nsns.scatterplot(x=\"day\", y=\"total_bill\", marker='X', color='black', s=100, zorder=3, ax=ax, legend=False, data=df_means)\nax.set_xlim(xlim)\nax.set_ylim(ylim)\nplt.show()",
            "masked_line": "tips = sns.load_dataset(\"tips\")",
            "answer": "load_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_519"
        },
        {
            "dependency": "numpy",
            "version": ">=1.20.0",
            "time": "2021-04-13",
            "description": "Calculate the covariance matrix of sliding windows of size 2x2 on the input array and normalize the resulting matrix.",
            "code": "from numpy.lib.stride_tricks import sliding_window_view\na = sliding_window_view(arr, (2,2), axis=(1,2)).reshape(32,2047,2047,-1)\n\nX = a - a.mean(axis=0)\n\nout = np.einsum('ijlk,ijlm,...->kmjl', X,X,1/32)",
            "masked_code": "from numpy.lib.stride_tricks import sliding_window_view\n<line_mask>\n\nX = a - a.mean(axis=0)\n\nout = np.einsum('ijlk,ijlm,...->kmjl', X,X,1/32)",
            "masked_line": "a = sliding_window_view(arr, (2,2), axis=(1,2)).reshape(32,2047,2047,-1)",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_520"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-11",
            "description": "The code generates a histogram overlaid with a Kernel Density Estimate (KDE) using Seaborn. It sets the number of bins to 20, normalizes the histogram by density, adds a KDE line, and customizes the appearance of the plot. Additionally, it edits the line color and adds a legend without a frame, as well as a title to the plot before displaying it.",
            "code": "# Plot seaborn histogram overlaid with KDE\nax = sns.histplot(data=df['variable'], bins=20, stat='density', alpha= 1, kde=True,\n                  edgecolor='white', linewidth=0.5,\n                  line_kws=dict(color='black', alpha=0.5, linewidth=1.5, label='KDE'))\nax.get_lines()[0].set_color('black') # edit line color due to bug in sns v 0.11.0\n\n# Edit legemd and add title\nax.legend(frameon=False)\nax.set_title('Seaborn histogram overlaid with KDE', fontsize=14, pad=15)\n\nplt.show()",
            "masked_code": "# Plot seaborn histogram overlaid with KDE\nax = sns.histplot(data=df['variable'], bins=20, stat='density', alpha= 1, kde=True,\n                  edgecolor='white', linewidth=0.5,\n                  line_kws=dict(color='black', alpha=0.5, linewidth=1.5, label='KDE'))\n<line_mask>\n\n# Edit legemd and add title\nax.legend(frameon=False)\nax.set_title('Seaborn histogram overlaid with KDE', fontsize=14, pad=15)\n\nplt.show()",
            "masked_line": "ax.get_lines()[0].set_color('black') # edit line color due to bug in sns v 0.11.0",
            "answer": "get_lines",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_521"
        },
        {
            "dependency": "setuptools",
            "version": ">=0.11.4",
            "time": "2021-02-04",
            "description": "This code sets up a Rust extension for a Python package named \"foo.rust\" with limited Python API support and specific features enabled.",
            "code": "from setuptools import setup\nfrom setuptools_rust import RustExtension\n\n\nsetup(\n    ...,\n    rust_extensions=[\n        RustExtension(\"foo.rust\", py_limited_api=True, features=[\"pyo3/abi3\"]),\n    ],\n)",
            "masked_code": "from setuptools import setup\nfrom setuptools_rust import RustExtension\n\n\nsetup(\n    ...,\n    rust_extensions=[\n        <line_mask>\n    ],\n)",
            "masked_line": "RustExtension(\"foo.rust\", py_limited_api=True, features=[\"pyo3/abi3\"]),",
            "answer": "RustExtension",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_522"
        },
        {
            "dependency": "dash",
            "version": "==2.0.0",
            "time": "2021-10-12",
            "description": "This code creates a web application using Dash that includes two dropdown menus for selecting materials, a graph for displaying new cases data, and styling elements such as font and text alignment. The application is run and displayed inline in the Jupyter notebook.",
            "code": "import json\nimport numpy as np\nimport dash_bootstrap_components as dbc\nimport dash\nfrom jupyter_dash import JupyterDash\n\nall_options = {k: v for k, v in zip(list(\"ABCD\"), np.random.randint(1, 4, 4))}\noptions1 = list(all_options.keys())\n# Build App\napp = JupyterDash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\napp.layout = dash.html.Div(\n    [\n        dbc.Row(\n            [\n                dbc.Col(\n                    dbc.Row(\n                        [\n                            dash.html.Label(\"Material 1\"),\n                            dash.dcc.Dropdown(\n                                id=\"dropdown1\",\n                                options=[\n                                    {\"label\": k, \"value\": k} for k in all_options.keys()\n                                ],\n                                value=options1[0],\n                                style={\"width\": \"400px\", \"margin-left\": 0},\n                            ),\n                        ],\n                        justify=\"center\",\n                    ),\n                ),\n                dbc.Col(\n                    dbc.Row(\n                        [\n                            dash.html.Label(\"Material 2\"),\n                            dash.dcc.Dropdown(\n                                id=\"dropdown2\",\n                                options=[\n                                    {\"label\": k, \"value\": k} for k in all_options.keys()\n                                ],\n                                value=options1[0],\n                                style={\"width\": \"400px\", \"margin-left\": 0},\n                            ),\n                        ],\n                        justify=\"center\",\n                    ),\n                ),\n            ],\n            justify=\"center\",\n        ),\n        dash.dcc.Graph(id=\"newCases\", style={\"height\": \"45vh\"}),\n    ],\n    style={\"font-family\": \"Arial\", \"font-size\": \"0.9em\", \"text-align\": \"center\"},\n)\n\n\n# Run app and display result inline in the notebook\napp.run_server(mode=\"inline\")",
            "masked_code": "import json\nimport numpy as np\nimport dash_bootstrap_components as dbc\nimport dash\nfrom jupyter_dash import JupyterDash\n\nall_options = {k: v for k, v in zip(list(\"ABCD\"), np.random.randint(1, 4, 4))}\noptions1 = list(all_options.keys())\n# Build App\napp = JupyterDash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\n<line_mask>\n    [\n        dbc.Row(\n            [\n                dbc.Col(\n                    dbc.Row(\n                        [\n                            dash.html.Label(\"Material 1\"),\n                            dash.dcc.Dropdown(\n                                id=\"dropdown1\",\n                                options=[\n                                    {\"label\": k, \"value\": k} for k in all_options.keys()\n                                ],\n                                value=options1[0],\n                                style={\"width\": \"400px\", \"margin-left\": 0},\n                            ),\n                        ],\n                        justify=\"center\",\n                    ),\n                ),\n                dbc.Col(\n                    dbc.Row(\n                        [\n                            dash.html.Label(\"Material 2\"),\n                            dash.dcc.Dropdown(\n                                id=\"dropdown2\",\n                                options=[\n                                    {\"label\": k, \"value\": k} for k in all_options.keys()\n                                ],\n                                value=options1[0],\n                                style={\"width\": \"400px\", \"margin-left\": 0},\n                            ),\n                        ],\n                        justify=\"center\",\n                    ),\n                ),\n            ],\n            justify=\"center\",\n        ),\n        dash.dcc.Graph(id=\"newCases\", style={\"height\": \"45vh\"}),\n    ],\n    style={\"font-family\": \"Arial\", \"font-size\": \"0.9em\", \"text-align\": \"center\"},\n)\n\n\n# Run app and display result inline in the notebook\napp.run_server(mode=\"inline\")",
            "masked_line": "app.layout = dash.html.Div(",
            "answer": "html",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_523"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.3",
            "time": "2021-09-30",
            "description": "The code randomly replaces some elements in a 3x4 numpy array with infinity and then creates a DataFrame using pandas with MultiIndex columns 'A' and 'B' for 'value1' and 'value2'.",
            "code": "import numpy as np\nimport pandas as pd  # version 1.3.3\nimport seaborn as sns\nfrom matplotlib import colors as mcolors\n\nnp.random.seed(25)\na = np.random.random((3, 4))\n# Replace Randomly With inf\na[np.random.randint(0, 2, size=a.shape) == 0] = np.inf\n\ndata = pd.DataFrame(a, columns=pd.MultiIndex.from_product([\n    list('AB'),\n    ['value1', 'value2']\n]))\ndata",
            "masked_code": "import numpy as np\nimport pandas as pd  # version 1.3.3\nimport seaborn as sns\nfrom matplotlib import colors as mcolors\n\nnp.random.seed(25)\na = np.random.random((3, 4))\n# Replace Randomly With inf\na[np.random.randint(0, 2, size=a.shape) == 0] = np.inf\n\n<line_mask>\n    list('AB'),\n    ['value1', 'value2']\n]))\ndata",
            "masked_line": "data = pd.DataFrame(a, columns=pd.MultiIndex.from_product([",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_524"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2021-08-06",
            "description": "The code defines and disables TensorFlow v2 behavior and initializes a flag object for storing command-line arguments.",
            "code": "import tensorflow.compat.v1 as tf\ntf.compat.v1.disable_v2_behavior()\n\nFLAGS = tf.app.flags.FLAGS",
            "masked_code": "<line_mask>\ntf.compat.v1.disable_v2_behavior()\n\nFLAGS = tf.app.flags.FLAGS",
            "masked_line": "import tensorflow.compat.v1 as tf",
            "answer": "compat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_525"
        },
        {
            "dependency": "pandas",
            "version": ">=1.2",
            "time": "2021-07-24",
            "description": "The code generates sentences describing a scenario where a person named person1 travels to a country with another person named person2 every year.",
            "code": "import pandas as pd\n\ndata = {\n    \"~GPE~\": ['UK', 'USA'],\n    \"~PERSON~\": ['John Davies', 'Tom Banton', 'Joe Morgan'],\n    # and so on ...\n}\n\ncountry = pd.DataFrame({'country':data['~GPE~']})\nperson = pd.DataFrame({'person':data['~PERSON~']})\n\ncart = country.merge(person, how='cross').merge(person, how='cross')\n\ncart.columns = ['country', 'person1', 'person2']\n\ncart = cart.query('person1 != person2').reset_index()\n\ncart['sentence'] = cart.apply(lambda row: f\"My name is {row['person1']}. I travel to {row['country']} with {row['person2']} every year.\" , axis=1)\n\nsentences = cart['sentence'].to_list()\n\nprint('\\n'.join(sentences))",
            "masked_code": "import pandas as pd\n\ndata = {\n    \"~GPE~\": ['UK', 'USA'],\n    \"~PERSON~\": ['John Davies', 'Tom Banton', 'Joe Morgan'],\n    # and so on ...\n}\n\ncountry = pd.DataFrame({'country':data['~GPE~']})\nperson = pd.DataFrame({'person':data['~PERSON~']})\n\ncart = country.merge(person, how='cross').merge(person, how='cross')\n\ncart.columns = ['country', 'person1', 'person2']\n\ncart = cart.query('person1 != person2').reset_index()\n\ncart['sentence'] = cart.apply(lambda row: f\"My name is {row['person1']}. I travel to {row['country']} with {row['person2']} every year.\" , axis=1)\n\n<line_mask>\n\nprint('\\n'.join(sentences))",
            "masked_line": "sentences = cart['sentence'].to_list()",
            "answer": "to_list",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_526"
        },
        {
            "dependency": "ctypes",
            "version": "==1.1.0 ",
            "time": "2021-10-01",
            "description": "The code opens a connection to a power meter using the FieldMax2Lib.dll library and checks for the availability of the power meter. It then prints the response.",
            "code": "import ctypes as c\n\nmydll = c.WinDLL(r'C:\\Program Files (x86)\\Coherent\\FieldMaxII PC\\Drivers\\Win10\\FieldMax2Lib\\x64\\FieldMax2Lib.dll')\n\npy_connect=mydll.fm2LibOpenDriver\npy_connect.restype=c.c_int32\npy_connect.argtypes=[c.c_int16]\nresponse=py_connect(0) # arg 0 = 1 available power meter\nprint(response)",
            "masked_code": "import ctypes as c\n\n<line_mask>\n\npy_connect=mydll.fm2LibOpenDriver\npy_connect.restype=c.c_int32\npy_connect.argtypes=[c.c_int16]\nresponse=py_connect(0) # arg 0 = 1 available power meter\nprint(response)",
            "masked_line": "mydll = c.WinDLL(r'C:\\Program Files (x86)\\Coherent\\FieldMaxII PC\\Drivers\\Win10\\FieldMax2Lib\\x64\\FieldMax2Lib.dll')",
            "answer": "WinDLL",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_527"
        },
        {
            "dependency": "pandas",
            "version": ">1.2",
            "time": "2021-04-26",
            "description": "The code merges two DataFrames df_main and df_other using a cross join method, adds suffixes to the column names indicating the source DataFrame, and then sorts the columns in the merged DataFrame by the column index.",
            "code": "pd.merge(df_main, df_other, how=\"cross\", suffixes=(\"_main\", \"_other\")).sort_index(axis=1)",
            "masked_code": "<line_mask>",
            "masked_line": "pd.merge(df_main, df_other, how=\"cross\", suffixes=(\"_main\", \"_other\")).sort_index(axis=1)",
            "answer": "sort_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_528"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4",
            "time": "2021-01-09",
            "description": "The code creates a sparse tensor from a given dense tensor using TensorFlow.",
            "code": "import tensorflow as tf\nimport numpy as np\n\na = np.array([[1., 0., 2., 0.],\n              [3., 0., 0., 4.]])\n\na_t = tf.constant(a)\na_s = tf.sparse.from_dense(a_t)",
            "masked_code": "import tensorflow as tf\nimport numpy as np\n\na = np.array([[1., 0., 2., 0.],\n              [3., 0., 0., 4.]])\n\n<line_mask>\na_s = tf.sparse.from_dense(a_t)",
            "masked_line": "a_t = tf.constant(a)",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_529"
        },
        {
            "dependency": "dash",
            "version": "==2.4.1",
            "time": "2022-05-17",
            "description": "The code defines a Dash web application that includes two dropdown menus. The first dropdown menu (dd-clients-seg-1) allows the user to select a segment (record_1, record_2, or record_3). The options in the second dropdown menu (dd-client-code) depend on the value selected in the first dropdown menu and are generated by the generate_options function. The second dropdown menu's options are updated dynamically based on the selected segment in the first dropdown menu. The application also includes an interval timer that triggers the update of the second dropdown menu.",
            "code": "import dash.exceptions\nfrom dash import Dash, dcc, html\nfrom dash.dependencies import Input, Output, State\n\napp = Dash(\n    prevent_initial_callbacks=True,\n    suppress_callback_exceptions=True,\n)\n\n\ndef generate_options(selected_segment):\n    if selected_segment == \"record_1\":\n        return [\"A\", \"B\", \"C\"]\n    elif selected_segment == \"record_2\":\n        return [\"One\", \"Two\", \"Three\"]\n    else:\n        return [\"Small\", \"Medium\", \"Large\"]\n\n\ndd1 = dcc.Dropdown(\n    id=\"dd-clients-seg-1\",\n    options=[\"record_1\", \"record_2\", \"record_3\"],\n    persistence=\"true\",\n    persistence_type=\"session\",\n)\n\n\ndef dd2(dd1_value):\n    \"\"\"Return a dd2 dropdown with the appropriate options based on dd1 value\"\"\"\n    options = [] if not dd1_value else generate_options(dd1_value)\n    return dcc.Dropdown(\n        id=\"dd-client-code\",\n        options=options,\n        persistence=\"true\",\n        persistence_type=\"session\",\n    )\n\n\n@app.callback(\n    Output(\"dd-client-code\", \"options\"),\n    # Store the value of dd1 dropdown when it changes\n    Output(\"dd-clients-seg-1-value\", \"data\"),\n    Input(\"dd-clients-seg-1\", \"value\")\n)\ndef dd_client_code(client_seg_1):\n    if not client_seg_1:\n        raise dash.exceptions.PreventUpdate\n\n    return generate_options(client_seg_1), client_seg_1\n\n\n@app.callback(\n    Output(\"dd2-div\", \"children\"),\n    Input(\"interval-timer\", \"n_intervals\"),\n    State(\"dd-clients-seg-1-value\", \"data\"),\n)\ndef dd2_div_handler(unused, dd1_value):\n    \"\"\"Update the dd2 menu when triggered by dcc.Interval\"\"\"\n    return dd2(dd1_value)\n\n\napp.layout = html.Div([\n    # store the latest value of dd-clients-seg-1 dropdown\n    dcc.Store(\"dd-clients-seg-1-value\", storage_type=\"session\"),\n    # fires 1ms after page load\n    dcc.Interval(id=\"interval-timer\", interval=1, max_intervals=1),\n    # static menu\n    dd1,\n    # dynamic menu: don't put dd2 here to avoid persistent value going null\n    html.Div(id=\"dd2-div\")\n])\n\napp.run_server(debug=True)",
            "masked_code": "import dash.exceptions\nfrom dash import Dash, dcc, html\nfrom dash.dependencies import Input, Output, State\n\napp = Dash(\n    prevent_initial_callbacks=True,\n    suppress_callback_exceptions=True,\n)\n\n\ndef generate_options(selected_segment):\n    if selected_segment == \"record_1\":\n        return [\"A\", \"B\", \"C\"]\n    elif selected_segment == \"record_2\":\n        return [\"One\", \"Two\", \"Three\"]\n    else:\n        return [\"Small\", \"Medium\", \"Large\"]\n\n\ndd1 = dcc.Dropdown(\n    id=\"dd-clients-seg-1\",\n    options=[\"record_1\", \"record_2\", \"record_3\"],\n    persistence=\"true\",\n    persistence_type=\"session\",\n)\n\n\ndef dd2(dd1_value):\n    \"\"\"Return a dd2 dropdown with the appropriate options based on dd1 value\"\"\"\n    options = [] if not dd1_value else generate_options(dd1_value)\n    return dcc.Dropdown(\n        id=\"dd-client-code\",\n        options=options,\n        persistence=\"true\",\n        persistence_type=\"session\",\n    )\n\n\n<line_mask>\n    Output(\"dd-client-code\", \"options\"),\n    # Store the value of dd1 dropdown when it changes\n    Output(\"dd-clients-seg-1-value\", \"data\"),\n    Input(\"dd-clients-seg-1\", \"value\")\n)\ndef dd_client_code(client_seg_1):\n    if not client_seg_1:\n        raise dash.exceptions.PreventUpdate\n\n    return generate_options(client_seg_1), client_seg_1\n\n\n@app.callback(\n    Output(\"dd2-div\", \"children\"),\n    Input(\"interval-timer\", \"n_intervals\"),\n    State(\"dd-clients-seg-1-value\", \"data\"),\n)\ndef dd2_div_handler(unused, dd1_value):\n    \"\"\"Update the dd2 menu when triggered by dcc.Interval\"\"\"\n    return dd2(dd1_value)\n\n\napp.layout = html.Div([\n    # store the latest value of dd-clients-seg-1 dropdown\n    dcc.Store(\"dd-clients-seg-1-value\", storage_type=\"session\"),\n    # fires 1ms after page load\n    dcc.Interval(id=\"interval-timer\", interval=1, max_intervals=1),\n    # static menu\n    dd1,\n    # dynamic menu: don't put dd2 here to avoid persistent value going null\n    html.Div(id=\"dd2-div\")\n])\n\napp.run_server(debug=True)",
            "masked_line": "@app.callback(",
            "answer": "callback",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_530"
        },
        {
            "dependency": "numpy",
            "version": ">=1.17",
            "time": "2021-05-26",
            "description": "The code generates an array of 5 unique random integers between 0 and 999 inclusive.",
            "code": "rng = np.random.default_rng()\nfirst = rng.choice(np.arange(1000, dtype=int), 5, replace=False)",
            "masked_code": "<line_mask>\nfirst = rng.choice(np.arange(1000, dtype=int), 5, replace=False)",
            "masked_line": "rng = np.random.default_rng()",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_531"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2021-10-16",
            "description": "The code creates a directed graph using the melted data frame, then finds all descendants for each parent node in the graph.",
            "code": "import networkx as nx\n\ns = df.melt('Parent').astype(str).query(\"value != '-1'\")\nG = nx.from_pandas_edgelist(s, 'Parent', 'value', create_using=nx.DiGraph())\nfamily = parent_list + [d for n in parent_list for d in nx.descendants(G, n)]",
            "masked_code": "import networkx as nx\n\ns = df.melt('Parent').astype(str).query(\"value != '-1'\")\n<line_mask>\nfamily = parent_list + [d for n in parent_list for d in nx.descendants(G, n)]",
            "masked_line": "G = nx.from_pandas_edgelist(s, 'Parent', 'value', create_using=nx.DiGraph())",
            "answer": "from_pandas_edgelist",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_532"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-02-12",
            "description": "The code generates a sample dataset with categorical variables and boolean values, then creates a seaborn countplot with wrapped tick labels for the categorical variable.",
            "code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\nimport textwrap\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\ncat_names = ['Short name', 'Slightly longer name', 'Rather much longer name',\n             'Longest name of them all by far']\ncounts = rng.integers(10, 100, len(cat_names))\nvar_cat = np.repeat(cat_names, counts)\nvar_bool = rng.choice(['True', 'False'], size=len(var_cat))\ndf = pd.DataFrame(dict(vcat=var_cat, vbool=var_bool))\n\n# Plot seaborn countplot with wrapped tick labels\nax = sns.countplot(data=df, x='vcat', hue='vbool')\nlabels = [textwrap.fill(label.get_text(), 12) for label in ax.get_xticklabels()]\nax.set_xticklabels(labels);",
            "masked_code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\nimport textwrap\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\ncat_names = ['Short name', 'Slightly longer name', 'Rather much longer name',\n             'Longest name of them all by far']\ncounts = rng.integers(10, 100, len(cat_names))\nvar_cat = np.repeat(cat_names, counts)\n<line_mask>\ndf = pd.DataFrame(dict(vcat=var_cat, vbool=var_bool))\n\n# Plot seaborn countplot with wrapped tick labels\nax = sns.countplot(data=df, x='vcat', hue='vbool')\nlabels = [textwrap.fill(label.get_text(), 12) for label in ax.get_xticklabels()]\nax.set_xticklabels(labels);",
            "masked_line": "var_bool = rng.choice(['True', 'False'], size=len(var_cat))",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_533"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-12",
            "description": "The code creates a sample dataset with categorical and boolean variables, then plots a seaborn countplot with wrapped tick labels for the categorical variable.",
            "code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\nimport textwrap\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\ncat_names = ['Short name', 'Slightly longer name', 'Rather much longer name',\n             'Longest name of them all by far']\ncounts = rng.integers(10, 100, len(cat_names))\nvar_cat = np.repeat(cat_names, counts)\nvar_bool = rng.choice(['True', 'False'], size=len(var_cat))\ndf = pd.DataFrame(dict(vcat=var_cat, vbool=var_bool))\n\n# Plot seaborn countplot with wrapped tick labels\nax = sns.countplot(data=df, x='vcat', hue='vbool')\nlabels = [textwrap.fill(label.get_text(), 12) for label in ax.get_xticklabels()]\nax.set_xticklabels(labels);",
            "masked_code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\nimport textwrap\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\ncat_names = ['Short name', 'Slightly longer name', 'Rather much longer name',\n             'Longest name of them all by far']\ncounts = rng.integers(10, 100, len(cat_names))\nvar_cat = np.repeat(cat_names, counts)\nvar_bool = rng.choice(['True', 'False'], size=len(var_cat))\n<line_mask>\n\n# Plot seaborn countplot with wrapped tick labels\nax = sns.countplot(data=df, x='vcat', hue='vbool')\nlabels = [textwrap.fill(label.get_text(), 12) for label in ax.get_xticklabels()]\nax.set_xticklabels(labels);",
            "masked_line": "df = pd.DataFrame(dict(vcat=var_cat, vbool=var_bool))",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_534"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-12",
            "description": "The code creates a sample dataset with categorical and boolean variables, then plots a seaborn countplot with wrapped tick labels for the categorical variable.",
            "code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\nimport textwrap\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\ncat_names = ['Short name', 'Slightly longer name', 'Rather much longer name',\n             'Longest name of them all by far']\ncounts = rng.integers(10, 100, len(cat_names))\nvar_cat = np.repeat(cat_names, counts)\nvar_bool = rng.choice(['True', 'False'], size=len(var_cat))\ndf = pd.DataFrame(dict(vcat=var_cat, vbool=var_bool))\n\n# Plot seaborn countplot with wrapped tick labels\nax = sns.countplot(data=df, x='vcat', hue='vbool')\nlabels = [textwrap.fill(label.get_text(), 12) for label in ax.get_xticklabels()]\nax.set_xticklabels(labels);",
            "masked_code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\nimport textwrap\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\ncat_names = ['Short name', 'Slightly longer name', 'Rather much longer name',\n             'Longest name of them all by far']\ncounts = rng.integers(10, 100, len(cat_names))\nvar_cat = np.repeat(cat_names, counts)\nvar_bool = rng.choice(['True', 'False'], size=len(var_cat))\ndf = pd.DataFrame(dict(vcat=var_cat, vbool=var_bool))\n\n# Plot seaborn countplot with wrapped tick labels\nax = sns.countplot(data=df, x='vcat', hue='vbool')\nlabels = [textwrap.fill(label.get_text(), 12) for label in ax.get_xticklabels()]\n<line_mask>",
            "masked_line": "ax.set_xticklabels(labels);",
            "answer": "set_xticklabels",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_535"
        },
        {
            "dependency": "numpy",
            "version": ">=1.19",
            "time": "2021-09-29",
            "description": "The code generates a random permutation of the elements in each row of a 2D numpy array.",
            "code": "import numpy as np\n\narr = np.array([[0, 0, 0, 0, 0], [0, 4, 1, 1, 1], [0, 1, 1, 2, 2], [0, 3, 2, 2, 2]])\n\nrng = np.random.default_rng()\narr_rand3 = rng.permutation(arr, axis=1)\n\nprint(arr_rand3)",
            "masked_code": "import numpy as np\n\n<line_mask>\n\nrng = np.random.default_rng()\narr_rand3 = rng.permutation(arr, axis=1)\n\nprint(arr_rand3)",
            "masked_line": "arr = np.array([[0, 0, 0, 0, 0], [0, 4, 1, 1, 1], [0, 1, 1, 2, 2], [0, 3, 2, 2, 2]])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_536"
        },
        {
            "dependency": "dash",
            "version": "==1.2.0",
            "time": "2021-06-14",
            "description": "The code creates a Dash web application with a layout containing a syntax error where a list of lists is used as children inside a html.Div element.",
            "code": "import dash\nimport dash_html_components as html\n\napp = dash.Dash()\napp.layout = html.Div([[\"Hello world\"]])  # list of lists as children, a typical syntax error\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "import dash\nimport dash_html_components as html\n\napp = dash.Dash()\napp.layout = html.Div([[\"Hello world\"]])  # list of lists as children, a typical syntax error\n\nif __name__ == '__main__':\n    <line_mask>",
            "masked_line": "app.run_server(debug=True)",
            "answer": "run_server",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_537"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==2.0",
            "time": "2021-05-18",
            "description": "The code defines two classes, Child and Toy, that are mapped to corresponding database tables. Child class has an id and name attribute, while Toy class has an id, color, and a foreign key reference to Child's id. The classes use SQLAlchemy ORM to create a database schema with a one-to-many relationship between Child and Toy tables.",
            "code": "from sqlalchemy import ForeignKey, String\nfrom sqlalchemy import create_engine, select\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, Session\nfrom sqlalchemy.orm import mapped_column, relationship\nfrom sqlalchemy.orm import contains_eager\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Child(Base):\n    __tablename__ = 'child'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(40))\n    toys = relationship('Toy')\n\nclass Toy(Base):\n    __tablename__ = 'toy'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    color: Mapped[str] = mapped_column(String(40))\n    child_id = mapped_column(ForeignKey('child.id'))",
            "masked_code": "from sqlalchemy import ForeignKey, String\nfrom sqlalchemy import create_engine, select\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, Session\nfrom sqlalchemy.orm import mapped_column, relationship\nfrom sqlalchemy.orm import contains_eager\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Child(Base):\n    __tablename__ = 'child'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(40))\n    toys = relationship('Toy')\n\nclass Toy(Base):\n    __tablename__ = 'toy'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    color: Mapped[str] = mapped_column(String(40))\n    <line_mask>",
            "masked_line": "child_id = mapped_column(ForeignKey('child.id'))",
            "answer": "ForeignKey",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_538"
        },
        {
            "dependency": "shap",
            "version": "==0.36",
            "time": "2021-12-10",
            "description": "The code displays SHAP (SHapley Additive exPlanations) plots in a Streamlit web application with a specified height of 400 pixels.",
            "code": "import streamlit as st\nimport streamlit.components.v1 as components\n\ndef st_shap(plot, height=None):\n    shap_html = f\"{shap.getjs()}{plot.html()}\"\n    components.html(shap_html, height=height)\n\nst_shap(shap.plots.text(shap_values),400)",
            "masked_code": "import streamlit as st\nimport streamlit.components.v1 as components\n\ndef st_shap(plot, height=None):\n    shap_html = f\"{shap.getjs()}{plot.html()}\"\n    components.html(shap_html, height=height)\n\n<line_mask>",
            "masked_line": "st_shap(shap.plots.text(shap_values),400)",
            "answer": "plots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_539"
        },
        {
            "dependency": "discord.py",
            "version": ">=1.0",
            "time": "2021-02-24",
            "description": "This Python code is a Discord bot that connects to a voice channel in a server and sends a message when the bot is ready. It sets the bot's status to watching \"Croissants!\" and defines a command to join a voice channel upon user request.",
            "code": "import discord\nimport os\nimport time\nfrom ka import keep_alive\nfrom discord.ext import commands\nimport asyncio\n\nclient = commands.Bot(command_prefix = '.')\nprefix = '.'\n\n@client.event\nasync def on_ready():\n  print(\"I'm ready! {0.user}\".format(client))\n  await client.change_presence(activity=discord.Activity(type=discord.ActivityType.watching, name=\"Croissants!\"))\n\n@client.command()\nasync def join(ctx):\n  channel = ctx.guild.get_member(ctx.author.id).voice.channel # This\n  await channel.connect()\n  await ctx.send(\"On my way!\")\n\nclient.run(os.getenv('TOKEN'))",
            "masked_code": "import discord\nimport os\nimport time\nfrom ka import keep_alive\nfrom discord.ext import commands\nimport asyncio\n\nclient = commands.Bot(command_prefix = '.')\nprefix = '.'\n\n@client.event\nasync def on_ready():\n  print(\"I'm ready! {0.user}\".format(client))\n  await client.change_presence(activity=discord.Activity(type=discord.ActivityType.watching, name=\"Croissants!\"))\n\n@client.command()\nasync def join(ctx):\n  channel = ctx.guild.get_member(ctx.author.id).voice.channel # This\n  await channel.connect()\n  await ctx.send(\"On my way!\")\n\n<line_mask>",
            "masked_line": "client.run(os.getenv('TOKEN'))",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_540"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2021-04-20",
            "description": "The code defines functions to dump and load an object to/from a file using TensorFlow and dill libraries in Python.",
            "code": "import codecs\nimport dill as pickle\nimport tensorflow as tf\n\ndef dump(obj, filename):\n    \"\"\" Wrapper to dump an object to a file.\"\"\"\n    with tf.io.gfile.GFile(filename, \"wb\") as f:\n        pickled = codecs.encode(\n            pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL),\n            \"base64\").decode()\n        f.write(pickled)\n\n\ndef load(filename):\n    \"\"\" Wrapper to load an object from a file.\"\"\"\n    with tf.io.gfile.GFile(filename, \"rb\") as f:\n        pickled = f.read()\n        return pickle.loads(codecs.decode(pickled, \"base64\"))",
            "masked_code": "import codecs\nimport dill as pickle\nimport tensorflow as tf\n\ndef dump(obj, filename):\n    \"\"\" Wrapper to dump an object to a file.\"\"\"\n    with tf.io.gfile.GFile(filename, \"wb\") as f:\n        pickled = codecs.encode(\n            pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL),\n            \"base64\").decode()\n        f.write(pickled)\n\n\ndef load(filename):\n    \"\"\" Wrapper to load an object from a file.\"\"\"\n    <line_mask>\n        pickled = f.read()\n        return pickle.loads(codecs.decode(pickled, \"base64\"))",
            "masked_line": "with tf.io.gfile.GFile(filename, \"rb\") as f:",
            "answer": "GFile",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_541"
        },
        {
            "dependency": "scipy",
            "version": "==1.7.0",
            "time": "2021-07-16",
            "description": "The code creates a cubic spline interpolation for the given dataset (x, y) and then calculates the derivative of the spline. It then plots the original spline and its derivative using matplotlib.",
            "code": "from scipy.interpolate import UnivariateSpline\n\nspl = UnivariateSpline(x, y, k=4, s=0)\ndiffspl = spl.derivative()\n\nplt.plot(x, spl(x), '--')\nplt.plot(x, diffspl(x), '--')\nplt.show()",
            "masked_code": "from scipy.interpolate import UnivariateSpline\n\nspl = UnivariateSpline(x, y, k=4, s=0)\n<line_mask>\n\nplt.plot(x, spl(x), '--')\nplt.plot(x, diffspl(x), '--')\nplt.show()",
            "masked_line": "diffspl = spl.derivative()",
            "answer": "derivative",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_542"
        },
        {
            "dependency": "numpy",
            "version": ">=1.20",
            "time": "2021-03-11",
            "description": "The code creates a sliding window view of a given array with a window shape of 2.",
            "code": "from numpy.lib.stride_tricks import sliding_window_view                                                                                                                                                                              \n\nwindow = sliding_window_view(arr, window_shape=2)",
            "masked_code": "<line_mask>\n\nwindow = sliding_window_view(arr, window_shape=2)",
            "masked_line": "from numpy.lib.stride_tricks import sliding_window_view",
            "answer": "sliding_window_view",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_543"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.3.1",
            "time": "2021-02-07",
            "description": "The code generates a time plot of the range from 0 to 10 with x-axis formatted as hours:minutes:seconds.",
            "code": "import matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport time\n\nnow_ms = int(time.time() * 1000)\nx = [now_ms+t for t in range(0,10_000,1000)]\n\nplt.plot([mpl.dates.epoch2num(t/1000) for t in x], range(10))\nplt.gca().xaxis.set_major_formatter(mpl.dates.DateFormatter(\"%H:%M:%S\"))",
            "masked_code": "import matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport time\n\nnow_ms = int(time.time() * 1000)\nx = [now_ms+t for t in range(0,10_000,1000)]\n\nplt.plot([mpl.dates.epoch2num(t/1000) for t in x], range(10))\n<line_mask>",
            "masked_line": "plt.gca().xaxis.set_major_formatter(mpl.dates.DateFormatter(\"%H:%M:%S\"))",
            "answer": "gca",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_544"
        },
        {
            "dependency": "numpy",
            "version": ">=1.20.0",
            "time": "2021-11-25",
            "description": "The code creates a sliding window view of an array 'arr' with a window size of 'n' in the first dimension and the same size as the original array in the second dimension.",
            "code": "from numpy.lib.stride_tricks import sliding_window_view\n\nnew_arr = sliding_window_view(arr, (n, arr.shape[1])).squeeze()",
            "masked_code": "from numpy.lib.stride_tricks import sliding_window_view\n\n<line_mask>",
            "masked_line": "new_arr = sliding_window_view(arr, (n, arr.shape[1])).squeeze()",
            "answer": "squeeze",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_545"
        },
        {
            "dependency": "transformers",
            "version": "==4.5.1",
            "time": "2021-05-12",
            "description": "The code initializes a BertTokenizer with the 'bert-base-uncased' pre-trained model, tokenizes the input text \"This is an example with an emoji .\", adds the emoji token '' to the tokenizer, and tokenizes the same input text again to include the added emoji token.",
            "code": "from transformers import BertTokenizer\nt = BertTokenizer.from_pretrained('bert-base-uncased')\nprint(t.tokenize(\"This is an example with an emoji .\"))\nt.add_tokens([''])\nprint(t.tokenize(\"This is an example with an emoji .\"))",
            "masked_code": "from transformers import BertTokenizer\n<line_mask>\nprint(t.tokenize(\"This is an example with an emoji .\"))\nt.add_tokens([''])\nprint(t.tokenize(\"This is an example with an emoji .\"))",
            "masked_line": "t = BertTokenizer.from_pretrained('bert-base-uncased')",
            "answer": "from_pretrained",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_546"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-28",
            "description": "The code generates a violin plot using seaborn library to visualize the distribution of total_bill amounts per day and gender. It includes features such as splitting the violin plots by gender, adjusting the scale, setting the inner style, and adding a legend. Additionally, it creates a zoomed-in subplot specifically for the data where day is 'Fri' and gender is 'Female', enhancing the visualization of this subset of the data.",
            "code": "import seaborn as sns  # v 0.11.0\n\n# Import sample dataset and generate seaborn violinplot\ntips = sns.load_dataset('tips')\nax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"sex\", data=tips, palette=\"Set2\",\n                    split=True, scale=\"count\", inner=\"stick\", scale_hue=False, bw=.2)\nax.figure.set_size_inches(10,4)\nax.legend(loc='upper left', frameon=False)\n\n# Create inset axes to zoom in on violinplot showing 'day'='Fri' & 'sex'='Female'\ntips_fri_fem = tips[(tips['day']=='Fri') & (tips['sex']=='Female')]\naxins = ax.inset_axes([0.44, 0.1, 0.06, 0.8])\nsns.violinplot(data=tips_fri_fem, x='sex', y=\"total_bill\", hue=\"sex\",\n               palette=\"Set2\", split=True, scale=\"count\", inner=\"stick\",\n               scale_hue=False, bw=.2, ax=axins)\naxins.set_xlim(1, 1.5)\naxins.set_ylim(0, 30)\naxins.set_xlabel('')\naxins.set_ylabel('')\naxins.set_xticklabels('')\naxins.legend().remove()\n\n# Add rectangle without the connector lines to indicate area that is enlarged\nrect, lines = ax.indicate_inset_zoom(axins, alpha=0.8)\nrect.set_bounds(*rect.get_xy(), 0.1, 30)\nfor line in lines:\n    line.remove()",
            "masked_code": "import seaborn as sns  # v 0.11.0\n\n# Import sample dataset and generate seaborn violinplot\ntips = sns.load_dataset('tips')\nax = sns.violinplot(x=\"day\", y=\"total_bill\", hue=\"sex\", data=tips, palette=\"Set2\",\n                    split=True, scale=\"count\", inner=\"stick\", scale_hue=False, bw=.2)\nax.figure.set_size_inches(10,4)\nax.legend(loc='upper left', frameon=False)\n\n# Create inset axes to zoom in on violinplot showing 'day'='Fri' & 'sex'='Female'\ntips_fri_fem = tips[(tips['day']=='Fri') & (tips['sex']=='Female')]\naxins = ax.inset_axes([0.44, 0.1, 0.06, 0.8])\nsns.violinplot(data=tips_fri_fem, x='sex', y=\"total_bill\", hue=\"sex\",\n               palette=\"Set2\", split=True, scale=\"count\", inner=\"stick\",\n               scale_hue=False, bw=.2, ax=axins)\naxins.set_xlim(1, 1.5)\naxins.set_ylim(0, 30)\naxins.set_xlabel('')\n<line_mask>\naxins.set_xticklabels('')\naxins.legend().remove()\n\n# Add rectangle without the connector lines to indicate area that is enlarged\nrect, lines = ax.indicate_inset_zoom(axins, alpha=0.8)\nrect.set_bounds(*rect.get_xy(), 0.1, 30)\nfor line in lines:\n    line.remove()",
            "masked_line": "axins.set_ylabel('')",
            "answer": "set_ylabel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_547"
        },
        {
            "dependency": "pmdarima",
            "version": "==1.0.0",
            "time": "2021-11-08",
            "description": "This Python code is used to train and make inferences using an auto.arima model on monthly taxi data. The code reads 8 months of clean, aggregated monthly taxi data, then defines functions to train the model and make inferences. The code uses Ray to run the training and inference tasks as distributed jobs using remote function calls. The training function splits the data into train/test sets, trains and fits the auto.arima model, and returns the trained model. The inference function unpickles the model, performs inference on the test data, and returns the forecasted results.",
            "code": "import ray\nimport pandas as pd\nimport pmdarima as pm\nfrom pmdarima.model_selection import train_test_split\n\n# read 8 months of clean, aggregated monthly taxi data\nfilename = \"https://github.com/christy/MachineLearningTools/blob/master/data/clean_taxi_monthly.parquet?raw=true\"\ng_month = pd.read_parquet(filename) \n\n# Define a train_model function, default train on 6 months, inference 2\ndef train_model(theDF:pd.DataFrame, item_col:str\n                , item_value:str, target_col:str\n                , train_size:int=6) -> list:\n\n    # split data into train/test\n    train, test = train_test_split(theDF.loc[(theDF[item_col]==item_value), :], train_size=train_size)\n    \n    # train and fit auto.arima model\n    model = pm.auto_arima(y=train[target_col]\n                          ,X=train.loc[:, (train.columns!=target_col) \n                                          & (train.columns!=item_col)]\n                         )\n    # here is the extra pickle step to handle statsmodel objects\n    return [train, test, pickle.dumps(model)]\n\n\n# Define inference_model function\ndef inference_model(model_pickle:bytes, test:pd.DataFrame\n                    , timestamp_col:str, item_col:str, target_col:str) -> pd.DataFrame:\n\n    # unpickle the model\n    model = pickle.loads(model_pickle)\n    \n    # inference on test data\n    forecast = pd.DataFrame(model.predict(n_periods=test.shape[0]\n                         , X=test.loc[:, (test.columns!=target_col) & (test.columns!=item_col)]\n                         , index=test.index))\n    \n    return forecast\n\n\n# start-up ray on your laptop for testing purposes\nimport ray\nNUM_CPU = 2\nray.init(\n    ignore_reinit_error=True\n    , num_cpus = NUM_CPU\n)\n\n###########\n# run your training as distributed jobs by using ray remote function calls\n###########\n    \n# Convert your regular python functions to ray remote functions\ntrain_model_remote = ray.remote(train_model).options(num_returns=3)  \ninference_model_remote = ray.remote(inference_model)\n    \n# Train every model\nitem_list = list(g_month['pulocationid'].unique())\nmodel = []\ntrain = []\ntest = []\n\nfor p,v in enumerate(item_list):\n    # ray remote eval\n    temp_train, temp_test, temp_model = \\\n        train_model_remote.remote(g_month\n                                  , item_col='pulocationid', item_value=v\n                                  , target_col='trip_quantity'\n                                  , train_size=6)\n    train.append(temp_train)\n    test.append(temp_test)\n    model.append(temp_model)\n\n# Inference every test dataset\nresult=[]\nfor p,v in enumerate(item_list):\n    # ray remote eval\n    result.append(inference_model_remote.remote(model[p], test[p]\n                                                , timestamp_col='pickup_monthly'\n                                                , item_col='pulocationid'\n                                                , target_col='trip_quantity'))\n\n# ray.get() means block until all objectIDs requested are available\nforecast = ray.get(result)",
            "masked_code": "import ray\nimport pandas as pd\nimport pmdarima as pm\nfrom pmdarima.model_selection import train_test_split\n\n# read 8 months of clean, aggregated monthly taxi data\nfilename = \"https://github.com/christy/MachineLearningTools/blob/master/data/clean_taxi_monthly.parquet?raw=true\"\ng_month = pd.read_parquet(filename) \n\n# Define a train_model function, default train on 6 months, inference 2\ndef train_model(theDF:pd.DataFrame, item_col:str\n                , item_value:str, target_col:str\n                , train_size:int=6) -> list:\n\n    # split data into train/test\n    train, test = train_test_split(theDF.loc[(theDF[item_col]==item_value), :], train_size=train_size)\n    \n    # train and fit auto.arima model\n    model = pm.auto_arima(y=train[target_col]\n                          ,X=train.loc[:, (train.columns!=target_col) \n                                          & (train.columns!=item_col)]\n                         )\n    # here is the extra pickle step to handle statsmodel objects\n    return [train, test, pickle.dumps(model)]\n\n\n# Define inference_model function\ndef inference_model(model_pickle:bytes, test:pd.DataFrame\n                    , timestamp_col:str, item_col:str, target_col:str) -> pd.DataFrame:\n\n    # unpickle the model\n    model = pickle.loads(model_pickle)\n    \n    # inference on test data\n    forecast = pd.DataFrame(model.predict(n_periods=test.shape[0]\n                         , X=test.loc[:, (test.columns!=target_col) & (test.columns!=item_col)]\n                         , index=test.index))\n    \n    return forecast\n\n\n# start-up ray on your laptop for testing purposes\nimport ray\nNUM_CPU = 2\nray.init(\n    ignore_reinit_error=True\n    , num_cpus = NUM_CPU\n)\n\n###########\n# run your training as distributed jobs by using ray remote function calls\n###########\n    \n# Convert your regular python functions to ray remote functions\ntrain_model_remote = ray.remote(train_model).options(num_returns=3)  \ninference_model_remote = ray.remote(inference_model)\n    \n# Train every model\nitem_list = list(g_month['pulocationid'].unique())\nmodel = []\ntrain = []\ntest = []\n\nfor p,v in enumerate(item_list):\n    # ray remote eval\n    temp_train, temp_test, temp_model = \\\n        train_model_remote.remote(g_month\n                                  , item_col='pulocationid', item_value=v\n                                  , target_col='trip_quantity'\n                                  , train_size=6)\n    train.append(temp_train)\n    <line_mask>\n    model.append(temp_model)\n\n# Inference every test dataset\nresult=[]\nfor p,v in enumerate(item_list):\n    # ray remote eval\n    result.append(inference_model_remote.remote(model[p], test[p]\n                                                , timestamp_col='pickup_monthly'\n                                                , item_col='pulocationid'\n                                                , target_col='trip_quantity'))\n\n# ray.get() means block until all objectIDs requested are available\nforecast = ray.get(result)",
            "masked_line": "test.append(temp_test)",
            "answer": "append",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_548"
        },
        {
            "dependency": "ray",
            "version": "==1.8",
            "time": "2021-11-08",
            "description": "The code defines functions to train an auto.arima model on taxi data and make predictions using the trained model. It uses Ray for distributed computing to train and infer models for each unique pulocationid in the dataset.",
            "code": "import ray\nimport pandas as pd\nimport pmdarima as pm\nfrom pmdarima.model_selection import train_test_split\n\n# read 8 months of clean, aggregated monthly taxi data\nfilename = \"https://github.com/christy/MachineLearningTools/blob/master/data/clean_taxi_monthly.parquet?raw=true\"\ng_month = pd.read_parquet(filename) \n\n# Define a train_model function, default train on 6 months, inference 2\ndef train_model(theDF:pd.DataFrame, item_col:str\n                , item_value:str, target_col:str\n                , train_size:int=6) -> list:\n\n    # split data into train/test\n    train, test = train_test_split(theDF.loc[(theDF[item_col]==item_value), :], train_size=train_size)\n    \n    # train and fit auto.arima model\n    model = pm.auto_arima(y=train[target_col]\n                          ,X=train.loc[:, (train.columns!=target_col) \n                                          & (train.columns!=item_col)]\n                         )\n    # here is the extra pickle step to handle statsmodel objects\n    return [train, test, pickle.dumps(model)]\n\n\n# Define inference_model function\ndef inference_model(model_pickle:bytes, test:pd.DataFrame\n                    , timestamp_col:str, item_col:str, target_col:str) -> pd.DataFrame:\n\n    # unpickle the model\n    model = pickle.loads(model_pickle)\n    \n    # inference on test data\n    forecast = pd.DataFrame(model.predict(n_periods=test.shape[0]\n                         , X=test.loc[:, (test.columns!=target_col) & (test.columns!=item_col)]\n                         , index=test.index))\n    \n    return forecast\n\n\n# start-up ray on your laptop for testing purposes\nimport ray\nNUM_CPU = 2\nray.init(\n    ignore_reinit_error=True\n    , num_cpus = NUM_CPU\n)\n\n###########\n# run your training as distributed jobs by using ray remote function calls\n###########\n    \n# Convert your regular python functions to ray remote functions\ntrain_model_remote = ray.remote(train_model).options(num_returns=3)  \ninference_model_remote = ray.remote(inference_model)\n    \n# Train every model\nitem_list = list(g_month['pulocationid'].unique())\nmodel = []\ntrain = []\ntest = []\n\nfor p,v in enumerate(item_list):\n    # ray remote eval\n    temp_train, temp_test, temp_model = \\\n        train_model_remote.remote(g_month\n                                  , item_col='pulocationid', item_value=v\n                                  , target_col='trip_quantity'\n                                  , train_size=6)\n    train.append(temp_train)\n    test.append(temp_test)\n    model.append(temp_model)\n\n# Inference every test dataset\nresult=[]\nfor p,v in enumerate(item_list):\n    # ray remote eval\n    result.append(inference_model_remote.remote(model[p], test[p]\n                                                , timestamp_col='pickup_monthly'\n                                                , item_col='pulocationid'\n                                                , target_col='trip_quantity'))\n\n# ray.get() means block until all objectIDs requested are available\nforecast = ray.get(result)",
            "masked_code": "import ray\nimport pandas as pd\nimport pmdarima as pm\nfrom pmdarima.model_selection import train_test_split\n\n# read 8 months of clean, aggregated monthly taxi data\nfilename = \"https://github.com/christy/MachineLearningTools/blob/master/data/clean_taxi_monthly.parquet?raw=true\"\ng_month = pd.read_parquet(filename) \n\n# Define a train_model function, default train on 6 months, inference 2\ndef train_model(theDF:pd.DataFrame, item_col:str\n                , item_value:str, target_col:str\n                , train_size:int=6) -> list:\n\n    # split data into train/test\n    train, test = train_test_split(theDF.loc[(theDF[item_col]==item_value), :], train_size=train_size)\n    \n    # train and fit auto.arima model\n    model = pm.auto_arima(y=train[target_col]\n                          ,X=train.loc[:, (train.columns!=target_col) \n                                          & (train.columns!=item_col)]\n                         )\n    # here is the extra pickle step to handle statsmodel objects\n    return [train, test, pickle.dumps(model)]\n\n\n# Define inference_model function\ndef inference_model(model_pickle:bytes, test:pd.DataFrame\n                    , timestamp_col:str, item_col:str, target_col:str) -> pd.DataFrame:\n\n    # unpickle the model\n    model = pickle.loads(model_pickle)\n    \n    # inference on test data\n    forecast = pd.DataFrame(model.predict(n_periods=test.shape[0]\n                         , X=test.loc[:, (test.columns!=target_col) & (test.columns!=item_col)]\n                         , index=test.index))\n    \n    return forecast\n\n\n# start-up ray on your laptop for testing purposes\nimport ray\nNUM_CPU = 2\nray.init(\n    ignore_reinit_error=True\n    , num_cpus = NUM_CPU\n)\n\n###########\n# run your training as distributed jobs by using ray remote function calls\n###########\n    \n# Convert your regular python functions to ray remote functions\n<line_mask>\ninference_model_remote = ray.remote(inference_model)\n    \n# Train every model\nitem_list = list(g_month['pulocationid'].unique())\nmodel = []\ntrain = []\ntest = []\n\nfor p,v in enumerate(item_list):\n    # ray remote eval\n    temp_train, temp_test, temp_model = \\\n        train_model_remote.remote(g_month\n                                  , item_col='pulocationid', item_value=v\n                                  , target_col='trip_quantity'\n                                  , train_size=6)\n    train.append(temp_train)\n    test.append(temp_test)\n    model.append(temp_model)\n\n# Inference every test dataset\nresult=[]\nfor p,v in enumerate(item_list):\n    # ray remote eval\n    result.append(inference_model_remote.remote(model[p], test[p]\n                                                , timestamp_col='pickup_monthly'\n                                                , item_col='pulocationid'\n                                                , target_col='trip_quantity'))\n\n# ray.get() means block until all objectIDs requested are available\nforecast = ray.get(result)",
            "masked_line": "train_model_remote = ray.remote(train_model).options(num_returns=3)",
            "answer": "options",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_549"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.3",
            "time": "2021-03-23",
            "description": "The code generates a random matrix of normal values with dimensions 50000x50000 and then computes the discrete cosine transform (DCT) of the matrix using the Fast Fourier Transform (FFT) algorithm.",
            "code": "import numpy as np\nimport scipy.fft as fft\n\nx = np.random.normal(size=(50000,50000))\ny = fft.dct(x)",
            "masked_code": "import numpy as np\nimport scipy.fft as fft\n\n<line_mask>\ny = fft.dct(x)",
            "masked_line": "x = np.random.normal(size=(50000,50000))",
            "answer": "normal",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_550"
        },
        {
            "dependency": "scipy",
            "version": "==1.6.1",
            "time": "2021-03-23",
            "description": "The code generates a 50000x50000 matrix of random numbers and computes the discrete cosine transform (DCT) of the matrix using the Fast Fourier Transform (FFT) algorithm.",
            "code": "import numpy as np\nimport scipy.fft as fft\n\nx = np.random.normal(size=(50000,50000))\ny = fft.dct(x)",
            "masked_code": "import numpy as np\nimport scipy.fft as fft\n\nx = np.random.normal(size=(50000,50000))\n<line_mask>",
            "masked_line": "y = fft.dct(x)",
            "answer": "dct",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_551"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-27",
            "description": "The code creates a joint plot using seaborn to visualize the relationship between two sets of data points. The first set of data points is represented by the variables x1 and y1 with categories 'a' and 'b', and the second set of data points is represented by the variables x2 and y2 with categories 'c' and 'd'. The code also extracts new colors for the categories from the color palette used in the joint plot to plot additional points from the second dataframe on the same scatter plot.",
            "code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {\n    'x1': [3,2,5,1,1,0],\n    'y1': [1,1,2,3,0,2],\n    'cat': ['a','a','a','b','b','b']\n}\n\ndf = pd.DataFrame(d)\n\n# Set seaborn color palette\nsns.set_palette('bright')\ng = sns.jointplot(data=df, x='x1', y='y1', hue='cat')\n\nd = {\n    'x2': [2,0,6,0,4,1],\n    'y2': [-3,-2,0,2,3,4],\n    'cat': ['c','c','c','c','d','d']\n}\ndf2 = pd.DataFrame(d)\n\n# Extract new colors from currently selected color palette\ncolors = sns.color_palette()[g.hue.nunique():][:df2['cat'].nunique()]\n\n# Plot additional points from second dataframe in scatter plot of the joint plot\nsns.scatterplot(data=df2, x='x2', y='y2', hue='cat', palette=colors, ax=g.ax_joint);",
            "masked_code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {\n    'x1': [3,2,5,1,1,0],\n    'y1': [1,1,2,3,0,2],\n    'cat': ['a','a','a','b','b','b']\n}\n\ndf = pd.DataFrame(d)\n\n# Set seaborn color palette\nsns.set_palette('bright')\ng = sns.jointplot(data=df, x='x1', y='y1', hue='cat')\n\nd = {\n    'x2': [2,0,6,0,4,1],\n    'y2': [-3,-2,0,2,3,4],\n    'cat': ['c','c','c','c','d','d']\n}\ndf2 = pd.DataFrame(d)\n\n# Extract new colors from currently selected color palette\n<line_mask>\n\n# Plot additional points from second dataframe in scatter plot of the joint plot\nsns.scatterplot(data=df2, x='x2', y='y2', hue='cat', palette=colors, ax=g.ax_joint);",
            "masked_line": "colors = sns.color_palette()[g.hue.nunique():][:df2['cat'].nunique()]",
            "answer": "nunique",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_552"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-27",
            "description": "The code creates two dataframes with x, y, and category columns, then plots a joint plot with the first dataframe points colored by category and additional points from the second dataframe plotted with different colors based on the category.",
            "code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {\n    'x1': [3,2,5,1,1,0],\n    'y1': [1,1,2,3,0,2],\n    'cat': ['a','a','a','b','b','b']\n}\n\ndf = pd.DataFrame(d)\n\n# Set seaborn color palette\nsns.set_palette('bright')\ng = sns.jointplot(data=df, x='x1', y='y1', hue='cat')\n\nd = {\n    'x2': [2,0,6,0,4,1],\n    'y2': [-3,-2,0,2,3,4],\n    'cat': ['c','c','c','c','d','d']\n}\ndf2 = pd.DataFrame(d)\n\n# Extract new colors from currently selected color palette\ncolors = sns.color_palette()[g.hue.nunique():][:df2['cat'].nunique()]\n\n# Plot additional points from second dataframe in scatter plot of the joint plot\nsns.scatterplot(data=df2, x='x2', y='y2', hue='cat', palette=colors, ax=g.ax_joint);",
            "masked_code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {\n    'x1': [3,2,5,1,1,0],\n    'y1': [1,1,2,3,0,2],\n    'cat': ['a','a','a','b','b','b']\n}\n\ndf = pd.DataFrame(d)\n\n# Set seaborn color palette\nsns.set_palette('bright')\ng = sns.jointplot(data=df, x='x1', y='y1', hue='cat')\n\nd = {\n    'x2': [2,0,6,0,4,1],\n    'y2': [-3,-2,0,2,3,4],\n    'cat': ['c','c','c','c','d','d']\n}\ndf2 = pd.DataFrame(d)\n\n# Extract new colors from currently selected color palette\ncolors = sns.color_palette()[g.hue.nunique():][:df2['cat'].nunique()]\n\n# Plot additional points from second dataframe in scatter plot of the joint plot\n<line_mask>",
            "masked_line": "sns.scatterplot(data=df2, x='x2', y='y2', hue='cat', palette=colors, ax=g.ax_joint);",
            "answer": "scatterplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_553"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-02-26",
            "description": "This code generates a sample dataset with columns 'Type', 'Label', and 'Date'. The 'Type' column contains random choices of 'A', 'B', 'C', or 'D'. The 'Label' column contains random choices of 0 or 1. The 'Date' column contains random dates between '2020-01-01' and '2020-01-31'.",
            "code": "import numpy as np   # v 1.19.2\nimport pandas as pd  # v 1.1.3\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndti = pd.date_range('2020-01-01', '2020-01-31', freq='D')\nsize = 2*dti.size\ndfraw = pd.DataFrame(data=dict(Type = rng.choice(list('ABCD'), size=size),\n                               Label = rng.choice([0,1], size=size),\n                               Date = rng.choice(dti, size=size)))\ndfraw.head()",
            "masked_code": "import numpy as np   # v 1.19.2\nimport pandas as pd  # v 1.1.3\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndti = pd.date_range('2020-01-01', '2020-01-31', freq='D')\nsize = 2*dti.size\n<line_mask>\n                               Label = rng.choice([0,1], size=size),\n                               Date = rng.choice(dti, size=size)))\ndfraw.head()",
            "masked_line": "dfraw = pd.DataFrame(data=dict(Type = rng.choice(list('ABCD'), size=size),",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_554"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-26",
            "description": "This code snippet generates a sample dataset consisting of Type, Label, and Date columns using random choices. The Type column contains random choices from the letters 'A', 'B', 'C', 'D', the Label column contains random choices of 0 or 1, and the Date column contains random dates from January 1, 2020, to January 31, 2020.",
            "code": "import numpy as np   # v 1.19.2\nimport pandas as pd  # v 1.1.3\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndti = pd.date_range('2020-01-01', '2020-01-31', freq='D')\nsize = 2*dti.size\ndfraw = pd.DataFrame(data=dict(Type = rng.choice(list('ABCD'), size=size),\n                               Label = rng.choice([0,1], size=size),\n                               Date = rng.choice(dti, size=size)))\ndfraw.head()",
            "masked_code": "import numpy as np   # v 1.19.2\nimport pandas as pd  # v 1.1.3\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\n<line_mask>\nsize = 2*dti.size\ndfraw = pd.DataFrame(data=dict(Type = rng.choice(list('ABCD'), size=size),\n                               Label = rng.choice([0,1], size=size),\n                               Date = rng.choice(dti, size=size)))\ndfraw.head()",
            "masked_line": "dti = pd.date_range('2020-01-01', '2020-01-31', freq='D')",
            "answer": "date_range",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_555"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-02-12",
            "description": "This code creates a time series plot using matplotlib with monthly ticks on the x-axis. The plot displays a sample dataset with a variable that has been cumulatively summed. The code generates monthly ticks based on the timestamp objects of the dataset, selecting an appropriate number of ticks to display on the plot and labeling them with month and year information.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create sample dataset\nstart_date = '2019-01-25'\nend_date = '2021-02-12'\nrng = np.random.default_rng(seed=123) # random number generator\ndti = pd.date_range(start_date, end_date, freq='D')\nvariable = 100 + rng.normal(size=dti.size).cumsum()\ndf = pd.DataFrame(dict(variable=variable), index=dti)\n\n# Create matplotlib plot\nfig, ax = plt.subplots(figsize=(10, 2))\nax.plot(df.index, df.variable)\n\n# Create list of monthly ticks made of timestamp objects\nmonthly_ticks = [timestamp for idx, timestamp in enumerate(df.index)\n                 if (timestamp.month != df.index[idx-1].month) | (idx == 0)]\n\n# Select appropriate number of ticks and include last month\nstep = 1\nwhile len(monthly_ticks[::step]) > 10:\n    step += 1\nticks = np.unique(np.append(monthly_ticks[::step], monthly_ticks[-1]))\n\n# Create tick labels from tick timestamps\nlabels = [timestamp.strftime('%b\\n%Y') if timestamp.year != ticks[idx-1].year\n          else timestamp.strftime('%b') for idx, timestamp in enumerate(ticks)]\n\nplt.xticks(ticks, labels, rotation=0, ha='center');",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create sample dataset\nstart_date = '2019-01-25'\nend_date = '2021-02-12'\nrng = np.random.default_rng(seed=123) # random number generator\ndti = pd.date_range(start_date, end_date, freq='D')\n<line_mask>\ndf = pd.DataFrame(dict(variable=variable), index=dti)\n\n# Create matplotlib plot\nfig, ax = plt.subplots(figsize=(10, 2))\nax.plot(df.index, df.variable)\n\n# Create list of monthly ticks made of timestamp objects\nmonthly_ticks = [timestamp for idx, timestamp in enumerate(df.index)\n                 if (timestamp.month != df.index[idx-1].month) | (idx == 0)]\n\n# Select appropriate number of ticks and include last month\nstep = 1\nwhile len(monthly_ticks[::step]) > 10:\n    step += 1\nticks = np.unique(np.append(monthly_ticks[::step], monthly_ticks[-1]))\n\n# Create tick labels from tick timestamps\nlabels = [timestamp.strftime('%b\\n%Y') if timestamp.year != ticks[idx-1].year\n          else timestamp.strftime('%b') for idx, timestamp in enumerate(ticks)]\n\nplt.xticks(ticks, labels, rotation=0, ha='center');",
            "masked_line": "variable = 100 + rng.normal(size=dti.size).cumsum()",
            "answer": "cumsum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_556"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-12",
            "description": "The code generates a time series dataset with a random variable, creates a plot using matplotlib, identifies monthly ticks on the x-axis of the plot, selects an appropriate number of monthly ticks with labels showing month and year, and displays the plot with monthly ticks and labels.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create sample dataset\nstart_date = '2019-01-25'\nend_date = '2021-02-12'\nrng = np.random.default_rng(seed=123) # random number generator\ndti = pd.date_range(start_date, end_date, freq='D')\nvariable = 100 + rng.normal(size=dti.size).cumsum()\ndf = pd.DataFrame(dict(variable=variable), index=dti)\n\n# Create matplotlib plot\nfig, ax = plt.subplots(figsize=(10, 2))\nax.plot(df.index, df.variable)\n\n# Create list of monthly ticks made of timestamp objects\nmonthly_ticks = [timestamp for idx, timestamp in enumerate(df.index)\n                 if (timestamp.month != df.index[idx-1].month) | (idx == 0)]\n\n# Select appropriate number of ticks and include last month\nstep = 1\nwhile len(monthly_ticks[::step]) > 10:\n    step += 1\nticks = np.unique(np.append(monthly_ticks[::step], monthly_ticks[-1]))\n\n# Create tick labels from tick timestamps\nlabels = [timestamp.strftime('%b\\n%Y') if timestamp.year != ticks[idx-1].year\n          else timestamp.strftime('%b') for idx, timestamp in enumerate(ticks)]\n\nplt.xticks(ticks, labels, rotation=0, ha='center');",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create sample dataset\nstart_date = '2019-01-25'\nend_date = '2021-02-12'\nrng = np.random.default_rng(seed=123) # random number generator\ndti = pd.date_range(start_date, end_date, freq='D')\nvariable = 100 + rng.normal(size=dti.size).cumsum()\n<line_mask>\n\n# Create matplotlib plot\nfig, ax = plt.subplots(figsize=(10, 2))\nax.plot(df.index, df.variable)\n\n# Create list of monthly ticks made of timestamp objects\nmonthly_ticks = [timestamp for idx, timestamp in enumerate(df.index)\n                 if (timestamp.month != df.index[idx-1].month) | (idx == 0)]\n\n# Select appropriate number of ticks and include last month\nstep = 1\nwhile len(monthly_ticks[::step]) > 10:\n    step += 1\nticks = np.unique(np.append(monthly_ticks[::step], monthly_ticks[-1]))\n\n# Create tick labels from tick timestamps\nlabels = [timestamp.strftime('%b\\n%Y') if timestamp.year != ticks[idx-1].year\n          else timestamp.strftime('%b') for idx, timestamp in enumerate(ticks)]\n\nplt.xticks(ticks, labels, rotation=0, ha='center');",
            "masked_line": "df = pd.DataFrame(dict(variable=variable), index=dti)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_557"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-12",
            "description": "The code generates a sample dataset with a date range, creates a matplotlib plot showing the variable trend over time, creates a list of monthly ticks for the x-axis labeling on the plot, selects an appropriate number of ticks to display on the x-axis, and adds tick labels in the format of month and year.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create sample dataset\nstart_date = '2019-01-25'\nend_date = '2021-02-12'\nrng = np.random.default_rng(seed=123) # random number generator\ndti = pd.date_range(start_date, end_date, freq='D')\nvariable = 100 + rng.normal(size=dti.size).cumsum()\ndf = pd.DataFrame(dict(variable=variable), index=dti)\n\n# Create matplotlib plot\nfig, ax = plt.subplots(figsize=(10, 2))\nax.plot(df.index, df.variable)\n\n# Create list of monthly ticks made of timestamp objects\nmonthly_ticks = [timestamp for idx, timestamp in enumerate(df.index)\n                 if (timestamp.month != df.index[idx-1].month) | (idx == 0)]\n\n# Select appropriate number of ticks and include last month\nstep = 1\nwhile len(monthly_ticks[::step]) > 10:\n    step += 1\nticks = np.unique(np.append(monthly_ticks[::step], monthly_ticks[-1]))\n\n# Create tick labels from tick timestamps\nlabels = [timestamp.strftime('%b\\n%Y') if timestamp.year != ticks[idx-1].year\n          else timestamp.strftime('%b') for idx, timestamp in enumerate(ticks)]\n\nplt.xticks(ticks, labels, rotation=0, ha='center');",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create sample dataset\nstart_date = '2019-01-25'\nend_date = '2021-02-12'\nrng = np.random.default_rng(seed=123) # random number generator\ndti = pd.date_range(start_date, end_date, freq='D')\nvariable = 100 + rng.normal(size=dti.size).cumsum()\ndf = pd.DataFrame(dict(variable=variable), index=dti)\n\n# Create matplotlib plot\n<line_mask>\nax.plot(df.index, df.variable)\n\n# Create list of monthly ticks made of timestamp objects\nmonthly_ticks = [timestamp for idx, timestamp in enumerate(df.index)\n                 if (timestamp.month != df.index[idx-1].month) | (idx == 0)]\n\n# Select appropriate number of ticks and include last month\nstep = 1\nwhile len(monthly_ticks[::step]) > 10:\n    step += 1\nticks = np.unique(np.append(monthly_ticks[::step], monthly_ticks[-1]))\n\n# Create tick labels from tick timestamps\nlabels = [timestamp.strftime('%b\\n%Y') if timestamp.year != ticks[idx-1].year\n          else timestamp.strftime('%b') for idx, timestamp in enumerate(ticks)]\n\nplt.xticks(ticks, labels, rotation=0, ha='center');",
            "masked_line": "fig, ax = plt.subplots(figsize=(10, 2))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_558"
        },
        {
            "dependency": "pyspark",
            "version": ">=2.4",
            "time": "2021-08-25",
            "description": "The code creates a new column 'NewColumn' in the DataFrame 'df', where the value of the column is 1 if there is no occurrence of the value 1 in the array of features 'feature2', 'feature3', and 'feature4' for each 'id' partition, and 0 otherwise.",
            "code": "from pyspark.sql.functions import expr\n\ndf = df.withColumn('NewColumn', \n                   expr(\"\"\"cast(\n                             not exists(\n                               flatten(\n                                 collect_list(array(feature2,feature3,feature4)) over (partition by id)),\n                               v -> v = 1)\n                             as int)\"\"\"))\ndf.show()\n\n# +---+--------+--------+--------+--------+---------+\n# | id|feature1|feature2|feature3|feature4|NewColumn|\n# +---+--------+--------+--------+--------+---------+\n# |  1|       a|       0|       0|       0|        1|\n# |  1|       b|       0|       0|       0|        1|\n# |  1|       c|       0|       0|       0|        1|\n# |  3|       b|       0|       0|       0|        0|\n# |  3|       c|       0|       1|       0|        0|\n# |  2|       a|       1|       0|       0|        0|\n# |  2|       b|       0|       0|       0|        0|\n# |  2|       c|       0|       0|       0|        0|\n# +---+--------+--------+--------+--------+---------+",
            "masked_code": "<line_mask>\n\ndf = df.withColumn('NewColumn', \n                   expr(\"\"\"cast(\n                             not exists(\n                               flatten(\n                                 collect_list(array(feature2,feature3,feature4)) over (partition by id)),\n                               v -> v = 1)\n                             as int)\"\"\"))\ndf.show()\n\n# +---+--------+--------+--------+--------+---------+\n# | id|feature1|feature2|feature3|feature4|NewColumn|\n# +---+--------+--------+--------+--------+---------+\n# |  1|       a|       0|       0|       0|        1|\n# |  1|       b|       0|       0|       0|        1|\n# |  1|       c|       0|       0|       0|        1|\n# |  3|       b|       0|       0|       0|        0|\n# |  3|       c|       0|       1|       0|        0|\n# |  2|       a|       1|       0|       0|        0|\n# |  2|       b|       0|       0|       0|        0|\n# |  2|       c|       0|       0|       0|        0|\n# +---+--------+--------+--------+--------+---------+",
            "masked_line": "from pyspark.sql.functions import expr",
            "answer": "expr",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_559"
        },
        {
            "dependency": "bokeh",
            "version": "==2.1.1",
            "time": "2021-08-06",
            "description": "This code creates a DataTable with two columns and an empty data source, then adds the DataTable to the document root but sets it to not be visible.",
            "code": "from bokeh.io import curdoc\nfrom bokeh.models import ColumnDataSource, DataTable, TableColumn\n\ncolumns=[TableColumn(field=str(i),title=str(i),width=200,name=str(i)) for i in range(2)]\nsource = ColumnDataSource(data={}, name='mySource')\ntable=DataTable(source=source,columns=columns,name='myTable',visible=False)\ncurdoc().add_root(table)",
            "masked_code": "from bokeh.io import curdoc\n<line_mask>\n\ncolumns=[TableColumn(field=str(i),title=str(i),width=200,name=str(i)) for i in range(2)]\nsource = ColumnDataSource(data={}, name='mySource')\ntable=DataTable(source=source,columns=columns,name='myTable',visible=False)\ncurdoc().add_root(table)",
            "masked_line": "from bokeh.models import ColumnDataSource, DataTable, TableColumn",
            "answer": "TableColumn",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_560"
        },
        {
            "dependency": "lark",
            "version": "==0.11.3",
            "time": "2021-06-20",
            "description": "This code defines a parser that can recognize and accept specific values assigned to a variable in a text input.",
            "code": "from lark import Lark\n\nparser = Lark(r\"\"\"\n?start: NAME \"=\" possible_values\npossible_values: \"apple\" | \"banana\" | \"orange\"\nNAME: /\\w+/\n%ignore /\\s+/\n\"\"\", parser=\"lalr\")\n\ninteractive = parser.parse_interactive(\"my_variable = \")\n\n# feeds the text given to above into the parsers. This is not done automatically.\ninteractive.exhaust_lexer()\n\n\n# returns the names of the Terminals that are currently accepted.\nprint(interactive.accepts())",
            "masked_code": "from lark import Lark\n\nparser = Lark(r\"\"\"\n?start: NAME \"=\" possible_values\npossible_values: \"apple\" | \"banana\" | \"orange\"\nNAME: /\\w+/\n%ignore /\\s+/\n\"\"\", parser=\"lalr\")\n\ninteractive = parser.parse_interactive(\"my_variable = \")\n\n# feeds the text given to above into the parsers. This is not done automatically.\ninteractive.exhaust_lexer()\n\n\n# returns the names of the Terminals that are currently accepted.\n<line_mask>",
            "masked_line": "print(interactive.accepts())",
            "answer": "accepts",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_561"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-06-01",
            "description": "The code reads and extracts data from an XML file named \"Input.xml\" containing signal information and stores it in a DataFrame called \"signals_df\".",
            "code": "signals_df = pd.read_xml(\"Input.xml\", xpath=\".//Signal\")",
            "masked_code": "<line_mask>",
            "masked_line": "signals_df = pd.read_xml(\"Input.xml\", xpath=\".//Signal\")",
            "answer": "read_xml",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_562"
        },
        {
            "dependency": "bokeh",
            "version": "==2.1.1",
            "time": "2021-06-16",
            "description": "The code creates a Bokeh layout with a button and a radio button group. When the button is clicked, it triggers a JavaScript code that displays an alert message if the radio button group is set to 'Alert ON'. The layout is then shown on the Bokeh server.",
            "code": "from bokeh.io import curdoc, show\nfrom bokeh.models.widgets import Button, RadioButtonGroup\nfrom bokeh.layouts import column\nfrom bokeh.models.callbacks import CustomJS\n\nbutton_classify = Button(label=\"Create Pop-up alert\")\nbutton_group = RadioButtonGroup(labels=['Alert ON', 'Alert OFF'], active=0)\n\ncode = 'if (button_group.active == 0) { alert(\"ALERT !\"); }'\nbutton_classify.js_on_click(CustomJS(args={'button_group': button_group}, code=code))\nlayout = column(button_group, button_classify)\n\nshow(layout)\n\n# curdoc().add_root(layout)\n# curdoc().title = \"Pop-up Alert\"",
            "masked_code": "from bokeh.io import curdoc, show\nfrom bokeh.models.widgets import Button, RadioButtonGroup\nfrom bokeh.layouts import column\nfrom bokeh.models.callbacks import CustomJS\n\nbutton_classify = Button(label=\"Create Pop-up alert\")\nbutton_group = RadioButtonGroup(labels=['Alert ON', 'Alert OFF'], active=0)\n\ncode = 'if (button_group.active == 0) { alert(\"ALERT !\"); }'\n<line_mask>\nlayout = column(button_group, button_classify)\n\nshow(layout)\n\n# curdoc().add_root(layout)\n# curdoc().title = \"Pop-up Alert\"",
            "masked_line": "button_classify.js_on_click(CustomJS(args={'button_group': button_group}, code=code))",
            "answer": "js_on_click",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_563"
        },
        {
            "dependency": "boto3",
            "version": "==1.0.0",
            "time": "2021-05-27",
            "description": "The code enables versioning on all buckets in an AWS S3 account using boto3 library in Python.",
            "code": "import json\nimport boto3\n\n\ndef lambda_handler(event, context):\n    s3 = boto3.client('s3')\n    response = s3.list_buckets()\n\n    for bucket in response['Buckets']:\n        s3.put_bucket_versioning(Bucket=bucket[\"Name\"],\n                             VersioningConfiguration={\n                                 'MFADelete': 'Disabled',\n                                 'Status': 'Enabled',\n                             },\n        )\n    \n    print(\"Enabled versioning on bucket : \", bucket[\"Name\"])\n    \n    return {\n        'statusCode': 200,\n        'body': json.dumps('Hello from Lambda!')\n    }",
            "masked_code": "import json\nimport boto3\n\n\ndef lambda_handler(event, context):\n    s3 = boto3.client('s3')\n    response = s3.list_buckets()\n\n    for bucket in response['Buckets']:\n        <line_mask>\n                             VersioningConfiguration={\n                                 'MFADelete': 'Disabled',\n                                 'Status': 'Enabled',\n                             },\n        )\n    \n    print(\"Enabled versioning on bucket : \", bucket[\"Name\"])\n    \n    return {\n        'statusCode': 200,\n        'body': json.dumps('Hello from Lambda!')\n    }",
            "masked_line": "s3.put_bucket_versioning(Bucket=bucket[\"Name\"],",
            "answer": "put_bucket_versioning",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_564"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-26",
            "description": "This code creates a line plot using the seaborn library, where the x-axis represents the values in column 'a4' of a Pandas DataFrame, the y-axis represents the values in column 'a3', each subplot column represents the unique values in column 'a1', the line colors are based on the values in column 'a2', and the height of each subplot is 4 units.",
            "code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {'a1': ['l1','l1','l1','l1','l1','l1','l2','l2','l2','l2','l2','l2'],\n     'a2': ['a', 'a', 'b','b','c','c','d','d','e','e','f','f'],\n     'a3': [15,20,17,19,23,15,22,21,23,23,24,27],\n     'a4': [1,2,1,2,1,2,1,2,1,2,1,2]}\ndf = pd.DataFrame(d)\n\nsns.relplot(data=df, x='a4', y='a3', col='a1', hue ='a2', kind='line', height=4)",
            "masked_code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {'a1': ['l1','l1','l1','l1','l1','l1','l2','l2','l2','l2','l2','l2'],\n     'a2': ['a', 'a', 'b','b','c','c','d','d','e','e','f','f'],\n     'a3': [15,20,17,19,23,15,22,21,23,23,24,27],\n     'a4': [1,2,1,2,1,2,1,2,1,2,1,2]}\n<line_mask>\n\nsns.relplot(data=df, x='a4', y='a3', col='a1', hue ='a2', kind='line', height=4)",
            "masked_line": "df = pd.DataFrame(d)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_565"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-26",
            "description": "The code creates a line plot using seaborn's relplot function, displaying the relationship between the values in column 'a4' on the x-axis and the values in column 'a3' on the y-axis. The plot is separated into multiple columns based on the unique values in column 'a1', with different colors distinguishing the values in column 'a2'.",
            "code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {'a1': ['l1','l1','l1','l1','l1','l1','l2','l2','l2','l2','l2','l2'],\n     'a2': ['a', 'a', 'b','b','c','c','d','d','e','e','f','f'],\n     'a3': [15,20,17,19,23,15,22,21,23,23,24,27],\n     'a4': [1,2,1,2,1,2,1,2,1,2,1,2]}\ndf = pd.DataFrame(d)\n\nsns.relplot(data=df, x='a4', y='a3', col='a1', hue ='a2', kind='line', height=4)",
            "masked_code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {'a1': ['l1','l1','l1','l1','l1','l1','l2','l2','l2','l2','l2','l2'],\n     'a2': ['a', 'a', 'b','b','c','c','d','d','e','e','f','f'],\n     'a3': [15,20,17,19,23,15,22,21,23,23,24,27],\n     'a4': [1,2,1,2,1,2,1,2,1,2,1,2]}\ndf = pd.DataFrame(d)\n\n<line_mask>",
            "masked_line": "sns.relplot(data=df, x='a4', y='a3', col='a1', hue ='a2', kind='line', height=4)",
            "answer": "relplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_566"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-01-25",
            "description": "The code generates a plot showing the distribution of 'TOTL_SQ_FT_CNT' values for two different deciles (10 and 1) in the dataset 'check3' with choice value equal to 1. The plot uses seaborn library to display the distribution of 'TOTL_SQ_FT_CNT' values for decile 10 and decile 1 on the same graph.",
            "code": "d10_ft = check3[(check3['choice'] == 1)&(check3['decile'] == 10)]['TOTL_SQ_FT_CNT']\nd1_ft = check3[(check3['choice'] == 1)&(check3['decile'] == 1)]['TOTL_SQ_FT_CNT']\n\nf, ax = plt.subplots(1, 1)\nsns.distplot(d10_ft, label = 'decile 10',ax=ax)\nsns.distplot(d1_ft, label = 'decile 1',ax=ax)\nax.legend()",
            "masked_code": "d10_ft = check3[(check3['choice'] == 1)&(check3['decile'] == 10)]['TOTL_SQ_FT_CNT']\nd1_ft = check3[(check3['choice'] == 1)&(check3['decile'] == 1)]['TOTL_SQ_FT_CNT']\n\nf, ax = plt.subplots(1, 1)\n<line_mask>\nsns.distplot(d1_ft, label = 'decile 1',ax=ax)\nax.legend()",
            "masked_line": "sns.distplot(d10_ft, label = 'decile 10',ax=ax)",
            "answer": "distplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_567"
        },
        {
            "dependency": "xlwings",
            "version": "==0.26.1",
            "time": "2022-02-21",
            "description": "This code adds and deletes a page break at row 24 in an Excel sheet. It first adds a page break at row 24 using xlwings, then checks and prints the page break status for rows 23, 24, and 25. After that, it deletes the page break at row 24 and again prints the page break status for rows 23, 24, and 25.",
            "code": "import xlwings as xw\nfrom xlwings.constants import PageBreak\n\n### Constant values for reference\n# xlPageBreakAutomatic = -4105\n# xlPageBreakManual = -4135\n# xlPageBreakNone = -4142\n\napp = xw.App(visible=True, add_book=False)\nsht = xw.Book(\"book.xlsx\").sheets['Sheet1']\n\nprint(\"Add Page break at row 24\")\nsht.api.Rows(24).PageBreak = True\n# sht.api.Rows(24).PageBreak = -4135  # This does the same as the line above \n# sht.api.Rows(24).PageBreak = PageBreak.xlPageBreakManual # As does this line\nprint('Row23: ' + str(sht.api.Rows(23).PageBreak))\nprint('Row24: ' + str(sht.api.Rows(24).PageBreak))\nprint('Row25: ' + str(sht.api.Rows(25).PageBreak))\n\nprint(\"\\nDelete Page break at row 24\")\nsht.api.Rows(24).PageBreak = PageBreak.xlPageBreakNone\nprint('Row23: ' + str(sht.api.Rows(23).PageBreak))\nprint('Row24: ' + str(sht.api.Rows(24).PageBreak))\nprint('Row25: ' + str(sht.api.Rows(25).PageBreak))",
            "masked_code": "import xlwings as xw\nfrom xlwings.constants import PageBreak\n\n### Constant values for reference\n# xlPageBreakAutomatic = -4105\n# xlPageBreakManual = -4135\n# xlPageBreakNone = -4142\n\napp = xw.App(visible=True, add_book=False)\n<line_mask>\n\nprint(\"Add Page break at row 24\")\nsht.api.Rows(24).PageBreak = True\n# sht.api.Rows(24).PageBreak = -4135  # This does the same as the line above \n# sht.api.Rows(24).PageBreak = PageBreak.xlPageBreakManual # As does this line\nprint('Row23: ' + str(sht.api.Rows(23).PageBreak))\nprint('Row24: ' + str(sht.api.Rows(24).PageBreak))\nprint('Row25: ' + str(sht.api.Rows(25).PageBreak))\n\nprint(\"\\nDelete Page break at row 24\")\nsht.api.Rows(24).PageBreak = PageBreak.xlPageBreakNone\nprint('Row23: ' + str(sht.api.Rows(23).PageBreak))\nprint('Row24: ' + str(sht.api.Rows(24).PageBreak))\nprint('Row25: ' + str(sht.api.Rows(25).PageBreak))",
            "masked_line": "sht = xw.Book(\"book.xlsx\").sheets['Sheet1']",
            "answer": "Book",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_568"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-27",
            "description": "The code converts the date strings in columns 'x' and 'y' of a pandas DataFrame into datetime objects and prints the updated DataFrame with the converted datetime values.",
            "code": "import pandas as pd  # v 1.1.3\n\ndf = pd.DataFrame(dict(x=['2020-12-30 12:00:00 UTC', '2020-12-30 13:00:00 UTC',\n                          '2020-12-30 14:00:00 UTC', '2020-12-30 15:00:00 UTC',\n                          '2020-12-30 16:00:00 UTC'],\n                       y=['2020-12-31 01:00:00 UTC', '2020-12-31 04:00:00 UTC',\n                          '2020-12-31 02:00:00 UTC', '2020-12-31 05:00:00 UTC',\n                          '2020-12-31 03:00:00 UTC']))\n\ndf[['x','y']] = df[['x','y']].apply(lambda x: pd.to_datetime(x).values)\nprint(df[['x','y']])\n#                      x                   y\n#  0 2020-12-30 12:00:00 2020-12-31 01:00:00\n#  1 2020-12-30 13:00:00 2020-12-31 04:00:00\n#  2 2020-12-30 14:00:00 2020-12-31 02:00:00\n#  3 2020-12-30 15:00:00 2020-12-31 05:00:00\n#  4 2020-12-30 16:00:00 2020-12-31 03:00:00",
            "masked_code": "import pandas as pd  # v 1.1.3\n\ndf = pd.DataFrame(dict(x=['2020-12-30 12:00:00 UTC', '2020-12-30 13:00:00 UTC',\n                          '2020-12-30 14:00:00 UTC', '2020-12-30 15:00:00 UTC',\n                          '2020-12-30 16:00:00 UTC'],\n                       y=['2020-12-31 01:00:00 UTC', '2020-12-31 04:00:00 UTC',\n                          '2020-12-31 02:00:00 UTC', '2020-12-31 05:00:00 UTC',\n                          '2020-12-31 03:00:00 UTC']))\n\n<line_mask>\nprint(df[['x','y']])\n#                      x                   y\n#  0 2020-12-30 12:00:00 2020-12-31 01:00:00\n#  1 2020-12-30 13:00:00 2020-12-31 04:00:00\n#  2 2020-12-30 14:00:00 2020-12-31 02:00:00\n#  3 2020-12-30 15:00:00 2020-12-31 05:00:00\n#  4 2020-12-30 16:00:00 2020-12-31 03:00:00",
            "masked_line": "df[['x','y']] = df[['x','y']].apply(lambda x: pd.to_datetime(x).values)",
            "answer": "apply",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_569"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-02-16",
            "description": "The code creates a plot with two subplots side by side, each showing data from a sample dataset. The data is split based on a boundary point and x-axis ticks are selected accordingly. The subplots have their x-axis limits adjusted, boundary spines removed, and specific x-axis ticks set. Finally, additional formatting such as axis labels and titles are applied to the plot.",
            "code": "import numpy as np               # v 1.19.2\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\nx = np.linspace(4000, 400, num=50)\ny = 1 - rng.exponential(scale=0.1, size=x.size)\ndf = pd.DataFrame(dict(Wavenumber=x, Intensity=y))\n\n# Select data for each subplot by using a boundary point\nx_boundary = min(df['Wavenumber'], key=lambda x: abs(x-2000))\ndf1 = df[df['Wavenumber'] >= x_boundary]\ndf2 = df[df['Wavenumber'] <= x_boundary]\n\n# Select x-axis ticks for each subplot\nticks = np.array([4000, 3000, 2000, 1600, 1200, 800, 400])\ntk1 = ticks[ticks >= x_boundary]\ntk2 = ticks[ticks <= x_boundary]\n\n# Create figure with 2 Axes side-by-side with no space in between\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5), sharey=True,\n                               gridspec_kw=dict(wspace=0))\n\n# Loop through both Axes to plot data, adjust x-axis limits and remove boundary spines\nfor ax, data, spine, tk in zip((ax1, ax2), (df1, df2), ('right','left'), (tk1, tk2)):\n    data.plot(x='Wavenumber', xlabel='', ax=ax, legend=None)\n    ax.set_xlim(data['Wavenumber'].iloc[[0,-1]])\n    ax.spines[spine].set_visible(False)\n    ax.set_xticks(tk)\n\n# Additional formatting\nax2.tick_params(axis='y', length=0)\nax1.set_xlabel('Wavenumber', x=1, labelpad=10, size=12)\nax1.set_ylabel('Intensity', labelpad=10, size=12)\nfig.suptitle('Plot with two linear x-axis scales joined together', size=16, y=0.95);",
            "masked_code": "import numpy as np               # v 1.19.2\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\nx = np.linspace(4000, 400, num=50)\ny = 1 - rng.exponential(scale=0.1, size=x.size)\ndf = pd.DataFrame(dict(Wavenumber=x, Intensity=y))\n\n# Select data for each subplot by using a boundary point\nx_boundary = min(df['Wavenumber'], key=lambda x: abs(x-2000))\ndf1 = df[df['Wavenumber'] >= x_boundary]\ndf2 = df[df['Wavenumber'] <= x_boundary]\n\n# Select x-axis ticks for each subplot\n<line_mask>\ntk1 = ticks[ticks >= x_boundary]\ntk2 = ticks[ticks <= x_boundary]\n\n# Create figure with 2 Axes side-by-side with no space in between\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5), sharey=True,\n                               gridspec_kw=dict(wspace=0))\n\n# Loop through both Axes to plot data, adjust x-axis limits and remove boundary spines\nfor ax, data, spine, tk in zip((ax1, ax2), (df1, df2), ('right','left'), (tk1, tk2)):\n    data.plot(x='Wavenumber', xlabel='', ax=ax, legend=None)\n    ax.set_xlim(data['Wavenumber'].iloc[[0,-1]])\n    ax.spines[spine].set_visible(False)\n    ax.set_xticks(tk)\n\n# Additional formatting\nax2.tick_params(axis='y', length=0)\nax1.set_xlabel('Wavenumber', x=1, labelpad=10, size=12)\nax1.set_ylabel('Intensity', labelpad=10, size=12)\nfig.suptitle('Plot with two linear x-axis scales joined together', size=16, y=0.95);",
            "masked_line": "ticks = np.array([4000, 3000, 2000, 1600, 1200, 800, 400])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_570"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-16",
            "description": "The code generates a plot with two subplots side-by-side, each displaying data from a sample dataset. The data is divided based on a boundary point, and x-axis ticks are selected accordingly for each subplot. The subplots share the y-axis scale and have no space in between. The x-axis limits are adjusted, and boundary spines are removed for better visualization. The plot is further formatted with axis labels, tick parameters, and a title indicating the combination of two linear x-axis scales.",
            "code": "import numpy as np               # v 1.19.2\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\nx = np.linspace(4000, 400, num=50)\ny = 1 - rng.exponential(scale=0.1, size=x.size)\ndf = pd.DataFrame(dict(Wavenumber=x, Intensity=y))\n\n# Select data for each subplot by using a boundary point\nx_boundary = min(df['Wavenumber'], key=lambda x: abs(x-2000))\ndf1 = df[df['Wavenumber'] >= x_boundary]\ndf2 = df[df['Wavenumber'] <= x_boundary]\n\n# Select x-axis ticks for each subplot\nticks = np.array([4000, 3000, 2000, 1600, 1200, 800, 400])\ntk1 = ticks[ticks >= x_boundary]\ntk2 = ticks[ticks <= x_boundary]\n\n# Create figure with 2 Axes side-by-side with no space in between\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5), sharey=True,\n                               gridspec_kw=dict(wspace=0))\n\n# Loop through both Axes to plot data, adjust x-axis limits and remove boundary spines\nfor ax, data, spine, tk in zip((ax1, ax2), (df1, df2), ('right','left'), (tk1, tk2)):\n    data.plot(x='Wavenumber', xlabel='', ax=ax, legend=None)\n    ax.set_xlim(data['Wavenumber'].iloc[[0,-1]])\n    ax.spines[spine].set_visible(False)\n    ax.set_xticks(tk)\n\n# Additional formatting\nax2.tick_params(axis='y', length=0)\nax1.set_xlabel('Wavenumber', x=1, labelpad=10, size=12)\nax1.set_ylabel('Intensity', labelpad=10, size=12)\nfig.suptitle('Plot with two linear x-axis scales joined together', size=16, y=0.95);",
            "masked_code": "import numpy as np               # v 1.19.2\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\nx = np.linspace(4000, 400, num=50)\ny = 1 - rng.exponential(scale=0.1, size=x.size)\n<line_mask>\n\n# Select data for each subplot by using a boundary point\nx_boundary = min(df['Wavenumber'], key=lambda x: abs(x-2000))\ndf1 = df[df['Wavenumber'] >= x_boundary]\ndf2 = df[df['Wavenumber'] <= x_boundary]\n\n# Select x-axis ticks for each subplot\nticks = np.array([4000, 3000, 2000, 1600, 1200, 800, 400])\ntk1 = ticks[ticks >= x_boundary]\ntk2 = ticks[ticks <= x_boundary]\n\n# Create figure with 2 Axes side-by-side with no space in between\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5), sharey=True,\n                               gridspec_kw=dict(wspace=0))\n\n# Loop through both Axes to plot data, adjust x-axis limits and remove boundary spines\nfor ax, data, spine, tk in zip((ax1, ax2), (df1, df2), ('right','left'), (tk1, tk2)):\n    data.plot(x='Wavenumber', xlabel='', ax=ax, legend=None)\n    ax.set_xlim(data['Wavenumber'].iloc[[0,-1]])\n    ax.spines[spine].set_visible(False)\n    ax.set_xticks(tk)\n\n# Additional formatting\nax2.tick_params(axis='y', length=0)\nax1.set_xlabel('Wavenumber', x=1, labelpad=10, size=12)\nax1.set_ylabel('Intensity', labelpad=10, size=12)\nfig.suptitle('Plot with two linear x-axis scales joined together', size=16, y=0.95);",
            "masked_line": "df = pd.DataFrame(dict(Wavenumber=x, Intensity=y))",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_571"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-16",
            "description": "The code creates a plot with two subplots side by side, each with a different linear x-axis scale. The data is selected based on a boundary point, and the x-axis ticks are customized for each subplot. The subplots have no space in between, and the x-axis limits are adjusted while removing boundary spines. The plot is further formatted with labels, title, and other visual adjustments.",
            "code": "import numpy as np               # v 1.19.2\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\nx = np.linspace(4000, 400, num=50)\ny = 1 - rng.exponential(scale=0.1, size=x.size)\ndf = pd.DataFrame(dict(Wavenumber=x, Intensity=y))\n\n# Select data for each subplot by using a boundary point\nx_boundary = min(df['Wavenumber'], key=lambda x: abs(x-2000))\ndf1 = df[df['Wavenumber'] >= x_boundary]\ndf2 = df[df['Wavenumber'] <= x_boundary]\n\n# Select x-axis ticks for each subplot\nticks = np.array([4000, 3000, 2000, 1600, 1200, 800, 400])\ntk1 = ticks[ticks >= x_boundary]\ntk2 = ticks[ticks <= x_boundary]\n\n# Create figure with 2 Axes side-by-side with no space in between\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5), sharey=True,\n                               gridspec_kw=dict(wspace=0))\n\n# Loop through both Axes to plot data, adjust x-axis limits and remove boundary spines\nfor ax, data, spine, tk in zip((ax1, ax2), (df1, df2), ('right','left'), (tk1, tk2)):\n    data.plot(x='Wavenumber', xlabel='', ax=ax, legend=None)\n    ax.set_xlim(data['Wavenumber'].iloc[[0,-1]])\n    ax.spines[spine].set_visible(False)\n    ax.set_xticks(tk)\n\n# Additional formatting\nax2.tick_params(axis='y', length=0)\nax1.set_xlabel('Wavenumber', x=1, labelpad=10, size=12)\nax1.set_ylabel('Intensity', labelpad=10, size=12)\nfig.suptitle('Plot with two linear x-axis scales joined together', size=16, y=0.95);",
            "masked_code": "import numpy as np               # v 1.19.2\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)\nx = np.linspace(4000, 400, num=50)\ny = 1 - rng.exponential(scale=0.1, size=x.size)\ndf = pd.DataFrame(dict(Wavenumber=x, Intensity=y))\n\n# Select data for each subplot by using a boundary point\nx_boundary = min(df['Wavenumber'], key=lambda x: abs(x-2000))\ndf1 = df[df['Wavenumber'] >= x_boundary]\ndf2 = df[df['Wavenumber'] <= x_boundary]\n\n# Select x-axis ticks for each subplot\nticks = np.array([4000, 3000, 2000, 1600, 1200, 800, 400])\ntk1 = ticks[ticks >= x_boundary]\ntk2 = ticks[ticks <= x_boundary]\n\n# Create figure with 2 Axes side-by-side with no space in between\n<line_mask>\n                               gridspec_kw=dict(wspace=0))\n\n# Loop through both Axes to plot data, adjust x-axis limits and remove boundary spines\nfor ax, data, spine, tk in zip((ax1, ax2), (df1, df2), ('right','left'), (tk1, tk2)):\n    data.plot(x='Wavenumber', xlabel='', ax=ax, legend=None)\n    ax.set_xlim(data['Wavenumber'].iloc[[0,-1]])\n    ax.spines[spine].set_visible(False)\n    ax.set_xticks(tk)\n\n# Additional formatting\nax2.tick_params(axis='y', length=0)\nax1.set_xlabel('Wavenumber', x=1, labelpad=10, size=12)\nax1.set_ylabel('Intensity', labelpad=10, size=12)\nfig.suptitle('Plot with two linear x-axis scales joined together', size=16, y=0.95);",
            "masked_line": "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5), sharey=True,",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_572"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-14",
            "description": "The code reads data containing information about costs over different years for different models in various countries, and then creates a seaborn FacetGrid with line plots to visualize the data. It further loops through the axes of the FacetGrid to plot bars representing the range of costs and adjust the x ticks accordingly. Finally, it removes the default Seaborn figure legend and displays a custom legend stored in the first axis.",
            "code": "import io\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\nimport seaborn as sns            # v 0.11.0\n\ndata ='''\n Country Model   Year    Costs   Min Max\n    494 FR  1   1990    300     250     350\n    495 FR  1   1995    250     200     300\n    496 FR  1   2000    220     150     240\n    497 FR  1   2005    210     189     270\n    555 JPN 8   1990    280     250     350\n    556 JPN 8   1995    240     200     300\n    557 JPN 8   2000    200     150     240\n    558 JPN 8   2005    200     189     270\n'''\ndf = pd.read_csv(io.StringIO(data), delim_whitespace=True)\n\n# Create seaborn FacetGrid with line plots\ngrid = sns.relplot(data=df, x='Year', y='Costs', hue='Model', style='Model',height=3.9,\n                   col='Country', kind='line', markers=True, palette='tab10')\n\n# Loop through axes of the FacetGrid to plot bars for ranges and edit x ticks\nfor country, ax in grid.axes_dict.items():\n    df_country = df[df['Country'] == country]\n    cost_range = df_country['Max']-df_country['Min']\n    ax.bar(x=df_country['Year'], height=cost_range, bottom=df_country['Min'], \n           color='black', alpha=0.1, label='Min/max\\nrange')\n    ax.set_xticks(df_country['Year'])\n\n# Remove default seaborn figure legend and show instead full legend stored in first ax\ngrid._legend.remove()\ngrid.axes.flat[0].legend(bbox_to_anchor=(2.1, 0.5), loc='center left',\n                         frameon=False, title=grid.legend.get_title().get_text());",
            "masked_code": "import io\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\nimport seaborn as sns            # v 0.11.0\n\ndata ='''\n Country Model   Year    Costs   Min Max\n    494 FR  1   1990    300     250     350\n    495 FR  1   1995    250     200     300\n    496 FR  1   2000    220     150     240\n    497 FR  1   2005    210     189     270\n    555 JPN 8   1990    280     250     350\n    556 JPN 8   1995    240     200     300\n    557 JPN 8   2000    200     150     240\n    558 JPN 8   2005    200     189     270\n'''\n<line_mask>\n\n# Create seaborn FacetGrid with line plots\ngrid = sns.relplot(data=df, x='Year', y='Costs', hue='Model', style='Model',height=3.9,\n                   col='Country', kind='line', markers=True, palette='tab10')\n\n# Loop through axes of the FacetGrid to plot bars for ranges and edit x ticks\nfor country, ax in grid.axes_dict.items():\n    df_country = df[df['Country'] == country]\n    cost_range = df_country['Max']-df_country['Min']\n    ax.bar(x=df_country['Year'], height=cost_range, bottom=df_country['Min'], \n           color='black', alpha=0.1, label='Min/max\\nrange')\n    ax.set_xticks(df_country['Year'])\n\n# Remove default seaborn figure legend and show instead full legend stored in first ax\ngrid._legend.remove()\ngrid.axes.flat[0].legend(bbox_to_anchor=(2.1, 0.5), loc='center left',\n                         frameon=False, title=grid.legend.get_title().get_text());",
            "masked_line": "df = pd.read_csv(io.StringIO(data), delim_whitespace=True)",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_573"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-14",
            "description": "The code reads in a dataset with information on costs, country, model, and year, then creates a seaborn FacetGrid with line plots for each country showing the cost trends over the years for different models. It also adds bar plots to show the range of costs, and customizes the legend placement.",
            "code": "import io\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\nimport seaborn as sns            # v 0.11.0\n\ndata ='''\n Country Model   Year    Costs   Min Max\n    494 FR  1   1990    300     250     350\n    495 FR  1   1995    250     200     300\n    496 FR  1   2000    220     150     240\n    497 FR  1   2005    210     189     270\n    555 JPN 8   1990    280     250     350\n    556 JPN 8   1995    240     200     300\n    557 JPN 8   2000    200     150     240\n    558 JPN 8   2005    200     189     270\n'''\ndf = pd.read_csv(io.StringIO(data), delim_whitespace=True)\n\n# Create seaborn FacetGrid with line plots\ngrid = sns.relplot(data=df, x='Year', y='Costs', hue='Model', style='Model',height=3.9,\n                   col='Country', kind='line', markers=True, palette='tab10')\n\n# Loop through axes of the FacetGrid to plot bars for ranges and edit x ticks\nfor country, ax in grid.axes_dict.items():\n    df_country = df[df['Country'] == country]\n    cost_range = df_country['Max']-df_country['Min']\n    ax.bar(x=df_country['Year'], height=cost_range, bottom=df_country['Min'], \n           color='black', alpha=0.1, label='Min/max\\nrange')\n    ax.set_xticks(df_country['Year'])\n\n# Remove default seaborn figure legend and show instead full legend stored in first ax\ngrid._legend.remove()\ngrid.axes.flat[0].legend(bbox_to_anchor=(2.1, 0.5), loc='center left',\n                         frameon=False, title=grid.legend.get_title().get_text());",
            "masked_code": "import io\nimport pandas as pd              # v 1.1.3\nimport matplotlib.pyplot as plt  # v 3.3.2\nimport seaborn as sns            # v 0.11.0\n\ndata ='''\n Country Model   Year    Costs   Min Max\n    494 FR  1   1990    300     250     350\n    495 FR  1   1995    250     200     300\n    496 FR  1   2000    220     150     240\n    497 FR  1   2005    210     189     270\n    555 JPN 8   1990    280     250     350\n    556 JPN 8   1995    240     200     300\n    557 JPN 8   2000    200     150     240\n    558 JPN 8   2005    200     189     270\n'''\ndf = pd.read_csv(io.StringIO(data), delim_whitespace=True)\n\n# Create seaborn FacetGrid with line plots\ngrid = sns.relplot(data=df, x='Year', y='Costs', hue='Model', style='Model',height=3.9,\n                   col='Country', kind='line', markers=True, palette='tab10')\n\n# Loop through axes of the FacetGrid to plot bars for ranges and edit x ticks\nfor country, ax in grid.axes_dict.items():\n    df_country = df[df['Country'] == country]\n    cost_range = df_country['Max']-df_country['Min']\n    ax.bar(x=df_country['Year'], height=cost_range, bottom=df_country['Min'], \n           color='black', alpha=0.1, label='Min/max\\nrange')\n    ax.set_xticks(df_country['Year'])\n\n# Remove default seaborn figure legend and show instead full legend stored in first ax\ngrid._legend.remove()\ngrid.axes.flat[0].legend(bbox_to_anchor=(2.1, 0.5), loc='center left',\n                         <line_mask>",
            "masked_line": "frameon=False, title=grid.legend.get_title().get_text());",
            "answer": "get_title",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_574"
        },
        {
            "dependency": "geopandas",
            "version": "==0.10.0",
            "time": "2021-12-30",
            "description": "The code retrieves earthquake data globally and creates a grid for California (or any specified area) to analyze earthquake occurrences within grid geometries. It then calculates the median magnitude and the number of earthquakes in each grid geometry. Finally, it visualizes the data on a map using folium.",
            "code": "import geopandas as gpd\nimport shapely.geometry\nimport numpy as np\n\n# equivalent of CSV, all earthquake points globally\ngdf_e = gpd.read_file(\n    \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson\"\n)\n\n# get geometry of bounding area.  Have selected a state rather than a city\ngdf_CA = gpd.read_file(\n    \"https://raw.githubusercontent.com/glynnbird/usstatesgeojson/master/california.geojson\"\n).loc[:, [\"geometry\"]]\n\nBOXES = 50\na, b, c, d = gdf_CA.total_bounds\n\n# create a grid for Califormia, could be a city\ngdf_grid = gpd.GeoDataFrame(\n    geometry=[\n        shapely.geometry.box(minx, miny, maxx, maxy)\n        for minx, maxx in zip(np.linspace(a, c, BOXES), np.linspace(a, c, BOXES)[1:])\n        for miny, maxy in zip(np.linspace(b, d, BOXES), np.linspace(b, d, BOXES)[1:])\n    ],\n    crs=\"epsg:4326\",\n)\n\n# remove grid boxes created outside actual geometry\ngdf_grid = gdf_grid.sjoin(gdf_CA).drop(columns=\"index_right\")\n\n# get earthquakes that have occured within one of the grid geometries\ngdf_e_CA = gdf_e.loc[:, [\"geometry\", \"mag\"]].sjoin(gdf_grid)\n# get median magnitude of eargquakes in grid\ngdf_grid = gdf_grid.join(\n    gdf_e_CA.dissolve(by=\"index_right\", aggfunc=\"median\").drop(columns=\"geometry\")\n)\n# how many earthquakes in the grid\ngdf_grid = gdf_grid.join(\n    gdf_e_CA.dissolve(by=\"index_right\", aggfunc=lambda d: len(d))\n    .drop(columns=\"geometry\")\n    .rename(columns={\"mag\": \"number\"})\n)\n\n# drop grids geometries that have no measures and create folium map\nm = gdf_grid.dropna().explore(column=\"mag\")\n# for good measure - boundary on map too\ngdf_CA[\"geometry\"].apply(lambda g: shapely.geometry.MultiLineString([p.exterior for p in g.geoms])).explore(m=m)",
            "masked_code": "import geopandas as gpd\nimport shapely.geometry\nimport numpy as np\n\n# equivalent of CSV, all earthquake points globally\ngdf_e = gpd.read_file(\n    \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson\"\n)\n\n# get geometry of bounding area.  Have selected a state rather than a city\ngdf_CA = gpd.read_file(\n    \"https://raw.githubusercontent.com/glynnbird/usstatesgeojson/master/california.geojson\"\n).loc[:, [\"geometry\"]]\n\nBOXES = 50\na, b, c, d = gdf_CA.total_bounds\n\n# create a grid for Califormia, could be a city\ngdf_grid = gpd.GeoDataFrame(\n    geometry=[\n        shapely.geometry.box(minx, miny, maxx, maxy)\n        for minx, maxx in zip(np.linspace(a, c, BOXES), np.linspace(a, c, BOXES)[1:])\n        for miny, maxy in zip(np.linspace(b, d, BOXES), np.linspace(b, d, BOXES)[1:])\n    ],\n    crs=\"epsg:4326\",\n)\n\n# remove grid boxes created outside actual geometry\n<line_mask>\n\n# get earthquakes that have occured within one of the grid geometries\ngdf_e_CA = gdf_e.loc[:, [\"geometry\", \"mag\"]].sjoin(gdf_grid)\n# get median magnitude of eargquakes in grid\ngdf_grid = gdf_grid.join(\n    gdf_e_CA.dissolve(by=\"index_right\", aggfunc=\"median\").drop(columns=\"geometry\")\n)\n# how many earthquakes in the grid\ngdf_grid = gdf_grid.join(\n    gdf_e_CA.dissolve(by=\"index_right\", aggfunc=lambda d: len(d))\n    .drop(columns=\"geometry\")\n    .rename(columns={\"mag\": \"number\"})\n)\n\n# drop grids geometries that have no measures and create folium map\nm = gdf_grid.dropna().explore(column=\"mag\")\n# for good measure - boundary on map too\ngdf_CA[\"geometry\"].apply(lambda g: shapely.geometry.MultiLineString([p.exterior for p in g.geoms])).explore(m=m)",
            "masked_line": "gdf_grid = gdf_grid.sjoin(gdf_CA).drop(columns=\"index_right\")",
            "answer": "sjoin",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_575"
        },
        {
            "dependency": "SQLAlchemy",
            "version": ">=1.4",
            "time": "2022-02-24",
            "description": "The code is to migrate data from a SQLite database to a PostgreSQL database using SQLAlchemy. It first sets up connections to the source and target databases, then it reflects the table structure from the source database and drops all existing tables in the target database. It then recreates the tables in the target database based on the structure of the source database. Finally, it copies data from the source tables to the target tables.",
            "code": "from sqlalchemy import create_engine, MetaData, event\nfrom sqlalchemy.sql import sqltypes\n\n#  Requires SQLALCHEMY 1.4+\n\nsrc_engine = create_engine(\"sqlite:///mydb.sqlite\")\nsrc_metadata = MetaData(bind=src_engine)\nexclude_tables = ('sqlite_master', 'sqlite_sequence', 'sqlite_temp_master')\n\ntgt_engine = create_engine(\"postgresql+psycopg2://@localhost/ngas\")\ntgt_metadata = MetaData(bind=tgt_engine)\n\n@event.listens_for(src_metadata, \"column_reflect\")\ndef genericize_datatypes(inspector, tablename, column_dict):\n   column_dict[\"type\"] = column_dict[\"type\"].as_generic(allow_nulltype=True)     \n\ntgt_conn = tgt_engine.connect()\ntgt_metadata.reflect()\n\n# drop all tables in target database\nfor table in reversed(tgt_metadata.sorted_tables):\n   if table.name not in exclude_tables:\n      print('dropping table =', table.name)\n      table.drop()\n\n# # Delete all data in target database\n# for table in reversed(tgt_metadata.sorted_tables):\n#    table.delete()\n\ntgt_metadata.clear()\ntgt_metadata.reflect()\nsrc_metadata.reflect()\n\n# create all tables in target database\nfor table in src_metadata.sorted_tables:\n   if table.name not in exclude_tables:\n      table.create(bind=tgt_engine)\n\n# refresh metadata before you can copy data\ntgt_metadata.clear()\ntgt_metadata.reflect()\n\n# Copy all data from src to target\nfor table in tgt_metadata.sorted_tables:\n   src_table = src_metadata.tables[table.name]\n   stmt = table.insert()\n   for index, row in enumerate(src_table.select().execute()):\n      print(\"table =\", table.name, \"Inserting row\", index)\n      stmt.execute(row._asdict())",
            "masked_code": "from sqlalchemy import create_engine, MetaData, event\nfrom sqlalchemy.sql import sqltypes\n\n#  Requires SQLALCHEMY 1.4+\n\nsrc_engine = create_engine(\"sqlite:///mydb.sqlite\")\nsrc_metadata = MetaData(bind=src_engine)\nexclude_tables = ('sqlite_master', 'sqlite_sequence', 'sqlite_temp_master')\n\ntgt_engine = create_engine(\"postgresql+psycopg2://@localhost/ngas\")\ntgt_metadata = MetaData(bind=tgt_engine)\n\n<line_mask>\ndef genericize_datatypes(inspector, tablename, column_dict):\n   column_dict[\"type\"] = column_dict[\"type\"].as_generic(allow_nulltype=True)     \n\ntgt_conn = tgt_engine.connect()\ntgt_metadata.reflect()\n\n# drop all tables in target database\nfor table in reversed(tgt_metadata.sorted_tables):\n   if table.name not in exclude_tables:\n      print('dropping table =', table.name)\n      table.drop()\n\n# # Delete all data in target database\n# for table in reversed(tgt_metadata.sorted_tables):\n#    table.delete()\n\ntgt_metadata.clear()\ntgt_metadata.reflect()\nsrc_metadata.reflect()\n\n# create all tables in target database\nfor table in src_metadata.sorted_tables:\n   if table.name not in exclude_tables:\n      table.create(bind=tgt_engine)\n\n# refresh metadata before you can copy data\ntgt_metadata.clear()\ntgt_metadata.reflect()\n\n# Copy all data from src to target\nfor table in tgt_metadata.sorted_tables:\n   src_table = src_metadata.tables[table.name]\n   stmt = table.insert()\n   for index, row in enumerate(src_table.select().execute()):\n      print(\"table =\", table.name, \"Inserting row\", index)\n      stmt.execute(row._asdict())",
            "masked_line": "@event.listens_for(src_metadata, \"column_reflect\")",
            "answer": "listens_for",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_576"
        },
        {
            "dependency": "SimpleITK",
            "version": "==1.2.4",
            "time": "2022-09-09",
            "description": "This code reads an image file using SimpleITK, sets the title of the image viewer to 'Cell Image', specifies the application to be used for viewing the image (e.g. ImageJ or ITK-SNAP), sets the file extension to \".tiff\", and displays the image using the image viewer.",
            "code": "import SimpleITK as sitk\n\nImage = sitk.ReadImage(inputImageFileName)\nimage_viewer = sitk.ImageViewer()\nimage_viewer.SetTitle('Cell Image') #title image (optional )\nimage_viewer.SetApplication(r'path\\ij153-win-java8\\ImageJ\\ImageJ.exe') #Application to be used e.g. ImageJ or ITK-SNAP\nimage_viewer.SetFileExtension(\".tiff\") #any formats you use\nimage_viewer.Execute(Image)",
            "masked_code": "import SimpleITK as sitk\n\nImage = sitk.ReadImage(inputImageFileName)\nimage_viewer = sitk.ImageViewer()\nimage_viewer.SetTitle('Cell Image') #title image (optional )\nimage_viewer.SetApplication(r'path\\ij153-win-java8\\ImageJ\\ImageJ.exe') #Application to be used e.g. ImageJ or ITK-SNAP\n<line_mask>\nimage_viewer.Execute(Image)",
            "masked_line": "image_viewer.SetFileExtension(\".tiff\") #any formats you use",
            "answer": "SetFileExtension",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_577"
        },
        {
            "dependency": "discord-py-slash-command",
            "version": "==1.1.2",
            "time": "2021-11-25",
            "description": "This code defines a Discord bot using the discord and discord_slash libraries, declares a slash command named \"ping\", and sends a message \"Pong!\" in response to the slash command being invoked.",
            "code": "import discord\nfrom discord_slash import SlashCommand\nclient = discord.Client(intents=discord.Intents.all())\nslash = SlashCommand(client, sync_commands=True) # Declares slash commands through the client.\n\nguild_ids = [1234567890] # Put your server IDs in this array.\n\n@slash.slash(name=\"ping\", guild_ids=guild_ids)\nasync def _ping(ctx):\n    await ctx.send(\"Pong!\")\n\nclient.run(\"token\")",
            "masked_code": "import discord\nfrom discord_slash import SlashCommand\nclient = discord.Client(intents=discord.Intents.all())\nslash = SlashCommand(client, sync_commands=True) # Declares slash commands through the client.\n\nguild_ids = [1234567890] # Put your server IDs in this array.\n\n<line_mask>\nasync def _ping(ctx):\n    await ctx.send(\"Pong!\")\n\nclient.run(\"token\")",
            "masked_line": "@slash.slash(name=\"ping\", guild_ids=guild_ids)",
            "answer": "slash",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_578"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.23.2",
            "time": "2021-10-11",
            "description": "The code defines a Decision Tree Regressor model with specified parameters.",
            "code": "from sklearn.tree import DecisionTreeRegressor\nimport sklearn\nprint(sklearn.__version__)\nmodel = DecisionTreeRegressor(ccp_alpha=0.0, criterion='mse', max_depth=None, max_features=None,\n                              max_leaf_nodes=None, min_impurity_decrease=0.0, \n                              min_impurity_split=None, min_samples_leaf=1, min_samples_split=2)",
            "masked_code": "from sklearn.tree import DecisionTreeRegressor\nimport sklearn\nprint(sklearn.__version__)\n<line_mask>\n                              max_leaf_nodes=None, min_impurity_decrease=0.0, \n                              min_impurity_split=None, min_samples_leaf=1, min_samples_split=2)",
            "masked_line": "model = DecisionTreeRegressor(ccp_alpha=0.0, criterion='mse', max_depth=None, max_features=None,",
            "answer": "DecisionTreeRegressor",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_579"
        },
        {
            "dependency": "stellargraph",
            "version": "==1.2.1",
            "time": "2022-04-29",
            "description": "The code creates an original graph with nodes 'a', 'b', 'c', and 'd', and edges connecting these nodes. It then adds new edges between nodes '3'-'1' and '3'-'2' to create a new graph with updated edge connections.",
            "code": "import pandas as pd\nfrom stellargraph import IndexedArray, StellarGraph\n\n#### original data / graph\n\nnodes = IndexedArray(index=['a', 'b', 'c', 'd'])\noriginal_edges = pd.DataFrame(\n    {\n        'source' : [0, 1, 2, 3, 0],\n        'target' : [1, 2, 3, 0, 2]\n    }\n)\noriginal_graph = StellarGraph(\n    nodes, \n    original_edges\n)\n\n#### new data\n\nnew_edges = pd.DataFrame(\n    {\n        'source' : [3, 3],\n        'target' : [1, 2]\n    }\n)\n\n#### new graph\n\nnew_graph = StellarGraph(\n    nodes, \n    pd.concat(\n        [\n            original_edges,\n            new_edges\n        ],\n        ignore_index=True\n    )\n)",
            "masked_code": "import pandas as pd\nfrom stellargraph import IndexedArray, StellarGraph\n\n#### original data / graph\n\nnodes = IndexedArray(index=['a', 'b', 'c', 'd'])\noriginal_edges = pd.DataFrame(\n    {\n        'source' : [0, 1, 2, 3, 0],\n        'target' : [1, 2, 3, 0, 2]\n    }\n)\n<line_mask>\n    nodes, \n    original_edges\n)\n\n#### new data\n\nnew_edges = pd.DataFrame(\n    {\n        'source' : [3, 3],\n        'target' : [1, 2]\n    }\n)\n\n#### new graph\n\nnew_graph = StellarGraph(\n    nodes, \n    pd.concat(\n        [\n            original_edges,\n            new_edges\n        ],\n        ignore_index=True\n    )\n)",
            "masked_line": "original_graph = StellarGraph(",
            "answer": "StellarGraph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_580"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.3",
            "time": "2021-01-21",
            "description": "This code generates a contour plot of a function defined by two Gaussian distributions added together. It uses numpy to create the x and y coordinates, calculates the function values, and then uses matplotlib to plot the contour plot with a logarithmic color scale.",
            "code": "import matplotlib.pyplot as plt\nfrom matplotlib import ticker, cm\nimport numpy as np\n\nx = np.linspace(-3.0, 3.0, 100)\ny = np.linspace(-2.0, 2.0, 100)\nX, Y = np.meshgrid(x, y)\n\nZ1 = np.exp(-(X)**2 - (Y)**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nz = Z1 + 50 * Z2\n\nfig, ax = plt.subplots()\n\nn_levels = 50\ncs = ax.contourf(X, Y, z, \n                 np.logspace(np.log10(z.min()),np.log10(z.max()), n_levels), \n                 locator=ticker.LogLocator(), \n                 cmap=cm.jet\n                 )\n\ncbar = fig.colorbar(cs)\ncbar.locator = ticker.LogLocator(10)\ncbar.set_ticks(cbar.locator.tick_values(z.min(), z.max()))\ncbar.minorticks_off()",
            "masked_code": "import matplotlib.pyplot as plt\nfrom matplotlib import ticker, cm\nimport numpy as np\n\nx = np.linspace(-3.0, 3.0, 100)\ny = np.linspace(-2.0, 2.0, 100)\nX, Y = np.meshgrid(x, y)\n\nZ1 = np.exp(-(X)**2 - (Y)**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nz = Z1 + 50 * Z2\n\nfig, ax = plt.subplots()\n\nn_levels = 50\ncs = ax.contourf(X, Y, z, \n                 np.logspace(np.log10(z.min()),np.log10(z.max()), n_levels), \n                 locator=ticker.LogLocator(), \n                 cmap=cm.jet\n                 )\n\ncbar = fig.colorbar(cs)\ncbar.locator = ticker.LogLocator(10)\n<line_mask>\ncbar.minorticks_off()",
            "masked_line": "cbar.set_ticks(cbar.locator.tick_values(z.min(), z.max()))",
            "answer": "tick_values",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_581"
        },
        {
            "dependency": "PyYAML",
            "version": "==6.0",
            "time": "2022-10-05",
            "description": "This code opens and reads a YAML file named 'sample.yaml' using the yaml.safe_load() function.",
            "code": "import yaml\nwith open('sample.yaml', 'r') as file:\n    yaml.safe_load(file)",
            "masked_code": "import yaml\nwith open('sample.yaml', 'r') as file:\n    <line_mask>",
            "masked_line": "yaml.safe_load(file)",
            "answer": "safe_load",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_582"
        },
        {
            "dependency": "PyMuPDF",
            "version": "==1.19.4",
            "time": "2022-04-06",
            "description": "The code calculates the percentage from the top of the PDF page where the text ends, based on a threshold value for binarization of the image extracted from the PDF.",
            "code": "import pdfkit\nfrom PyPDF2 import PdfFileReader\nfrom io import BytesIO\n\n# This library isn't named fitz on pypi,\n# obtain this library with `pip install PyMuPDF==1.19.4`\nimport fitz\n\n# `pip install Pillow==8.3.1`\nfrom PIL import Image\n\nimport numpy as np\n\n# However you arrive at valid HTML, it makes no difference to the solution.\nrendered = \"Hello Worldhello\"\n\n# This first renders PDF from HTML normally (multiple pages)\n# Then counts how many pages were created and determines the required single-page height\n# Then renders a single-page PDF from HTML using the page height and width arguments\npdf_bytes = pdfkit.from_string(rendered, options={\n    \"page-height\": f\"{297 * PdfFileReader(BytesIO(pdfkit.from_string(rendered))).getNumPages()}mm\",\n    \"page-width\": \"210mm\"\n})\n\n# convert the pdf into an image.\npdf = fitz.open(stream=pdf_bytes, filetype=\"pdf\")\nlast_page = pdf[pdf.pageCount-1]\nmatrix = fitz.Matrix(1, 1)\nimage_pixels = last_page.get_pixmap(matrix=matrix, colorspace=\"GRAY\")\n\nimage = Image.frombytes(\"L\", [image_pixels.width, image_pixels.height], image_pixels.samples)\n\n#Uncomment if you want to see.\n#image.show()\n\n# Now figure out where the end of the text is:\n\n# First binarize. This might not be the most efficient way to do this.\n# But it's how I do it.\nTHRESHOLD = 100\n# I wrote this code ages ago and don't remember the details but\n# basically, we treat every pixel > 100 as a white pixel, \n# We convert the result to a true/false matrix \n# And then invert that. \n# The upshot is that, at the end, a value of \"True\" \n# in the matrix will represent a black pixel in that location.\nbinary_matrix = np.logical_not(image.point( lambda p: 255 if p > THRESHOLD else 0 ).convert(\"1\"))\n\n# Now find last white row, starting at the bottom\nrow_count, column_count = binary_matrix.shape\n\nlast_row = 0\nfor i, row in enumerate(reversed(binary_matrix)):\n    if any(row):\n        last_row = i\n        break\n    else:\n        continue \n\npercentage_from_top = (1 - last_row / row_count) * 100\nprint(percentage_from_top)\n\n# Now you know where the page ends.\n# Go back and crop the PDF accordingly.",
            "masked_code": "import pdfkit\nfrom PyPDF2 import PdfFileReader\nfrom io import BytesIO\n\n# This library isn't named fitz on pypi,\n# obtain this library with `pip install PyMuPDF==1.19.4`\nimport fitz\n\n# `pip install Pillow==8.3.1`\nfrom PIL import Image\n\nimport numpy as np\n\n# However you arrive at valid HTML, it makes no difference to the solution.\nrendered = \"Hello Worldhello\"\n\n# This first renders PDF from HTML normally (multiple pages)\n# Then counts how many pages were created and determines the required single-page height\n# Then renders a single-page PDF from HTML using the page height and width arguments\npdf_bytes = pdfkit.from_string(rendered, options={\n    \"page-height\": f\"{297 * PdfFileReader(BytesIO(pdfkit.from_string(rendered))).getNumPages()}mm\",\n    \"page-width\": \"210mm\"\n})\n\n# convert the pdf into an image.\n<line_mask>\nlast_page = pdf[pdf.pageCount-1]\nmatrix = fitz.Matrix(1, 1)\nimage_pixels = last_page.get_pixmap(matrix=matrix, colorspace=\"GRAY\")\n\nimage = Image.frombytes(\"L\", [image_pixels.width, image_pixels.height], image_pixels.samples)\n\n#Uncomment if you want to see.\n#image.show()\n\n# Now figure out where the end of the text is:\n\n# First binarize. This might not be the most efficient way to do this.\n# But it's how I do it.\nTHRESHOLD = 100\n# I wrote this code ages ago and don't remember the details but\n# basically, we treat every pixel > 100 as a white pixel, \n# We convert the result to a true/false matrix \n# And then invert that. \n# The upshot is that, at the end, a value of \"True\" \n# in the matrix will represent a black pixel in that location.\nbinary_matrix = np.logical_not(image.point( lambda p: 255 if p > THRESHOLD else 0 ).convert(\"1\"))\n\n# Now find last white row, starting at the bottom\nrow_count, column_count = binary_matrix.shape\n\nlast_row = 0\nfor i, row in enumerate(reversed(binary_matrix)):\n    if any(row):\n        last_row = i\n        break\n    else:\n        continue \n\npercentage_from_top = (1 - last_row / row_count) * 100\nprint(percentage_from_top)\n\n# Now you know where the page ends.\n# Go back and crop the PDF accordingly.",
            "masked_line": "pdf = fitz.open(stream=pdf_bytes, filetype=\"pdf\")",
            "answer": "open",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_583"
        },
        {
            "dependency": "pillow",
            "version": "==8.3.1",
            "time": "2022-04-06",
            "description": "The code takes an HTML string, converts it into a PDF, and then converts that PDF into an image. It then processes the image to determine the vertical position of the end of the text on the page as a percentage from the top, and prints this percentage.",
            "code": "import pdfkit\nfrom PyPDF2 import PdfFileReader\nfrom io import BytesIO\n\n# This library isn't named fitz on pypi,\n# obtain this library with `pip install PyMuPDF==1.19.4`\nimport fitz\n\n# `pip install Pillow==8.3.1`\nfrom PIL import Image\n\nimport numpy as np\n\n# However you arrive at valid HTML, it makes no difference to the solution.\nrendered = \"Hello Worldhello\"\n\n# This first renders PDF from HTML normally (multiple pages)\n# Then counts how many pages were created and determines the required single-page height\n# Then renders a single-page PDF from HTML using the page height and width arguments\npdf_bytes = pdfkit.from_string(rendered, options={\n    \"page-height\": f\"{297 * PdfFileReader(BytesIO(pdfkit.from_string(rendered))).getNumPages()}mm\",\n    \"page-width\": \"210mm\"\n})\n\n# convert the pdf into an image.\npdf = fitz.open(stream=pdf_bytes, filetype=\"pdf\")\nlast_page = pdf[pdf.pageCount-1]\nmatrix = fitz.Matrix(1, 1)\nimage_pixels = last_page.get_pixmap(matrix=matrix, colorspace=\"GRAY\")\n\nimage = Image.frombytes(\"L\", [image_pixels.width, image_pixels.height], image_pixels.samples)\n\n#Uncomment if you want to see.\n#image.show()\n\n# Now figure out where the end of the text is:\n\n# First binarize. This might not be the most efficient way to do this.\n# But it's how I do it.\nTHRESHOLD = 100\n# I wrote this code ages ago and don't remember the details but\n# basically, we treat every pixel > 100 as a white pixel, \n# We convert the result to a true/false matrix \n# And then invert that. \n# The upshot is that, at the end, a value of \"True\" \n# in the matrix will represent a black pixel in that location.\nbinary_matrix = np.logical_not(image.point( lambda p: 255 if p > THRESHOLD else 0 ).convert(\"1\"))\n\n# Now find last white row, starting at the bottom\nrow_count, column_count = binary_matrix.shape\n\nlast_row = 0\nfor i, row in enumerate(reversed(binary_matrix)):\n    if any(row):\n        last_row = i\n        break\n    else:\n        continue \n\npercentage_from_top = (1 - last_row / row_count) * 100\nprint(percentage_from_top)\n\n# Now you know where the page ends.\n# Go back and crop the PDF accordingly.",
            "masked_code": "import pdfkit\nfrom PyPDF2 import PdfFileReader\nfrom io import BytesIO\n\n# This library isn't named fitz on pypi,\n# obtain this library with `pip install PyMuPDF==1.19.4`\nimport fitz\n\n# `pip install Pillow==8.3.1`\nfrom PIL import Image\n\nimport numpy as np\n\n# However you arrive at valid HTML, it makes no difference to the solution.\nrendered = \"Hello Worldhello\"\n\n# This first renders PDF from HTML normally (multiple pages)\n# Then counts how many pages were created and determines the required single-page height\n# Then renders a single-page PDF from HTML using the page height and width arguments\npdf_bytes = pdfkit.from_string(rendered, options={\n    \"page-height\": f\"{297 * PdfFileReader(BytesIO(pdfkit.from_string(rendered))).getNumPages()}mm\",\n    \"page-width\": \"210mm\"\n})\n\n# convert the pdf into an image.\npdf = fitz.open(stream=pdf_bytes, filetype=\"pdf\")\nlast_page = pdf[pdf.pageCount-1]\nmatrix = fitz.Matrix(1, 1)\nimage_pixels = last_page.get_pixmap(matrix=matrix, colorspace=\"GRAY\")\n\nimage = Image.frombytes(\"L\", [image_pixels.width, image_pixels.height], image_pixels.samples)\n\n#Uncomment if you want to see.\n#image.show()\n\n# Now figure out where the end of the text is:\n\n# First binarize. This might not be the most efficient way to do this.\n# But it's how I do it.\nTHRESHOLD = 100\n# I wrote this code ages ago and don't remember the details but\n# basically, we treat every pixel > 100 as a white pixel, \n# We convert the result to a true/false matrix \n# And then invert that. \n# The upshot is that, at the end, a value of \"True\" \n# in the matrix will represent a black pixel in that location.\n<line_mask>\n\n# Now find last white row, starting at the bottom\nrow_count, column_count = binary_matrix.shape\n\nlast_row = 0\nfor i, row in enumerate(reversed(binary_matrix)):\n    if any(row):\n        last_row = i\n        break\n    else:\n        continue \n\npercentage_from_top = (1 - last_row / row_count) * 100\nprint(percentage_from_top)\n\n# Now you know where the page ends.\n# Go back and crop the PDF accordingly.",
            "masked_line": "binary_matrix = np.logical_not(image.point( lambda p: 255 if p > THRESHOLD else 0 ).convert(\"1\"))",
            "answer": "point",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_584"
        },
        {
            "dependency": "statsmodels",
            "version": "==0.13.0",
            "time": "2022-07-25",
            "description": "The code generates a time series plot of sunspot activity data from the year 1950 to 2009, fits an ARIMA model to the data, and then plots the predicted values for the years 1990 to 2012.",
            "code": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport statsmodels.api as sm\nfrom statsmodels.graphics.tsaplots import plot_predict\nfrom statsmodels.tsa.arima.model import ARIMA\n\ndta = sm.datasets.sunspots.load_pandas().data[['SUNACTIVITY']]\ndta.index = pd.date_range(start='1700', end='2009', freq='A')\nres = ARIMA(dta, order=(0,2,0)).fit()\nfig, ax = plt.subplots()\nax = dta.loc['1950':].plot(ax=ax)\nplot_predict(res, '1990', '2012', ax=ax)\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport statsmodels.api as sm\nfrom statsmodels.graphics.tsaplots import plot_predict\nfrom statsmodels.tsa.arima.model import ARIMA\n\ndta = sm.datasets.sunspots.load_pandas().data[['SUNACTIVITY']]\ndta.index = pd.date_range(start='1700', end='2009', freq='A')\n<line_mask>\nfig, ax = plt.subplots()\nax = dta.loc['1950':].plot(ax=ax)\nplot_predict(res, '1990', '2012', ax=ax)\nplt.show()",
            "masked_line": "res = ARIMA(dta, order=(0,2,0)).fit()",
            "answer": "ARIMA",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_585"
        },
        {
            "dependency": "wtforms",
            "version": "==2.3",
            "time": "2022-02-15",
            "description": "This code defines a DateTimeLocalField field, which allows users to input date and time values in a specified format (\"%Y-%m-%dT%H:%M\").",
            "code": "from wtforms.fields.html5 import DateTimeLocalField\ndttm = DateTimeLocalField(\"Date/Time: \", format=\"%Y-%m-%dT%H:%M\")",
            "masked_code": "from wtforms.fields.html5 import DateTimeLocalField\n<line_mask>",
            "masked_line": "dttm = DateTimeLocalField(\"Date/Time: \", format=\"%Y-%m-%dT%H:%M\")",
            "answer": "DateTimeLocalField",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_586"
        },
        {
            "dependency": "pytest",
            "version": "==7.1.3",
            "time": "2022-10-25",
            "description": "This code snippet defines a component called sample_df_component that generates a sample dataframe with columns for name and age, and saves it as a CSV file. It also includes a fixture called sample_df that creates an output artifact using the sample_df_component and returns the artifact with the updated path.",
            "code": "from kfp.v2.dsl import component, Dataset, Output\nimport pytest\n\nfrom tests.utils import make_test_artifact\n\n@component\ndef sample_df_component(dataset: Output[Dataset]):\n    import pandas as pd\n\n    df = pd.DataFrame({\n        'name': ['Ana', 'Maria', 'Josh'],\n        'age': [15, 19, 22],\n    })\n    dataset.path += '.csv'\n    df.to_csv(dataset.path, index=False)\n\n@pytest.fixture\ndef sample_df():\n    # define output artifact\n    output_path = 'local_sample_df.csv'  # any writable local path. I'd recommend to use pytest `tmp_path` fixture.\n    sample_df_artifact = make_test_artifact(Dataset)(uri=output_path)\n\n    # call component python_func by passing the artifact yourself\n    sample_df_component.python_func(dataset=sample_df_artifact)\n    # the artifact object is now altered with the new path that you define in sample_df_component (\".csv\" extension added)\n\n    return sample_df_artifact",
            "masked_code": "from kfp.v2.dsl import component, Dataset, Output\nimport pytest\n\nfrom tests.utils import make_test_artifact\n\n@component\ndef sample_df_component(dataset: Output[Dataset]):\n    import pandas as pd\n\n    df = pd.DataFrame({\n        'name': ['Ana', 'Maria', 'Josh'],\n        'age': [15, 19, 22],\n    })\n    dataset.path += '.csv'\n    df.to_csv(dataset.path, index=False)\n\n@pytest.fixture\ndef sample_df():\n    # define output artifact\n    <line_mask>\n    sample_df_artifact = make_test_artifact(Dataset)(uri=output_path)\n\n    # call component python_func by passing the artifact yourself\n    sample_df_component.python_func(dataset=sample_df_artifact)\n    # the artifact object is now altered with the new path that you define in sample_df_component (\".csv\" extension added)\n\n    return sample_df_artifact",
            "masked_line": "output_path = 'local_sample_df.csv'  # any writable local path. I'd recommend to use pytest `tmp_path` fixture.",
            "answer": "fixture",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_587"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==2.0",
            "time": "2023-06-01",
            "description": "This Python code defines a model class called Email that represents an email entity in a database. The class has attributes such as name, sender, subject, html, and template_id. Each attribute is mapped to a specific column in the database table named 'emails'. The template_id attribute is mapped to a UUID column with a foreign key constraint referencing the 'id' column in a table named 'templates'. The class enforces non-null constraints on certain attributes such as name, sender, subject, html while providing default values for others.",
            "code": "import uuid\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy.dialects.postgresql import UUID\n\nclass Email(Model):\n    __tablename__ = 'emails'\n\n    name: Mapped[str] = mapped_column(String, nullable=False)\n    sender: Mapped[str] = mapped_column(\n        String, default=default_sender, nullable=False\n    )\n    subject: Mapped[str] = mapped_column(String, nullable=False)\n    html: Mapped[str] = mapped_column(String, nullable=False)\n    template_id: Mapped[uuid.UUID] = mapped_column(\n        UUID(as_uuid=True),\n        ForeignKey('templates.id'),\n        index=True,\n    )",
            "masked_code": "import uuid\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy.dialects.postgresql import UUID\n\nclass Email(Model):\n    __tablename__ = 'emails'\n\n    name: Mapped[str] = mapped_column(String, nullable=False)\n    sender: Mapped[str] = mapped_column(\n        String, default=default_sender, nullable=False\n    )\n    subject: Mapped[str] = mapped_column(String, nullable=False)\n    html: Mapped[str] = mapped_column(String, nullable=False)\n    <line_mask>\n        UUID(as_uuid=True),\n        ForeignKey('templates.id'),\n        index=True,\n    )",
            "masked_line": "template_id: Mapped[uuid.UUID] = mapped_column(",
            "answer": "mapped_column",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_588"
        },
        {
            "dependency": "pyarrow",
            "version": "==6.0.1",
            "time": "2022-01-03",
            "description": "The code writes two tables to separate parquet files in different directories and then tries to read them back into tables. It demonstrates reading a dataset without a schema, with a specified schema, and handling potential errors during the process.",
            "code": "import os\n\nimport pyarrow as pa\nimport pyarrow.parquet as pq\nimport pyarrow.dataset as ds\n\ntab = pa.Table.from_pydict({'x': [1, 2, 3], 'y': [None, None, None]})\ntab2 = pa.Table.from_pydict({'x': [4, 5, 6], 'y': ['x', 'y', 'z']})\n\nos.makedirs('/tmp/null_first_dataset', exist_ok=True)\npq.write_table(tab, '/tmp/null_first_dataset/0.parquet')\npq.write_table(tab2, '/tmp/null_first_dataset/1.parquet')\n\nos.makedirs('/tmp/null_second_dataset', exist_ok=True)\npq.write_table(tab, '/tmp/null_second_dataset/1.parquet')\npq.write_table(tab2, '/tmp/null_second_dataset/0.parquet')\n\ntry:\n    dataset = ds.dataset('/tmp/null_first_dataset')\n    tab = dataset.to_table()\n    print(f'Was able to read in null_first_dataset without schema.')\n    print(tab)\nexcept Exception as ex:\n    print('Was not able to read in null_first_dataset without schema')\n    print(f'  Error: {ex}')\nprint()\n\ntry:\n    dataset = ds.dataset('/tmp/null_second_dataset')\n    tab = dataset.to_table()\n    print(f'Was able to read in null_second_dataset without schema.')\n    print(tab)\nexcept:\n    print('Was not able to read in null_second_dataset without schema')\n    print(f'  Error: {ex}')\nprint()\n\ndataset = ds.dataset('/tmp/null_first_dataset', schema=tab2.schema)\ntab = dataset.to_table()\nprint(f'Was able to read in null_first_dataset by specifying schema.')\nprint(tab)",
            "masked_code": "import os\n\nimport pyarrow as pa\nimport pyarrow.parquet as pq\nimport pyarrow.dataset as ds\n\ntab = pa.Table.from_pydict({'x': [1, 2, 3], 'y': [None, None, None]})\n<line_mask>\n\nos.makedirs('/tmp/null_first_dataset', exist_ok=True)\npq.write_table(tab, '/tmp/null_first_dataset/0.parquet')\npq.write_table(tab2, '/tmp/null_first_dataset/1.parquet')\n\nos.makedirs('/tmp/null_second_dataset', exist_ok=True)\npq.write_table(tab, '/tmp/null_second_dataset/1.parquet')\npq.write_table(tab2, '/tmp/null_second_dataset/0.parquet')\n\ntry:\n    dataset = ds.dataset('/tmp/null_first_dataset')\n    tab = dataset.to_table()\n    print(f'Was able to read in null_first_dataset without schema.')\n    print(tab)\nexcept Exception as ex:\n    print('Was not able to read in null_first_dataset without schema')\n    print(f'  Error: {ex}')\nprint()\n\ntry:\n    dataset = ds.dataset('/tmp/null_second_dataset')\n    tab = dataset.to_table()\n    print(f'Was able to read in null_second_dataset without schema.')\n    print(tab)\nexcept:\n    print('Was not able to read in null_second_dataset without schema')\n    print(f'  Error: {ex}')\nprint()\n\ndataset = ds.dataset('/tmp/null_first_dataset', schema=tab2.schema)\ntab = dataset.to_table()\nprint(f'Was able to read in null_first_dataset by specifying schema.')\nprint(tab)",
            "masked_line": "tab2 = pa.Table.from_pydict({'x': [4, 5, 6], 'y': ['x', 'y', 'z']})",
            "answer": "Table",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_589"
        },
        {
            "dependency": "pyarrow",
            "version": ">=9.0.0",
            "time": "2022-08-09",
            "description": "The code filters a DataFrame named df based on whether the number of days between the \"date\" column and today's date is greater than 5.",
            "code": "import datetime\nimport pyarrow.compute as pc\n\nexpr = pc.days_between(pc.field(\"date\"), pc.scalar(today)) > 5\n#  5)>\n\ndf.filter(expr)",
            "masked_code": "import datetime\nimport pyarrow.compute as pc\n\n<line_mask>\n#  5)>\n\ndf.filter(expr)",
            "masked_line": "expr = pc.days_between(pc.field(\"date\"), pc.scalar(today)) > 5",
            "answer": "field",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_590"
        },
        {
            "dependency": "transformers",
            "version": "==3.1.0",
            "time": "2022-08-03",
            "description": "This code sets the logging verbosity level to warning for the transformers library.",
            "code": "from transformers import logging\n\nlogging.set_verbosity_warning()",
            "masked_code": "from transformers import logging\n\n<line_mask>",
            "masked_line": "logging.set_verbosity_warning()",
            "answer": "set_verbosity_warning",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_591"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.0",
            "time": "2022-01-12",
            "description": "The code converts a TensorFlow model stored in a SavedModel directory into a TensorFlow Lite model and saves it as a file named 'model.tflite'.",
            "code": "import tensorflow as tf\n\n# Convert the model\nconverter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir) # path to the SavedModel directory\ntflite_model = converter.convert()\n\n# Save the model.\nwith open('model.tflite', 'wb') as f:\n  f.write(tflite_model)",
            "masked_code": "import tensorflow as tf\n\n# Convert the model\n<line_mask>\ntflite_model = converter.convert()\n\n# Save the model.\nwith open('model.tflite', 'wb') as f:\n  f.write(tflite_model)",
            "masked_line": "converter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir) # path to the SavedModel directory",
            "answer": "lite",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_592"
        },
        {
            "dependency": "ipywidgets",
            "version": ">=3.8",
            "time": "2022-12-01",
            "description": "This code creates two widgets: ToggleButtons and BoundedIntText. The ToggleButtons widget allows the user to select between options \"Just me!\" and \"Yes.\", while the BoundedIntText widget allows the user to input a number between 0 and 10. The code then displays the ToggleButtons widget and initializes the Output widget. The 'changed' function monitors changes in the ToggleButtons widget, and if \"Just me!\" is selected, it clears the output. If \"Yes.\" is selected, it appends the BoundedIntText widget to the output and displays it.",
            "code": "import ipywidgets as widgets\nfrom ipywidgets import Output\n\n# create widgets\nfriends = widgets.ToggleButtons(\n        options= [\"Just me!\", \"Yes.\"])\n    \nwho = widgets.BoundedIntText(\n        value=0,\n        min=0,\n        max=10,\n        step=1,\n        description='How many?:',\n        disabled=False,)\n\n# display the first widget\ndisplay(friends) \n\n# intialize the output - second widget\nout = Output() \n\ndef changed(change):\n    '''\n    Monitor change in the first widget\n    '''\n    global out\n    if friends.value == 'Just me!':  \n        out.clear_output() #clear output\n        out = Output() # redefine output\n\n    else:\n        out.append_display_data(who)\n        display(out)\n                \n# monitor the friends widget for changes\nfriends.observe(changed, 'value')",
            "masked_code": "import ipywidgets as widgets\nfrom ipywidgets import Output\n\n# create widgets\nfriends = widgets.ToggleButtons(\n        options= [\"Just me!\", \"Yes.\"])\n    \nwho = widgets.BoundedIntText(\n        value=0,\n        min=0,\n        max=10,\n        step=1,\n        description='How many?:',\n        disabled=False,)\n\n# display the first widget\ndisplay(friends) \n\n# intialize the output - second widget\nout = Output() \n\ndef changed(change):\n    '''\n    Monitor change in the first widget\n    '''\n    global out\n    if friends.value == 'Just me!':  \n        out.clear_output() #clear output\n        <line_mask>\n\n    else:\n        out.append_display_data(who)\n        display(out)\n                \n# monitor the friends widget for changes\nfriends.observe(changed, 'value')",
            "masked_line": "out = Output() # redefine output",
            "answer": "Output",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_593"
        },
        {
            "dependency": "pillow",
            "version": "<9.4.0",
            "time": "2022-12-02",
            "description": "This code generates a new JPEG image file with a comment \"hello world\" encoded in a COM segment appended to the image. It then reads the newly created image file to ensure that the comment is successfully stored and retrieved.",
            "code": "import struct\nfrom PIL import Image\n\ndef make_jpeg_variable_segment(marker: int, payload: bytes) -> bytes:\n    \"make a JPEG segment from the given payload\"\n    return struct.pack('>HH', marker, 2 + len(payload)) + payload\n\ndef make_jpeg_comment_segment(comment: bytes) -> bytes:\n    \"make a JPEG comment/COM segment\"\n    return make_jpeg_variable_segment(0xFFFE, comment)\n\n# open source image\nwith Image.open(\"foo.jpeg\") as im:\n    # save out with new JPEG comment\n    im.save('bar.jpeg', extra=make_jpeg_comment_segment(\"hello world\".encode()))\n\n# read file back in to ensure comment round-trips\nwith Image.open('bar.jpeg') as im:\n    print(im.app['COM'])\n    print(im.info['comment'])",
            "masked_code": "import struct\nfrom PIL import Image\n\ndef make_jpeg_variable_segment(marker: int, payload: bytes) -> bytes:\n    \"make a JPEG segment from the given payload\"\n    return struct.pack('>HH', marker, 2 + len(payload)) + payload\n\ndef make_jpeg_comment_segment(comment: bytes) -> bytes:\n    \"make a JPEG comment/COM segment\"\n    return make_jpeg_variable_segment(0xFFFE, comment)\n\n# open source image\nwith Image.open(\"foo.jpeg\") as im:\n    # save out with new JPEG comment\n    im.save('bar.jpeg', extra=make_jpeg_comment_segment(\"hello world\".encode()))\n\n# read file back in to ensure comment round-trips\n<line_mask>\n    print(im.app['COM'])\n    print(im.info['comment'])",
            "masked_line": "with Image.open('bar.jpeg') as im:",
            "answer": "open",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_594"
        },
        {
            "dependency": "datasets",
            "version": "==2.4.0",
            "time": "2022-08-04",
            "description": "This code snippet creates an instance of the Image class from the datasets module and encodes an example image into a dictionary using the encode_example method.",
            "code": "from datasets import Image\n\nfeature = Image()\n# assuming image is a Pillow image\nimg_dict['image'] = feature.encode_example(image)",
            "masked_code": "from datasets import Image\n\nfeature = Image()\n# assuming image is a Pillow image\n<line_mask>",
            "masked_line": "img_dict['image'] = feature.encode_example(image)",
            "answer": "encode_example",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_595"
        },
        {
            "dependency": "amazon-textract-textractor",
            "version": "==1.0.16",
            "time": "2022-10-26",
            "description": "The code extracts text data from a PDF document using Amazon Textract. It analyzes the document by answering specified queries (\"What is X?\", \"What is Y?\", etc.) and uploads the results to an S3 bucket.",
            "code": "from textractor import Textractor\nfrom textractor.data.constants import TextractFeatures\n\nextractor = Textractor(profile_name=\"default\")\ndocument = extractor.start_document_analysis(\n    file_source=(\"Application Form trimmed.pdf\"),\n    features=[TextractFeatures.QUERIES],\n    queries=[\n        \"What is X?\",\n        \"What is Y?\",\n        # Up to 15 questions here\n    ],\n    s3_upload_path=\"s3://textractbucket2/\"\n)\n\nprint(document.queries)",
            "masked_code": "from textractor import Textractor\nfrom textractor.data.constants import TextractFeatures\n\n<line_mask>\ndocument = extractor.start_document_analysis(\n    file_source=(\"Application Form trimmed.pdf\"),\n    features=[TextractFeatures.QUERIES],\n    queries=[\n        \"What is X?\",\n        \"What is Y?\",\n        # Up to 15 questions here\n    ],\n    s3_upload_path=\"s3://textractbucket2/\"\n)\n\nprint(document.queries)",
            "masked_line": "extractor = Textractor(profile_name=\"default\")",
            "answer": "Textractor",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_596"
        },
        {
            "dependency": "plotly",
            "version": "==5.10.0",
            "time": "2022-08-26",
            "description": "This code generates a plot using Plotly library with dummy data. It creates a scatter plot of 'Measure' against 'Date' from a DataFrame with date range data. The x-axis includes range breaks to skip weekends and a range selector with a button for 1 month interval. The plot also includes a range slider for zooming in on the date range. The plot is displayed using the 'fig.show()' function.",
            "code": "import pandas as pd\nimport plotly.graph_objects as go\n\n# Dummy data\ns = pd.date_range(end=pd.Timestamp('2022-08-27'), periods=100, freq='D')\ndf = pd.DataFrame({'Date':s, 'Measure': s.day})\n\n# Plot\nfig = go.Figure()\n\nfig.add_trace(\n    # replace Scattergl with the Scatter object\n    go.Scatter(x=df.Date, y=df.Measure))\n\nfig.update_xaxes(\n    rangebreaks=[\n        dict(bounds=[\"sat\", \"mon\"]), # skip weekends\n    ],\n    rangeselector=dict(\n        buttons=list([\n            dict(count=1,\n                 label=\"1m\",\n                 step=\"month\",\n                 stepmode=\"backward\")\n        ])\n    ),\n    rangeslider=dict(\n        visible=True\n    ),\n    type=\"date\"\n)\n\nfig.show()",
            "masked_code": "import pandas as pd\nimport plotly.graph_objects as go\n\n# Dummy data\ns = pd.date_range(end=pd.Timestamp('2022-08-27'), periods=100, freq='D')\ndf = pd.DataFrame({'Date':s, 'Measure': s.day})\n\n# Plot\nfig = go.Figure()\n\nfig.add_trace(\n    # replace Scattergl with the Scatter object\n    <line_mask>\n\nfig.update_xaxes(\n    rangebreaks=[\n        dict(bounds=[\"sat\", \"mon\"]), # skip weekends\n    ],\n    rangeselector=dict(\n        buttons=list([\n            dict(count=1,\n                 label=\"1m\",\n                 step=\"month\",\n                 stepmode=\"backward\")\n        ])\n    ),\n    rangeslider=dict(\n        visible=True\n    ),\n    type=\"date\"\n)\n\nfig.show()",
            "masked_line": "go.Scatter(x=df.Date, y=df.Measure))",
            "answer": "Scatter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_597"
        },
        {
            "dependency": "sktime",
            "version": "==0.10.1",
            "time": "2022-03-21",
            "description": "The code fits a forecasting pipeline model using AutoETS algorithm with seasonality parameter of 1 to the training data, and then prints a summary of the model.",
            "code": "from sktime.forecasting.compose import ForecastingPipeline\n\nmodel = ForecastingPipeline(steps=[\n(\"forecaster\", AutoETS(sp=1))])\nmodel.fit(y_train)\n\nmodel.steps_[-1][1].summary() # model.steps[-1][1].summary() would throw an error",
            "masked_code": "<line_mask>\n\nmodel = ForecastingPipeline(steps=[\n(\"forecaster\", AutoETS(sp=1))])\nmodel.fit(y_train)\n\nmodel.steps_[-1][1].summary() # model.steps[-1][1].summary() would throw an error",
            "masked_line": "from sktime.forecasting.compose import ForecastingPipeline",
            "answer": "ForecastingPipeline",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_598"
        },
        {
            "dependency": "plotly",
            "version": "==4.14.0",
            "time": "2022-01-23",
            "description": "This code generates a 3D mesh plot using the data loaded from a text file and displays it using Plotly.",
            "code": "import plotly.graph_objects as go\nimport numpy as np\n\npts = np.loadtxt(np.DataSource().open('https://raw.githubusercontent.com/plotly/datasets/master/mesh_dataset.txt'))\nx, y, z = pts.T\n\nfig = go.Figure(data=[go.Mesh3d(x=x, y=y, z=z,\n                   alphahull=5,\n                   opacity=0.4,\n                   color='cyan')])\nfig.show()",
            "masked_code": "import plotly.graph_objects as go\nimport numpy as np\n\npts = np.loadtxt(np.DataSource().open('https://raw.githubusercontent.com/plotly/datasets/master/mesh_dataset.txt'))\nx, y, z = pts.T\n\nfig = go.Figure(data=[go.Mesh3d(x=x, y=y, z=z,\n                   alphahull=5,\n                   opacity=0.4,\n                   color='cyan')])\n<line_mask>",
            "masked_line": "fig.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_599"
        },
        {
            "dependency": "bokeh",
            "version": "==2.1.1",
            "time": "2022-08-11",
            "description": "This Python code generates a Bokeh datatable with multiple tabs, allowing users to select a check and a product to display corresponding data in the table. The data displayed in the table is updated dynamically based on the user's selection of check and product.",
            "code": "import pandas as pd\n\nfrom bokeh.models import ColumnDataSource, DataTable, TableColumn, Tabs, Select, Panel, Row, Column, CustomJS\nfrom bokeh.plotting import show\n\nd1 = {'table1' : [['Product1', 11], ['Product2',12]],\n     'table2': [['Product1', 21], ['Product2',22]],\n     'table3': [['Product1', 31], ['Product2',32]]}\n \ndfs = {k:pd.DataFrame(v, columns=['Product', 'value']) for k, v in zip(d1.keys(), [d1[t] for t in d1.keys()])}\n\ndef fDP(df):\n    tables = []\n    for s in df.keys():\n        src = ColumnDataSource(df[s])\n        cls = [TableColumn(field=c, title=c) for c in df[s].columns]\n        dt = DataTable(source=src,columns=cls, width=600, height=200,editable=True)\n \n        tables.append(dt)\n    \n    return tables\n \nplist = list(dfs['table1']['Product'].unique())\nplist.insert(0, ' ')\ntables1 = fDP(dfs)\npanels1 = {t: Panel(child=p, title='') for t, p in zip(dfs.keys(), tables1)}\ntabs1 = Tabs(tabs=[x for x in panels1.values()], align='start', width=10)\n\nls = [x for x in dfs.keys()]\n \nsel1 = Select(title='Select Check:', align='start', value=ls[0], options=ls, width=195, margin = (15, 5, 0, 0))\nselP = Select(title='Select Product:', align='start', value=plist[0], options=plist, width=195, margin = (15, 5, 0, 0))\n\ncolT = Column(Row(sel1, selP), tabs1, spacing=-26)\n \nsel1.js_on_change('value', CustomJS(args={'sel':sel1, 'selP':selP, 'tab':tabs1, 'diPanel':panels1}\n        ,code='''\n        var sv = sel.value\n        tab.tabs = [diPanel[sv]]\n        selP.value = ' '\n        '''))\n\nds = ColumnDataSource(d1)\nselP.js_on_change('value', CustomJS(args={'selT':sel1, 'selP':selP, 'tab':tabs1, 'diPanel':panels1, 'ds': ds}\n        ,code='''\n        var tb_name = selT.value\n        var p_name = selP.value         \n        var c_tb_ds = diPanel[tb_name].child.source // table datasource to update\n        var c_tb_ds_data = ds.data[tb_name] // original data to work with\n\n        var new_data = {}\n        var p_index = null\n        var keys = Object.keys(c_tb_ds.data)\n\n        if (index > -1) { \n            keys.splice(index, 1); // 1 means remove one item only => index\n        }\n        \n        for (var k in keys){\n            new_data[keys[k]] = []\n        }\n\n        for (var i in c_tb_ds_data) {          \n            if(p_index == null) {\n                for (var j in keys) {\n                    if(c_tb_ds_data[i][j] == p_name) {\n                        if(c_tb_ds_data[i][j].includes('Product')) {\n                            p_index = i\n                        }\n                    }\n                }\n            }\n        }\n\n        if(p_index != null) {\n            for (var j in keys) {\n                new_data[keys[j]].push(c_tb_ds_data[p_index][j])              \n            }            \n        }\n\n        c_tb_ds.data = new_data // update table data source'''))\n\nshow(colT)",
            "masked_code": "import pandas as pd\n\nfrom bokeh.models import ColumnDataSource, DataTable, TableColumn, Tabs, Select, Panel, Row, Column, CustomJS\nfrom bokeh.plotting import show\n\nd1 = {'table1' : [['Product1', 11], ['Product2',12]],\n     'table2': [['Product1', 21], ['Product2',22]],\n     'table3': [['Product1', 31], ['Product2',32]]}\n \ndfs = {k:pd.DataFrame(v, columns=['Product', 'value']) for k, v in zip(d1.keys(), [d1[t] for t in d1.keys()])}\n\ndef fDP(df):\n    tables = []\n    for s in df.keys():\n        src = ColumnDataSource(df[s])\n        cls = [TableColumn(field=c, title=c) for c in df[s].columns]\n        dt = DataTable(source=src,columns=cls, width=600, height=200,editable=True)\n \n        tables.append(dt)\n    \n    return tables\n \nplist = list(dfs['table1']['Product'].unique())\nplist.insert(0, ' ')\ntables1 = fDP(dfs)\npanels1 = {t: Panel(child=p, title='') for t, p in zip(dfs.keys(), tables1)}\ntabs1 = Tabs(tabs=[x for x in panels1.values()], align='start', width=10)\n\nls = [x for x in dfs.keys()]\n \nsel1 = Select(title='Select Check:', align='start', value=ls[0], options=ls, width=195, margin = (15, 5, 0, 0))\n<line_mask>\n\ncolT = Column(Row(sel1, selP), tabs1, spacing=-26)\n \nsel1.js_on_change('value', CustomJS(args={'sel':sel1, 'selP':selP, 'tab':tabs1, 'diPanel':panels1}\n        ,code='''\n        var sv = sel.value\n        tab.tabs = [diPanel[sv]]\n        selP.value = ' '\n        '''))\n\nds = ColumnDataSource(d1)\nselP.js_on_change('value', CustomJS(args={'selT':sel1, 'selP':selP, 'tab':tabs1, 'diPanel':panels1, 'ds': ds}\n        ,code='''\n        var tb_name = selT.value\n        var p_name = selP.value         \n        var c_tb_ds = diPanel[tb_name].child.source // table datasource to update\n        var c_tb_ds_data = ds.data[tb_name] // original data to work with\n\n        var new_data = {}\n        var p_index = null\n        var keys = Object.keys(c_tb_ds.data)\n\n        if (index > -1) { \n            keys.splice(index, 1); // 1 means remove one item only => index\n        }\n        \n        for (var k in keys){\n            new_data[keys[k]] = []\n        }\n\n        for (var i in c_tb_ds_data) {          \n            if(p_index == null) {\n                for (var j in keys) {\n                    if(c_tb_ds_data[i][j] == p_name) {\n                        if(c_tb_ds_data[i][j].includes('Product')) {\n                            p_index = i\n                        }\n                    }\n                }\n            }\n        }\n\n        if(p_index != null) {\n            for (var j in keys) {\n                new_data[keys[j]].push(c_tb_ds_data[p_index][j])              \n            }            \n        }\n\n        c_tb_ds.data = new_data // update table data source'''))\n\nshow(colT)",
            "masked_line": "selP = Select(title='Select Product:', align='start', value=plist[0], options=plist, width=195, margin = (15, 5, 0, 0))",
            "answer": "Select",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_600"
        },
        {
            "dependency": "gym",
            "version": "==0.19",
            "time": "2022-03-26",
            "description": "The code creates an environment for a Taxi simulation, resets the environment, and renders the initial state of the environment.",
            "code": "import gym\n\nenv = gym.make(\"Taxi-v3\")\nenv.reset()\nenv.render()",
            "masked_code": "import gym\n\nenv = gym.make(\"Taxi-v3\")\n<line_mask>\nenv.render()",
            "masked_line": "env.reset()",
            "answer": "reset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_601"
        },
        {
            "dependency": "undetected-chromedriver",
            "version": "==3.1.3",
            "time": "2022-01-27",
            "description": "The code opens a Chrome browser using an undetected chromedriver, disables notifications, and navigates to a specified URL.",
            "code": "import undetected_chromedriver as webdriver\noptions = webdriver.ChromeOptions()\noptions.add_argument('--disable-notifications')\n\ndriver = webdriver.Chrome(browser_executable_path=your_chrome_driver_path, options=options) \n\ndriver.get('https://...')",
            "masked_code": "import undetected_chromedriver as webdriver\n<line_mask>\noptions.add_argument('--disable-notifications')\n\ndriver = webdriver.Chrome(browser_executable_path=your_chrome_driver_path, options=options) \n\ndriver.get('https://...')",
            "masked_line": "options = webdriver.ChromeOptions()",
            "answer": "ChromeOptions",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_602"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.6",
            "time": "2022-12-26",
            "description": "This code creates a figure with 2 subplots in a constrained layout, adds a colorbar to one of the subplots using a ScalarMappable object, and displays the figure.",
            "code": "import matplotlib as M\nf, a = M.pyplot.subplots(1, 2, layout='constrained')\nf.colorbar(M.cm.ScalarMappable(), ax=a)\nf.show()",
            "masked_code": "import matplotlib as M\nf, a = M.pyplot.subplots(1, 2, layout='constrained')\n<line_mask>\nf.show()",
            "masked_line": "f.colorbar(M.cm.ScalarMappable(), ax=a)",
            "answer": "cm",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_603"
        },
        {
            "dependency": "pytest",
            "version": "==7.1.1",
            "time": "2022-04-22",
            "description": "The code defines two functions, func(x) which returns x + 1 and func_var(x) which raises a NotImplementedError. It also includes two test functions, test_answer() and test_answer_var(), which assert the output of func(3) should be 5 and func_var(3) should be 4 respectively. Both test functions are marked with pytest's xfail to indicate that they are expected to fail due to the functions not being fully implemented.",
            "code": "import pytest\n\ndef func(x):\n    return x + 1\n\ndef func_var(x):\n    raise NotImplementedError\n\n@pytest.mark.xfail(raises=NotImplementedError)\ndef test_answer():\n    assert func(3) == 5\n\n@pytest.mark.xfail(raises=NotImplementedError)\ndef test_answer_var():\n    assert func_var(3) == 4",
            "masked_code": "import pytest\n\ndef func(x):\n    return x + 1\n\ndef func_var(x):\n    raise NotImplementedError\n\n@pytest.mark.xfail(raises=NotImplementedError)\ndef test_answer():\n    assert func(3) == 5\n\n<line_mask>\ndef test_answer_var():\n    assert func_var(3) == 4",
            "masked_line": "@pytest.mark.xfail(raises=NotImplementedError)",
            "answer": "mark",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_604"
        },
        {
            "dependency": "xpress",
            "version": ">=9.0",
            "time": "2022-12-14",
            "description": "The code creates two variables x and y, adds them to a problem p, and adds a constraint that the product of x and y must equal 0. The code then optimizes the problem by maximizing the value of x.",
            "code": "import xpress as xp\n\nx = xp.var()\ny = xp.var()\n\np = xp.problem()\np.addVariable(x, y)\np.addConstraint(x * y == 0)\n\np.optimize('x')",
            "masked_code": "import xpress as xp\n\nx = xp.var()\ny = xp.var()\n\np = xp.problem()\np.addVariable(x, y)\n<line_mask>\n\np.optimize('x')",
            "masked_line": "p.addConstraint(x * y == 0)",
            "answer": "addConstraint",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_605"
        },
        {
            "dependency": "xlwings",
            "version": ">=0.24.3",
            "time": "2022-08-11",
            "description": "This code opens an Excel file, creates a new Excel worksheet, writes a DataFrame to a specific cell on the worksheet, saves the changes to the Excel file, and then closes the Excel file.",
            "code": "import xlwings as xw\n\npath = r\"test.xlsx\"\n\nwith xw.App(visible=False) as app:\n    wb = xw.Book(path)\n    ws = wb.sheets[1]\n    ws.range(\"A2\").options(index=False).value = df\n    wb.save(path)\n    wb.close()",
            "masked_code": "import xlwings as xw\n\npath = r\"test.xlsx\"\n\nwith xw.App(visible=False) as app:\n    <line_mask>\n    ws = wb.sheets[1]\n    ws.range(\"A2\").options(index=False).value = df\n    wb.save(path)\n    wb.close()",
            "masked_line": "wb = xw.Book(path)",
            "answer": "Book",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_606"
        },
        {
            "dependency": "wordcloud",
            "version": "==1.8.2.2",
            "time": "2022-12-22",
            "description": "The code generates a word cloud image from the frequencies of specific words and saves it as a JPG file.",
            "code": "from wordcloud import WordCloud\n\nwords={\n    ''     : 2,\n    ''     : 3,\n    '' : 4,\n    ''   : 4\n    }\n\n# The font is taken from\n# https://github.com/amueller/word_cloud/raw/master/examples/fonts/SourceHanSerif/SourceHanSerifK-Light.otf \nwc = WordCloud(\n    font_path='./SourceHanSerifK-Light.otf',\n    background_color=\"white\",\n    width=1000,\n    height=860\n    )\n\nwen = wc.generate_from_frequencies(words)\nwc.to_file('./wc.jpg')",
            "masked_code": "<line_mask>\n\nwords={\n    ''     : 2,\n    ''     : 3,\n    '' : 4,\n    ''   : 4\n    }\n\n# The font is taken from\n# https://github.com/amueller/word_cloud/raw/master/examples/fonts/SourceHanSerif/SourceHanSerifK-Light.otf \nwc = WordCloud(\n    font_path='./SourceHanSerifK-Light.otf',\n    background_color=\"white\",\n    width=1000,\n    height=860\n    )\n\nwen = wc.generate_from_frequencies(words)\nwc.to_file('./wc.jpg')",
            "masked_line": "from wordcloud import WordCloud",
            "answer": "WordCloud",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_607"
        },
        {
            "dependency": "dash",
            "version": "==2.6.2",
            "time": "2022-10-08",
            "description": "This code sets up a Dash web application that allows users to select a continent and a country from dropdown menus, and displays a line graph of life expectancy over the years for the selected country. Users can also reset the selections and view the number of times the reset button has been clicked.",
            "code": "from dash import Dash, dcc, html, Output, Input, callback,ctx\nfrom dash.exceptions import PreventUpdate\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objs as go\nimport dash\n\ndf = pd.read_csv(\n    'https://raw.githubusercontent.com/plotly/datasets/master/gapminderDataFiveYear.csv')\n\napp = Dash(__name__)\n\n\napp.layout = html.Div([\n    html.Div([\n        dcc.Dropdown(\n            options=df['continent'].unique(),\n            placeholder=\"Select a continent\",\n            clearable=True,\n            id='continent'\n        ),\n        dcc.Dropdown(\n            value=None,\n            placeholder=\"Select a country\",\n            clearable=True,\n            id='country',\n            disabled=True\n        )\n        ],\n        style={'width': '48%', 'display': 'inline-block'}\n),\n\n    dcc.Graph(id='graph'),\n        \n    html.Button(id='reset',children = 'Reset'),\n    \n    html.Div(id='text')\n])\n\n\n@callback(\n    Output(component_id='country', component_property='options'),\n    Output(component_id='country', component_property='disabled'),\n    Input(component_id='continent', component_property='value')\n)\ndef update_text(continent_val):\n    return (df.country[df.continent == continent_val].unique(),\n            False)\n    \n@callback(\n    Output(component_id='graph', component_property='figure'),\n    Output(component_id='continent', component_property='value'),\n    Output(component_id='country', component_property='value'),\n    Input(component_id='continent', component_property='value'),\n    Input(component_id='country', component_property='value'),\n    Input(component_id='reset', component_property='n_clicks')\n    )\ndef update_fig(continent_val, country_val,n_clicks):\n\n    if ctx.triggered_id == \"reset\":\n        return ({},None,None)\n    \n    elif (continent_val is not None) and (country_val is not None):\n            mask = (df.continent == continent_val) & (df.country == country_val)\n            dff = df[mask]\n            fig = px.line(dff, x='year', y='lifeExp')\n            fig.update_layout(transition_duration=500)\n            return fig,continent_val,country_val\n    \n    return dash.no_update\n \n    \n@callback(\n    Output('text','children'),\n    Input('reset','n_clicks')\n    )\ndef text(nclick):\n    return 'Button has been clicked {} times'.format(nclick)\n    \nif __name__ == '__main__':\n    app.run(port=8004)",
            "masked_code": "from dash import Dash, dcc, html, Output, Input, callback,ctx\nfrom dash.exceptions import PreventUpdate\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objs as go\nimport dash\n\ndf = pd.read_csv(\n    'https://raw.githubusercontent.com/plotly/datasets/master/gapminderDataFiveYear.csv')\n\napp = Dash(__name__)\n\n\napp.layout = html.Div([\n    html.Div([\n        dcc.Dropdown(\n            options=df['continent'].unique(),\n            placeholder=\"Select a continent\",\n            clearable=True,\n            id='continent'\n        ),\n        dcc.Dropdown(\n            value=None,\n            placeholder=\"Select a country\",\n            clearable=True,\n            id='country',\n            disabled=True\n        )\n        ],\n        style={'width': '48%', 'display': 'inline-block'}\n),\n\n    dcc.Graph(id='graph'),\n        \n    <line_mask>\n    \n    html.Div(id='text')\n])\n\n\n@callback(\n    Output(component_id='country', component_property='options'),\n    Output(component_id='country', component_property='disabled'),\n    Input(component_id='continent', component_property='value')\n)\ndef update_text(continent_val):\n    return (df.country[df.continent == continent_val].unique(),\n            False)\n    \n@callback(\n    Output(component_id='graph', component_property='figure'),\n    Output(component_id='continent', component_property='value'),\n    Output(component_id='country', component_property='value'),\n    Input(component_id='continent', component_property='value'),\n    Input(component_id='country', component_property='value'),\n    Input(component_id='reset', component_property='n_clicks')\n    )\ndef update_fig(continent_val, country_val,n_clicks):\n\n    if ctx.triggered_id == \"reset\":\n        return ({},None,None)\n    \n    elif (continent_val is not None) and (country_val is not None):\n            mask = (df.continent == continent_val) & (df.country == country_val)\n            dff = df[mask]\n            fig = px.line(dff, x='year', y='lifeExp')\n            fig.update_layout(transition_duration=500)\n            return fig,continent_val,country_val\n    \n    return dash.no_update\n \n    \n@callback(\n    Output('text','children'),\n    Input('reset','n_clicks')\n    )\ndef text(nclick):\n    return 'Button has been clicked {} times'.format(nclick)\n    \nif __name__ == '__main__':\n    app.run(port=8004)",
            "masked_line": "html.Button(id='reset',children = 'Reset'),",
            "answer": "Button",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_608"
        },
        {
            "dependency": "beautifulsoup4",
            "version": ">=4.9.0",
            "time": "2022-09-13",
            "description": "The code retrieves the HTML content from 'https://www.nytimes.com/', parses it using BeautifulSoup, and extracts the text content from the body section of the webpage by removing extra whitespaces.",
            "code": "import bs4, requests\n\nresponse = requests.get('https://www.nytimes.com/',headers={'User-Agent': 'Mozilla/5.0'})\nsoup = bs4.BeautifulSoup(response.text,'lxml')\n\nsoup.body.get_text(' ', strip=True)",
            "masked_code": "import bs4, requests\n\nresponse = requests.get('https://www.nytimes.com/',headers={'User-Agent': 'Mozilla/5.0'})\nsoup = bs4.BeautifulSoup(response.text,'lxml')\n\n<line_mask>",
            "masked_line": "soup.body.get_text(' ', strip=True)",
            "answer": "body",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_609"
        },
        {
            "dependency": "networkx",
            "version": "==3.0",
            "time": "2023-02-22",
            "description": "The code calculates the graph edit distance between two molecular graphs represented by SMILES strings.",
            "code": "from rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nIPythonConsole.ipython_useSVG=True  \nimport networkx as nx\n\nsmiles_1 = 'CC(C)(C)[C+](C=C)(C=C)'\nsmiles_2 = 'CC(C)(C)C(C=C)(C=[C+])'\n\nmol1 = Chem.MolFromSmiles(smiles_1)\nmol2 = Chem.MolFromSmiles(smiles_2)\n\ndef get_graph(mol): \n  atomic_nums = [atom.GetAtomicNum() for atom in mol.GetAtoms()]\n  formal_charges = [atom.GetFormalCharge() for atom in mol.GetAtoms()]\n  ad_matrix = Chem.GetAdjacencyMatrix(mol,useBO=True)\n  for i,(a_num,f_c) in enumerate(zip(atomic_nums, formal_charges)):\n    if f_c !=0:\n      ad_matrix[i,i] = a_num + f_c\n    else:\n      ad_matrix[i,i] = a_num\n  G = nx.from_numpy_array(ad_matrix)\n  return G\n\nG1 = get_graph(mol1)\nG2 = get_graph(mol2)\n\nGED= nx.graph_edit_distance(G1, G2, edge_match=lambda a,b: a['weight'] == b['weight'])\n\nprint((GED) )\n# >> Outputs 2.0",
            "masked_code": "from rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nIPythonConsole.ipython_useSVG=True  \nimport networkx as nx\n\nsmiles_1 = 'CC(C)(C)[C+](C=C)(C=C)'\nsmiles_2 = 'CC(C)(C)C(C=C)(C=[C+])'\n\nmol1 = Chem.MolFromSmiles(smiles_1)\nmol2 = Chem.MolFromSmiles(smiles_2)\n\ndef get_graph(mol): \n  atomic_nums = [atom.GetAtomicNum() for atom in mol.GetAtoms()]\n  formal_charges = [atom.GetFormalCharge() for atom in mol.GetAtoms()]\n  ad_matrix = Chem.GetAdjacencyMatrix(mol,useBO=True)\n  for i,(a_num,f_c) in enumerate(zip(atomic_nums, formal_charges)):\n    if f_c !=0:\n      ad_matrix[i,i] = a_num + f_c\n    else:\n      ad_matrix[i,i] = a_num\n  <line_mask>\n  return G\n\nG1 = get_graph(mol1)\nG2 = get_graph(mol2)\n\nGED= nx.graph_edit_distance(G1, G2, edge_match=lambda a,b: a['weight'] == b['weight'])\n\nprint((GED) )\n# >> Outputs 2.0",
            "masked_line": "G = nx.from_numpy_array(ad_matrix)",
            "answer": "from_numpy_array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_610"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.8.0",
            "time": "2022-04-13",
            "description": "This code creates a 3D plot using matplotlib to visualize a mesh loaded from an STL file, specifically the 'HalfDonut.stl' file. The plot is then displayed on the screen with the mesh vectors added to it.",
            "code": "from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\naxes = figure.add_subplot(projection='3d')\n\n# Load the STL files and add the vectors to the plot \n# file is at https://github.com/wolph/numpy-stl/tree/develop/tests/stl_binary\nyour_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show()",
            "masked_code": "from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\n<line_mask>\n\n# Load the STL files and add the vectors to the plot \n# file is at https://github.com/wolph/numpy-stl/tree/develop/tests/stl_binary\nyour_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show()",
            "masked_line": "axes = figure.add_subplot(projection='3d')",
            "answer": "add_subplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_611"
        },
        {
            "dependency": "stl",
            "version": "==3.0.1",
            "time": "2022-04-13",
            "description": "The code loads an STL file, creates a 3D plot, adds the vectors from the STL file to the plot, auto-scales the plot to the mesh size, and then displays the 3D plot on the screen.",
            "code": "from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\naxes = figure.add_subplot(projection='3d')\n\n# Load the STL files and add the vectors to the plot \n# file is at https://github.com/wolph/numpy-stl/tree/develop/tests/stl_binary\nyour_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show()",
            "masked_code": "from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\naxes = figure.add_subplot(projection='3d')\n\n# Load the STL files and add the vectors to the plot \n# file is at https://github.com/wolph/numpy-stl/tree/develop/tests/stl_binary\n<line_mask>\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show()",
            "masked_line": "your_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')",
            "answer": "Mesh",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_612"
        },
        {
            "dependency": "gensim",
            "version": "==3.6",
            "time": "2022-04-08",
            "description": "This code snippet uses the gensim library to train a Word2Vec model on common_texts data. It creates word vectors of dimension 100 and extracts the vector for the word \"computer\".",
            "code": "import gensim\ngensim.__version__\n# 3.6.0\n\nfrom gensim.test.utils import common_texts\nfrom gensim.models import Word2Vec\n\nmodel = Word2Vec(sentences=common_texts, window=5, min_count=1, workers=4) # do not specify size, leave the default 100\n\nwv = model.wv['computer']  # get numpy vector of a word in the corpus\nwv.shape # verify the dimension of a single vector is 100\n# (100,)",
            "masked_code": "import gensim\ngensim.__version__\n# 3.6.0\n\nfrom gensim.test.utils import common_texts\n<line_mask>\n\nmodel = Word2Vec(sentences=common_texts, window=5, min_count=1, workers=4) # do not specify size, leave the default 100\n\nwv = model.wv['computer']  # get numpy vector of a word in the corpus\nwv.shape # verify the dimension of a single vector is 100\n# (100,)",
            "masked_line": "from gensim.models import Word2Vec",
            "answer": "Word2Vec",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_613"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.3",
            "time": "2022-08-25",
            "description": "This code generates a list of quarterly dates starting from the first date of the input period (specified as a quarter) to the last date of the input period. It then prints out the list of quarterly dates with the frequency set to December quarters.",
            "code": "import pandas as pd\nfrom pprint import pprint\n\nstart_date = '2021Q4'\nend_date = '2024Q1'\n\nfirst_date_of_period  = pd.Period(start_date, 'Q').to_timestamp('D', 'S') # D for day, S for start\nlast_date_of_period = pd.Period(end_date, 'Q').to_timestamp('D', 'E') # D for day, E for end\n\nprint(first_date_of_period)\n# >> 2021-10-01 00:00:00\nprint(last_date_of_period)\n# >> 2024-03-31 23:59:59.999999999\n\ndates=pd.date_range(start=first_date_of_period, end=last_date_of_period, freq='Q').to_list()\npprint(dates)\n# >> [Timestamp('2021-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-03-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-06-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-09-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-03-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-06-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-09-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2024-03-31 00:00:00', freq='Q-DEC')]",
            "masked_code": "import pandas as pd\nfrom pprint import pprint\n\nstart_date = '2021Q4'\nend_date = '2024Q1'\n\n<line_mask>\nlast_date_of_period = pd.Period(end_date, 'Q').to_timestamp('D', 'E') # D for day, E for end\n\nprint(first_date_of_period)\n# >> 2021-10-01 00:00:00\nprint(last_date_of_period)\n# >> 2024-03-31 23:59:59.999999999\n\ndates=pd.date_range(start=first_date_of_period, end=last_date_of_period, freq='Q').to_list()\npprint(dates)\n# >> [Timestamp('2021-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-03-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-06-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-09-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-03-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-06-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-09-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2024-03-31 00:00:00', freq='Q-DEC')]",
            "masked_line": "first_date_of_period  = pd.Period(start_date, 'Q').to_timestamp('D', 'S') # D for day, S for start",
            "answer": "to_timestamp",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_614"
        },
        {
            "dependency": "bigtree",
            "version": "==0.6.6",
            "time": "2022-12-14",
            "description": "The code converts a tree data structure into a pillow image and saves it as a JPEG file named \"tree.jpg\".",
            "code": "from bigtree import tree_to_pillow\n\npillow_image = tree_to_pillow(root)\npillow_image.save(\"tree.jpg\")",
            "masked_code": "from bigtree import tree_to_pillow\n\n<line_mask>\npillow_image.save(\"tree.jpg\")",
            "masked_line": "pillow_image = tree_to_pillow(root)",
            "answer": "tree_to_pillow",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_615"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2022-12-29",
            "description": "The code concatenates three dataframes (df1, df2, df3) into a single dataframe (df). The resulting dataframe contains columns for City, Country, Phone, and Street. The final dataframe (df) contains all the rows from the input dataframes (df1, df2, df3) combined.",
            "code": "import pandas as pd\ndf1 = pd.DataFrame({\"City\":[\"Berlin\",\"Paris\"],\"Country\":[\"DE\",\"FR\"],\"Phone\":[111,122]})\ndf2 = pd.DataFrame({\"City\":[\"Amstera\",\"Copenhag\"],\"Country\":[\"NL\",\"DK\"]})\ndf3 = pd.DataFrame({\"City\":[\"Vienna\",\"Madrid\"],\"Country\":[\"AT\",\"ES\"],\"Phone\":[222,343],\"Street\":[\"Leoplstr\",\"Avenia\"]})\ndf = pd.concat([df1,df2,df3])\nprint(df)",
            "masked_code": "import pandas as pd\ndf1 = pd.DataFrame({\"City\":[\"Berlin\",\"Paris\"],\"Country\":[\"DE\",\"FR\"],\"Phone\":[111,122]})\ndf2 = pd.DataFrame({\"City\":[\"Amstera\",\"Copenhag\"],\"Country\":[\"NL\",\"DK\"]})\n<line_mask>\ndf = pd.concat([df1,df2,df3])\nprint(df)",
            "masked_line": "df3 = pd.DataFrame({\"City\":[\"Vienna\",\"Madrid\"],\"Country\":[\"AT\",\"ES\"],\"Phone\":[222,343],\"Street\":[\"Leoplstr\",\"Avenia\"]})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_616"
        },
        {
            "dependency": "pandas",
            "version": "==1.5",
            "time": "2022-12-10",
            "description": "The code creates a multi-index DataFrame by grouping and categorizing the data based on the values in columns A, B, C, D, and E.",
            "code": "import pandas as pd\n\ndata = {\n  'A' : [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n  'B' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  'C' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n  'D' : [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n  'E' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n}\n\ndf = pd.DataFrame.from_dict(data)\n\ncategorical = pd.from_dummies(df)[\"\"].rename(\"category\")\ngroups = (categorical != categorical.shift()).cumsum().rename(\"group_num\")\n\nindex = pd.MultiIndex.from_arrays([\n    df.index,\n    pd.concat([categorical, groups], axis=1).groupby(\"category\")[\"group_num\"].transform(lambda x: (x != x.shift()).cumsum()),\n    groups.groupby(groups).cumcount().add(1).rename(\"group_id\"),\n    categorical\n])\n\nprint(df.set_index(index))",
            "masked_code": "import pandas as pd\n\ndata = {\n  'A' : [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n  'B' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  'C' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n  'D' : [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n  'E' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n}\n\ndf = pd.DataFrame.from_dict(data)\n\ncategorical = pd.from_dummies(df)[\"\"].rename(\"category\")\ngroups = (categorical != categorical.shift()).cumsum().rename(\"group_num\")\n\nindex = pd.MultiIndex.from_arrays([\n    df.index,\n    pd.concat([categorical, groups], axis=1).groupby(\"category\")[\"group_num\"].transform(lambda x: (x != x.shift()).cumsum()),\n    groups.groupby(groups).cumcount().add(1).rename(\"group_id\"),\n    categorical\n])\n\n<line_mask>",
            "masked_line": "print(df.set_index(index))",
            "answer": "set_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_617"
        },
        {
            "dependency": "pytest",
            "version": "==7.0.1",
            "time": "2022-06-21",
            "description": "The function call_sql compares the result of two SQL queries by executing them through a provided database connection, and returns True if the results are equal, otherwise returns False. The test function test_Call_sql uses a mock database connection to simulate the execution of SQL queries and verifies the correctness of the call_sql function based on the expected outcomes provided in the test cases.",
            "code": "from unittest.mock import MagicMock\nimport pytest\n\n\ndef call_sql(conn):\n    \n    query1 = \"\"\n    query2 = \"\"\n\n    cur = conn.cursor()\n    run1 = cur.execute(query1).fetchone()\n    run2 = cur.execute(query2).fetchone()\n\n    count1 = run1[0]\n    count2 = run2[0]\n\n    return count1 == count2\n\n\n@pytest.mark.parametrize(\n    \"data,expected\", \n    [\n        ([(1, ), (1, )], True),\n        ([(1, ), (2, )], False)\n    ]\n)\ndef test_Call_sql(data, expected):\n    mock_connect = MagicMock()\n    cursor = mock_connect.cursor.return_value\n    cursor.execute.return_value.fetchone.side_effect = data\n\n    assert call_sql(mock_connect) is expected",
            "masked_code": "from unittest.mock import MagicMock\nimport pytest\n\n\ndef call_sql(conn):\n    \n    query1 = \"\"\n    query2 = \"\"\n\n    cur = conn.cursor()\n    run1 = cur.execute(query1).fetchone()\n    run2 = cur.execute(query2).fetchone()\n\n    count1 = run1[0]\n    count2 = run2[0]\n\n    return count1 == count2\n\n\n<line_mask>\n    \"data,expected\", \n    [\n        ([(1, ), (1, )], True),\n        ([(1, ), (2, )], False)\n    ]\n)\ndef test_Call_sql(data, expected):\n    mock_connect = MagicMock()\n    cursor = mock_connect.cursor.return_value\n    cursor.execute.return_value.fetchone.side_effect = data\n\n    assert call_sql(mock_connect) is expected",
            "masked_line": "@pytest.mark.parametrize(",
            "answer": "parametrize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_618"
        },
        {
            "dependency": "mock",
            "version": "==3.7.0",
            "time": "2022-06-21",
            "description": "The function `call_sql` compares the results of two SQL queries executed using a given connection object `conn`. It fetches the first result from each query, extracts a count value from each result, and then returns True if the count values are equal, otherwise it returns False. The `test_Call_sql` function is used to test the functionality of `call_sql` using mock data for the SQL queries and expected output.",
            "code": "from unittest.mock import MagicMock\nimport pytest\n\n\ndef call_sql(conn):\n    \n    query1 = \"\"\n    query2 = \"\"\n\n    cur = conn.cursor()\n    run1 = cur.execute(query1).fetchone()\n    run2 = cur.execute(query2).fetchone()\n\n    count1 = run1[0]\n    count2 = run2[0]\n\n    return count1 == count2\n\n\n@pytest.mark.parametrize(\n    \"data,expected\", \n    [\n        ([(1, ), (1, )], True),\n        ([(1, ), (2, )], False)\n    ]\n)\ndef test_Call_sql(data, expected):\n    mock_connect = MagicMock()\n    cursor = mock_connect.cursor.return_value\n    cursor.execute.return_value.fetchone.side_effect = data\n\n    assert call_sql(mock_connect) is expected",
            "masked_code": "from unittest.mock import MagicMock\nimport pytest\n\n\ndef call_sql(conn):\n    \n    query1 = \"\"\n    query2 = \"\"\n\n    cur = conn.cursor()\n    run1 = cur.execute(query1).fetchone()\n    run2 = cur.execute(query2).fetchone()\n\n    count1 = run1[0]\n    count2 = run2[0]\n\n    return count1 == count2\n\n\n@pytest.mark.parametrize(\n    \"data,expected\", \n    [\n        ([(1, ), (1, )], True),\n        ([(1, ), (2, )], False)\n    ]\n)\ndef test_Call_sql(data, expected):\n    <line_mask>\n    cursor = mock_connect.cursor.return_value\n    cursor.execute.return_value.fetchone.side_effect = data\n\n    assert call_sql(mock_connect) is expected",
            "masked_line": "mock_connect = MagicMock()",
            "answer": "MagicMock",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_619"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.1",
            "time": "2022-02-14",
            "description": "This code performs entity linking on a list of documents using Azure Text Analytics service. It recognizes entities in the text, retrieves their linked information from a data source, and creates a DataFrame with columns 'doc_name', 'name', 'id', 'text', and 'wiki_url' containing the extracted information for each entity in the documents.",
            "code": "import os\nimport asyncio\nimport pandas as pd\nfrom azure.ai.textanalytics.aio import TextAnalyticsClient\nfrom azure.core.credentials import AzureKeyCredential\n\n# this is the input list of documents\nace = [{'doc_name': 'doc_1',\n        'mention': 'Chris Evans',\n        'title': 'Chris Evans',\n        'full_text': \"Chris Evans started as human torch.......\"},\n       {'doc_name': 'doc_2',\n        'mention': 'Tony Stark',\n        'title': 'Chris Evans',\n        'full_text': \"Tony Stark is ironman which likes.......\"},\n       {'doc_name': 'doc_3',\n        'mention': 'Chris Evans',\n        'title': 'Thor',\n        'full_text': \"Thor loves to drink.......\"}]\n\nkey = \"my-key\"\nendpoint = \"my-endpoint\"\n\nazure_client = TextAnalyticsClient(endpoint=endpoint, credential=AzureKeyCredential(key))\n\n\nasync def entity_linking(full_text, doc_name, azure_client):\n\n    name = []\n    i_d = []\n    url = []\n    temp = []\n    text = []\n    doc_n = []\n\n    documents = [full_text]\n\n    try:\n        result = await azure_client.recognize_linked_entities(documents=documents)\n        docs = [doc for doc in result if not doc.is_error]\n\n        for doc in docs:\n            for entity in doc.entities:\n                doc_n.append(doc_name)\n                name.append(entity.name)\n                i_d.append(entity.data_source_entity_id)\n                url.append(entity.url)\n                temp.append(entity.matches)\n\n    except Exception as err:\n        print(\"Encountered exception. {}\".format(err))\n\n    for i in range(len(temp)):\n        text.append(temp[i][0]['text'])\n\n    dataframe = pd.DataFrame({\n        'doc_name': doc_n,\n        'name': name,\n        'id': i_d,\n        'text': text,\n        'wiki_url': url\n    })\n\n    return dataframe\n\nasync def agg_azure_pred(doc, azure_client):\n    pred_df = pd.DataFrame()\n\n    async with azure_client:\n        coro_df = [entity_linking(doc[i]['full_text'], doc[i]['doc_name'], azure_client) for i in range(len(doc))]\n        results = await asyncio.gather(*coro_df)\n\n        for df in results:\n            pred_df = pd.concat([pd.DataFrame(df), pred_df])\n\n    return pred_df\n    # I ran the code use this command below\n\n\nasync def main():\n    await agg_azure_pred(ace, azure_client)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())",
            "masked_code": "import os\nimport asyncio\nimport pandas as pd\nfrom azure.ai.textanalytics.aio import TextAnalyticsClient\nfrom azure.core.credentials import AzureKeyCredential\n\n# this is the input list of documents\nace = [{'doc_name': 'doc_1',\n        'mention': 'Chris Evans',\n        'title': 'Chris Evans',\n        'full_text': \"Chris Evans started as human torch.......\"},\n       {'doc_name': 'doc_2',\n        'mention': 'Tony Stark',\n        'title': 'Chris Evans',\n        'full_text': \"Tony Stark is ironman which likes.......\"},\n       {'doc_name': 'doc_3',\n        'mention': 'Chris Evans',\n        'title': 'Thor',\n        'full_text': \"Thor loves to drink.......\"}]\n\nkey = \"my-key\"\nendpoint = \"my-endpoint\"\n\nazure_client = TextAnalyticsClient(endpoint=endpoint, credential=AzureKeyCredential(key))\n\n\nasync def entity_linking(full_text, doc_name, azure_client):\n\n    name = []\n    i_d = []\n    url = []\n    temp = []\n    text = []\n    doc_n = []\n\n    documents = [full_text]\n\n    try:\n        result = await azure_client.recognize_linked_entities(documents=documents)\n        docs = [doc for doc in result if not doc.is_error]\n\n        for doc in docs:\n            for entity in doc.entities:\n                doc_n.append(doc_name)\n                name.append(entity.name)\n                i_d.append(entity.data_source_entity_id)\n                url.append(entity.url)\n                temp.append(entity.matches)\n\n    except Exception as err:\n        print(\"Encountered exception. {}\".format(err))\n\n    for i in range(len(temp)):\n        text.append(temp[i][0]['text'])\n\n    <line_mask>\n        'doc_name': doc_n,\n        'name': name,\n        'id': i_d,\n        'text': text,\n        'wiki_url': url\n    })\n\n    return dataframe\n\nasync def agg_azure_pred(doc, azure_client):\n    pred_df = pd.DataFrame()\n\n    async with azure_client:\n        coro_df = [entity_linking(doc[i]['full_text'], doc[i]['doc_name'], azure_client) for i in range(len(doc))]\n        results = await asyncio.gather(*coro_df)\n\n        for df in results:\n            pred_df = pd.concat([pd.DataFrame(df), pred_df])\n\n    return pred_df\n    # I ran the code use this command below\n\n\nasync def main():\n    await agg_azure_pred(ace, azure_client)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())",
            "masked_line": "dataframe = pd.DataFrame({",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_620"
        },
        {
            "dependency": "azure-ai-textanalytics",
            "version": "==5.1.0",
            "time": "2022-02-14",
            "description": "The code performs entity linking for a list of documents using Azure Text Analytics service. It extracts entities such as names, IDs, text, and Wikipedia URLs from the text of the documents provided in the input list. It then aggregates the extracted entities into a pandas DataFrame for further analysis.",
            "code": "import os\nimport asyncio\nimport pandas as pd\nfrom azure.ai.textanalytics.aio import TextAnalyticsClient\nfrom azure.core.credentials import AzureKeyCredential\n\n# this is the input list of documents\nace = [{'doc_name': 'doc_1',\n        'mention': 'Chris Evans',\n        'title': 'Chris Evans',\n        'full_text': \"Chris Evans started as human torch.......\"},\n       {'doc_name': 'doc_2',\n        'mention': 'Tony Stark',\n        'title': 'Chris Evans',\n        'full_text': \"Tony Stark is ironman which likes.......\"},\n       {'doc_name': 'doc_3',\n        'mention': 'Chris Evans',\n        'title': 'Thor',\n        'full_text': \"Thor loves to drink.......\"}]\n\nkey = \"my-key\"\nendpoint = \"my-endpoint\"\n\nazure_client = TextAnalyticsClient(endpoint=endpoint, credential=AzureKeyCredential(key))\n\n\nasync def entity_linking(full_text, doc_name, azure_client):\n\n    name = []\n    i_d = []\n    url = []\n    temp = []\n    text = []\n    doc_n = []\n\n    documents = [full_text]\n\n    try:\n        result = await azure_client.recognize_linked_entities(documents=documents)\n        docs = [doc for doc in result if not doc.is_error]\n\n        for doc in docs:\n            for entity in doc.entities:\n                doc_n.append(doc_name)\n                name.append(entity.name)\n                i_d.append(entity.data_source_entity_id)\n                url.append(entity.url)\n                temp.append(entity.matches)\n\n    except Exception as err:\n        print(\"Encountered exception. {}\".format(err))\n\n    for i in range(len(temp)):\n        text.append(temp[i][0]['text'])\n\n    dataframe = pd.DataFrame({\n        'doc_name': doc_n,\n        'name': name,\n        'id': i_d,\n        'text': text,\n        'wiki_url': url\n    })\n\n    return dataframe\n\nasync def agg_azure_pred(doc, azure_client):\n    pred_df = pd.DataFrame()\n\n    async with azure_client:\n        coro_df = [entity_linking(doc[i]['full_text'], doc[i]['doc_name'], azure_client) for i in range(len(doc))]\n        results = await asyncio.gather(*coro_df)\n\n        for df in results:\n            pred_df = pd.concat([pd.DataFrame(df), pred_df])\n\n    return pred_df\n    # I ran the code use this command below\n\n\nasync def main():\n    await agg_azure_pred(ace, azure_client)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())",
            "masked_code": "import os\nimport asyncio\nimport pandas as pd\nfrom azure.ai.textanalytics.aio import TextAnalyticsClient\nfrom azure.core.credentials import AzureKeyCredential\n\n# this is the input list of documents\nace = [{'doc_name': 'doc_1',\n        'mention': 'Chris Evans',\n        'title': 'Chris Evans',\n        'full_text': \"Chris Evans started as human torch.......\"},\n       {'doc_name': 'doc_2',\n        'mention': 'Tony Stark',\n        'title': 'Chris Evans',\n        'full_text': \"Tony Stark is ironman which likes.......\"},\n       {'doc_name': 'doc_3',\n        'mention': 'Chris Evans',\n        'title': 'Thor',\n        'full_text': \"Thor loves to drink.......\"}]\n\nkey = \"my-key\"\nendpoint = \"my-endpoint\"\n\nazure_client = TextAnalyticsClient(endpoint=endpoint, credential=AzureKeyCredential(key))\n\n\nasync def entity_linking(full_text, doc_name, azure_client):\n\n    name = []\n    i_d = []\n    url = []\n    temp = []\n    text = []\n    doc_n = []\n\n    documents = [full_text]\n\n    try:\n        <line_mask>\n        docs = [doc for doc in result if not doc.is_error]\n\n        for doc in docs:\n            for entity in doc.entities:\n                doc_n.append(doc_name)\n                name.append(entity.name)\n                i_d.append(entity.data_source_entity_id)\n                url.append(entity.url)\n                temp.append(entity.matches)\n\n    except Exception as err:\n        print(\"Encountered exception. {}\".format(err))\n\n    for i in range(len(temp)):\n        text.append(temp[i][0]['text'])\n\n    dataframe = pd.DataFrame({\n        'doc_name': doc_n,\n        'name': name,\n        'id': i_d,\n        'text': text,\n        'wiki_url': url\n    })\n\n    return dataframe\n\nasync def agg_azure_pred(doc, azure_client):\n    pred_df = pd.DataFrame()\n\n    async with azure_client:\n        coro_df = [entity_linking(doc[i]['full_text'], doc[i]['doc_name'], azure_client) for i in range(len(doc))]\n        results = await asyncio.gather(*coro_df)\n\n        for df in results:\n            pred_df = pd.concat([pd.DataFrame(df), pred_df])\n\n    return pred_df\n    # I ran the code use this command below\n\n\nasync def main():\n    await agg_azure_pred(ace, azure_client)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())",
            "masked_line": "result = await azure_client.recognize_linked_entities(documents=documents)",
            "answer": "recognize_linked_entities",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_621"
        },
        {
            "dependency": "azure-core",
            "version": "==1.22.1",
            "time": "2022-02-14",
            "description": "This code uses Azure Text Analytics to perform entity linking on a list of documents. It takes the full text, document name, and Azure client as input, recognizes linked entities in the text, extracts entity information like name, ID, text, and wiki URL, and returns this information in a pandas DataFrame.",
            "code": "import os\nimport asyncio\nimport pandas as pd\nfrom azure.ai.textanalytics.aio import TextAnalyticsClient\nfrom azure.core.credentials import AzureKeyCredential\n\n# this is the input list of documents\nace = [{'doc_name': 'doc_1',\n        'mention': 'Chris Evans',\n        'title': 'Chris Evans',\n        'full_text': \"Chris Evans started as human torch.......\"},\n       {'doc_name': 'doc_2',\n        'mention': 'Tony Stark',\n        'title': 'Chris Evans',\n        'full_text': \"Tony Stark is ironman which likes.......\"},\n       {'doc_name': 'doc_3',\n        'mention': 'Chris Evans',\n        'title': 'Thor',\n        'full_text': \"Thor loves to drink.......\"}]\n\nkey = \"my-key\"\nendpoint = \"my-endpoint\"\n\nazure_client = TextAnalyticsClient(endpoint=endpoint, credential=AzureKeyCredential(key))\n\n\nasync def entity_linking(full_text, doc_name, azure_client):\n\n    name = []\n    i_d = []\n    url = []\n    temp = []\n    text = []\n    doc_n = []\n\n    documents = [full_text]\n\n    try:\n        result = await azure_client.recognize_linked_entities(documents=documents)\n        docs = [doc for doc in result if not doc.is_error]\n\n        for doc in docs:\n            for entity in doc.entities:\n                doc_n.append(doc_name)\n                name.append(entity.name)\n                i_d.append(entity.data_source_entity_id)\n                url.append(entity.url)\n                temp.append(entity.matches)\n\n    except Exception as err:\n        print(\"Encountered exception. {}\".format(err))\n\n    for i in range(len(temp)):\n        text.append(temp[i][0]['text'])\n\n    dataframe = pd.DataFrame({\n        'doc_name': doc_n,\n        'name': name,\n        'id': i_d,\n        'text': text,\n        'wiki_url': url\n    })\n\n    return dataframe\n\nasync def agg_azure_pred(doc, azure_client):\n    pred_df = pd.DataFrame()\n\n    async with azure_client:\n        coro_df = [entity_linking(doc[i]['full_text'], doc[i]['doc_name'], azure_client) for i in range(len(doc))]\n        results = await asyncio.gather(*coro_df)\n\n        for df in results:\n            pred_df = pd.concat([pd.DataFrame(df), pred_df])\n\n    return pred_df\n    # I ran the code use this command below\n\n\nasync def main():\n    await agg_azure_pred(ace, azure_client)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())",
            "masked_code": "import os\nimport asyncio\nimport pandas as pd\nfrom azure.ai.textanalytics.aio import TextAnalyticsClient\nfrom azure.core.credentials import AzureKeyCredential\n\n# this is the input list of documents\nace = [{'doc_name': 'doc_1',\n        'mention': 'Chris Evans',\n        'title': 'Chris Evans',\n        'full_text': \"Chris Evans started as human torch.......\"},\n       {'doc_name': 'doc_2',\n        'mention': 'Tony Stark',\n        'title': 'Chris Evans',\n        'full_text': \"Tony Stark is ironman which likes.......\"},\n       {'doc_name': 'doc_3',\n        'mention': 'Chris Evans',\n        'title': 'Thor',\n        'full_text': \"Thor loves to drink.......\"}]\n\nkey = \"my-key\"\nendpoint = \"my-endpoint\"\n\n<line_mask>\n\n\nasync def entity_linking(full_text, doc_name, azure_client):\n\n    name = []\n    i_d = []\n    url = []\n    temp = []\n    text = []\n    doc_n = []\n\n    documents = [full_text]\n\n    try:\n        result = await azure_client.recognize_linked_entities(documents=documents)\n        docs = [doc for doc in result if not doc.is_error]\n\n        for doc in docs:\n            for entity in doc.entities:\n                doc_n.append(doc_name)\n                name.append(entity.name)\n                i_d.append(entity.data_source_entity_id)\n                url.append(entity.url)\n                temp.append(entity.matches)\n\n    except Exception as err:\n        print(\"Encountered exception. {}\".format(err))\n\n    for i in range(len(temp)):\n        text.append(temp[i][0]['text'])\n\n    dataframe = pd.DataFrame({\n        'doc_name': doc_n,\n        'name': name,\n        'id': i_d,\n        'text': text,\n        'wiki_url': url\n    })\n\n    return dataframe\n\nasync def agg_azure_pred(doc, azure_client):\n    pred_df = pd.DataFrame()\n\n    async with azure_client:\n        coro_df = [entity_linking(doc[i]['full_text'], doc[i]['doc_name'], azure_client) for i in range(len(doc))]\n        results = await asyncio.gather(*coro_df)\n\n        for df in results:\n            pred_df = pd.concat([pd.DataFrame(df), pred_df])\n\n    return pred_df\n    # I ran the code use this command below\n\n\nasync def main():\n    await agg_azure_pred(ace, azure_client)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())",
            "masked_line": "azure_client = TextAnalyticsClient(endpoint=endpoint, credential=AzureKeyCredential(key))",
            "answer": "AzureKeyCredential",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_622"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2022-11-30",
            "description": "This code creates a pandas DataFrame with product names and their corresponding values, including a column called 'MAX' to store the product with the highest value. It then assigns the product name with the highest value to the 'MAX' column for each row in the DataFrame.",
            "code": "# Panda 1.5.2\nimport pandas as pd\n\nd = {'prod': ['p1', 'p2', 'p3'], 'p1': [10, 20.0, 30], 'p2': [7 ,6 ,4], 'p3': [12,50,5], 'MAX': ['','','']}\ndf = pd.DataFrame(data=d)\nprint(type(df)) # \ndf['MAX'] = df.idxmax(1, numeric_only=True)\nprint(df)",
            "masked_code": "# Panda 1.5.2\nimport pandas as pd\n\nd = {'prod': ['p1', 'p2', 'p3'], 'p1': [10, 20.0, 30], 'p2': [7 ,6 ,4], 'p3': [12,50,5], 'MAX': ['','','']}\ndf = pd.DataFrame(data=d)\nprint(type(df)) # \n<line_mask>\nprint(df)",
            "masked_line": "df['MAX'] = df.idxmax(1, numeric_only=True)",
            "answer": "idxmax",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_623"
        },
        {
            "dependency": "pytest",
            "version": "==7.0.1",
            "time": "2022-06-25",
            "description": "The code tests the functionality of the get_clicked_events function by mocking the Client object and checking for success and failure scenarios. In the success test, the function should return \"fizz\" when called, while in the failure test, an ApiException with the message \"Failed to get events!\" should be raised.",
            "code": "from unittest.mock import patch\n\nimport pytest\n\nfrom hubspot import Client\nfrom hubspot.events.exceptions import ApiException\n\nfrom src.get_events import get_clicked_events\n\n\ndef test_get_clicked_events_success():\n    with patch(\"src.get_events.Client\", spec=Client) as mock_client:\n        mock_client.configure_mock(\n            **{\n                \"create.return_value\": mock_client,\n                \"events.get_page.return_value\": \"fizz\"\n            }\n        )\n\n        events = get_clicked_events()\n        assert events == \"fizz\"\n\n\ndef test_get_clicked_events_fail():\n    err_msg = \"Failed to get events!\"\n\n    with patch(\"src.get_events.Client\", spec=Client) as mock_client:\n        mock_client.configure_mock(\n            **{\n                \"create.return_value\": mock_client,\n                \"events.get_page.side_effect\": ApiException(err_msg)\n            }\n        )\n\n        with pytest.raises(ApiException) as err:\n            get_clicked_events()\n            assert err_msg == err.value",
            "masked_code": "from unittest.mock import patch\n\nimport pytest\n\nfrom hubspot import Client\nfrom hubspot.events.exceptions import ApiException\n\nfrom src.get_events import get_clicked_events\n\n\ndef test_get_clicked_events_success():\n    with patch(\"src.get_events.Client\", spec=Client) as mock_client:\n        mock_client.configure_mock(\n            **{\n                \"create.return_value\": mock_client,\n                \"events.get_page.return_value\": \"fizz\"\n            }\n        )\n\n        events = get_clicked_events()\n        assert events == \"fizz\"\n\n\ndef test_get_clicked_events_fail():\n    err_msg = \"Failed to get events!\"\n\n    with patch(\"src.get_events.Client\", spec=Client) as mock_client:\n        mock_client.configure_mock(\n            **{\n                \"create.return_value\": mock_client,\n                \"events.get_page.side_effect\": ApiException(err_msg)\n            }\n        )\n\n        <line_mask>\n            get_clicked_events()\n            assert err_msg == err.value",
            "masked_line": "with pytest.raises(ApiException) as err:",
            "answer": "raises",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_624"
        },
        {
            "dependency": "mock",
            "version": "==3.7.0",
            "time": "2022-06-25",
            "description": "The given Python code defines two test functions, test_get_clicked_events_success and test_get_clicked_events_fail, that test the functionality of the get_clicked_events function. The test_get_clicked_events_success function mocks the Client class and sets up the expected response from the events.get_page method to return \"fizz\" when the get_clicked_events function is called. It then asserts that the returned events match the expected value.\n\nOn the other hand, the test_get_clicked_events_fail function also mocks the Client class but this time sets up a side effect where the events.get_page method raises an ApiException with the error message \"Failed to get events!\" when the get_clicked_events function is called. It then uses pytest to check if calling get_clicked_events results in raising an ApiException with the expected error message.",
            "code": "from unittest.mock import patch\n\nimport pytest\n\nfrom hubspot import Client\nfrom hubspot.events.exceptions import ApiException\n\nfrom src.get_events import get_clicked_events\n\n\ndef test_get_clicked_events_success():\n    with patch(\"src.get_events.Client\", spec=Client) as mock_client:\n        mock_client.configure_mock(\n            **{\n                \"create.return_value\": mock_client,\n                \"events.get_page.return_value\": \"fizz\"\n            }\n        )\n\n        events = get_clicked_events()\n        assert events == \"fizz\"\n\n\ndef test_get_clicked_events_fail():\n    err_msg = \"Failed to get events!\"\n\n    with patch(\"src.get_events.Client\", spec=Client) as mock_client:\n        mock_client.configure_mock(\n            **{\n                \"create.return_value\": mock_client,\n                \"events.get_page.side_effect\": ApiException(err_msg)\n            }\n        )\n\n        with pytest.raises(ApiException) as err:\n            get_clicked_events()\n            assert err_msg == err.value",
            "masked_code": "from unittest.mock import patch\n\nimport pytest\n\nfrom hubspot import Client\nfrom hubspot.events.exceptions import ApiException\n\nfrom src.get_events import get_clicked_events\n\n\ndef test_get_clicked_events_success():\n    with patch(\"src.get_events.Client\", spec=Client) as mock_client:\n        mock_client.configure_mock(\n            **{\n                \"create.return_value\": mock_client,\n                \"events.get_page.return_value\": \"fizz\"\n            }\n        )\n\n        events = get_clicked_events()\n        assert events == \"fizz\"\n\n\ndef test_get_clicked_events_fail():\n    err_msg = \"Failed to get events!\"\n\n    <line_mask>\n        mock_client.configure_mock(\n            **{\n                \"create.return_value\": mock_client,\n                \"events.get_page.side_effect\": ApiException(err_msg)\n            }\n        )\n\n        with pytest.raises(ApiException) as err:\n            get_clicked_events()\n            assert err_msg == err.value",
            "masked_line": "with patch(\"src.get_events.Client\", spec=Client) as mock_client:",
            "answer": "patch",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_625"
        },
        {
            "dependency": "spacy",
            "version": ">=3.0",
            "time": "2023-04-13",
            "description": "The code converts a spaCy model into a Hugging Face model for token classification, including saving the tokenizer, model configuration, vocabulary, and weights to the specified output directory.",
            "code": "from spacy.lang.en import English\nfrom spacy.pipeline import EntityRecognizer\n\n# Load your saved spaCy model\nimport spacy\nimport os\nimport shutil\n\n# Load your trained spaCy model\nnlp = spacy.load(\"your-spacy-model\")\n\n# Name of your new hf model\noutput_dir = 'hf-model-output-dir'\nos.makedirs(output_dir, exist_ok=True)\n\nfrom transformers import PreTrainedTokenizerFast, RobertaTokenizerFast\n\n# Convert spaCy tokenization to your model's standard tokenization (eg. wordpiece, bpe, etc.)\n\nclass CustomTokenizer(PreTrainedTokenizerFast):\n    def __init__(self, spacy_tokenizer, backend_tokenizer, *args, **kwargs):\n        super().__init__(tokenizer_object=backend_tokenizer, *args, **kwargs)\n        self.spacy_tokenizer = spacy_tokenizer\n        self._backend_tokenizer = backend_tokenizer\n\n    def _tokenize(self, text):\n        return [token.text for token in self.spacy_tokenizer(text)]\n\n    def __getattr__(self, name):\n        return getattr(self._backend_tokenizer, name)\n\n    @property\n    def backend_tokenizer(self):\n        return self._backend_tokenizer\n\n    def save_pretrained(self, save_directory, legacy_format=True, filename_prefix=None, push_to_hub=False, **kwargs):\n        self._backend_tokenizer.save_pretrained(save_directory, legacy_format=legacy_format, filename_prefix=filename_prefix, push_to_hub=push_to_hub, **kwargs)\n\n\n# Instantiate the custom tokenizer with the spaCy tokenizer and a backend tokenizer\n\nspacy_tokenizer = nlp.tokenizer\nbackend_tokenizer = RobertaTokenizerFast.from_pretrained(\"roberta-base\")\ncustom_tokenizer = CustomTokenizer(spacy_tokenizer, backend_tokenizer)\n\n# Save the tokenizer\n\ncustom_tokenizer.save_pretrained(output_dir)\n\n# Save the model weights and configuration files\n#nlp.config.to_disk(os.path.join(output_dir, 'config.json'))\nimport spacy\nfrom transformers import AutoConfig\nimport json\n\n\n# Get the label names from the named entity recognizer component\nner = nlp.get_pipe(\"ner\")\nlabel_names = ner.labels\n\n# Create an AutoConfig object based on the spaCy model ... I finetuned a roberta-base model for NER, in my case ...\nconfig = AutoConfig.from_pretrained('roberta-base', num_labels=len(label_names), id2label={i: label for i, label in enumerate(label_names)}, label2id={label: i for i, label in enumerate(label_names)})\n\n# Save the configuration to disk in the Transformers-compatible format\nconfig_dict = config.to_dict()\nwith open(os.path.join(output_dir, 'config.json'), 'w') as f:\n    json.dump(config_dict, f)\n\nnlp.vocab.to_disk(os.path.join(output_dir, 'vocab.txt'))\nfrom transformers import RobertaForTokenClassification\n\n# Create a Hugging Face model using the configuration object\n\nhf_model = RobertaForTokenClassification.from_pretrained(\"roberta-base\", config=config)\n\n# Get the weights from the spaCy model and set the Hugging Face model weights\nstate_dict = {k.replace(\"roberta.\", \"\"): v for k, v in nlp.get_pipe(\"transformer\").model.transformer.named_parameters()}\nstate_dict[\"embeddings.position_ids\"] = hf_model.roberta.embeddings.position_ids\nstate_dict = {k: v for k, v in state_dict.items() if not k.startswith(\"pooler.\")}\nhf_model.roberta.load_state_dict(state_dict)\n\n# Finally, save the Hugging Face model to disk\n\nhf_model.save_pretrained(output_dir)",
            "masked_code": "from spacy.lang.en import English\nfrom spacy.pipeline import EntityRecognizer\n\n# Load your saved spaCy model\nimport spacy\nimport os\nimport shutil\n\n# Load your trained spaCy model\nnlp = spacy.load(\"your-spacy-model\")\n\n# Name of your new hf model\noutput_dir = 'hf-model-output-dir'\nos.makedirs(output_dir, exist_ok=True)\n\nfrom transformers import PreTrainedTokenizerFast, RobertaTokenizerFast\n\n# Convert spaCy tokenization to your model's standard tokenization (eg. wordpiece, bpe, etc.)\n\nclass CustomTokenizer(PreTrainedTokenizerFast):\n    def __init__(self, spacy_tokenizer, backend_tokenizer, *args, **kwargs):\n        super().__init__(tokenizer_object=backend_tokenizer, *args, **kwargs)\n        self.spacy_tokenizer = spacy_tokenizer\n        self._backend_tokenizer = backend_tokenizer\n\n    def _tokenize(self, text):\n        return [token.text for token in self.spacy_tokenizer(text)]\n\n    def __getattr__(self, name):\n        return getattr(self._backend_tokenizer, name)\n\n    @property\n    def backend_tokenizer(self):\n        return self._backend_tokenizer\n\n    def save_pretrained(self, save_directory, legacy_format=True, filename_prefix=None, push_to_hub=False, **kwargs):\n        self._backend_tokenizer.save_pretrained(save_directory, legacy_format=legacy_format, filename_prefix=filename_prefix, push_to_hub=push_to_hub, **kwargs)\n\n\n# Instantiate the custom tokenizer with the spaCy tokenizer and a backend tokenizer\n\nspacy_tokenizer = nlp.tokenizer\nbackend_tokenizer = RobertaTokenizerFast.from_pretrained(\"roberta-base\")\ncustom_tokenizer = CustomTokenizer(spacy_tokenizer, backend_tokenizer)\n\n# Save the tokenizer\n\ncustom_tokenizer.save_pretrained(output_dir)\n\n# Save the model weights and configuration files\n#nlp.config.to_disk(os.path.join(output_dir, 'config.json'))\nimport spacy\nfrom transformers import AutoConfig\nimport json\n\n\n# Get the label names from the named entity recognizer component\nner = nlp.get_pipe(\"ner\")\nlabel_names = ner.labels\n\n# Create an AutoConfig object based on the spaCy model ... I finetuned a roberta-base model for NER, in my case ...\nconfig = AutoConfig.from_pretrained('roberta-base', num_labels=len(label_names), id2label={i: label for i, label in enumerate(label_names)}, label2id={label: i for i, label in enumerate(label_names)})\n\n# Save the configuration to disk in the Transformers-compatible format\nconfig_dict = config.to_dict()\nwith open(os.path.join(output_dir, 'config.json'), 'w') as f:\n    json.dump(config_dict, f)\n\nnlp.vocab.to_disk(os.path.join(output_dir, 'vocab.txt'))\nfrom transformers import RobertaForTokenClassification\n\n# Create a Hugging Face model using the configuration object\n\nhf_model = RobertaForTokenClassification.from_pretrained(\"roberta-base\", config=config)\n\n# Get the weights from the spaCy model and set the Hugging Face model weights\n<line_mask>\nstate_dict[\"embeddings.position_ids\"] = hf_model.roberta.embeddings.position_ids\nstate_dict = {k: v for k, v in state_dict.items() if not k.startswith(\"pooler.\")}\nhf_model.roberta.load_state_dict(state_dict)\n\n# Finally, save the Hugging Face model to disk\n\nhf_model.save_pretrained(output_dir)",
            "masked_line": "state_dict = {k.replace(\"roberta.\", \"\"): v for k, v in nlp.get_pipe(\"transformer\").model.transformer.named_parameters()}",
            "answer": "transformer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_626"
        },
        {
            "dependency": "numpy",
            "version": "==1.18.1",
            "time": "2022-04-29",
            "description": "The code calculates the angle (in radians) of a complex number 0+0j and checks if it is equal to 0.",
            "code": "import numpy as np\nassert np.angle(0+0j) == 0",
            "masked_code": "import numpy as np\n<line_mask>",
            "masked_line": "assert np.angle(0+0j) == 0",
            "answer": "angle",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_627"
        },
        {
            "dependency": "selenium",
            "version": "==4.x",
            "time": "2022-03-16",
            "description": "The code opens a Chrome web browser using Selenium, navigates to the website \"https://uplearn.co.uk/login\", waits for a button with class containing 'Login_SubmitButton' to become clickable using CSS_SELECTOR, and then clicks on it. It also waits for a button with the text 'Login' to become clickable using XPATH, and then clicks on it.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support import expected_conditions as EC\n\ns = Service('C:\\\\Program Files (x86)\\\\chromedriver.exe')\ndriver = webdriver.Chrome(service=s)\ndriver.get('https://uplearn.co.uk/login')\n# using CSS_SELECTOR\nWebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.CSS_SELECTOR, \"button[class*='Login_SubmitButton']\"))).click()\n# using XPATH\nWebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.XPATH, \"//button[text()='Login']\"))).click()",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n<line_mask>\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support import expected_conditions as EC\n\ns = Service('C:\\\\Program Files (x86)\\\\chromedriver.exe')\ndriver = webdriver.Chrome(service=s)\ndriver.get('https://uplearn.co.uk/login')\n# using CSS_SELECTOR\nWebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.CSS_SELECTOR, \"button[class*='Login_SubmitButton']\"))).click()\n# using XPATH\nWebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.XPATH, \"//button[text()='Login']\"))).click()",
            "masked_line": "from selenium.webdriver.chrome.service import Service",
            "answer": "Service",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_628"
        },
        {
            "dependency": "selenium",
            "version": "==4.6.0",
            "time": "2023-06-13",
            "description": "The code opens a Chrome browser using Selenium, navigates to the Google homepage, and then closes the browser.",
            "code": "from selenium import webdriver\n\ndriver = webdriver.Chrome()\ndriver.get(\"https://www.google.com/\")\ndriver.quit()",
            "masked_code": "from selenium import webdriver\n\n<line_mask>\ndriver.get(\"https://www.google.com/\")\ndriver.quit()",
            "masked_line": "driver = webdriver.Chrome()",
            "answer": "Chrome",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_629"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.1",
            "time": "2023-11-09",
            "description": "The code takes a dataframe as input where each row contains a text data. It uses a pretrained sentiment analysis model to classify the sentiment of each text in the dataframe. It assigns a sentiment prediction to each row in the dataframe and returns the dataframe with an additional \"prediction\" column indicating the sentiment of each text.",
            "code": "from transformers import AutoTokenizer, AutoModelForSequenceClassification\nimport torch as t\nimport pandas as pd\n        \nmodel = AutoModelForSequenceClassification.from_pretrained(\"finiteautomata/beto-sentiment-analysis\")\ntokenizer = AutoTokenizer.from_pretrained(\"finiteautomata/beto-sentiment-analysis\")\n            \ndef classify_dataframe_row(\n    example: pd.Series,\n):\n    output = model(**tokenizer(example[\"text\"], return_tensors=\"pt\"))\n    prediction = t.argmax(output[0]).detach().numpy()\n    return prediction\n\ndataset = pd.read_csv(\"file\")\ndataset = dataset.assign(\n    prediction=dataset.progress_apply(classify_dataframe_row, axis=1)\n)",
            "masked_code": "from transformers import AutoTokenizer, AutoModelForSequenceClassification\nimport torch as t\nimport pandas as pd\n        \nmodel = AutoModelForSequenceClassification.from_pretrained(\"finiteautomata/beto-sentiment-analysis\")\ntokenizer = AutoTokenizer.from_pretrained(\"finiteautomata/beto-sentiment-analysis\")\n            \ndef classify_dataframe_row(\n    example: pd.Series,\n):\n    <line_mask>\n    prediction = t.argmax(output[0]).detach().numpy()\n    return prediction\n\ndataset = pd.read_csv(\"file\")\ndataset = dataset.assign(\n    prediction=dataset.progress_apply(classify_dataframe_row, axis=1)\n)",
            "masked_line": "output = model(**tokenizer(example[\"text\"], return_tensors=\"pt\"))",
            "answer": "tokenizer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_630"
        },
        {
            "dependency": "pytest",
            "version": "==7.2.0",
            "time": "2023-01-11",
            "description": "This code defines a test_param function that uses the pytest framework to run parameterized tests with the parameters 'my param' and 'my param 2'. Inside the function, it prints the value of the environment variable \"PYTEST_CURRENT_TEST\".",
            "code": "import pytest\nimport os\n\n@pytest.mark.parametrize('param', ['my param', 'my param 2'])\ndef test_param(param):\n    print (os.environ[\"PYTEST_CURRENT_TEST\"])",
            "masked_code": "import pytest\nimport os\n\n<line_mask>\ndef test_param(param):\n    print (os.environ[\"PYTEST_CURRENT_TEST\"])",
            "masked_line": "@pytest.mark.parametrize('param', ['my param', 'my param 2'])",
            "answer": "parametrize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_631"
        },
        {
            "dependency": "selenium",
            "version": ">=4.6",
            "time": "2023-07-09",
            "description": "The Python code initializes a Firefox WebDriver with specific options for binary location and opens a Firefox browser for web automation tasks.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver import FirefoxOptions\n\noptions = FirefoxOptions()\noptions.binary_location = '\\path\\to\\firefox'\ndriver = webdriver.Firefox(options = options)",
            "masked_code": "from selenium import webdriver\n<line_mask>\n\noptions = FirefoxOptions()\noptions.binary_location = '\\path\\to\\firefox'\ndriver = webdriver.Firefox(options = options)",
            "masked_line": "from selenium.webdriver import FirefoxOptions",
            "answer": "FirefoxOptions",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_632"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.2",
            "time": "2023-04-08",
            "description": "The code initializes TrainingArguments object with a specified directory path and sets the device attribute to CPU.",
            "code": "import torch\nfrom transformers import TrainingArguments\n\nargs = TrainingArguments('./')\n\nargs.device  # [out]: device(type='cpu')\n\nargs.device = torch.device(type='cpu')",
            "masked_code": "import torch\n<line_mask>\n\nargs = TrainingArguments('./')\n\nargs.device  # [out]: device(type='cpu')\n\nargs.device = torch.device(type='cpu')",
            "masked_line": "from transformers import TrainingArguments",
            "answer": "TrainingArguments",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_633"
        },
        {
            "dependency": "numpy",
            "version": "==1.26.0",
            "time": "2023-11-09",
            "description": "The code returns the index of the maximum value in a set or dictionary values.",
            "code": "np.argmax({1,2,3})\n0\n\nnp.argmax(d.values())\n0",
            "masked_code": "np.argmax({1,2,3})\n0\n\n<line_mask>\n0",
            "masked_line": "np.argmax(d.values())",
            "answer": "argmax",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_634"
        },
        {
            "dependency": "Flask",
            "version": "==2.2.2",
            "time": "2023-03-08",
            "description": "This code is a Python program that creates a Flask server to implement a Spotify OAuth2 authorization flow. It defines routes for the root (\"/\"), login (\"/login\"), and callback (\"/callback\") endpoints. The callback endpoint handles the Spotify authorization code flow to allow the server to access the currently playing song of the authenticated user.",
            "code": "from flask import Flask, request, redirect\nfrom requests_oauthlib import OAuth2Session\nfrom requests.auth import HTTPBasicAuth\nimport requests\nimport os\n\napp = Flask(__name__)\ntry:\n    AUTH_URL=os.getenv(\"AUTH_URL\")\n    TOKEN_URL=os.getenv(\"TOKEN_URL\")\n    REDIRECT_URI=os.getenv(\"REDIRECT_URI\")\n    CLIENT_ID=os.getenv(\"CLIENT_ID\")\n    CLIENT_SECRET=os.getenv(\"CLIENT_SECRET\")\n    SCOPE=['user-read-currently-playing']\n    # The checking environment variable is set\n    print(AUTH_URL)\n    print(TOKEN_URL)\nexcept KeyError: \n   print ('Please set the environment variable for Spotify')\n\ndef get_headers(token):\n    return {\"Authorization\": \"Bearer \" + token}\n\n@app.route(\"/\")\ndef root_message():\n    app.logger.info('hello! root accessed')\n    return 'I am a spotify server'\n\n@app.route(\"/login\")\ndef login():\n    app.logger.info('login logged in successfully')\n    spotify = OAuth2Session(CLIENT_ID, scope=SCOPE, redirect_uri=REDIRECT_URI)\n    authorization_url, state = spotify.authorization_url(AUTH_URL)\n    return redirect(authorization_url)\n\n# Your redirect URI's path\n# http://localhost:3000/callback?code=AQDTZDK66wl...se8A1YTe&state=kt4H....963Nd\n@app.route(\"/callback\", methods=['GET'])\ndef callback():\n    # get access token\n    code = request.args.get('code')\n    resp = requests.post(TOKEN_URL,\n        auth=HTTPBasicAuth(CLIENT_ID, CLIENT_SECRET),\n        data={\n            'grant_type': 'authorization_code',\n            'code': code,\n            'redirect_uri': REDIRECT_URI\n        })\n    access_token = resp.json()['access_token']\n\n    # get current playing\n    headers = get_headers(access_token)\n    result1 = requests.get(url='https://api.spotify.com/v1/me/player/currently-playing', headers=headers)\n    current_song = result1.json()\n    return current_song\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3000,debug=True) # your redirect URI's port",
            "masked_code": "from flask import Flask, request, redirect\nfrom requests_oauthlib import OAuth2Session\nfrom requests.auth import HTTPBasicAuth\nimport requests\nimport os\n\napp = Flask(__name__)\ntry:\n    AUTH_URL=os.getenv(\"AUTH_URL\")\n    TOKEN_URL=os.getenv(\"TOKEN_URL\")\n    REDIRECT_URI=os.getenv(\"REDIRECT_URI\")\n    CLIENT_ID=os.getenv(\"CLIENT_ID\")\n    CLIENT_SECRET=os.getenv(\"CLIENT_SECRET\")\n    SCOPE=['user-read-currently-playing']\n    # The checking environment variable is set\n    print(AUTH_URL)\n    print(TOKEN_URL)\nexcept KeyError: \n   print ('Please set the environment variable for Spotify')\n\ndef get_headers(token):\n    return {\"Authorization\": \"Bearer \" + token}\n\n@app.route(\"/\")\ndef root_message():\n    <line_mask>\n    return 'I am a spotify server'\n\n@app.route(\"/login\")\ndef login():\n    app.logger.info('login logged in successfully')\n    spotify = OAuth2Session(CLIENT_ID, scope=SCOPE, redirect_uri=REDIRECT_URI)\n    authorization_url, state = spotify.authorization_url(AUTH_URL)\n    return redirect(authorization_url)\n\n# Your redirect URI's path\n# http://localhost:3000/callback?code=AQDTZDK66wl...se8A1YTe&state=kt4H....963Nd\n@app.route(\"/callback\", methods=['GET'])\ndef callback():\n    # get access token\n    code = request.args.get('code')\n    resp = requests.post(TOKEN_URL,\n        auth=HTTPBasicAuth(CLIENT_ID, CLIENT_SECRET),\n        data={\n            'grant_type': 'authorization_code',\n            'code': code,\n            'redirect_uri': REDIRECT_URI\n        })\n    access_token = resp.json()['access_token']\n\n    # get current playing\n    headers = get_headers(access_token)\n    result1 = requests.get(url='https://api.spotify.com/v1/me/player/currently-playing', headers=headers)\n    current_song = result1.json()\n    return current_song\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3000,debug=True) # your redirect URI's port",
            "masked_line": "app.logger.info('hello! root accessed')",
            "answer": "info",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_635"
        },
        {
            "dependency": "requests",
            "version": "==2.28.1",
            "time": "2023-03-08",
            "description": "This code sets up a Flask server that acts as a Spotify client. It allows users to login with their Spotify account, obtain authorization, and access information about the currently playing song through the Spotify API.",
            "code": "from flask import Flask, request, redirect\nfrom requests_oauthlib import OAuth2Session\nfrom requests.auth import HTTPBasicAuth\nimport requests\nimport os\n\napp = Flask(__name__)\ntry:\n    AUTH_URL=os.getenv(\"AUTH_URL\")\n    TOKEN_URL=os.getenv(\"TOKEN_URL\")\n    REDIRECT_URI=os.getenv(\"REDIRECT_URI\")\n    CLIENT_ID=os.getenv(\"CLIENT_ID\")\n    CLIENT_SECRET=os.getenv(\"CLIENT_SECRET\")\n    SCOPE=['user-read-currently-playing']\n    # The checking environment variable is set\n    print(AUTH_URL)\n    print(TOKEN_URL)\nexcept KeyError: \n   print ('Please set the environment variable for Spotify')\n\ndef get_headers(token):\n    return {\"Authorization\": \"Bearer \" + token}\n\n@app.route(\"/\")\ndef root_message():\n    app.logger.info('hello! root accessed')\n    return 'I am a spotify server'\n\n@app.route(\"/login\")\ndef login():\n    app.logger.info('login logged in successfully')\n    spotify = OAuth2Session(CLIENT_ID, scope=SCOPE, redirect_uri=REDIRECT_URI)\n    authorization_url, state = spotify.authorization_url(AUTH_URL)\n    return redirect(authorization_url)\n\n# Your redirect URI's path\n# http://localhost:3000/callback?code=AQDTZDK66wl...se8A1YTe&state=kt4H....963Nd\n@app.route(\"/callback\", methods=['GET'])\ndef callback():\n    # get access token\n    code = request.args.get('code')\n    resp = requests.post(TOKEN_URL,\n        auth=HTTPBasicAuth(CLIENT_ID, CLIENT_SECRET),\n        data={\n            'grant_type': 'authorization_code',\n            'code': code,\n            'redirect_uri': REDIRECT_URI\n        })\n    access_token = resp.json()['access_token']\n\n    # get current playing\n    headers = get_headers(access_token)\n    result1 = requests.get(url='https://api.spotify.com/v1/me/player/currently-playing', headers=headers)\n    current_song = result1.json()\n    return current_song\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3000,debug=True) # your redirect URI's port",
            "masked_code": "from flask import Flask, request, redirect\nfrom requests_oauthlib import OAuth2Session\nfrom requests.auth import HTTPBasicAuth\nimport requests\nimport os\n\napp = Flask(__name__)\ntry:\n    AUTH_URL=os.getenv(\"AUTH_URL\")\n    TOKEN_URL=os.getenv(\"TOKEN_URL\")\n    REDIRECT_URI=os.getenv(\"REDIRECT_URI\")\n    CLIENT_ID=os.getenv(\"CLIENT_ID\")\n    CLIENT_SECRET=os.getenv(\"CLIENT_SECRET\")\n    SCOPE=['user-read-currently-playing']\n    # The checking environment variable is set\n    print(AUTH_URL)\n    print(TOKEN_URL)\nexcept KeyError: \n   print ('Please set the environment variable for Spotify')\n\ndef get_headers(token):\n    return {\"Authorization\": \"Bearer \" + token}\n\n@app.route(\"/\")\ndef root_message():\n    app.logger.info('hello! root accessed')\n    return 'I am a spotify server'\n\n@app.route(\"/login\")\ndef login():\n    app.logger.info('login logged in successfully')\n    spotify = OAuth2Session(CLIENT_ID, scope=SCOPE, redirect_uri=REDIRECT_URI)\n    authorization_url, state = spotify.authorization_url(AUTH_URL)\n    return redirect(authorization_url)\n\n# Your redirect URI's path\n# http://localhost:3000/callback?code=AQDTZDK66wl...se8A1YTe&state=kt4H....963Nd\n@app.route(\"/callback\", methods=['GET'])\ndef callback():\n    # get access token\n    code = request.args.get('code')\n    resp = requests.post(TOKEN_URL,\n        auth=HTTPBasicAuth(CLIENT_ID, CLIENT_SECRET),\n        data={\n            'grant_type': 'authorization_code',\n            'code': code,\n            'redirect_uri': REDIRECT_URI\n        })\n    access_token = resp.json()['access_token']\n\n    # get current playing\n    headers = get_headers(access_token)\n    result1 = requests.get(url='https://api.spotify.com/v1/me/player/currently-playing', headers=headers)\n    <line_mask>\n    return current_song\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3000,debug=True) # your redirect URI's port",
            "masked_line": "current_song = result1.json()",
            "answer": "json",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_636"
        },
        {
            "dependency": "pandas",
            "version": "==2.0",
            "time": "2023-05-02",
            "description": "This code reads a CSV file using the PyArrow engine in Pandas, with the data types specified also using PyArrow.",
            "code": "import pandas\n\npandas.read_csv(fname, engine='pyarrow', dtype_backend='pyarrow')",
            "masked_code": "import pandas\n\n<line_mask>",
            "masked_line": "pandas.read_csv(fname, engine='pyarrow', dtype_backend='pyarrow')",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_637"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.0",
            "time": "2023-07-19",
            "description": "This code extracts specific information from lines in a file related to a certain type, applies literal evaluation to the extracted type, and then normalizes the extracted dictionary data into a DataFrame.",
            "code": "import pandas as pd\nimport ast\n\nregex = r'^(?P.*) INFO    Type:type: (?P.*), (?P\\{.*\\})$'\n\nwith open(infile) as f:\n    lines = [line for line in f if \"type\" in line]\n\ndf = pd.Series(lines).str.extract(regex)\ndf['type'] = df['type'].apply(ast.literal_eval).str[0]\n# Uses pop!\ndf = df.join(df.pop('dict').apply(ast.literal_eval).pipe(pd.json_normalize))",
            "masked_code": "import pandas as pd\nimport ast\n\nregex = r'^(?P.*) INFO    Type:type: (?P.*), (?P\\{.*\\})$'\n\nwith open(infile) as f:\n    lines = [line for line in f if \"type\" in line]\n\ndf = pd.Series(lines).str.extract(regex)\ndf['type'] = df['type'].apply(ast.literal_eval).str[0]\n# Uses pop!\n<line_mask>",
            "masked_line": "df = df.join(df.pop('dict').apply(ast.literal_eval).pipe(pd.json_normalize))",
            "answer": "join",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_638"
        },
        {
            "dependency": "geopandas",
            "version": "==0.13.2",
            "time": "2023-06-25",
            "description": "The code reads a shapefile of countries from a specified URL using fsspec and geopandas, and stores it as a GeoDataFrame named gdf.",
            "code": "import fsspec\n\nurl = \"https://www.naturalearthdata.com/http//www.naturalearthdata.com/\" \\\n      \"download/110m/cultural/ne_110m_admin_0_countries.zip\"\n    \nwith fsspec.open(f\"simplecache::{url}\") as file:\n    gdf = gpd.read_file(file)",
            "masked_code": "import fsspec\n\nurl = \"https://www.naturalearthdata.com/http//www.naturalearthdata.com/\" \\\n      \"download/110m/cultural/ne_110m_admin_0_countries.zip\"\n    \nwith fsspec.open(f\"simplecache::{url}\") as file:\n    <line_mask>",
            "masked_line": "gdf = gpd.read_file(file)",
            "answer": "read_file",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_639"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2023-09-20",
            "description": "This code creates a Pandas DataFrame with two columns \"a\" and \"b\" containing consecutive numbers from 1 to 999999 and 2 to 1000000 respectively. It then saves this DataFrame to a CSV file named \"irrelevant.csv\" and appends the same DataFrame to a file named \"test.csv\" in append mode.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({\n    \"a\": range(1, 1000000),\n    \"b\": range(2, 1000001),\n})\nprint(df)\n# This causes the pandas CSV library to be loaded\ndf.to_csv(\"irrelevant.csv\")\n\ndump = \"test.csv\"\nprint(\"appending\")\ndf.to_csv(dump, mode=\"a+\")",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame({\n    \"a\": range(1, 1000000),\n    \"b\": range(2, 1000001),\n})\nprint(df)\n# This causes the pandas CSV library to be loaded\n<line_mask>\n\ndump = \"test.csv\"\nprint(\"appending\")\ndf.to_csv(dump, mode=\"a+\")",
            "masked_line": "df.to_csv(\"irrelevant.csv\")",
            "answer": "to_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_640"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==2.0.16",
            "time": "2023-09-20",
            "description": "This code connects to a database engine using SQLAlchemy, executes a SQL query defined in `q1`, stores the results in a dataframe using Pandas, and there is a commented-out line of code for committing changes to the database which is not necessary in this context.",
            "code": "# sqlalchemy==2.0.16\n# pandas==2.0.2\nfrom sqlalchemy.sql import text\n\nwith Session(engine) as session:\n    results = session.execute(text(q1))\n    df = pd.DataFrame(results)\n    # session.commit()  # commit is irrelevant if you don't write data",
            "masked_code": "# sqlalchemy==2.0.16\n# pandas==2.0.2\nfrom sqlalchemy.sql import text\n\nwith Session(engine) as session:\n    <line_mask>\n    df = pd.DataFrame(results)\n    # session.commit()  # commit is irrelevant if you don't write data",
            "masked_line": "results = session.execute(text(q1))",
            "answer": "text",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_641"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.2",
            "time": "2023-09-20",
            "description": "The code conducts a query (q1) using SQLAlchemy to retrieve data from a database through a session with the engine. The results are then converted into a DataFrame using pandas. The code contains a commented out line for committing changes, which is unnecessary for this specific operation since no data is being written.",
            "code": "# sqlalchemy==2.0.16\n# pandas==2.0.2\nfrom sqlalchemy.sql import text\n\nwith Session(engine) as session:\n    results = session.execute(text(q1))\n    df = pd.DataFrame(results)\n    # session.commit()  # commit is irrelevant if you don't write data",
            "masked_code": "# sqlalchemy==2.0.16\n# pandas==2.0.2\nfrom sqlalchemy.sql import text\n\nwith Session(engine) as session:\n    results = session.execute(text(q1))\n    <line_mask>\n    # session.commit()  # commit is irrelevant if you don't write data",
            "masked_line": "df = pd.DataFrame(results)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_642"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.2",
            "time": "2023-08-18",
            "description": "This code generates a 3D plot using matplotlib with data points specified in the lists xs, ys, and zs. The plot is colored blue and axis labels are added for X, Y, and Z dimensions. Mouse zoom functionality is disabled for the plot.",
            "code": "import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Making data\nxs = [1,2,3,4,5,6]\nys = [10,20,30,40,50,60]\nzs = [15,25,35,45,55,65]\n\n# Creating the 3D plot\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\n# Plotting data\nax.plot(xs, ys, zs, color='blue')\n\n# Disabling mouse zoom by setting it to none\nax.mouse_init(zoom_btn=None)\n\n# Labeling axis\nax.set_xlabel(\"X\", color=\"red\")\nax.set_ylabel(\"Y\", color=\"green\")\nax.set_zlabel(\"Z\", color=\"blue\")\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Making data\nxs = [1,2,3,4,5,6]\nys = [10,20,30,40,50,60]\nzs = [15,25,35,45,55,65]\n\n# Creating the 3D plot\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\n# Plotting data\nax.plot(xs, ys, zs, color='blue')\n\n# Disabling mouse zoom by setting it to none\nax.mouse_init(zoom_btn=None)\n\n# Labeling axis\nax.set_xlabel(\"X\", color=\"red\")\n<line_mask>\nax.set_zlabel(\"Z\", color=\"blue\")\n\nplt.show()",
            "masked_line": "ax.set_ylabel(\"Y\", color=\"green\")",
            "answer": "set_ylabel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_643"
        },
        {
            "dependency": "open3d",
            "version": "==0.18.0",
            "time": "2023-12-15",
            "description": "The code generates a random point cloud with 30,000 points in 3D space, assigns random colors to each point, and visualizes the point cloud using Open3D library.",
            "code": "import numpy as np\nimport open3d as o3d\n\npoints = np.random.rand(30000, 3) * [1,2,3]\ncolors = np.random.rand(30000, 3)\npcd = o3d.geometry.PointCloud()\npcd.points = o3d.utility.Vector3dVector(points)\npcd.colors = o3d.utility.Vector3dVector(colors)\n\n\nvisualizer = o3d.visualization.Visualizer()\nvisualizer.create_window()\nvisualizer.add_geometry(pcd)\nview_ctl = visualizer.get_view_control()\nview_ctl.camera_local_translate(forward=0, right=0.5, up=0)\nvisualizer.update_renderer()\nvisualizer.run()",
            "masked_code": "import numpy as np\nimport open3d as o3d\n\npoints = np.random.rand(30000, 3) * [1,2,3]\ncolors = np.random.rand(30000, 3)\npcd = o3d.geometry.PointCloud()\npcd.points = o3d.utility.Vector3dVector(points)\npcd.colors = o3d.utility.Vector3dVector(colors)\n\n\nvisualizer = o3d.visualization.Visualizer()\nvisualizer.create_window()\n<line_mask>\nview_ctl = visualizer.get_view_control()\nview_ctl.camera_local_translate(forward=0, right=0.5, up=0)\nvisualizer.update_renderer()\nvisualizer.run()",
            "masked_line": "visualizer.add_geometry(pcd)",
            "answer": "add_geometry",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_644"
        },
        {
            "dependency": "selenium",
            "version": "==4.12",
            "time": "2023-09-21",
            "description": "This code initializes a headless Firefox browser using Selenium, allowing for automated browsing tasks without displaying the browser interface.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.firefox.service import Service as FirefoxService\nfrom subprocess import CREATE_NO_WINDOW\noptions = webdriver.FirefoxOptions()\noptions.add_argument(\"--headless\")\n\nservice = FirefoxService(log_output=os.devnull)\nservice.creation_flags = CREATE_NO_WINDOW\ndriver = webdriver.Firefox(service=service, options=options)",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.firefox.service import Service as FirefoxService\nfrom subprocess import CREATE_NO_WINDOW\noptions = webdriver.FirefoxOptions()\noptions.add_argument(\"--headless\")\n\nservice = FirefoxService(log_output=os.devnull)\nservice.creation_flags = CREATE_NO_WINDOW\n<line_mask>",
            "masked_line": "driver = webdriver.Firefox(service=service, options=options)",
            "answer": "Firefox",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_645"
        },
        {
            "dependency": "graphene",
            "version": "==2.1.9",
            "time": "2023-11-30",
            "description": "This Python code defines a class `MutationWithAuth` that inherits from `Mutation`. It includes a class attribute `decorators` that holds a list of decorators, such as `login_required`.\n\nThe `Field` method within the class dynamically generates a `Field` object for the mutation. It applies the decorators listed in the `decorators` attribute to the resolver function of the mutation.\n\nOverall, this code aims to add authentication functionality to mutations in a GraphQL schema by applying decorators to the resolver function.",
            "code": "from graphene import Mutation, Field\n\n\nclass MutationWithAuth(Mutation):\n    class Meta:\n        abstract = True\n\n    # App-wide decorators for all mutations\n    decorators = [login_required]  # <-- list your desired decorators here\n\n    @classmethod\n    def Field(cls, name=None, description=None, deprecation_reason=None, required=False):\n        resolver = cls._meta.resolver\n        for decorator in cls.decorators:\n            resolver = decorator(cls._meta.resolver)  # <-- here we apply them\n\n        return Field(\n            cls._meta.output,\n            args=cls._meta.arguments,\n            resolver=resolver,\n            name=name,\n            description=description or cls._meta.description,\n            deprecation_reason=deprecation_reason,\n            required=required,\n        )",
            "masked_code": "<line_mask>\n\n\nclass MutationWithAuth(Mutation):\n    class Meta:\n        abstract = True\n\n    # App-wide decorators for all mutations\n    decorators = [login_required]  # <-- list your desired decorators here\n\n    @classmethod\n    def Field(cls, name=None, description=None, deprecation_reason=None, required=False):\n        resolver = cls._meta.resolver\n        for decorator in cls.decorators:\n            resolver = decorator(cls._meta.resolver)  # <-- here we apply them\n\n        return Field(\n            cls._meta.output,\n            args=cls._meta.arguments,\n            resolver=resolver,\n            name=name,\n            description=description or cls._meta.description,\n            deprecation_reason=deprecation_reason,\n            required=required,\n        )",
            "masked_line": "from graphene import Mutation, Field",
            "answer": "Field",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_646"
        },
        {
            "dependency": "tokenizers",
            "version": "==0.10.0",
            "time": "2023-02-21",
            "description": "The code loads the datasets 'wiki_split' for training, testing, and validation. It then defines an iterator function to extract and yield complex sentences from the datasets. After that, it sets up a BPE tokenizer with special tokens and trains it using the iterator function. Finally, it encodes a given input text using the trained tokenizer and prints the tokens.",
            "code": "# Load the datasets\nfrom datasets import load_dataset\ntrain_dataset = load_dataset('wiki_split', split='train')\ntest_dataset = load_dataset('wiki_split', split='test')\nval_dataset = load_dataset('wiki_split', split='validation')\n\n# Iterator using the text form complex_sentence\ndef iterator_wiki(train_dataset, test_dataset, val_dataset):\n  for mydataset in [train_dataset, test_dataset, val_dataset]:\n    for i, data in enumerate(mydataset):\n      if isinstance(data.get(\"complex_sentence\", None), str):\n        yield data[\"complex_sentence\"]\n \nfrom tokenizers.trainers import BpeTrainer\ntokenizer = Tokenizer(BPE())\n\nfrom tokenizers.pre_tokenizers import Whitespace\ntokenizer.pre_tokenizer = Whitespace()\n\ntrainer = BpeTrainer(special_tokens=[\"[UNK]\", \"[CLS]\", \"[SEP]\", \"[PAD]\", \"[MASK]\"])\ntokenizer.train_from_iterator(iterator_wiki(\n    train_dataset, test_dataset, val_dataset), trainer=trainer)\n\noutput = tokenizer.encode(\"Hello, y'all! How are you  ?\")\nprint(output.tokens)",
            "masked_code": "# Load the datasets\nfrom datasets import load_dataset\ntrain_dataset = load_dataset('wiki_split', split='train')\ntest_dataset = load_dataset('wiki_split', split='test')\nval_dataset = load_dataset('wiki_split', split='validation')\n\n# Iterator using the text form complex_sentence\ndef iterator_wiki(train_dataset, test_dataset, val_dataset):\n  for mydataset in [train_dataset, test_dataset, val_dataset]:\n    for i, data in enumerate(mydataset):\n      if isinstance(data.get(\"complex_sentence\", None), str):\n        yield data[\"complex_sentence\"]\n \nfrom tokenizers.trainers import BpeTrainer\ntokenizer = Tokenizer(BPE())\n\n<line_mask>\ntokenizer.pre_tokenizer = Whitespace()\n\ntrainer = BpeTrainer(special_tokens=[\"[UNK]\", \"[CLS]\", \"[SEP]\", \"[PAD]\", \"[MASK]\"])\ntokenizer.train_from_iterator(iterator_wiki(\n    train_dataset, test_dataset, val_dataset), trainer=trainer)\n\noutput = tokenizer.encode(\"Hello, y'all! How are you  ?\")\nprint(output.tokens)",
            "masked_line": "from tokenizers.pre_tokenizers import Whitespace",
            "answer": "Whitespace",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_647"
        },
        {
            "dependency": "coremltools",
            "version": "==3.2",
            "time": "2023-07-01",
            "description": "Converts an ONNX model to a CoreML model.",
            "code": "import coremltools as ct\nct.converters.onnx.convert(your_onnx_model)",
            "masked_code": "import coremltools as ct\n<line_mask>",
            "masked_line": "ct.converters.onnx.convert(your_onnx_model)",
            "answer": "convert",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_648"
        },
        {
            "dependency": "oracledb",
            "version": "==1.3.1",
            "time": "2023-06-14",
            "description": "This code connects to an Oracle database using the provided credentials, prompts the user to input a table name and cursor size, executes a SQL query to select all data from the specified table, fetches the results, loads them into a pandas DataFrame, and then prints the prefetchrows, arraysize, number of rows retrieved, and the time taken to fetch the data.",
            "code": "import os\nimport time\nimport pandas as pd\nimport sqlalchemy as sql\nimport oracledb as oracledb\n\n# Database Credentials\nusername = os.environ.get(\"PYTHON_USERNAME\")\npassword = os.environ.get(\"PYTHON_PASSWORD\")\n\ncp = oracledb.ConnectParams()\ncp.parse_connect_string(os.environ.get(\"PYTHON_CONNECTSTRING\"))\n\neng = sql.create_engine(f'oracle+oracledb://{username}:{password}@{cp.host}:{cp.port}/?service_name={cp.service_name}')\ntablename = input(\"enter table name: \")\ncursorsize = input(\"enter cursor size: \")\nsqlStatement = 'select * from {}'.format(tablename)\nconn = eng.pool._creator()\nstart = time.time()\nwith conn.cursor() as cursor:\n    cursor.arraysize = int(cursorsize)\n    cursor.execute(sqlStatement)\n    res = cursor.fetchall()\n    #loading the result list in pandas Dataframe\n    df = pd.DataFrame(res, columns = ['description','done'])\n    elapsed = (time.time() - start)\n    print(\"Prefetchrows:\", cursor.prefetchrows, \"Arraysize:\", cursor.arraysize)\n    print(\"Retrieved\", len(res), \"rows in\", elapsed, \"seconds\")",
            "masked_code": "import os\nimport time\nimport pandas as pd\nimport sqlalchemy as sql\nimport oracledb as oracledb\n\n# Database Credentials\nusername = os.environ.get(\"PYTHON_USERNAME\")\npassword = os.environ.get(\"PYTHON_PASSWORD\")\n\ncp = oracledb.ConnectParams()\n<line_mask>\n\neng = sql.create_engine(f'oracle+oracledb://{username}:{password}@{cp.host}:{cp.port}/?service_name={cp.service_name}')\ntablename = input(\"enter table name: \")\ncursorsize = input(\"enter cursor size: \")\nsqlStatement = 'select * from {}'.format(tablename)\nconn = eng.pool._creator()\nstart = time.time()\nwith conn.cursor() as cursor:\n    cursor.arraysize = int(cursorsize)\n    cursor.execute(sqlStatement)\n    res = cursor.fetchall()\n    #loading the result list in pandas Dataframe\n    df = pd.DataFrame(res, columns = ['description','done'])\n    elapsed = (time.time() - start)\n    print(\"Prefetchrows:\", cursor.prefetchrows, \"Arraysize:\", cursor.arraysize)\n    print(\"Retrieved\", len(res), \"rows in\", elapsed, \"seconds\")",
            "masked_line": "cp.parse_connect_string(os.environ.get(\"PYTHON_CONNECTSTRING\"))",
            "answer": "parse_connect_string",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_649"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2023-06-14",
            "description": "This code connects to an Oracle database using the provided credentials, prompts the user to enter a table name and cursor size, executes a SQL query to select all records from the specified table, fetches the results, loads them into a pandas DataFrame, and calculates the time taken to retrieve the data. It then prints the prefetch rows, array size, number of rows retrieved, and the time taken to retrieve the rows.",
            "code": "import os\nimport time\nimport pandas as pd\nimport sqlalchemy as sql\nimport oracledb as oracledb\n\n# Database Credentials\nusername = os.environ.get(\"PYTHON_USERNAME\")\npassword = os.environ.get(\"PYTHON_PASSWORD\")\n\ncp = oracledb.ConnectParams()\ncp.parse_connect_string(os.environ.get(\"PYTHON_CONNECTSTRING\"))\n\neng = sql.create_engine(f'oracle+oracledb://{username}:{password}@{cp.host}:{cp.port}/?service_name={cp.service_name}')\ntablename = input(\"enter table name: \")\ncursorsize = input(\"enter cursor size: \")\nsqlStatement = 'select * from {}'.format(tablename)\nconn = eng.pool._creator()\nstart = time.time()\nwith conn.cursor() as cursor:\n    cursor.arraysize = int(cursorsize)\n    cursor.execute(sqlStatement)\n    res = cursor.fetchall()\n    #loading the result list in pandas Dataframe\n    df = pd.DataFrame(res, columns = ['description','done'])\n    elapsed = (time.time() - start)\n    print(\"Prefetchrows:\", cursor.prefetchrows, \"Arraysize:\", cursor.arraysize)\n    print(\"Retrieved\", len(res), \"rows in\", elapsed, \"seconds\")",
            "masked_code": "import os\nimport time\nimport pandas as pd\nimport sqlalchemy as sql\nimport oracledb as oracledb\n\n# Database Credentials\nusername = os.environ.get(\"PYTHON_USERNAME\")\npassword = os.environ.get(\"PYTHON_PASSWORD\")\n\ncp = oracledb.ConnectParams()\ncp.parse_connect_string(os.environ.get(\"PYTHON_CONNECTSTRING\"))\n\neng = sql.create_engine(f'oracle+oracledb://{username}:{password}@{cp.host}:{cp.port}/?service_name={cp.service_name}')\ntablename = input(\"enter table name: \")\ncursorsize = input(\"enter cursor size: \")\nsqlStatement = 'select * from {}'.format(tablename)\nconn = eng.pool._creator()\nstart = time.time()\nwith conn.cursor() as cursor:\n    cursor.arraysize = int(cursorsize)\n    cursor.execute(sqlStatement)\n    res = cursor.fetchall()\n    #loading the result list in pandas Dataframe\n    <line_mask>\n    elapsed = (time.time() - start)\n    print(\"Prefetchrows:\", cursor.prefetchrows, \"Arraysize:\", cursor.arraysize)\n    print(\"Retrieved\", len(res), \"rows in\", elapsed, \"seconds\")",
            "masked_line": "df = pd.DataFrame(res, columns = ['description','done'])",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_650"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==2.0.5",
            "time": "2023-06-14",
            "description": "This code connects to an Oracle database using the provided credentials, prompts the user to enter a table name and cursor size, executes a select query to retrieve all data from the specified table, and then loads the result into a pandas DataFrame. Finally, it calculates the time taken to retrieve the data and prints out the prefetchrows, arraysize, number of rows retrieved, and the elapsed time in seconds.",
            "code": "import os\nimport time\nimport pandas as pd\nimport sqlalchemy as sql\nimport oracledb as oracledb\n\n# Database Credentials\nusername = os.environ.get(\"PYTHON_USERNAME\")\npassword = os.environ.get(\"PYTHON_PASSWORD\")\n\ncp = oracledb.ConnectParams()\ncp.parse_connect_string(os.environ.get(\"PYTHON_CONNECTSTRING\"))\n\neng = sql.create_engine(f'oracle+oracledb://{username}:{password}@{cp.host}:{cp.port}/?service_name={cp.service_name}')\ntablename = input(\"enter table name: \")\ncursorsize = input(\"enter cursor size: \")\nsqlStatement = 'select * from {}'.format(tablename)\nconn = eng.pool._creator()\nstart = time.time()\nwith conn.cursor() as cursor:\n    cursor.arraysize = int(cursorsize)\n    cursor.execute(sqlStatement)\n    res = cursor.fetchall()\n    #loading the result list in pandas Dataframe\n    df = pd.DataFrame(res, columns = ['description','done'])\n    elapsed = (time.time() - start)\n    print(\"Prefetchrows:\", cursor.prefetchrows, \"Arraysize:\", cursor.arraysize)\n    print(\"Retrieved\", len(res), \"rows in\", elapsed, \"seconds\")",
            "masked_code": "import os\nimport time\nimport pandas as pd\nimport sqlalchemy as sql\nimport oracledb as oracledb\n\n# Database Credentials\nusername = os.environ.get(\"PYTHON_USERNAME\")\npassword = os.environ.get(\"PYTHON_PASSWORD\")\n\ncp = oracledb.ConnectParams()\ncp.parse_connect_string(os.environ.get(\"PYTHON_CONNECTSTRING\"))\n\neng = sql.create_engine(f'oracle+oracledb://{username}:{password}@{cp.host}:{cp.port}/?service_name={cp.service_name}')\ntablename = input(\"enter table name: \")\ncursorsize = input(\"enter cursor size: \")\nsqlStatement = 'select * from {}'.format(tablename)\nconn = eng.pool._creator()\nstart = time.time()\n<line_mask>\n    cursor.arraysize = int(cursorsize)\n    cursor.execute(sqlStatement)\n    res = cursor.fetchall()\n    #loading the result list in pandas Dataframe\n    df = pd.DataFrame(res, columns = ['description','done'])\n    elapsed = (time.time() - start)\n    print(\"Prefetchrows:\", cursor.prefetchrows, \"Arraysize:\", cursor.arraysize)\n    print(\"Retrieved\", len(res), \"rows in\", elapsed, \"seconds\")",
            "masked_line": "with conn.cursor() as cursor:",
            "answer": "cursor",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_651"
        },
        {
            "dependency": "deepl",
            "version": "==1.15.0",
            "time": "2023-11-06",
            "description": "The code reads an Excel file and then translates the text content in the file from one language to another language using the DeepL API. It prints the translated text along with the original text.",
            "code": "import pandas as pd\nimport deepl\n\ninput_file = 'excel_example.xlsx'\ndf = pd.read_excel(input_file, header=None)\ndf.applymap(lambda text: print(text))\n# prints the following:\n# :1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.\n# Table 1\n# This is an example sentence.\n# This is another example sentence.\n#      0\n# 0  None\n# 1  None\n# 2  None\nt = deepl.Translator('MY_API_KEY')\nres = df.applymap(lambda text: t.translate_text(str(text), target_lang=\"DE\"))\nprint(res)\n# prints the following\n#                                      0\n# 0                            Tabelle 1\n# 1           Dies ist ein Beispielsatz.\n# 2  Dies ist ein weiterer Beispielsatz.",
            "masked_code": "import pandas as pd\nimport deepl\n\ninput_file = 'excel_example.xlsx'\ndf = pd.read_excel(input_file, header=None)\ndf.applymap(lambda text: print(text))\n# prints the following:\n# :1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.\n# Table 1\n# This is an example sentence.\n# This is another example sentence.\n#      0\n# 0  None\n# 1  None\n# 2  None\nt = deepl.Translator('MY_API_KEY')\n<line_mask>\nprint(res)\n# prints the following\n#                                      0\n# 0                            Tabelle 1\n# 1           Dies ist ein Beispielsatz.\n# 2  Dies ist ein weiterer Beispielsatz.",
            "masked_line": "res = df.applymap(lambda text: t.translate_text(str(text), target_lang=\"DE\"))",
            "answer": "translate_text",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_652"
        },
        {
            "dependency": "pandas",
            "version": "==2.1.2",
            "time": "2023-11-06",
            "description": "This code reads data from an Excel file, prints the contents of the file, translates the text in the file to German language using the DeepL API, and then prints the translated text.",
            "code": "import pandas as pd\nimport deepl\n\ninput_file = 'excel_example.xlsx'\ndf = pd.read_excel(input_file, header=None)\ndf.applymap(lambda text: print(text))\n# prints the following:\n# :1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.\n# Table 1\n# This is an example sentence.\n# This is another example sentence.\n#      0\n# 0  None\n# 1  None\n# 2  None\nt = deepl.Translator('MY_API_KEY')\nres = df.applymap(lambda text: t.translate_text(str(text), target_lang=\"DE\"))\nprint(res)\n# prints the following\n#                                      0\n# 0                            Tabelle 1\n# 1           Dies ist ein Beispielsatz.\n# 2  Dies ist ein weiterer Beispielsatz.",
            "masked_code": "import pandas as pd\nimport deepl\n\ninput_file = 'excel_example.xlsx'\ndf = pd.read_excel(input_file, header=None)\ndf.applymap(lambda text: print(text))\n# prints the following:\n# :1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.\n# Table 1\n# This is an example sentence.\n# This is another example sentence.\n#      0\n# 0  None\n# 1  None\n# 2  None\nt = deepl.Translator('MY_API_KEY')\n<line_mask>\nprint(res)\n# prints the following\n#                                      0\n# 0                            Tabelle 1\n# 1           Dies ist ein Beispielsatz.\n# 2  Dies ist ein weiterer Beispielsatz.",
            "masked_line": "res = df.applymap(lambda text: t.translate_text(str(text), target_lang=\"DE\"))",
            "answer": "applymap",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_653"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==1.4.4",
            "time": "2023-11-03",
            "description": "The code reads data from a table named \"wikipedia\" using the SQLAlchemy library.",
            "code": "# pip install sqlalchemy==1.4.4\nfrom sqlalchemy import MetaData, Table\nfrom sqlalchemy.engine import create_engine\n\nengine = create_engine(\"druid://localhost:8888/druid/v2/sql\") # add ?header=True\nta = Table(\"wikipedia\", MetaData(bind=engine), autoload=True) # if needed\n\ndf = pd.read_sql(ta.select(), engine)",
            "masked_code": "# pip install sqlalchemy==1.4.4\nfrom sqlalchemy import MetaData, Table\nfrom sqlalchemy.engine import create_engine\n\nengine = create_engine(\"druid://localhost:8888/druid/v2/sql\") # add ?header=True\nta = Table(\"wikipedia\", MetaData(bind=engine), autoload=True) # if needed\n\n<line_mask>",
            "masked_line": "df = pd.read_sql(ta.select(), engine)",
            "answer": "select",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_654"
        },
        {
            "dependency": "playsound",
            "version": "==1.2.2",
            "time": "2023-09-27",
            "description": "The code changes the background image of a turtle graphics window when the letter \"s\" is pressed, plays a sound, and then updates the background image back to the original.",
            "code": "import turtle\nfrom playsound import playsound\n\nwn = turtle.Screen()\nBase = \"Background.png\"\nwn.bgpic(Base)\n\ndef SNARE():\n    wn.bgpic(\"Snare Hit.png\")\n    wn.update()\n    playsound(\"Snare-Drum-Hit.mp3\")\n    wn.bgpic(Base)\n    wn.update()\n\nwn.onkeypress(SNARE, \"s\")\n\nturtle.listen()\n\nwn.mainloop()",
            "masked_code": "import turtle\nfrom playsound import playsound\n\nwn = turtle.Screen()\nBase = \"Background.png\"\nwn.bgpic(Base)\n\ndef SNARE():\n    wn.bgpic(\"Snare Hit.png\")\n    wn.update()\n    <line_mask>\n    wn.bgpic(Base)\n    wn.update()\n\nwn.onkeypress(SNARE, \"s\")\n\nturtle.listen()\n\nwn.mainloop()",
            "masked_line": "playsound(\"Snare-Drum-Hit.mp3\")",
            "answer": "playsound",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_655"
        },
        {
            "dependency": "openpyxl",
            "version": "==3.0.10",
            "time": "2023-08-26",
            "description": "This code retrieves the values in the \"Panel Name\" column from a named table in an Excel sheet and prints them out.",
            "code": "from openpyxl.utils.cell import range_boundaries\nimport openpyxl as pyxl  # v3.0.10\n\n# Access excel sheet\ninput_excel_file = pyxl.load_workbook(path_backup_excel_file, data_only=True)\nsheet_panels_to_run = input_excel_file['Panels to Run']\n\n# Access named table\nrequest_table = sheet_panels_to_run.tables['RequestTable']\n\n# Get range boundaries of table\nmin_col, min_row, max_col, max_row = range_boundaries(request_table.ref)\n\n# Construct headers lookup dictionary\nheaders = {\n    col_name: col_idx\n    for (col_idx, col_name)\n    in enumerate(request_table.column_names)\n}\n\n# Get relative column index of target column\ntarget_col_idx = headers['Panel Name']\n\n# Loop over all data values in target column\nfor i in range(min_row + 1, max_row + 1):\n    value = sheet_panels_to_run.cell(i, min_col + target_col_idx).value\n    print(value)",
            "masked_code": "from openpyxl.utils.cell import range_boundaries\nimport openpyxl as pyxl  # v3.0.10\n\n# Access excel sheet\n<line_mask>\nsheet_panels_to_run = input_excel_file['Panels to Run']\n\n# Access named table\nrequest_table = sheet_panels_to_run.tables['RequestTable']\n\n# Get range boundaries of table\nmin_col, min_row, max_col, max_row = range_boundaries(request_table.ref)\n\n# Construct headers lookup dictionary\nheaders = {\n    col_name: col_idx\n    for (col_idx, col_name)\n    in enumerate(request_table.column_names)\n}\n\n# Get relative column index of target column\ntarget_col_idx = headers['Panel Name']\n\n# Loop over all data values in target column\nfor i in range(min_row + 1, max_row + 1):\n    value = sheet_panels_to_run.cell(i, min_col + target_col_idx).value\n    print(value)",
            "masked_line": "input_excel_file = pyxl.load_workbook(path_backup_excel_file, data_only=True)",
            "answer": "load_workbook",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_656"
        },
        {
            "dependency": "selenium",
            "version": ">=4.6",
            "time": "2023-07-24",
            "description": "The code initializes a Chrome WebDriver with specific options for headless browsing and downloading files to the current working directory.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"download.default_directory={}\".format(os.getcwd()))\noptions.add_argument(\"--headless=new\")\noptions.binary_location = \".\\\\chrome-win32\\\\chrome.exe\"\ndriver = webdriver.Chrome(options=options)",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"download.default_directory={}\".format(os.getcwd()))\noptions.add_argument(\"--headless=new\")\noptions.binary_location = \".\\\\chrome-win32\\\\chrome.exe\"\n<line_mask>",
            "masked_line": "driver = webdriver.Chrome(options=options)",
            "answer": "Chrome",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_657"
        },
        {
            "dependency": "numba",
            "version": "==0.56.4",
            "time": "2023-07-02",
            "description": "The code sorts the input array 'data' based on the shuffled indices in 'irange' using a shufflesort algorithm implemented with CUDA parallel programming, and stores the sorted result in the 'res' array.",
            "code": "from numba import cuda, types\n\n@cuda.jit(types.int64(types.int64,types.int64), device=True)\ndef cmpexch(x,y):\n\n  if x > y: return x,y\n  else: return y,x\n\n@cuda.jit(types.void(types.int64[:]), device=True)\ndef sort4(arr):\n\n    arr[2], arr[4] = cmpexch(arr[2], arr[4]);  \n    arr[0], arr[1] = cmpexch(arr[0], arr[1]);\n    arr[0], arr[2] = cmpexch(arr[0], arr[2]);  \n    arr[1], arr[4] = cmpexch(arr[1], arr[4]);\n    arr[2], arr[3] = cmpexch(arr[2], arr[3]);\n    arr[1], arr[2] = cmpexch(arr[1], arr[2]);\n    arr[2], arr[3] = cmpexch(arr[2], arr[3]);  \n    arr[0], arr[1] = cmpexch(arr[0], arr[1]);\n    arr[3], arr[4] = cmpexch(arr[3], arr[4]);\n\n\n@cuda.jit(types.void(types.int64[:],types.int64[:], types.int64[:]))\ndef shufflesort_k(data, indices, output):\n\n    larr = cuda.local.array(4, dtype=types.int64)\n    idx = cuda.grid(1)\n    \n    larr[0] = data[indices[4*idx+0]]\n    larr[1] = data[indices[4*idx+1]]\n    larr[2] = data[indices[4*idx+2]]\n    larr[3] = data[indices[4*idx+3]]\n\n    sort4(larr)\n    output[4*idx] = larr[0]\n    output[4*idx+1] = larr[1] \n    output[4*idx+2] = larr[2]\n    output[4*idx+3] = larr[3]\n\nimport numpy as np\n\ndata = np.random.randint(0,2048, 128, dtype=np.int64)\nirange = np.arange(0,128, dtype=np.int64); np.random.shuffle(irange)\nres = np.zeros_like(data)\n\nshufflesort_k[1,32](data, irange, res)\n\nprint(data[irange])\nprint(res)",
            "masked_code": "from numba import cuda, types\n\n<line_mask>\ndef cmpexch(x,y):\n\n  if x > y: return x,y\n  else: return y,x\n\n@cuda.jit(types.void(types.int64[:]), device=True)\ndef sort4(arr):\n\n    arr[2], arr[4] = cmpexch(arr[2], arr[4]);  \n    arr[0], arr[1] = cmpexch(arr[0], arr[1]);\n    arr[0], arr[2] = cmpexch(arr[0], arr[2]);  \n    arr[1], arr[4] = cmpexch(arr[1], arr[4]);\n    arr[2], arr[3] = cmpexch(arr[2], arr[3]);\n    arr[1], arr[2] = cmpexch(arr[1], arr[2]);\n    arr[2], arr[3] = cmpexch(arr[2], arr[3]);  \n    arr[0], arr[1] = cmpexch(arr[0], arr[1]);\n    arr[3], arr[4] = cmpexch(arr[3], arr[4]);\n\n\n@cuda.jit(types.void(types.int64[:],types.int64[:], types.int64[:]))\ndef shufflesort_k(data, indices, output):\n\n    larr = cuda.local.array(4, dtype=types.int64)\n    idx = cuda.grid(1)\n    \n    larr[0] = data[indices[4*idx+0]]\n    larr[1] = data[indices[4*idx+1]]\n    larr[2] = data[indices[4*idx+2]]\n    larr[3] = data[indices[4*idx+3]]\n\n    sort4(larr)\n    output[4*idx] = larr[0]\n    output[4*idx+1] = larr[1] \n    output[4*idx+2] = larr[2]\n    output[4*idx+3] = larr[3]\n\nimport numpy as np\n\ndata = np.random.randint(0,2048, 128, dtype=np.int64)\nirange = np.arange(0,128, dtype=np.int64); np.random.shuffle(irange)\nres = np.zeros_like(data)\n\nshufflesort_k[1,32](data, irange, res)\n\nprint(data[irange])\nprint(res)",
            "masked_line": "@cuda.jit(types.int64(types.int64,types.int64), device=True)",
            "answer": "jit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_658"
        },
        {
            "dependency": "Brotli",
            "version": "==1.0.9",
            "time": "2023-05-08",
            "description": "The code compresses a serialized object using the Brotli compression algorithm in chunks, writing the compressed data to an output file. It flushes the remaining compressed data at the end and allows for decompression and deserialization of the original object.",
            "code": "import brotli\nimport dill\nimport io\nimport pickle\n\n# The following serialized object is 30kb\nobjects = [\"234r234r234\", \"3f234f2343f3\", \"234ff234f234f234rf32\"]*5000\nobjects_serialized = dill.dumps(objects, pickle.HIGHEST_PROTOCOL)\n\n# Set up a buffer for reading chunks of serialized data\nchunk_size = 1024 * 1024\nbuffer = io.BytesIO(objects_serialized)\n\n# Create compressor for repeated use\ncompressor = brotli.Compressor(quality=1)\nwith open('output.brotli', 'wb') as output:\n    # Read chunks from the buffer and compress them\n    while True:\n        chunk = buffer.read(chunk_size)\n        if not chunk:\n            break\n        compressed_chunk = compressor.process(chunk)\n        output.write(compressed_chunk)\n\n    # Flush the remaining compressed data\n    compressed_remainder = compressor.finish()\n    # 4kb in my computer\n    # I decompressed, de-serialized, and retrieved the original object\n    output.write(compressed_remainder)",
            "masked_code": "import brotli\nimport dill\nimport io\nimport pickle\n\n# The following serialized object is 30kb\nobjects = [\"234r234r234\", \"3f234f2343f3\", \"234ff234f234f234rf32\"]*5000\nobjects_serialized = dill.dumps(objects, pickle.HIGHEST_PROTOCOL)\n\n# Set up a buffer for reading chunks of serialized data\nchunk_size = 1024 * 1024\nbuffer = io.BytesIO(objects_serialized)\n\n# Create compressor for repeated use\ncompressor = brotli.Compressor(quality=1)\nwith open('output.brotli', 'wb') as output:\n    # Read chunks from the buffer and compress them\n    while True:\n        chunk = buffer.read(chunk_size)\n        if not chunk:\n            break\n        compressed_chunk = compressor.process(chunk)\n        output.write(compressed_chunk)\n\n    # Flush the remaining compressed data\n    <line_mask>\n    # 4kb in my computer\n    # I decompressed, de-serialized, and retrieved the original object\n    output.write(compressed_remainder)",
            "masked_line": "compressed_remainder = compressor.finish()",
            "answer": "finish",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_659"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7",
            "time": "2023-04-24",
            "description": "The code generates a scatter plot with random x and y coordinates for 100 data points colored based on a random integer between 0 and 3 using a custom colormap. It also adds a colorbar to the plot.",
            "code": "import matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport numpy as np\n\ncmap = mpl.colors.ListedColormap([\"#fd635c\", \"#00b9a8\", \"#124191\"])\n\nmpl.colormaps.register(cmap, name=\"my_cmap\")\n\nnp.random.seed(123456)\nx = np.random.rand(100) * 3,\ny = np.random.rand(100) * 3\nc = np.random.randint(0, 3, 100)\n\nplt.scatter(x=x, y=y, c=c, cmap=\"my_cmap\")\n\nplt.colorbar()",
            "masked_code": "import matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport numpy as np\n\ncmap = mpl.colors.ListedColormap([\"#fd635c\", \"#00b9a8\", \"#124191\"])\n\n<line_mask>\n\nnp.random.seed(123456)\nx = np.random.rand(100) * 3,\ny = np.random.rand(100) * 3\nc = np.random.randint(0, 3, 100)\n\nplt.scatter(x=x, y=y, c=c, cmap=\"my_cmap\")\n\nplt.colorbar()",
            "masked_line": "mpl.colormaps.register(cmap, name=\"my_cmap\")",
            "answer": "colormaps",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_660"
        },
        {
            "dependency": "pandas",
            "version": "==2.0",
            "time": "2023-04-19",
            "description": "This code defines a function that returns an empty pandas DataFrame with columns specified by the input schema, with specified data types.",
            "code": "import pandas as pd\nimport numpy as np\nimport pyarrow as pa\n\ndef return_empty_dataframe(schema: dict[str, np.dtype]): \n    return pd.DataFrame(columns=schema.keys()).astype(schema)\n\nschema = {'time': 'time64[us][pyarrow]', 'power': 'float32[pyarrow]', 'profile': 'string[pyarrow]'}  \nempty_df = return_empty_dataframe(schema)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport pyarrow as pa\n\ndef return_empty_dataframe(schema: dict[str, np.dtype]): \n    <line_mask>\n\nschema = {'time': 'time64[us][pyarrow]', 'power': 'float32[pyarrow]', 'profile': 'string[pyarrow]'}  \nempty_df = return_empty_dataframe(schema)",
            "masked_line": "return pd.DataFrame(columns=schema.keys()).astype(schema)",
            "answer": "astype",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_661"
        },
        {
            "dependency": "smtplib",
            "version": ">=3.6",
            "time": "2023-03-11",
            "description": "This Python code sends an email using the SMTP protocol with a secure SSL context.",
            "code": "import smtplib, ssl\n\n# Create secure SSL context\ncont = ssl.create_default_context()\n\nserver = smtplib.SMTP(smtp_server, port = 587)\nserver.starttls(context = cont)\nserver.login(sender_email, password)\nserver.sendmail(sender_email, receiver_email, message)\nserver.quit()",
            "masked_code": "import smtplib, ssl\n\n# Create secure SSL context\ncont = ssl.create_default_context()\n\nserver = smtplib.SMTP(smtp_server, port = 587)\nserver.starttls(context = cont)\nserver.login(sender_email, password)\nserver.sendmail(sender_email, receiver_email, message)\n<line_mask>",
            "masked_line": "server.quit()",
            "answer": "quit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_662"
        },
        {
            "dependency": "datasets",
            "version": "==2.8.0",
            "time": "2023-01-17",
            "description": "The code loads the IMDb training dataset from a public cloud storage location and prints the number of items in the dataset, which is 25000.",
            "code": "from datasets import load_from_disk\n# load encoded_dataset from cloud storage\n\ndataset = load_from_disk(\"s3://a-public-datasets/imdb/train\", storage_options=storage_options)  \n\nprint(len(dataset))\n25000",
            "masked_code": "from datasets import load_from_disk\n# load encoded_dataset from cloud storage\n\n<line_mask>\n\nprint(len(dataset))\n25000",
            "masked_line": "dataset = load_from_disk(\"s3://a-public-datasets/imdb/train\", storage_options=storage_options)",
            "answer": "load_from_disk",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_663"
        },
        {
            "dependency": "Flask",
            "version": "==2.3.2",
            "time": "2023-08-09",
            "description": "This code creates a Flask web application that defines a route for the root URL (\"/\"). When the user visits the root URL, the code renders the \"index.html\" template with the options variable containing a list of tuples representing different options.",
            "code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index_view():\n    options = [(1,\"uno\"),(2,\"dos\"),(3,\"tres\")]\n    return render_template(\"index.html\", options=options)\n\nif __name__ == \"__main__\":\n    app.run()",
            "masked_code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index_view():\n    options = [(1,\"uno\"),(2,\"dos\"),(3,\"tres\")]\n    return render_template(\"index.html\", options=options)\n\nif __name__ == \"__main__\":\n    <line_mask>",
            "masked_line": "app.run()",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_664"
        },
        {
            "dependency": "scikit-learn",
            "version": ">=1.2",
            "time": "2023-06-16",
            "description": "The code sets the output format for transformation results to pandas.",
            "code": "from sklearn import set_config\nset_config(transform_output=\"pandas\")",
            "masked_code": "from sklearn import set_config\n<line_mask>",
            "masked_line": "set_config(transform_output=\"pandas\")",
            "answer": "set_config",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_665"
        },
        {
            "dependency": "xmlschema",
            "version": "==2.2.3",
            "time": "2023-04-28",
            "description": "The code parses an XML document using lxml library, then validates the XML document against an XML schema using xmlschema library. It iterates through any validation errors and prints out the error details including sourceline, path, reason, and message.",
            "code": "import lxml.etree as ET\n\nfrom xmlschema import XMLSchema\n\nxml_doc = ET.parse(\"sample1.xml\")\n\nschema = XMLSchema(\"sample1.xsd\")\n\nfor error in schema.iter_errors(xml_doc):\n    print(f'sourceline: {error.sourceline}; path: {error.path} | reason: {error.reason} | message: {error.message}')",
            "masked_code": "import lxml.etree as ET\n\nfrom xmlschema import XMLSchema\n\nxml_doc = ET.parse(\"sample1.xml\")\n\nschema = XMLSchema(\"sample1.xsd\")\n\n<line_mask>\n    print(f'sourceline: {error.sourceline}; path: {error.path} | reason: {error.reason} | message: {error.message}')",
            "masked_line": "for error in schema.iter_errors(xml_doc):",
            "answer": "iter_errors",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_666"
        },
        {
            "dependency": "scipy",
            "version": ">=1.11.1",
            "time": "2023-07-25",
            "description": "The code optimizes a linear programming problem using the linear programming solver from scipy.optimize. It uses the 'highs-ipm' solver with specified parameters to minimize the objective function subject to inequality and equality constraints, and calculates the number of iterations used in the crossover process, which should be 0.",
            "code": "from scipy.optimize import linprog\n\n# Define c, A_ub, b_ub, A_eq, b_eq, bounds\n...\n\n# Define options\nsolver = 'highs-ipm'\nparams = {'run_crossover': False}\n\n# Optimize\nsol = linprog(c, A_ub, b_ub, A_eq, b_eq, bounds, method=solver, options=params)\n\n# Check the number of iteration in crossover\nprint(sol.crossover_nit)  # it should be 0",
            "masked_code": "<line_mask>\n\n# Define c, A_ub, b_ub, A_eq, b_eq, bounds\n...\n\n# Define options\nsolver = 'highs-ipm'\nparams = {'run_crossover': False}\n\n# Optimize\nsol = linprog(c, A_ub, b_ub, A_eq, b_eq, bounds, method=solver, options=params)\n\n# Check the number of iteration in crossover\nprint(sol.crossover_nit)  # it should be 0",
            "masked_line": "from scipy.optimize import linprog",
            "answer": "linprog",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_667"
        },
        {
            "dependency": "guidata",
            "version": "==2.3.1",
            "time": "2023-04-17",
            "description": "The code defines a class named Input which contains attributes select_chA, select_chB, and select_chD. select_chA is a choice item, select_chB is a boolean item, and select_chD is a choice item that is displayed conditionally based on the values of select_chA and select_chB.",
            "code": "...\nimport guidata.dataset.datatypes as gdt\nimport guidata.dataset.dataitems as gdi\n...\nclass Input(gdt.DataSet):\n    \n    _prop1 = gdt.GetAttrProp('select_chA')\n    ...\n    select_chA = gdi.ChoiceItem(...).set_prop('display', store=_prop1)\n\n    _prop2 = gdt.GetAttrProp('select_chB')\n    select_chB = gdi.BoolItem(...).set_prop('display', store=_prop2)\n\n    ...\n    select_chD = gdi.ChoiceItem(...).set_prop('display', active=\n        gdt.ItemProperty(lambda *args:\n            Input._prop1(*args) == 'a1' or Input._prop2(*args)))\n...",
            "masked_code": "...\nimport guidata.dataset.datatypes as gdt\nimport guidata.dataset.dataitems as gdi\n...\nclass Input(gdt.DataSet):\n    \n    _prop1 = gdt.GetAttrProp('select_chA')\n    ...\n    select_chA = gdi.ChoiceItem(...).set_prop('display', store=_prop1)\n\n    _prop2 = gdt.GetAttrProp('select_chB')\n    select_chB = gdi.BoolItem(...).set_prop('display', store=_prop2)\n\n    ...\n    select_chD = gdi.ChoiceItem(...).set_prop('display', active=\n        <line_mask>\n            Input._prop1(*args) == 'a1' or Input._prop2(*args)))\n...",
            "masked_line": "gdt.ItemProperty(lambda *args:",
            "answer": "ItemProperty",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_668"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2023-02-13",
            "description": "The code overrides the default text parsing behavior in pandas.read_html for HTML parsing by defining a custom_text_getter function, which extracts the text content of HTML elements and returns it as a string.",
            "code": "import lxml.html\nimport pandas as pd\n\nhtml = \"\"\"\n \n \n X1 \n X2 \n\n \n   \nTest   \n Test2  \n\n\n\n\"\"\"\n\ndef custom_text_getter(self, obj):\n   result = obj.xpath(\"node()\")[0]\n   if isinstance(result, lxml.html.HtmlElement):\n      result = lxml.html.tostring(result, encoding=\"unicode\")\n   return result\n\npd.io.html._LxmlFrameParser._text_getter = custom_text_getter\n\nprint(\n    pd.read_html(html)[0]\n)",
            "masked_code": "import lxml.html\nimport pandas as pd\n\nhtml = \"\"\"\n \n \n X1 \n X2 \n\n \n   \nTest   \n Test2  \n\n\n\n\"\"\"\n\ndef custom_text_getter(self, obj):\n   result = obj.xpath(\"node()\")[0]\n   if isinstance(result, lxml.html.HtmlElement):\n      result = lxml.html.tostring(result, encoding=\"unicode\")\n   return result\n\npd.io.html._LxmlFrameParser._text_getter = custom_text_getter\n\nprint(\n    <line_mask>\n)",
            "masked_line": "pd.read_html(html)[0]",
            "answer": "read_html",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_669"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.1",
            "time": "2019-02-12",
            "description": "The code creates a DataFrame using a dictionary of lists, renames the column, duplicates the DataFrame, adds a 'group' column, initializes a new series, defines a function to append lists over rows, and loops over groups to apply the function to each group in the DataFrame.",
            "code": "import pandas as pd\nmylists={1:[[1]],2:[[1,2,3]],3:[[2,9,7,9]],4:[[2,7,3,5]]}\nmydf=pd.DataFrame.from_dict(mylists,orient='index')\nmydf=mydf.rename(columns={0:'lists'})\nmydf = pd.concat([mydf, mydf], axis=0, ignore_index=True)\nmydf['group'] = ['A']*4 + ['B']*4\n\n# initialize your new series\nmydf['newseries'] = mydf['lists']\n\n# define the function that appends lists overs rows\ndef append_row_lists(data):\n    for i in data.index:\n        try: data.loc[i+1, 'newseries'] = data.loc[i, 'lists'] + data.loc[i+1, 'lists']\n        except: pass\n    return data\n\n# loop over your groups\nfor gp in mydf.group.unique():\n    condition = mydf.group == gp\n    mydf[condition] = append_row_lists(mydf[condition])",
            "masked_code": "import pandas as pd\nmylists={1:[[1]],2:[[1,2,3]],3:[[2,9,7,9]],4:[[2,7,3,5]]}\nmydf=pd.DataFrame.from_dict(mylists,orient='index')\nmydf=mydf.rename(columns={0:'lists'})\n<line_mask>\nmydf['group'] = ['A']*4 + ['B']*4\n\n# initialize your new series\nmydf['newseries'] = mydf['lists']\n\n# define the function that appends lists overs rows\ndef append_row_lists(data):\n    for i in data.index:\n        try: data.loc[i+1, 'newseries'] = data.loc[i, 'lists'] + data.loc[i+1, 'lists']\n        except: pass\n    return data\n\n# loop over your groups\nfor gp in mydf.group.unique():\n    condition = mydf.group == gp\n    mydf[condition] = append_row_lists(mydf[condition])",
            "masked_line": "mydf = pd.concat([mydf, mydf], axis=0, ignore_index=True)",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_670"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2022-04-01",
            "description": "The code creates a TensorFlow StaticHashTable with keys and values tensors, then creates a dataset from given data. It maps each item in the dataset to a tuple containing the lookup result based on 'investment_id' key, 'features' value, and 'target' value. Finally, it prints each item in the dataset.",
            "code": "import tensorflow as tf\n\ndata = {\n    \"investment_id\": [1, 2, 3, 4, 5], \n    \"features\": [12, 912, 28, 90, 17],\n    \"target\": [1, 0, 1, 1, 1]\n}\n\nkeys_tensor = tf.constant([1, 2, 3])\nvals_tensor = tf.constant([1, 2, 3])\ntable = tf.lookup.StaticHashTable(\n    tf.lookup.KeyValueTensorInitializer(keys_tensor, vals_tensor),\n    default_value=0)\n\n\nds = tf.data.Dataset.from_tensor_slices(data)\nds = ds.map(lambda item: (table.lookup(item['investment_id']), item['features'], item['target']))\n\nfor d in ds:\n  print(d)",
            "masked_code": "import tensorflow as tf\n\ndata = {\n    \"investment_id\": [1, 2, 3, 4, 5], \n    \"features\": [12, 912, 28, 90, 17],\n    \"target\": [1, 0, 1, 1, 1]\n}\n\nkeys_tensor = tf.constant([1, 2, 3])\nvals_tensor = tf.constant([1, 2, 3])\n<line_mask>\n    tf.lookup.KeyValueTensorInitializer(keys_tensor, vals_tensor),\n    default_value=0)\n\n\nds = tf.data.Dataset.from_tensor_slices(data)\nds = ds.map(lambda item: (table.lookup(item['investment_id']), item['features'], item['target']))\n\nfor d in ds:\n  print(d)",
            "masked_line": "table = tf.lookup.StaticHashTable(",
            "answer": "StaticHashTable",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_671"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2022-08-10",
            "description": "The function generates random values using TensorFlow and updates a tensor by scattering the values at specific indices.",
            "code": "import tensorflow as tf\n\ndef f():\n  return tf.random.normal((10,))\n\n@tf.function\ndef store_this():\n  reps = 4\n  n = 10\n  store = tf.zeros((n, reps))\n  values = [f() for _ in range(reps)]\n  indices = tf.stack([tf.tile(tf.range(n), multiples=[reps]), tf.repeat(tf.range(reps), repeats=n)], axis=-1)\n  return tf.tensor_scatter_nd_update(store, indices, tf.reshape(values, [-1]))\n\nstore_this()",
            "masked_code": "import tensorflow as tf\n\ndef f():\n  return tf.random.normal((10,))\n\n<line_mask>\ndef store_this():\n  reps = 4\n  n = 10\n  store = tf.zeros((n, reps))\n  values = [f() for _ in range(reps)]\n  indices = tf.stack([tf.tile(tf.range(n), multiples=[reps]), tf.repeat(tf.range(reps), repeats=n)], axis=-1)\n  return tf.tensor_scatter_nd_update(store, indices, tf.reshape(values, [-1]))\n\nstore_this()",
            "masked_line": "@tf.function",
            "answer": "function",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_672"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-04-01",
            "description": "The code demonstrates how to maintain integer data types in a DataFrame while performing various operations like appending data, slicing existing rows, and inserting data based on labels. It also highlights unexpected behavior where label-based insertion for an entire row does not convert to float, but referring to all columns in a row does convert to float.",
            "code": "import pandas as pd\nimport numpy as np\nimport sys\n\nprint(sys.version)\nprint(pd.__version__)\n\nprint(\"int dtypes preserved\")\n# append on populated DataFrame\ndf = pd.DataFrame([[0, 0], [1,1]], index=['a', 'b'], columns=[\"col1\", \"col2\"])\ndf.loc[\"c\"] = np.int64(0)\n# slice existing rows\ndf.loc[\"a\":\"c\"] = np.int64(1)\ndf.loc[\"a\":\"c\", \"col1\":\"col2\":1] = np.int64(2)\nprint(df.dtypes)\n\n# no selection AND no data, remains np.int64 if defined as such\ndf = pd.DataFrame(columns=[\"col1\", \"col2\"], dtype=np.int64)\ndf.loc[:, \"col1\":\"col2\":1] = np.int64(0)\ndf.loc[:,:] = np.int64(0)\nprint(df.dtypes)\n\n# and works if no index but data\ndf = pd.DataFrame([[0, 0], [1,1]], columns=[\"col1\", \"col2\"])\ndf.loc[:,\"col1\":\"col2\":1] = np.int64(0)\nprint(df.dtypes)\n\n# the surprise... label based insertion for the entire row does not convert to float\ndf = pd.DataFrame(columns=[\"col1\", \"col2\"], dtype=np.int64)\ndf.loc[\"a\"] = np.int64(0)\nprint(df.dtypes)\n\n# a surprise because referring to all columns, as above, does convert to float\nprint(\"unexpectedly converted to float dtypes\")\ndf = pd.DataFrame(columns=[\"col1\", \"col2\"], dtype=np.int64)\ndf.loc[\"a\", \"col1\":\"col2\"] = np.int64(0)\nprint(df.dtypes)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport sys\n\nprint(sys.version)\nprint(pd.__version__)\n\nprint(\"int dtypes preserved\")\n# append on populated DataFrame\ndf = pd.DataFrame([[0, 0], [1,1]], index=['a', 'b'], columns=[\"col1\", \"col2\"])\ndf.loc[\"c\"] = np.int64(0)\n# slice existing rows\ndf.loc[\"a\":\"c\"] = np.int64(1)\ndf.loc[\"a\":\"c\", \"col1\":\"col2\":1] = np.int64(2)\nprint(df.dtypes)\n\n# no selection AND no data, remains np.int64 if defined as such\ndf = pd.DataFrame(columns=[\"col1\", \"col2\"], dtype=np.int64)\ndf.loc[:, \"col1\":\"col2\":1] = np.int64(0)\ndf.loc[:,:] = np.int64(0)\nprint(df.dtypes)\n\n# and works if no index but data\ndf = pd.DataFrame([[0, 0], [1,1]], columns=[\"col1\", \"col2\"])\ndf.loc[:,\"col1\":\"col2\":1] = np.int64(0)\nprint(df.dtypes)\n\n# the surprise... label based insertion for the entire row does not convert to float\ndf = pd.DataFrame(columns=[\"col1\", \"col2\"], dtype=np.int64)\ndf.loc[\"a\"] = np.int64(0)\nprint(df.dtypes)\n\n# a surprise because referring to all columns, as above, does convert to float\nprint(\"unexpectedly converted to float dtypes\")\n<line_mask>\ndf.loc[\"a\", \"col1\":\"col2\"] = np.int64(0)\nprint(df.dtypes)",
            "masked_line": "df = pd.DataFrame(columns=[\"col1\", \"col2\"], dtype=np.int64)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_673"
        },
        {
            "dependency": "spacy",
            "version": "==2.1.8",
            "time": "2019-09-26",
            "description": "The code loads the English language model for natural language processing using the spaCy library and sets a custom infix tokenizer for tokenization of text based on specified regular expressions.",
            "code": "nlp = spacy.load('en')\nnlp.tokenizer.infix_finditer = infix_re.finditer",
            "masked_code": "<line_mask>\nnlp.tokenizer.infix_finditer = infix_re.finditer",
            "masked_line": "nlp = spacy.load('en')",
            "answer": "load",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_674"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14",
            "time": "2019-09-03",
            "description": "The code defines a function `run_avg(signal, alpha=0.2)` that calculates the moving average of a signal with a specified alpha value. It then generates random data, applies the `run_avg` function to it, reshapes the data, and trains a SimpleRNN model using the TensorFlow/Keras framework with a specified configuration. The model is compiled, trained on the data, and the weights of the RNN layer are printed before and after training.",
            "code": "from tensorflow import keras\nimport numpy as np\nfrom tensorflow.keras.models import Sequential as Sequential\n\nnp.random.seed(1337)  # for reproducibility\n\ndef run_avg(signal, alpha=0.2):\n    avg_signal = []\n    avg = np.mean(signal)\n    for i, sample in enumerate(signal):\n        if np.isnan(sample) or sample == 0:\n            sample = avg\n        avg = (1 - alpha) * avg + alpha * sample\n        avg_signal.append(avg)\n    return np.array(avg_signal)\n\ndef train():\n    x = np.random.rand(3000)\n    y = run_avg(x)\n    x = np.reshape(x, (-1, 1, 1))\n    y = np.reshape(y, (-1, 1))\n    \n    # SimpleRNN model\n    model = Sequential()\n    model.add(keras.layers.Input(batch_shape=(1, 1, 1), dtype='float32'))\n    model.add(keras.layers.SimpleRNN(1, stateful=True, activation=None, name='rnn_layer_1'))\n    model.compile(optimizer=keras.optimizers.SGD(lr=0.1), loss='mse')\n    model.summary()\n    \n    print(model.get_layer('rnn_layer_1').get_weights())\n    model.fit(x=x, y=y, batch_size=1, epochs=10, shuffle=False)\n    print(model.get_layer('rnn_layer_1').get_weights())\n\ntrain()",
            "masked_code": "from tensorflow import keras\nimport numpy as np\nfrom tensorflow.keras.models import Sequential as Sequential\n\nnp.random.seed(1337)  # for reproducibility\n\ndef run_avg(signal, alpha=0.2):\n    avg_signal = []\n    avg = np.mean(signal)\n    for i, sample in enumerate(signal):\n        if np.isnan(sample) or sample == 0:\n            sample = avg\n        avg = (1 - alpha) * avg + alpha * sample\n        avg_signal.append(avg)\n    return np.array(avg_signal)\n\ndef train():\n    x = np.random.rand(3000)\n    y = run_avg(x)\n    x = np.reshape(x, (-1, 1, 1))\n    y = np.reshape(y, (-1, 1))\n    \n    # SimpleRNN model\n    model = Sequential()\n    model.add(keras.layers.Input(batch_shape=(1, 1, 1), dtype='float32'))\n    model.add(keras.layers.SimpleRNN(1, stateful=True, activation=None, name='rnn_layer_1'))\n    model.compile(optimizer=keras.optimizers.SGD(lr=0.1), loss='mse')\n    <line_mask>\n    \n    print(model.get_layer('rnn_layer_1').get_weights())\n    model.fit(x=x, y=y, batch_size=1, epochs=10, shuffle=False)\n    print(model.get_layer('rnn_layer_1').get_weights())\n\ntrain()",
            "masked_line": "model.summary()",
            "answer": "summary",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_675"
        },
        {
            "dependency": "django",
            "version": ">=2.1",
            "time": "2019-10-16",
            "description": "This code defines a Django model called Person with two fields: first_name and last_name. It also defines a method full_name that concatenates the first_name and last_name fields to return the full name of the person. Additionally, it sets the admin_order_field for the full_name method to concatenate the first_name and last_name fields in the database query for ordering purposes in the Django admin interface.",
            "code": "from django.db.models import Value\nfrom django.db.models.functions import Concat\n\nclass Person(models.Model):\n    first_name = models.CharField(max_length=50)\n    last_name = models.CharField(max_length=50)\n\n    def full_name(self):\n        return self.first_name + ' ' + self.last_name\n    full_name.admin_order_field = Concat('first_name', Value(' '), 'last_name')",
            "masked_code": "from django.db.models import Value\nfrom django.db.models.functions import Concat\n\nclass Person(models.Model):\n    first_name = models.CharField(max_length=50)\n    last_name = models.CharField(max_length=50)\n\n    def full_name(self):\n        return self.first_name + ' ' + self.last_name\n    <line_mask>",
            "masked_line": "full_name.admin_order_field = Concat('first_name', Value(' '), 'last_name')",
            "answer": "Value",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_676"
        },
        {
            "dependency": "tqdm",
            "version": ">=4.41.0",
            "time": "2019-12-20",
            "description": "The code uses TqdmCallback from tqdm.keras to display progress bars during the model fitting process in Keras, with verbose set to 2.",
            "code": "from tqdm.keras import TqdmCallback\n...\nmodel.fit(..., verbose=0, callbacks=[TqdmCallback(verbose=2)])",
            "masked_code": "<line_mask>\n...\nmodel.fit(..., verbose=0, callbacks=[TqdmCallback(verbose=2)])",
            "masked_line": "from tqdm.keras import TqdmCallback",
            "answer": "TqdmCallback",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_677"
        },
        {
            "dependency": "numpy",
            "version": "==1.16.2",
            "time": "2019-03-12",
            "description": "This code generates a visualization of the distribution of quotient values calculated from data in a CSV file. It loads the data from the file, calculates the quotient values based on certain conditions, and then displays the distribution plot using seaborn and matplotlib libraries. The plot includes both the original values and the normalized values for comparison.",
            "code": "import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sys\n\nprint('System versions          : {}'.format(sys.version))\nprint('System versions          : {}'.format(sys.version_info))\nprint('Numpy versqion           : {}'.format(np.__version__))\nprint('matplotlib.pyplot version: {}'.format(matplotlib.__version__))\nprint('seaborn version          : {}'.format(sns.__version__))\n\nprotocols = {}\n\ntypes = {\"data_v\": \"data_v.csv\"}\n\nfor protname, fname in types.items():\n    col_time,col_window = np.loadtxt(fname,delimiter=',').T\n    trailing_window = col_window[:-1] # \"past\" values at a given index\n    leading_window  = col_window[1:]  # \"current values at a given index\n    decreasing_inds = np.where(leading_window < trailing_window)[0]\n    quotient = leading_window[decreasing_inds]/trailing_window[decreasing_inds]\n    quotient_times = col_time[decreasing_inds]\n\n    protocols[protname] = {\n        \"col_time\": col_time,\n        \"col_window\": col_window,\n        \"quotient_times\": quotient_times,\n        \"quotient\": quotient,\n    }\n\n    fig, (ax1, ax2) = plt.subplots(1,2, sharey=False, sharex=False)\n    g = sns.distplot(quotient, hist=True, label=protname, ax=ax1, rug=True)\n    ax1.set_title('basic distplot (kde=True)')\n    # get distplot line points\n    line = g.get_lines()[0]\n    xd = line.get_xdata()\n    yd = line.get_ydata()\n    # https://stackoverflow.com/questions/29661574/normalize-numpy-array-columns-in-python\n    def normalize(x):\n        return (x - x.min(0)) / x.ptp(0)\n    #normalize points\n    yd2 = normalize(yd)\n    # plot them in another graph\n    ax2.plot(xd, yd2)\n    ax2.set_title('basic distplot (kde=True)\\nwith normalized y plot values')\n\n    plt.show()",
            "masked_code": "import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sys\n\nprint('System versions          : {}'.format(sys.version))\nprint('System versions          : {}'.format(sys.version_info))\nprint('Numpy versqion           : {}'.format(np.__version__))\nprint('matplotlib.pyplot version: {}'.format(matplotlib.__version__))\nprint('seaborn version          : {}'.format(sns.__version__))\n\nprotocols = {}\n\ntypes = {\"data_v\": \"data_v.csv\"}\n\nfor protname, fname in types.items():\n    <line_mask>\n    trailing_window = col_window[:-1] # \"past\" values at a given index\n    leading_window  = col_window[1:]  # \"current values at a given index\n    decreasing_inds = np.where(leading_window < trailing_window)[0]\n    quotient = leading_window[decreasing_inds]/trailing_window[decreasing_inds]\n    quotient_times = col_time[decreasing_inds]\n\n    protocols[protname] = {\n        \"col_time\": col_time,\n        \"col_window\": col_window,\n        \"quotient_times\": quotient_times,\n        \"quotient\": quotient,\n    }\n\n    fig, (ax1, ax2) = plt.subplots(1,2, sharey=False, sharex=False)\n    g = sns.distplot(quotient, hist=True, label=protname, ax=ax1, rug=True)\n    ax1.set_title('basic distplot (kde=True)')\n    # get distplot line points\n    line = g.get_lines()[0]\n    xd = line.get_xdata()\n    yd = line.get_ydata()\n    # https://stackoverflow.com/questions/29661574/normalize-numpy-array-columns-in-python\n    def normalize(x):\n        return (x - x.min(0)) / x.ptp(0)\n    #normalize points\n    yd2 = normalize(yd)\n    # plot them in another graph\n    ax2.plot(xd, yd2)\n    ax2.set_title('basic distplot (kde=True)\\nwith normalized y plot values')\n\n    plt.show()",
            "masked_line": "col_time,col_window = np.loadtxt(fname,delimiter=',').T",
            "answer": "loadtxt",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_678"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.0.2",
            "time": "2019-03-12",
            "description": "The code generates kernel density estimation plots for the quotient values of two consecutive columns in a CSV file. It calculates the quotient values, normalizes them, and plots the distribution of the quotient values along with a graph of the normalized y plot values.",
            "code": "import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sys\n\nprint('System versions          : {}'.format(sys.version))\nprint('System versions          : {}'.format(sys.version_info))\nprint('Numpy versqion           : {}'.format(np.__version__))\nprint('matplotlib.pyplot version: {}'.format(matplotlib.__version__))\nprint('seaborn version          : {}'.format(sns.__version__))\n\nprotocols = {}\n\ntypes = {\"data_v\": \"data_v.csv\"}\n\nfor protname, fname in types.items():\n    col_time,col_window = np.loadtxt(fname,delimiter=',').T\n    trailing_window = col_window[:-1] # \"past\" values at a given index\n    leading_window  = col_window[1:]  # \"current values at a given index\n    decreasing_inds = np.where(leading_window < trailing_window)[0]\n    quotient = leading_window[decreasing_inds]/trailing_window[decreasing_inds]\n    quotient_times = col_time[decreasing_inds]\n\n    protocols[protname] = {\n        \"col_time\": col_time,\n        \"col_window\": col_window,\n        \"quotient_times\": quotient_times,\n        \"quotient\": quotient,\n    }\n\n    fig, (ax1, ax2) = plt.subplots(1,2, sharey=False, sharex=False)\n    g = sns.distplot(quotient, hist=True, label=protname, ax=ax1, rug=True)\n    ax1.set_title('basic distplot (kde=True)')\n    # get distplot line points\n    line = g.get_lines()[0]\n    xd = line.get_xdata()\n    yd = line.get_ydata()\n    # https://stackoverflow.com/questions/29661574/normalize-numpy-array-columns-in-python\n    def normalize(x):\n        return (x - x.min(0)) / x.ptp(0)\n    #normalize points\n    yd2 = normalize(yd)\n    # plot them in another graph\n    ax2.plot(xd, yd2)\n    ax2.set_title('basic distplot (kde=True)\\nwith normalized y plot values')\n\n    plt.show()",
            "masked_code": "import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sys\n\nprint('System versions          : {}'.format(sys.version))\nprint('System versions          : {}'.format(sys.version_info))\nprint('Numpy versqion           : {}'.format(np.__version__))\nprint('matplotlib.pyplot version: {}'.format(matplotlib.__version__))\nprint('seaborn version          : {}'.format(sns.__version__))\n\nprotocols = {}\n\ntypes = {\"data_v\": \"data_v.csv\"}\n\nfor protname, fname in types.items():\n    col_time,col_window = np.loadtxt(fname,delimiter=',').T\n    trailing_window = col_window[:-1] # \"past\" values at a given index\n    leading_window  = col_window[1:]  # \"current values at a given index\n    decreasing_inds = np.where(leading_window < trailing_window)[0]\n    quotient = leading_window[decreasing_inds]/trailing_window[decreasing_inds]\n    quotient_times = col_time[decreasing_inds]\n\n    protocols[protname] = {\n        \"col_time\": col_time,\n        \"col_window\": col_window,\n        \"quotient_times\": quotient_times,\n        \"quotient\": quotient,\n    }\n\n    <line_mask>\n    g = sns.distplot(quotient, hist=True, label=protname, ax=ax1, rug=True)\n    ax1.set_title('basic distplot (kde=True)')\n    # get distplot line points\n    line = g.get_lines()[0]\n    xd = line.get_xdata()\n    yd = line.get_ydata()\n    # https://stackoverflow.com/questions/29661574/normalize-numpy-array-columns-in-python\n    def normalize(x):\n        return (x - x.min(0)) / x.ptp(0)\n    #normalize points\n    yd2 = normalize(yd)\n    # plot them in another graph\n    ax2.plot(xd, yd2)\n    ax2.set_title('basic distplot (kde=True)\\nwith normalized y plot values')\n\n    plt.show()",
            "masked_line": "fig, (ax1, ax2) = plt.subplots(1,2, sharey=False, sharex=False)",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_679"
        },
        {
            "dependency": "seaborn",
            "version": "==0.9.0",
            "time": "2019-03-12",
            "description": "The code generates plots using seaborn and matplotlib to visualize the distribution of quotient values calculated from the data in the \"data_v.csv\" file. It normalizes the y plot values for better visualization and displays the plots in separate subplots.",
            "code": "import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sys\n\nprint('System versions          : {}'.format(sys.version))\nprint('System versions          : {}'.format(sys.version_info))\nprint('Numpy versqion           : {}'.format(np.__version__))\nprint('matplotlib.pyplot version: {}'.format(matplotlib.__version__))\nprint('seaborn version          : {}'.format(sns.__version__))\n\nprotocols = {}\n\ntypes = {\"data_v\": \"data_v.csv\"}\n\nfor protname, fname in types.items():\n    col_time,col_window = np.loadtxt(fname,delimiter=',').T\n    trailing_window = col_window[:-1] # \"past\" values at a given index\n    leading_window  = col_window[1:]  # \"current values at a given index\n    decreasing_inds = np.where(leading_window < trailing_window)[0]\n    quotient = leading_window[decreasing_inds]/trailing_window[decreasing_inds]\n    quotient_times = col_time[decreasing_inds]\n\n    protocols[protname] = {\n        \"col_time\": col_time,\n        \"col_window\": col_window,\n        \"quotient_times\": quotient_times,\n        \"quotient\": quotient,\n    }\n\n    fig, (ax1, ax2) = plt.subplots(1,2, sharey=False, sharex=False)\n    g = sns.distplot(quotient, hist=True, label=protname, ax=ax1, rug=True)\n    ax1.set_title('basic distplot (kde=True)')\n    # get distplot line points\n    line = g.get_lines()[0]\n    xd = line.get_xdata()\n    yd = line.get_ydata()\n    # https://stackoverflow.com/questions/29661574/normalize-numpy-array-columns-in-python\n    def normalize(x):\n        return (x - x.min(0)) / x.ptp(0)\n    #normalize points\n    yd2 = normalize(yd)\n    # plot them in another graph\n    ax2.plot(xd, yd2)\n    ax2.set_title('basic distplot (kde=True)\\nwith normalized y plot values')\n\n    plt.show()",
            "masked_code": "import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sys\n\nprint('System versions          : {}'.format(sys.version))\nprint('System versions          : {}'.format(sys.version_info))\nprint('Numpy versqion           : {}'.format(np.__version__))\nprint('matplotlib.pyplot version: {}'.format(matplotlib.__version__))\nprint('seaborn version          : {}'.format(sns.__version__))\n\nprotocols = {}\n\ntypes = {\"data_v\": \"data_v.csv\"}\n\nfor protname, fname in types.items():\n    col_time,col_window = np.loadtxt(fname,delimiter=',').T\n    trailing_window = col_window[:-1] # \"past\" values at a given index\n    leading_window  = col_window[1:]  # \"current values at a given index\n    decreasing_inds = np.where(leading_window < trailing_window)[0]\n    quotient = leading_window[decreasing_inds]/trailing_window[decreasing_inds]\n    quotient_times = col_time[decreasing_inds]\n\n    protocols[protname] = {\n        \"col_time\": col_time,\n        \"col_window\": col_window,\n        \"quotient_times\": quotient_times,\n        \"quotient\": quotient,\n    }\n\n    fig, (ax1, ax2) = plt.subplots(1,2, sharey=False, sharex=False)\n    <line_mask>\n    ax1.set_title('basic distplot (kde=True)')\n    # get distplot line points\n    line = g.get_lines()[0]\n    xd = line.get_xdata()\n    yd = line.get_ydata()\n    # https://stackoverflow.com/questions/29661574/normalize-numpy-array-columns-in-python\n    def normalize(x):\n        return (x - x.min(0)) / x.ptp(0)\n    #normalize points\n    yd2 = normalize(yd)\n    # plot them in another graph\n    ax2.plot(xd, yd2)\n    ax2.set_title('basic distplot (kde=True)\\nwith normalized y plot values')\n\n    plt.show()",
            "masked_line": "g = sns.distplot(quotient, hist=True, label=protname, ax=ax1, rug=True)",
            "answer": "distplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_680"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0.0",
            "time": "2019-07-29",
            "description": "This code implements a neural network model using TensorFlow/Keras to perform a regression task with two separate inputs. The model consists of shared embedding layers, global average pooling layers, dense layers, and output layers. The model is trained using the Adam optimizer and Mean Squared Error loss function for a specified number of iterations. Finally, the code visualizes the loss values over the iterations using Matplotlib.",
            "code": "## Do this\n#pip install tensorflow==2.0.0\n\nimport tensorflow.keras as keras\nimport numpy as np\nfrom tensorflow.keras.models import Model\n\n\ndata_1=np.array([[25,  5, 11, 24,  6],\n       [25,  5, 11, 24,  6],\n       [25,  0, 11, 24,  6],\n       [25, 11, 28, 11, 24],\n       [25, 11,  6, 11, 11]])\n\ndata_2=np.array([[25, 11, 31,  6, 11],\n       [25, 11, 28, 11, 31],\n       [25, 11, 11, 11, 31]])\n\nY_1=np.array([[2.33],\n       [2.59],\n       [2.59],\n       [2.54],\n       [4.06]])\n\n\nY_2=np.array([[2.9],\n       [2.54],\n       [4.06]])\n\n\n\nuser_input = keras.layers.Input(shape=((None,)), name='Input_1')\nproducts_input =  keras.layers.Input(shape=((None,)), name='Input_2')\n\nshared_embed=(keras.layers.Embedding(37, 3, input_length=5))\nuser_vec_1 = shared_embed(user_input )\nuser_vec_2 = shared_embed(products_input )\n\nx = keras.layers.GlobalAveragePooling1D()(user_vec_1)\nnn = keras.layers.Dense(90, activation='relu',name='layer_1')(x)\nresult_a = keras.layers.Dense(1, activation='linear', name='output_1')(nn)\n\n# Task 2 FC layers\nx = keras.layers.GlobalAveragePooling1D()(user_vec_2)\nnn1 = keras.layers.Dense(90, activation='relu', name='layer_2')(x)\n\nresult_b = keras.layers.Dense(1, activation='linear',name='output_2')(nn1)\n\nmodel = Model(inputs=[user_input , products_input], outputs=[result_a, result_b])\n\n\nloss = tf.keras.losses.MeanSquaredError()\noptimizer = tf.keras.optimizers.Adam()\n\nloss_values = []\nnum_iter = 300\nfor i in range(num_iter):\n    with tf.GradientTape() as tape:\n        # Forward pass.\n        logits = model([data_1, data_2])          \n        loss_value = loss(Y_1, logits[0]) + loss(Y_2, logits[1]) \n        loss_values.append(loss_value)\n    gradients = tape.gradient(loss_value, model.trainable_weights)          \n    optimizer.apply_gradients(zip(gradients, model.trainable_weights))\n\nimport matplotlib.pyplot as plt\nplt.plot(range(num_iter), loss_values)\nplt.xlabel(\"iterations\")\nplt.ylabel('loss value')",
            "masked_code": "## Do this\n#pip install tensorflow==2.0.0\n\nimport tensorflow.keras as keras\nimport numpy as np\nfrom tensorflow.keras.models import Model\n\n\ndata_1=np.array([[25,  5, 11, 24,  6],\n       [25,  5, 11, 24,  6],\n       [25,  0, 11, 24,  6],\n       [25, 11, 28, 11, 24],\n       [25, 11,  6, 11, 11]])\n\ndata_2=np.array([[25, 11, 31,  6, 11],\n       [25, 11, 28, 11, 31],\n       [25, 11, 11, 11, 31]])\n\nY_1=np.array([[2.33],\n       [2.59],\n       [2.59],\n       [2.54],\n       [4.06]])\n\n\nY_2=np.array([[2.9],\n       [2.54],\n       [4.06]])\n\n\n\nuser_input = keras.layers.Input(shape=((None,)), name='Input_1')\nproducts_input =  keras.layers.Input(shape=((None,)), name='Input_2')\n\nshared_embed=(keras.layers.Embedding(37, 3, input_length=5))\nuser_vec_1 = shared_embed(user_input )\nuser_vec_2 = shared_embed(products_input )\n\nx = keras.layers.GlobalAveragePooling1D()(user_vec_1)\nnn = keras.layers.Dense(90, activation='relu',name='layer_1')(x)\nresult_a = keras.layers.Dense(1, activation='linear', name='output_1')(nn)\n\n# Task 2 FC layers\nx = keras.layers.GlobalAveragePooling1D()(user_vec_2)\nnn1 = keras.layers.Dense(90, activation='relu', name='layer_2')(x)\n\nresult_b = keras.layers.Dense(1, activation='linear',name='output_2')(nn1)\n\n<line_mask>\n\n\nloss = tf.keras.losses.MeanSquaredError()\noptimizer = tf.keras.optimizers.Adam()\n\nloss_values = []\nnum_iter = 300\nfor i in range(num_iter):\n    with tf.GradientTape() as tape:\n        # Forward pass.\n        logits = model([data_1, data_2])          \n        loss_value = loss(Y_1, logits[0]) + loss(Y_2, logits[1]) \n        loss_values.append(loss_value)\n    gradients = tape.gradient(loss_value, model.trainable_weights)          \n    optimizer.apply_gradients(zip(gradients, model.trainable_weights))\n\nimport matplotlib.pyplot as plt\nplt.plot(range(num_iter), loss_values)\nplt.xlabel(\"iterations\")\nplt.ylabel('loss value')",
            "masked_line": "model = Model(inputs=[user_input , products_input], outputs=[result_a, result_b])",
            "answer": "Model",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_681"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-10-05",
            "description": "This code is for writing data pairs (label, image) into .tfrecord files and using them for training a simple neural network. The code includes functions for writing the data into .tfrecord files, parsing the serialized data, creating a neural network model, compiling the model, and training the model using the data from the .tfrecord files.",
            "code": "# Developed using python 3.6, tensorflow 1.14.0.\n# This code writes data (pairs (label, image) where label is int64 and image is np.ndarray) into .tfrecord files and\n# uses them for training a simple neural network. It is meant as a minimal working example of how to use tfrecords. This\n# solution is likely not optimal. If you know how to improve it, please comment on\n# https://stackoverflow.com/q/57717004/9988487. Refer to links therein for further information.\nimport tensorflow as tf\nimport numpy as np\nfrom tensorflow.python import keras as keras\n\n\n# Helper functions (see also https://www.tensorflow.org/tutorials/load_data/tf_records)\ndef _int64_feature(value):\n    return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))\n\n\ndef _bytes_feature(value):\n    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))\n\n\ndef write_tfrecords_file(out_path: str, images: np.ndarray, labels: np.ndarray) -> None:\n    \"\"\"Write all image-label pairs into a single .tfrecord file.\n    :param out_path: File path of the .tfrecord file to generate or overwrite.\n    :param images: array with first dimension being the image index. Every images[i].tostring() is\n        serialized and written into the file as 'image': wrap_bytes(img_bytes)\n    :param labels: 1d array of integers. labels[i] is the label of images[i]. Written as 'label': wrap_int64(label)\"\"\"\n    assert len(images) == len(labels)\n    with tf.io.TFRecordWriter(out_path) as writer:  # could use writer_options parameter to enable compression\n        for i in range(len(labels)):\n            img_bytes = images[i].tostring()  # Convert the image to raw bytes.\n            label = labels[i]\n            data = {'image': _bytes_feature(img_bytes), 'label': _int64_feature(label)}\n            feature = tf.train.Features(feature=data)  # Wrap the data as TensorFlow Features.\n            example = tf.train.Example(features=feature)  # Wrap again as a TensorFlow Example.\n            serialized = example.SerializeToString()  # Serialize the data.\n            writer.write(serialized)  # Write the serialized data to the TFRecords file.\n\n\ndef parse_example(serialized, shape=(256, 256, 1)):\n    features = {'image': tf.io.FixedLenFeature([], tf.string), 'label': tf.io.FixedLenFeature([], tf.int64)}\n    # Parse the serialized data so we get a dict with our data.\n    parsed_example = tf.io.parse_single_example(serialized=serialized, features=features)\n    label = parsed_example['label']\n    image_raw = parsed_example['image']  # Get the image as raw bytes.\n    image = tf.decode_raw(image_raw, tf.float32)  # Decode the raw bytes so it becomes a tensor with type.\n    image = tf.reshape(image, shape=shape)\n    return image, label  # this function will be called once (to add it to tf graph; then parse images individually)\n\n\n# create some arbitrary data to play with: 1000 images sized 256x256 with one colour channel. Use your custom np-arrays\nIMAGE_WIDTH, NUM_OF_IMAGES, NUM_OF_CLASSES, COLOUR_CHANNELS = 256, 10_000, 10, 1\n# using float32 to save memory. Must match type in parse_example(), tf.decode_raw(image_raw, tf.float32)\nfeatures_train = np.random.sample((NUM_OF_IMAGES, IMAGE_WIDTH, IMAGE_WIDTH, COLOUR_CHANNELS)).astype(np.float32)\nlabels_train = np.random.randint(low=0, high=NUM_OF_CLASSES, size=NUM_OF_IMAGES)  # one random label for each image\nfeatures_eval = features_train[:200]  # use the first 200 images as evaluation data for simplicity.\nlabels_eval = labels_train[:200]\nwrite_tfrecords_file(\"train.tfrecord\", features_train, labels_train)  # normal: split the data files of several GB each\nwrite_tfrecords_file(\"eval.tfrecord\", features_eval, labels_eval)  # this may take a while. Consider a progressbar\n# The files are complete. Now define a model and use datasets to feed the data from the .tfrecord files into the model.\nmodel = keras.Sequential([keras.layers.Flatten(input_shape=(256, 256, 1)),\n                          keras.layers.Dense(128, activation='relu'),\n                          keras.layers.Dense(10, activation='softmax')])\nmodel.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n# Check docs for parameters (compression, buffer size, thread count. Also www.tensorflow.org/guide/performance/datasets\n\ntrain_dataset = tf.data.TFRecordDataset(\"train.tfrecord\")  # specify a list (or dataset) of file names for large data\ntrain_dataset = train_dataset.map(parse_example)  # parse tfrecords. Parameter num_parallel_calls may help performance.\ntrain_dataset = train_dataset.shuffle(buffer_size=1024).batch(64)\n\nvalidation_dataset = tf.data.TFRecordDataset(\"eval.tfrecord\")\nvalidation_dataset = validation_dataset.map(parse_example).batch(64)\n\nmodel.fit(train_dataset, epochs=3)\n# evaluate the results\nresults = model.evaluate(validation_dataset)\nprint('\\n\\nvalidation loss, validation acc:', results)",
            "masked_code": "# Developed using python 3.6, tensorflow 1.14.0.\n# This code writes data (pairs (label, image) where label is int64 and image is np.ndarray) into .tfrecord files and\n# uses them for training a simple neural network. It is meant as a minimal working example of how to use tfrecords. This\n# solution is likely not optimal. If you know how to improve it, please comment on\n# https://stackoverflow.com/q/57717004/9988487. Refer to links therein for further information.\nimport tensorflow as tf\nimport numpy as np\nfrom tensorflow.python import keras as keras\n\n\n# Helper functions (see also https://www.tensorflow.org/tutorials/load_data/tf_records)\ndef _int64_feature(value):\n    return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))\n\n\ndef _bytes_feature(value):\n    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))\n\n\ndef write_tfrecords_file(out_path: str, images: np.ndarray, labels: np.ndarray) -> None:\n    \"\"\"Write all image-label pairs into a single .tfrecord file.\n    :param out_path: File path of the .tfrecord file to generate or overwrite.\n    :param images: array with first dimension being the image index. Every images[i].tostring() is\n        serialized and written into the file as 'image': wrap_bytes(img_bytes)\n    :param labels: 1d array of integers. labels[i] is the label of images[i]. Written as 'label': wrap_int64(label)\"\"\"\n    assert len(images) == len(labels)\n    with tf.io.TFRecordWriter(out_path) as writer:  # could use writer_options parameter to enable compression\n        for i in range(len(labels)):\n            img_bytes = images[i].tostring()  # Convert the image to raw bytes.\n            label = labels[i]\n            data = {'image': _bytes_feature(img_bytes), 'label': _int64_feature(label)}\n            feature = tf.train.Features(feature=data)  # Wrap the data as TensorFlow Features.\n            example = tf.train.Example(features=feature)  # Wrap again as a TensorFlow Example.\n            serialized = example.SerializeToString()  # Serialize the data.\n            writer.write(serialized)  # Write the serialized data to the TFRecords file.\n\n\ndef parse_example(serialized, shape=(256, 256, 1)):\n    features = {'image': tf.io.FixedLenFeature([], tf.string), 'label': tf.io.FixedLenFeature([], tf.int64)}\n    # Parse the serialized data so we get a dict with our data.\n    parsed_example = tf.io.parse_single_example(serialized=serialized, features=features)\n    label = parsed_example['label']\n    image_raw = parsed_example['image']  # Get the image as raw bytes.\n    image = tf.decode_raw(image_raw, tf.float32)  # Decode the raw bytes so it becomes a tensor with type.\n    image = tf.reshape(image, shape=shape)\n    return image, label  # this function will be called once (to add it to tf graph; then parse images individually)\n\n\n# create some arbitrary data to play with: 1000 images sized 256x256 with one colour channel. Use your custom np-arrays\nIMAGE_WIDTH, NUM_OF_IMAGES, NUM_OF_CLASSES, COLOUR_CHANNELS = 256, 10_000, 10, 1\n# using float32 to save memory. Must match type in parse_example(), tf.decode_raw(image_raw, tf.float32)\nfeatures_train = np.random.sample((NUM_OF_IMAGES, IMAGE_WIDTH, IMAGE_WIDTH, COLOUR_CHANNELS)).astype(np.float32)\nlabels_train = np.random.randint(low=0, high=NUM_OF_CLASSES, size=NUM_OF_IMAGES)  # one random label for each image\nfeatures_eval = features_train[:200]  # use the first 200 images as evaluation data for simplicity.\nlabels_eval = labels_train[:200]\nwrite_tfrecords_file(\"train.tfrecord\", features_train, labels_train)  # normal: split the data files of several GB each\nwrite_tfrecords_file(\"eval.tfrecord\", features_eval, labels_eval)  # this may take a while. Consider a progressbar\n# The files are complete. Now define a model and use datasets to feed the data from the .tfrecord files into the model.\nmodel = keras.Sequential([keras.layers.Flatten(input_shape=(256, 256, 1)),\n                          keras.layers.Dense(128, activation='relu'),\n                          keras.layers.Dense(10, activation='softmax')])\nmodel.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n# Check docs for parameters (compression, buffer size, thread count. Also www.tensorflow.org/guide/performance/datasets\n\ntrain_dataset = tf.data.TFRecordDataset(\"train.tfrecord\")  # specify a list (or dataset) of file names for large data\ntrain_dataset = train_dataset.map(parse_example)  # parse tfrecords. Parameter num_parallel_calls may help performance.\ntrain_dataset = train_dataset.shuffle(buffer_size=1024).batch(64)\n\nvalidation_dataset = tf.data.TFRecordDataset(\"eval.tfrecord\")\nvalidation_dataset = validation_dataset.map(parse_example).batch(64)\n\n<line_mask>\n# evaluate the results\nresults = model.evaluate(validation_dataset)\nprint('\\n\\nvalidation loss, validation acc:', results)",
            "masked_line": "model.fit(train_dataset, epochs=3)",
            "answer": "fit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_682"
        },
        {
            "dependency": "plotly",
            "version": "==4.x",
            "time": "2019-02-12",
            "description": "The code generates a plot using Plotly library with a scatter plot, where x-axis values are [1, 2, 3] and y-axis values are [1, 3, 2], and displays the plot.",
            "code": "import plotly.graph_objects as go\nfig = go.Figure( go.Scatter(x=[1,2,3], y=[1,3,2] ) )\nfig.show()",
            "masked_code": "import plotly.graph_objects as go\nfig = go.Figure( go.Scatter(x=[1,2,3], y=[1,3,2] ) )\n<line_mask>",
            "masked_line": "fig.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_683"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.8",
            "time": "2019-03-12",
            "description": "The code preprocesses images using TensorFlow and keras to prepare them for input into an InceptionV3 model for image classification. It includes functions to decode JPEG images, convert image data types to float32, and preprocess a batch of images. It also removes the first layer of the InceptionV3 model, adds a new input layer for string inputs, compiles the model with SGD optimizer, and retrieves the model weights.",
            "code": "from keras.applications.inception_v3 import InceptionV3, preprocess_input\nfrom keras.models import Model\nimport numpy as np\nimport cv2\nimport tensorflow as tf\nfrom keras.layers import Input, Lambda\nfrom keras import backend as K\n\nbase_model = InceptionV3(\n                weights='imagenet',\n                include_top=True)\n\nmodel = Model(\n    inputs=base_model.input,\n    outputs=base_model.get_layer('avg_pool').output)\n\n\n\ndef prepare_image(image_str_tensor):\n            #image = tf.squeeze(tf.cast(image_str_tensor, tf.string), axis=[0])\n            image_str_tensor = tf.cast(image_str_tensor, tf.string)\n            image = tf.image.decode_jpeg(image_str_tensor,\n                                        channels=3)\n            #image = tf.divide(image, 255)\n            #image = tf.expand_dims(image, 0)\n            image = tf.image.convert_image_dtype(image, tf.float32)\n            return image\n\ndef prepare_image_batch(image_str_tensor):\n    return tf.map_fn(prepare_image, image_str_tensor, dtype=tf.float32)\n\n# IF BYTE STR\n\nmodel.layers.pop(0)\nprint(model.layers[0])\n\ninput_img = Input(dtype= tf.string,\n            name ='string_input',\n            shape = ()\n            )\noutputs = Lambda(prepare_image_batch)(input_img)\noutputs = model(outputs)\ninception_model = Model(input_img, outputs)\ninception_model.compile(optimizer = \"sgd\", loss='categorical_crossentropy')\nweights = inception_model.get_weights()",
            "masked_code": "from keras.applications.inception_v3 import InceptionV3, preprocess_input\nfrom keras.models import Model\nimport numpy as np\nimport cv2\nimport tensorflow as tf\nfrom keras.layers import Input, Lambda\nfrom keras import backend as K\n\nbase_model = InceptionV3(\n                weights='imagenet',\n                include_top=True)\n\nmodel = Model(\n    inputs=base_model.input,\n    outputs=base_model.get_layer('avg_pool').output)\n\n\n\ndef prepare_image(image_str_tensor):\n            #image = tf.squeeze(tf.cast(image_str_tensor, tf.string), axis=[0])\n            image_str_tensor = tf.cast(image_str_tensor, tf.string)\n            image = tf.image.decode_jpeg(image_str_tensor,\n                                        channels=3)\n            #image = tf.divide(image, 255)\n            #image = tf.expand_dims(image, 0)\n            <line_mask>\n            return image\n\ndef prepare_image_batch(image_str_tensor):\n    return tf.map_fn(prepare_image, image_str_tensor, dtype=tf.float32)\n\n# IF BYTE STR\n\nmodel.layers.pop(0)\nprint(model.layers[0])\n\ninput_img = Input(dtype= tf.string,\n            name ='string_input',\n            shape = ()\n            )\noutputs = Lambda(prepare_image_batch)(input_img)\noutputs = model(outputs)\ninception_model = Model(input_img, outputs)\ninception_model.compile(optimizer = \"sgd\", loss='categorical_crossentropy')\nweights = inception_model.get_weights()",
            "masked_line": "image = tf.image.convert_image_dtype(image, tf.float32)",
            "answer": "convert_image_dtype",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_684"
        },
        {
            "dependency": "Flask",
            "version": "==0.12",
            "time": "2019-06-16",
            "description": "This Python code defines a Flask application with SQLAlchemy integration that allows for database migrations. It includes configuration settings, initializes the database, migrates the database schema, and imports models for Flask-Migrate. The function create_app() creates and returns the Flask application.",
            "code": "from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\n\n\ndb = SQLAlchemy()\n\n\ndef create_app(test_config=None):\n    app = Flask(__name__)\n\n    app.config.from_object(f\"{__name__}.config\")\n    app.config.from_envvar(\"PROJECTNAME_SETTINGS\", silent=True)\n    if test_config:\n        app.config.from_mapping(test_config)\n\n    db.init_app(app)\n    Migrate(app, db)\n\n    # importing the models to make sure they are known to Flask-Migrate\n    from models import models1, models2\n\n    # any other registrations; blueprints, template utilities, commands\n\n    return app",
            "masked_code": "from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\n\n\ndb = SQLAlchemy()\n\n\ndef create_app(test_config=None):\n    app = Flask(__name__)\n\n    <line_mask>\n    app.config.from_envvar(\"PROJECTNAME_SETTINGS\", silent=True)\n    if test_config:\n        app.config.from_mapping(test_config)\n\n    db.init_app(app)\n    Migrate(app, db)\n\n    # importing the models to make sure they are known to Flask-Migrate\n    from models import models1, models2\n\n    # any other registrations; blueprints, template utilities, commands\n\n    return app",
            "masked_line": "app.config.from_object(f\"{__name__}.config\")",
            "answer": "from_object",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_685"
        },
        {
            "dependency": "elasticsearch",
            "version": "==6.6",
            "time": "2019-02-13",
            "description": "This code snippet creates a mapping in Elasticsearch for an index called \"2\" with a nested type called \"tablets\", which contains properties for \"Names\" with fields for \"ID\", \"Combination\", and \"Synonyms\". It also inserts two documents into the index with the specified fields.",
            "code": "import time\n\nfrom elasticsearch import Elasticsearch\nes = Elasticsearch()\n\n# fix typo - missing comma after \"nested\"\nmapping = '''{\n\"mappings\": {\n    \"tablets\": {\n      \"properties\": {\n        \"Names\": {\n          \"type\": \"nested\",\n          \"properties\":{\n              \"ID\": {\"type\" : \"long\"},\n              \"Combination\": {\"type\" : \"text\"},\n              \"Synonyms\": {\"type\" : \"text\"}\n          }\n        }\n      }\n    }\n  }\n}'''\n\n# remove ignore=\"400\"\nes.indices.create(index=\"2\", body=mapping)\n\ntablets = {\n    \"Names\": [\n        {\n            \"ID\": 1,\n            \"Combination\": \"Paracetamol\",\n            \"Synonyms\": \"Crocin\"\n        }, {\n            \"ID\": 2,\n            \"Combination\": \"Pantaprazole\",\n            \"Synonyms\": \"Pantap\"\n        }\n    ]\n}",
            "masked_code": "import time\n\nfrom elasticsearch import Elasticsearch\n<line_mask>\n\n# fix typo - missing comma after \"nested\"\nmapping = '''{\n\"mappings\": {\n    \"tablets\": {\n      \"properties\": {\n        \"Names\": {\n          \"type\": \"nested\",\n          \"properties\":{\n              \"ID\": {\"type\" : \"long\"},\n              \"Combination\": {\"type\" : \"text\"},\n              \"Synonyms\": {\"type\" : \"text\"}\n          }\n        }\n      }\n    }\n  }\n}'''\n\n# remove ignore=\"400\"\nes.indices.create(index=\"2\", body=mapping)\n\ntablets = {\n    \"Names\": [\n        {\n            \"ID\": 1,\n            \"Combination\": \"Paracetamol\",\n            \"Synonyms\": \"Crocin\"\n        }, {\n            \"ID\": 2,\n            \"Combination\": \"Pantaprazole\",\n            \"Synonyms\": \"Pantap\"\n        }\n    ]\n}",
            "masked_line": "es = Elasticsearch()",
            "answer": "Elasticsearch",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_686"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2020-05-27",
            "description": "The code converts the first three columns of the 'iris' dataset into float32 data type and assigns them to variable X. It also converts the fourth column of the 'iris' dataset into float32 data type and assigns it to variable y.",
            "code": "X = tf.cast(iris[:, :3], tf.float32) \ny = tf.cast(iris[:, 3], tf.float32)",
            "masked_code": "<line_mask>\ny = tf.cast(iris[:, 3], tf.float32)",
            "masked_line": "X = tf.cast(iris[:, :3], tf.float32)",
            "answer": "cast",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_687"
        },
        {
            "dependency": "dash",
            "version": "==1.6.0",
            "time": "2019-11-25",
            "description": "The code sets up a dashboard using Dash framework in Python. It reads data from a CSV file hosted online, displays it in a DataTable component, and updates the data in the table every 2 seconds.",
            "code": "import dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport dash_table\nimport pandas as pd\n\napp = dash.Dash(__name__)\n\ndf = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/solar.csv')\n\napp.layout = html.Div([\n      html.H4('Dashboard'),\n      dcc.Interval('graph-update', interval = 2000, n_intervals = 0),\n      dash_table.DataTable(\n          id = 'table',\n          data = df.to_dict('records'),\n          columns=[{\"name\": i, \"id\": i} for i in df.columns])])\n\n@app.callback(\n        dash.dependencies.Output('table','data'),\n        [dash.dependencies.Input('graph-update', 'n_intervals')])\ndef updateTable(n):\n    df = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/solar.csv')\n    return df.to_dict('records')\n\nif __name__ == '__main__':\n     app.run_server(debug=True, port=10451)",
            "masked_code": "import dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport dash_table\nimport pandas as pd\n\napp = dash.Dash(__name__)\n\ndf = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/solar.csv')\n\napp.layout = html.Div([\n      html.H4('Dashboard'),\n      dcc.Interval('graph-update', interval = 2000, n_intervals = 0),\n      dash_table.DataTable(\n          id = 'table',\n          data = df.to_dict('records'),\n          columns=[{\"name\": i, \"id\": i} for i in df.columns])])\n\n@app.callback(\n        <line_mask>\n        [dash.dependencies.Input('graph-update', 'n_intervals')])\ndef updateTable(n):\n    df = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/solar.csv')\n    return df.to_dict('records')\n\nif __name__ == '__main__':\n     app.run_server(debug=True, port=10451)",
            "masked_line": "dash.dependencies.Output('table','data'),",
            "answer": "Output",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_688"
        },
        {
            "dependency": "PySide2",
            "version": "==5.13",
            "time": "2019-06-18",
            "description": "This function allows for compiling a given `.ui` design file in-memory and executing the resulting Python code. It returns the form class and base class corresponding to the design file.",
            "code": "from PySide2 import QtWidgets\nfrom pyside2uic import compileUi\nfrom xml.etree import ElementTree\nfrom io import StringIO\n\ndef loadUiType(design):\n    \"\"\"\n    PySide2 equivalent of PyQt5's `uic.loadUiType()` function.\n\n    Compiles the given `.ui` design file in-memory and executes the\n    resulting Python code. Returns form and base class.\n    \"\"\"\n    parsed_xml   = ElementTree.parse(design)\n    widget_class = parsed_xml.find('widget').get('class')\n    form_class   = parsed_xml.find('class').text\n    with open(design) as input:\n        output = StringIO()\n        compileUi(input, output, indent=0)\n        source_code = output.getvalue()\n        syntax_tree = compile(source_code, filename='', mode='exec')\n        scope = {}\n        exec(syntax_tree, scope)\n        form_class = scope[f'Ui_{form_class}']\n        base_class = eval(f'QtWidgets.{widget_class}')\n    return (form_class, base_class)",
            "masked_code": "from PySide2 import QtWidgets\nfrom pyside2uic import compileUi\nfrom xml.etree import ElementTree\nfrom io import StringIO\n\ndef loadUiType(design):\n    \"\"\"\n    PySide2 equivalent of PyQt5's `uic.loadUiType()` function.\n\n    Compiles the given `.ui` design file in-memory and executes the\n    resulting Python code. Returns form and base class.\n    \"\"\"\n    parsed_xml   = ElementTree.parse(design)\n    widget_class = parsed_xml.find('widget').get('class')\n    form_class   = parsed_xml.find('class').text\n    with open(design) as input:\n        output = StringIO()\n        <line_mask>\n        source_code = output.getvalue()\n        syntax_tree = compile(source_code, filename='', mode='exec')\n        scope = {}\n        exec(syntax_tree, scope)\n        form_class = scope[f'Ui_{form_class}']\n        base_class = eval(f'QtWidgets.{widget_class}')\n    return (form_class, base_class)",
            "masked_line": "compileUi(input, output, indent=0)",
            "answer": "compileUi",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_689"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2019-03-24",
            "description": "The code creates a 3D grid of random binary values and identifies coordinates where the value is greater than 0. It then builds a k-d tree based on these coordinates and generates a graph where nodes are connected based on their distance. Next, it finds connected components in the graph and assigns each node to a specific component. Finally, it visualizes the nodes in a 3D scatter plot with colors representing the connected components.",
            "code": "import pandas as pd\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.ckdtree import cKDTree\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# create data\ndata = np.random.binomial(1, 0.1, 1000)\ndata = data.reshape((10,10,10))\n\n# find coordinates\ncs = np.argwhere(data > 0)\n\n# build k-d tree\nkdt = cKDTree(cs)\nedges = kdt.query_pairs(1)\n\n# create graph\nG = nx.from_edgelist(edges)\n\n# find connected components\nccs = nx.connected_components(G)\nnode_component = {v:k for k,vs in enumerate(ccs) for v in vs}\n\n# visualize\ndf = pd.DataFrame(cs, columns=['x','y','z'])\ndf['c'] = pd.Series(node_component)\n\n# to include single-node connected components\n# df.loc[df['c'].isna(), 'c'] = df.loc[df['c'].isna(), 'c'].isna().cumsum() + df['c'].max()\n\nfig = plt.figure(figsize=(10,10))\nax = fig.add_subplot(111, projection='3d')\ncmhot = plt.get_cmap(\"hot\")\nax.scatter(df['x'], df['y'], df['z'], c=df['c'], s=50, cmap=cmhot)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.ckdtree import cKDTree\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# create data\ndata = np.random.binomial(1, 0.1, 1000)\ndata = data.reshape((10,10,10))\n\n# find coordinates\ncs = np.argwhere(data > 0)\n\n# build k-d tree\nkdt = cKDTree(cs)\nedges = kdt.query_pairs(1)\n\n# create graph\nG = nx.from_edgelist(edges)\n\n# find connected components\n<line_mask>\nnode_component = {v:k for k,vs in enumerate(ccs) for v in vs}\n\n# visualize\ndf = pd.DataFrame(cs, columns=['x','y','z'])\ndf['c'] = pd.Series(node_component)\n\n# to include single-node connected components\n# df.loc[df['c'].isna(), 'c'] = df.loc[df['c'].isna(), 'c'].isna().cumsum() + df['c'].max()\n\nfig = plt.figure(figsize=(10,10))\nax = fig.add_subplot(111, projection='3d')\ncmhot = plt.get_cmap(\"hot\")\nax.scatter(df['x'], df['y'], df['z'], c=df['c'], s=50, cmap=cmhot)",
            "masked_line": "ccs = nx.connected_components(G)",
            "answer": "connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_690"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-02-17",
            "description": "This code fits a generalized extreme value distribution to a given array of data using the method of maximum likelihood estimation.",
            "code": "import numpy as np\nfrom scipy.stats import genextreme as gev\nwith np.errstate(divide='ignore', invalid='ignore'):\n    t=np.array([3.8482, 3.6435, 3.0417, 4.0329, 3.2967, 3.3535, 3.6179, 3.3042, 3.6164, 3.5855, 2.7932, 2.8833, 2.6513, 2.7794, 3.2649, 3.2613, 3.1736, 3.1131, 3.3896, 4.2891])\n    a=gev.fit(t)",
            "masked_code": "import numpy as np\nfrom scipy.stats import genextreme as gev\n<line_mask>\n    t=np.array([3.8482, 3.6435, 3.0417, 4.0329, 3.2967, 3.3535, 3.6179, 3.3042, 3.6164, 3.5855, 2.7932, 2.8833, 2.6513, 2.7794, 3.2649, 3.2613, 3.1736, 3.1131, 3.3896, 4.2891])\n    a=gev.fit(t)",
            "masked_line": "with np.errstate(divide='ignore', invalid='ignore'):",
            "answer": "errstate",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_691"
        },
        {
            "dependency": "numba",
            "version": "==0.58",
            "time": "2024-01-29",
            "description": "The function foo generates unique 2-element arrays of random integers between 0 and 1, by utilizing a hashing technique to ensure uniqueness.",
            "code": "import numpy as np\nimport numba as nb\n\ndef make_hashable(arr):\n    return hash(arr.tobytes())\n\n@nb.jit(nopython=True)\ndef foo(n):\n    uniques = []\n    uniques_set = set()\n    for _ in range(n):\n        arr = np.random.randint(0, 2, 2)\n        with nb.objmode(arr_hashable='intp'):\n            arr_hashable = make_hashable(arr)\n\n        if arr_hashable not in uniques_set:\n            uniques_set.add(arr_hashable)\n            uniques.append(arr)\n    return uniques\n\nfoo(100)\n# => [array([0, 0]), array([0, 1]), array([1, 1]), array([1, 0])]",
            "masked_code": "import numpy as np\nimport numba as nb\n\ndef make_hashable(arr):\n    return hash(arr.tobytes())\n\n@nb.jit(nopython=True)\ndef foo(n):\n    uniques = []\n    uniques_set = set()\n    for _ in range(n):\n        arr = np.random.randint(0, 2, 2)\n        <line_mask>\n            arr_hashable = make_hashable(arr)\n\n        if arr_hashable not in uniques_set:\n            uniques_set.add(arr_hashable)\n            uniques.append(arr)\n    return uniques\n\nfoo(100)\n# => [array([0, 0]), array([0, 1]), array([1, 1]), array([1, 0])]",
            "masked_line": "with nb.objmode(arr_hashable='intp'):",
            "answer": "objmode",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_692"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-21",
            "description": "This code creates two Bokeh plots, one with circles and tooltips, and another with lines. It defines a JavaScript callback function to customize the position of the tooltip plot based on mouse movement. Finally, it displays both plots in a row layout.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.layouts import Row\nfrom bokeh.models import ColumnDataSource, CDSView, BooleanFilter, CustomJS, BoxSelectTool, HoverTool\nimport pandas as pd\n\nplot = figure(tools = 'hover', tooltips = [(\"x\", \"@x\"), (\"y\", \"@y\")])\ncircles = plot.circle('x', 'y', size = 20, source = ColumnDataSource({'x': [1, 2, 3], 'y':[1, 2, 3]}))\n\ninner_plot = figure(name = 'inner_plot', plot_width = 200, plot_height = 200)\nlines = inner_plot.line('x', 'y', source = ColumnDataSource({'x': [8, 9, 10], 'y':[8, 6, 8]}))\n\ncode = \"\"\"  div = document.getElementsByClassName('bk-root')[0];            \n            tooltip_plot = div.children[0].children[1]\n            tooltip_plot.style = \"position:absolute; left: 340px; top: 350px;\"; \"\"\"\n\ncallback = CustomJS(code = code)\nplot.js_on_event('mousemove', callback)\n\nshow(Row(plot, inner_plot))",
            "masked_code": "from bokeh.plotting import figure, show\nfrom bokeh.layouts import Row\nfrom bokeh.models import ColumnDataSource, CDSView, BooleanFilter, CustomJS, BoxSelectTool, HoverTool\nimport pandas as pd\n\nplot = figure(tools = 'hover', tooltips = [(\"x\", \"@x\"), (\"y\", \"@y\")])\ncircles = plot.circle('x', 'y', size = 20, source = ColumnDataSource({'x': [1, 2, 3], 'y':[1, 2, 3]}))\n\ninner_plot = figure(name = 'inner_plot', plot_width = 200, plot_height = 200)\n<line_mask>\n\ncode = \"\"\"  div = document.getElementsByClassName('bk-root')[0];            \n            tooltip_plot = div.children[0].children[1]\n            tooltip_plot.style = \"position:absolute; left: 340px; top: 350px;\"; \"\"\"\n\ncallback = CustomJS(code = code)\nplot.js_on_event('mousemove', callback)\n\nshow(Row(plot, inner_plot))",
            "masked_line": "lines = inner_plot.line('x', 'y', source = ColumnDataSource({'x': [8, 9, 10], 'y':[8, 6, 8]}))",
            "answer": "ColumnDataSource",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_693"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-05-15",
            "description": "The code creates a Keras function to get the output of the i-th layer in a Model, and then extracts the output of that layer using the function with input data df.",
            "code": "from tensorflow.keras import backend as K\n\n# create a Keras function to get i-th layer\nget_layer_output = K.function(inputs = Model.layers[0].input, outputs = Model.layers[i].output)\n\n# extract output\nlayer_output = get_layer_output(df)",
            "masked_code": "from tensorflow.keras import backend as K\n\n# create a Keras function to get i-th layer\n<line_mask>\n\n# extract output\nlayer_output = get_layer_output(df)",
            "masked_line": "get_layer_output = K.function(inputs = Model.layers[0].input, outputs = Model.layers[i].output)",
            "answer": "function",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_694"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-05",
            "description": "This code generates a button labeled \"Download JSON\" that, when clicked, triggers the download of a JSON file containing the data stored in the 'data' variable (which consists of mean and variance arrays). The download functionality is implemented using JavaScript within the CustomJS callback associated with the button.",
            "code": "from bokeh.io import show\nfrom bokeh.plotting import figure\nfrom bokeh import events\nfrom bokeh.models import CustomJS, Div, Button, RadioButtonGroup\nfrom bokeh.layouts import column, row\nimport numpy as np\n\ndata = {'mean': np.arange(10), 'variance': np.random.random(10) }\nbutton = Button(label = \"Download JSON\", button_type = \"success\")\n\njs_download = \"\"\"\nvar filename = 'results.json';\nvar blob = new Blob([JSON.stringify(data)], { type: 'text/json;charset=utf-8;' });\nif (navigator.msSaveBlob) { // IE 10+\nnavigator.msSaveBlob(blob, filename);\n} else {\nvar link = document.createElement(\"a\");\nif (link.download !== undefined) { // feature detection\n    // Browsers that support HTML5 download attribute\n    var url = URL.createObjectURL(blob);\n    link.setAttribute(\"href\", url);\n    link.setAttribute(\"download\", filename);\n    link.style.visibility = 'hidden';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link); } }\"\"\"\n\nbutton.callback = CustomJS(args = dict(data = data), code = js_download)\nshow(button)",
            "masked_code": "from bokeh.io import show\nfrom bokeh.plotting import figure\nfrom bokeh import events\nfrom bokeh.models import CustomJS, Div, Button, RadioButtonGroup\nfrom bokeh.layouts import column, row\nimport numpy as np\n\ndata = {'mean': np.arange(10), 'variance': np.random.random(10) }\nbutton = Button(label = \"Download JSON\", button_type = \"success\")\n\njs_download = \"\"\"\nvar filename = 'results.json';\nvar blob = new Blob([JSON.stringify(data)], { type: 'text/json;charset=utf-8;' });\nif (navigator.msSaveBlob) { // IE 10+\nnavigator.msSaveBlob(blob, filename);\n} else {\nvar link = document.createElement(\"a\");\nif (link.download !== undefined) { // feature detection\n    // Browsers that support HTML5 download attribute\n    var url = URL.createObjectURL(blob);\n    link.setAttribute(\"href\", url);\n    link.setAttribute(\"download\", filename);\n    link.style.visibility = 'hidden';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link); } }\"\"\"\n\nbutton.callback = CustomJS(args = dict(data = data), code = js_download)\n<line_mask>",
            "masked_line": "show(button)",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_695"
        },
        {
            "dependency": "bokeh",
            "version": ">1.0",
            "time": "2019-01-31",
            "description": "This code creates a plot with circles using the Bokeh library in Python. It includes a slider that allows users to change the radius of the circles interactively.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.models import CustomJS, Slider\nfrom bokeh.layouts import column\nimport pandas as pd\n\nsource = pd.DataFrame([[1, 2], [3, 5], [3, 4]], columns=['a','b'])\np = figure()\nr = p.circle(x='a', y='b', source=source, radius=0.3)\n\ncallback = CustomJS(args=dict(renderer=r), code=\"\"\"\n    renderer.glyph.radius = cb_obj.value;\n\"\"\")\n\nslider = Slider(start=0.1, end=1.0, value=0.3, step=.05, title=\"Circle-radius\")\nslider.js_on_change('value', callback)\n\nshow(column(p, slider))",
            "masked_code": "<line_mask>\nfrom bokeh.models import CustomJS, Slider\nfrom bokeh.layouts import column\nimport pandas as pd\n\nsource = pd.DataFrame([[1, 2], [3, 5], [3, 4]], columns=['a','b'])\np = figure()\nr = p.circle(x='a', y='b', source=source, radius=0.3)\n\ncallback = CustomJS(args=dict(renderer=r), code=\"\"\"\n    renderer.glyph.radius = cb_obj.value;\n\"\"\")\n\nslider = Slider(start=0.1, end=1.0, value=0.3, step=.05, title=\"Circle-radius\")\nslider.js_on_change('value', callback)\n\nshow(column(p, slider))",
            "masked_line": "from bokeh.plotting import figure, show",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_696"
        },
        {
            "dependency": "scipy",
            "version": "==1.3.3",
            "time": "2019-12-05",
            "description": "The code defines functions for utility, capital accumulation, and the objective function. It then uses scipy's minimize function to optimize the objective function given certain constraints and initial values. The code ultimately prints whether the optimization was successful and the optimal values of the variables.",
            "code": "import numpy as np\nfrom scipy.optimize import minimize\n\n\ndef u(x):\n    return np.log(x[0] ** alpha * x[0] ** (beta + nabla))\n\n\ndef k_plus(k, x):\n    return A * k + 1 - delta - x[0] - x[1]\n\n\ndef obj_fun(x, k, v_array):\n    return -u(x) - rho * np.log(k_plus(k, x))\n\n\nalpha = 1\nbeta = 0.5\nnabla = 0.5\nA = 1\ndelta = 1\nrho = 1\n\ngrid_max = 10\ngrid_size = 250\ngrid = np.linspace(1e-5, grid_max, grid_size)\n\nx_prueba = [2, 2]\nk = 10\n\nres = minimize(obj_fun, x0=[5, 4], args=(k, np.log(grid)),\n               bounds=((0, np.inf), (0, np.inf)),\n               constraints={\"type\": \"ineq\",\n                            \"fun\": lambda x: -x[0] - x[1] + 10})\nprint(res.success)\nprint(res.x)",
            "masked_code": "import numpy as np\nfrom scipy.optimize import minimize\n\n\ndef u(x):\n    return np.log(x[0] ** alpha * x[0] ** (beta + nabla))\n\n\ndef k_plus(k, x):\n    return A * k + 1 - delta - x[0] - x[1]\n\n\ndef obj_fun(x, k, v_array):\n    return -u(x) - rho * np.log(k_plus(k, x))\n\n\nalpha = 1\nbeta = 0.5\nnabla = 0.5\nA = 1\ndelta = 1\nrho = 1\n\ngrid_max = 10\ngrid_size = 250\ngrid = np.linspace(1e-5, grid_max, grid_size)\n\nx_prueba = [2, 2]\nk = 10\n\n<line_mask>\n               bounds=((0, np.inf), (0, np.inf)),\n               constraints={\"type\": \"ineq\",\n                            \"fun\": lambda x: -x[0] - x[1] + 10})\nprint(res.success)\nprint(res.x)",
            "masked_line": "res = minimize(obj_fun, x0=[5, 4], args=(k, np.log(grid)),",
            "answer": "minimize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_697"
        },
        {
            "dependency": "azure-storage-blob",
            "version": "==12.0.0",
            "time": "2019-11-25",
            "description": "The code creates a ContainerClient object for interacting with a container in Azure storage. It specifies the account URL, container name, and credential to connect to the container. It then retrieves a list of blob names within the container.",
            "code": "from azure.storage.blob import ContainerClient\n\ncontainer_client = ContainerClient(account_url='xxx', # note this is the url and not name\n                                   container_name=\"root_container\",\n                                   credential='yyy')\n\nblob_names = container_client.list_blobs()",
            "masked_code": "from azure.storage.blob import ContainerClient\n\ncontainer_client = ContainerClient(account_url='xxx', # note this is the url and not name\n                                   container_name=\"root_container\",\n                                   credential='yyy')\n\n<line_mask>",
            "masked_line": "blob_names = container_client.list_blobs()",
            "answer": "list_blobs",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_698"
        },
        {
            "dependency": "pyautogui",
            "version": "==0.9.52",
            "time": "2020-12-06",
            "description": "This code checks if the image 'foo.png' is present on the screen using PyAutoGUI. If the image is found, it prints 'image found', otherwise it prints 'ImageNotFoundException: image not found'.",
            "code": "import pyautogui\n\n# force use of ImageNotFoundException\npyautogui.useImageNotFoundException()\n\ntry:\n    location = pyautogui.locateOnScreen('foo.png')\n    print('image found')\nexcept pyautogui.ImageNotFoundException:\n    print('ImageNotFoundException: image not found')",
            "masked_code": "import pyautogui\n\n# force use of ImageNotFoundException\npyautogui.useImageNotFoundException()\n\ntry:\n    <line_mask>\n    print('image found')\nexcept pyautogui.ImageNotFoundException:\n    print('ImageNotFoundException: image not found')",
            "masked_line": "location = pyautogui.locateOnScreen('foo.png')",
            "answer": "locateOnScreen",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_699"
        },
        {
            "dependency": "torch",
            "version": "==1.4.0",
            "time": "2020-06-29",
            "description": "This code defines an LSTM neural network model with 4 layers and bidirectional functionality in PyTorch. It generates random input data, hidden states, and cell states, then runs the model to obtain output and new hidden and cell states. It exports the model to ONNX format both with default export settings and with dynamic axes specified. Finally, it checks the exported ONNX model's results against the PyTorch model's results using ONNX runtime.",
            "code": "import torch\nimport onnx\nfrom torch import nn\nimport numpy as np\nimport onnxruntime.backend as backend\nimport numpy as np\n\ntorch.manual_seed(0)\n\nlayer_count = 4\n\nmodel = nn.LSTM(10, 20, num_layers=layer_count, bidirectional=True)\nmodel.eval()\n\nwith torch.no_grad():\n    input = torch.randn(1, 3, 10)\n    h0 = torch.randn(layer_count * 2, 3, 20)\n    c0 = torch.randn(layer_count * 2, 3, 20)\n    output, (hn, cn) = model(input, (h0, c0))\n\n    # default export\n    torch.onnx.export(model, (input, (h0, c0)), 'lstm.onnx')\n    onnx_model = onnx.load('lstm.onnx')\n    # input shape [5, 3, 10]\n    print(onnx_model.graph.input[0])\n\n    # export with `dynamic_axes`\n    torch.onnx.export(model, (input, (h0, c0)), 'lstm.onnx',\n                    input_names=['input', 'h0', 'c0'],\n                    output_names=['output', 'hn', 'cn'],\n                    dynamic_axes={'input': {0: 'sequence'}, 'output': {0: 'sequence'}})\n    onnx_model = onnx.load('lstm.onnx')\n    # input shape ['sequence', 3, 10]\n\n# Check export\ny, (hn, cn) = model(input, (h0, c0))\ny_onnx, hn_onnx, cn_onnx = backend.run(\n    onnx_model, \n    [input.numpy(), h0.numpy(), c0.numpy()],\n    device='CPU'\n)\n\nnp.testing.assert_almost_equal(y_onnx, y.detach(), decimal=5)\nnp.testing.assert_almost_equal(hn_onnx, hn.detach(), decimal=5)\nnp.testing.assert_almost_equal(cn_onnx, cn.detach(), decimal=5)",
            "masked_code": "import torch\nimport onnx\nfrom torch import nn\nimport numpy as np\nimport onnxruntime.backend as backend\nimport numpy as np\n\ntorch.manual_seed(0)\n\nlayer_count = 4\n\nmodel = nn.LSTM(10, 20, num_layers=layer_count, bidirectional=True)\nmodel.eval()\n\nwith torch.no_grad():\n    input = torch.randn(1, 3, 10)\n    h0 = torch.randn(layer_count * 2, 3, 20)\n    c0 = torch.randn(layer_count * 2, 3, 20)\n    output, (hn, cn) = model(input, (h0, c0))\n\n    # default export\n    torch.onnx.export(model, (input, (h0, c0)), 'lstm.onnx')\n    onnx_model = onnx.load('lstm.onnx')\n    # input shape [5, 3, 10]\n    print(onnx_model.graph.input[0])\n\n    # export with `dynamic_axes`\n    torch.onnx.export(model, (input, (h0, c0)), 'lstm.onnx',\n                    input_names=['input', 'h0', 'c0'],\n                    output_names=['output', 'hn', 'cn'],\n                    dynamic_axes={'input': {0: 'sequence'}, 'output': {0: 'sequence'}})\n    onnx_model = onnx.load('lstm.onnx')\n    # input shape ['sequence', 3, 10]\n\n# Check export\ny, (hn, cn) = model(input, (h0, c0))\ny_onnx, hn_onnx, cn_onnx = backend.run(\n    onnx_model, \n    [input.numpy(), h0.numpy(), c0.numpy()],\n    device='CPU'\n)\n\n<line_mask>\nnp.testing.assert_almost_equal(hn_onnx, hn.detach(), decimal=5)\nnp.testing.assert_almost_equal(cn_onnx, cn.detach(), decimal=5)",
            "masked_line": "np.testing.assert_almost_equal(y_onnx, y.detach(), decimal=5)",
            "answer": "detach",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_700"
        },
        {
            "dependency": "onnx",
            "version": "==1.7.0",
            "time": "2020-06-29",
            "description": "This code defines an LSTM neural network model with bidirectional functionality in PyTorch, generates an ONNX model representation of the LSTM model, and validates the output of the ONNX model against the original PyTorch model by running both models on input data and verifying the results with tolerance.",
            "code": "import torch\nimport onnx\nfrom torch import nn\nimport numpy as np\nimport onnxruntime.backend as backend\nimport numpy as np\n\ntorch.manual_seed(0)\n\nlayer_count = 4\n\nmodel = nn.LSTM(10, 20, num_layers=layer_count, bidirectional=True)\nmodel.eval()\n\nwith torch.no_grad():\n    input = torch.randn(1, 3, 10)\n    h0 = torch.randn(layer_count * 2, 3, 20)\n    c0 = torch.randn(layer_count * 2, 3, 20)\n    output, (hn, cn) = model(input, (h0, c0))\n\n    # default export\n    torch.onnx.export(model, (input, (h0, c0)), 'lstm.onnx')\n    onnx_model = onnx.load('lstm.onnx')\n    # input shape [5, 3, 10]\n    print(onnx_model.graph.input[0])\n\n    # export with `dynamic_axes`\n    torch.onnx.export(model, (input, (h0, c0)), 'lstm.onnx',\n                    input_names=['input', 'h0', 'c0'],\n                    output_names=['output', 'hn', 'cn'],\n                    dynamic_axes={'input': {0: 'sequence'}, 'output': {0: 'sequence'}})\n    onnx_model = onnx.load('lstm.onnx')\n    # input shape ['sequence', 3, 10]\n\n# Check export\ny, (hn, cn) = model(input, (h0, c0))\ny_onnx, hn_onnx, cn_onnx = backend.run(\n    onnx_model, \n    [input.numpy(), h0.numpy(), c0.numpy()],\n    device='CPU'\n)\n\nnp.testing.assert_almost_equal(y_onnx, y.detach(), decimal=5)\nnp.testing.assert_almost_equal(hn_onnx, hn.detach(), decimal=5)\nnp.testing.assert_almost_equal(cn_onnx, cn.detach(), decimal=5)",
            "masked_code": "import torch\nimport onnx\nfrom torch import nn\nimport numpy as np\nimport onnxruntime.backend as backend\nimport numpy as np\n\ntorch.manual_seed(0)\n\nlayer_count = 4\n\nmodel = nn.LSTM(10, 20, num_layers=layer_count, bidirectional=True)\nmodel.eval()\n\nwith torch.no_grad():\n    input = torch.randn(1, 3, 10)\n    h0 = torch.randn(layer_count * 2, 3, 20)\n    c0 = torch.randn(layer_count * 2, 3, 20)\n    output, (hn, cn) = model(input, (h0, c0))\n\n    # default export\n    torch.onnx.export(model, (input, (h0, c0)), 'lstm.onnx')\n    onnx_model = onnx.load('lstm.onnx')\n    # input shape [5, 3, 10]\n    print(onnx_model.graph.input[0])\n\n    # export with `dynamic_axes`\n    torch.onnx.export(model, (input, (h0, c0)), 'lstm.onnx',\n                    input_names=['input', 'h0', 'c0'],\n                    output_names=['output', 'hn', 'cn'],\n                    dynamic_axes={'input': {0: 'sequence'}, 'output': {0: 'sequence'}})\n    onnx_model = onnx.load('lstm.onnx')\n    # input shape ['sequence', 3, 10]\n\n# Check export\ny, (hn, cn) = model(input, (h0, c0))\n<line_mask>\n    onnx_model, \n    [input.numpy(), h0.numpy(), c0.numpy()],\n    device='CPU'\n)\n\nnp.testing.assert_almost_equal(y_onnx, y.detach(), decimal=5)\nnp.testing.assert_almost_equal(hn_onnx, hn.detach(), decimal=5)\nnp.testing.assert_almost_equal(cn_onnx, cn.detach(), decimal=5)",
            "masked_line": "y_onnx, hn_onnx, cn_onnx = backend.run(",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_701"
        },
        {
            "dependency": "scipy",
            "version": "==0.16.1",
            "time": "2019-11-23",
            "description": "This code calculates the cumulative distribution function (CDF) of the standard normal distribution at 0, which returns the probability of a random variable being less than or equal to 0 under the standard normal distribution. The result is 0.5, indicating that the probability of a random variable being less than or equal to 0 is 0.5.",
            "code": "from scipy import stats\nstats.norm.cdf(0)\n0.5",
            "masked_code": "from scipy import stats\n<line_mask>\n0.5",
            "masked_line": "stats.norm.cdf(0)",
            "answer": "cdf",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_702"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.15.0",
            "time": "2019-10-30",
            "description": "The code creates a constant tensor using TensorFlow with values [1, 2, 3] and prints it, enabling eager mode. It also prints the second dimension of a TensorShape object [1, 2], which is 2.",
            "code": "import os\nos.environ['TF2_BEHAVIOR'] = '1'\nimport tensorflow as tf\n\nprint(tf.constant([1, 2, 3]))  # Eager mode is enabled\n# tf.Tensor([1 2 3], shape=(3,), dtype=int32)\nprint(tf.TensorShape([1, 2])[1])  # TensorShape dimensions are int\n# 2",
            "masked_code": "import os\nos.environ['TF2_BEHAVIOR'] = '1'\nimport tensorflow as tf\n\n<line_mask>\n# tf.Tensor([1 2 3], shape=(3,), dtype=int32)\nprint(tf.TensorShape([1, 2])[1])  # TensorShape dimensions are int\n# 2",
            "masked_line": "print(tf.constant([1, 2, 3]))  # Eager mode is enabled",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_703"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2019-05-19",
            "description": "The code generates a 1x13 array of random numbers using NumPy and prints the array.",
            "code": "import numpy as np\n\nnp.set_printoptions(linewidth=np.inf)\n\na = np.random.rand(1,13)\nprint(a)  # expected output",
            "masked_code": "import numpy as np\n\nnp.set_printoptions(linewidth=np.inf)\n\n<line_mask>\nprint(a)  # expected output",
            "masked_line": "a = np.random.rand(1,13)",
            "answer": "rand",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_704"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-05-05",
            "description": "The code defines a command-line application with a 'configcmd' command that includes a 'test_cmd' subcommand. When executed, the application prints version information for Click and Python, and then iterates through a set of commands, including executing the 'configcmd test_cmd' and 'configcmd --help' commands. The application catches exceptions during command execution and handles them appropriately.",
            "code": "import sys\nimport click\n\nfrom commands.config_cmd import configcmd\n\n\n@click.group()\n@click.version_option()\ndef cli(args=None):\n    \"\"\"A command line application\"\"\"\n    return 0\n\n\ncli.add_command(configcmd)\n\n\n@configcmd.command()\ndef test_cmd():\n    click.echo('In test_cmd')\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'configcmd test_cmd',\n        'configcmd --help',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import sys\nimport click\n\nfrom commands.config_cmd import configcmd\n\n\n<line_mask>\n@click.version_option()\ndef cli(args=None):\n    \"\"\"A command line application\"\"\"\n    return 0\n\n\ncli.add_command(configcmd)\n\n\n@configcmd.command()\ndef test_cmd():\n    click.echo('In test_cmd')\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'configcmd test_cmd',\n        'configcmd --help',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.group()",
            "answer": "group",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_705"
        },
        {
            "dependency": "keras",
            "version": "==2.0.9",
            "time": "2019-03-11",
            "description": "This Python code defines a custom Attention Layer class (AttLayer) for a neural network model. The purpose of this class is to compute the attention weights for input sequences and apply those weights to the input sequences to generate a weighted output representation. The attention mechanism helps the model focus on different parts of the input sequence during the prediction process. The class includes functions to build the attention mechanism, compute the attention weights, apply the weights to the input sequences, and compute the final output representation based on the weighted inputs. Additionally, the class includes functions to handle masking and configuration for model saving and loading.",
            "code": "import tensorflow as tf\nimport numpy as np\nimport pandas as pd\nimport re\nfrom bs4 import BeautifulSoup\nimport os\nfrom keras.preprocessing.text import Tokenizer, text_to_word_sequence\nfrom keras.utils import plot_model\nfrom keras.utils.np_utils import to_categorical\nfrom keras.layers import Dense, Input\nfrom keras.layers import Embedding, GRU, Bidirectional, TimeDistributed, Lambda\nfrom keras.models import Model\nfrom keras import backend as K\nfrom keras.engine.topology import Layer\nfrom keras import initializers\n\nclass AttLayer(Layer):\n    def __init__(self, attention_dim, **kwargs):\n        self.init = initializers.get('normal')\n        self.supports_masking = True\n        self.attention_dim = attention_dim\n        super(AttLayer, self).__init__(**kwargs)\n\n    def build(self, input_shape):\n        assert len(input_shape) == 3\n        self.W = K.variable(self.init((input_shape[-1], self.attention_dim)))\n        self.b = K.variable(self.init((self.attention_dim,)))\n        self.u = K.variable(self.init((self.attention_dim, 1)))\n        self.trainable_weights = [self.W, self.b, self.u]\n        super(AttLayer, self).build(input_shape)\n\n    def compute_mask(self, inputs, mask=None):\n        return None\n\n    def call(self, x, mask=None):\n        # size of x :[batch_size, sel_len, attention_dim]\n        # size of u :[batch_size, attention_dim]\n        # uit = tanh(xW+b)\n        uit = K.tile(K.expand_dims(self.W, axis=0), (K.shape(x)[0], 1, 1))\n        uit = tf.matmul(x, uit)\n        uit = K.tanh(K.bias_add(uit, self.b))\n        ait = K.dot(uit, self.u)\n        ait = K.squeeze(ait, -1)\n\n        ait = K.exp(ait)\n\n        if mask is not None:\n            # Cast the mask to floatX to avoid float64 upcasting in theano\n            ait *= K.cast(mask, K.floatx())\n        ait /= K.cast(K.sum(ait, axis=1, keepdims=True) + K.epsilon(), K.floatx())\n        ait = K.expand_dims(ait)\n        weighted_input = x * ait\n        output = K.sum(weighted_input, axis=1)\n\n        return output\n\n    def compute_output_shape(self, input_shape):\n        return (input_shape[0], input_shape[-1])\n\n    # https://github.com/keras-team/keras/issues/5401\n    # solve the problem of keras.models.clone_model\n    # and model.save_weights, model.load_weights\n    def get_config(self):\n        config = {'attention_dim': self.attention_dim}\n        base_config = super(AttLayer, self).get_config()\n        return dict(list(base_config.items()) + list(config.items()))",
            "masked_code": "import tensorflow as tf\nimport numpy as np\nimport pandas as pd\nimport re\nfrom bs4 import BeautifulSoup\nimport os\nfrom keras.preprocessing.text import Tokenizer, text_to_word_sequence\nfrom keras.utils import plot_model\nfrom keras.utils.np_utils import to_categorical\nfrom keras.layers import Dense, Input\nfrom keras.layers import Embedding, GRU, Bidirectional, TimeDistributed, Lambda\nfrom keras.models import Model\nfrom keras import backend as K\nfrom keras.engine.topology import Layer\nfrom keras import initializers\n\nclass AttLayer(Layer):\n    def __init__(self, attention_dim, **kwargs):\n        self.init = initializers.get('normal')\n        self.supports_masking = True\n        self.attention_dim = attention_dim\n        super(AttLayer, self).__init__(**kwargs)\n\n    def build(self, input_shape):\n        assert len(input_shape) == 3\n        self.W = K.variable(self.init((input_shape[-1], self.attention_dim)))\n        self.b = K.variable(self.init((self.attention_dim,)))\n        self.u = K.variable(self.init((self.attention_dim, 1)))\n        self.trainable_weights = [self.W, self.b, self.u]\n        super(AttLayer, self).build(input_shape)\n\n    def compute_mask(self, inputs, mask=None):\n        return None\n\n    def call(self, x, mask=None):\n        # size of x :[batch_size, sel_len, attention_dim]\n        # size of u :[batch_size, attention_dim]\n        # uit = tanh(xW+b)\n        uit = K.tile(K.expand_dims(self.W, axis=0), (K.shape(x)[0], 1, 1))\n        uit = tf.matmul(x, uit)\n        uit = K.tanh(K.bias_add(uit, self.b))\n        ait = K.dot(uit, self.u)\n        ait = K.squeeze(ait, -1)\n\n        ait = K.exp(ait)\n\n        if mask is not None:\n            # Cast the mask to floatX to avoid float64 upcasting in theano\n            ait *= K.cast(mask, K.floatx())\n        <line_mask>\n        ait = K.expand_dims(ait)\n        weighted_input = x * ait\n        output = K.sum(weighted_input, axis=1)\n\n        return output\n\n    def compute_output_shape(self, input_shape):\n        return (input_shape[0], input_shape[-1])\n\n    # https://github.com/keras-team/keras/issues/5401\n    # solve the problem of keras.models.clone_model\n    # and model.save_weights, model.load_weights\n    def get_config(self):\n        config = {'attention_dim': self.attention_dim}\n        base_config = super(AttLayer, self).get_config()\n        return dict(list(base_config.items()) + list(config.items()))",
            "masked_line": "ait /= K.cast(K.sum(ait, axis=1, keepdims=True) + K.epsilon(), K.floatx())",
            "answer": "epsilon",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_706"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-01-07",
            "description": "The code initializes a TensorFlow session with GPU memory allocation set to allow growth.",
            "code": "from tensorflow.compat.v1 import ConfigProto\nfrom tensorflow.compat.v1 import InteractiveSession\nconfig = ConfigProto()\nconfig.gpu_options.allow_growth = True\nsession = InteractiveSession(config=config)",
            "masked_code": "from tensorflow.compat.v1 import ConfigProto\n<line_mask>\nconfig = ConfigProto()\nconfig.gpu_options.allow_growth = True\nsession = InteractiveSession(config=config)",
            "masked_line": "from tensorflow.compat.v1 import InteractiveSession",
            "answer": "InteractiveSession",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_707"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24",
            "time": "2019-08-29",
            "description": "The code reads a dataset 'weatherHistory.csv' into a pandas DataFrame and converts the 'Formatted Date' column into a datetime format with UTC timezone.",
            "code": "import pandas as pd\n\n# load dataset\ndf = pd.read_csv('weatherHistory.csv')\n\ndf['Date'] = df['Formatted Date'].apply(pd.to_datetime, utc=True)",
            "masked_code": "import pandas as pd\n\n# load dataset\n<line_mask>\n\ndf['Date'] = df['Formatted Date'].apply(pd.to_datetime, utc=True)",
            "masked_line": "df = pd.read_csv('weatherHistory.csv')",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_708"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-23",
            "description": "The code generates a Bokeh plot with two tabs, each containing different content. The first tab displays a line plot with x values of 1 and 2, and y values of 3 and 4. The second tab displays a paragraph with the text \"Another tab\". The plot and paragraph are displayed within a column layout and saved to an output file using a specified template.",
            "code": "from bokeh.plotting import save, figure\nfrom bokeh.models import Paragraph, Panel, Tabs, Column\n\ntemplate = \"\"\"\n{% block postamble %}\n\n{% endblock %}\n\"\"\"\n\np = Paragraph(text = \"Another tab\", width = 600)\n\nplot = figure()\nplot.line(x = [1, 2], y = [3, 4])\ntabs = [Panel(title = 'Tab1', child = plot)]\ntabs.append(Panel(title = 'Tab2', child = p))\n\nsave(Column(Tabs(tabs = tabs, width = 600)), template = template)",
            "masked_code": "<line_mask>\nfrom bokeh.models import Paragraph, Panel, Tabs, Column\n\ntemplate = \"\"\"\n{% block postamble %}\n\n{% endblock %}\n\"\"\"\n\np = Paragraph(text = \"Another tab\", width = 600)\n\nplot = figure()\nplot.line(x = [1, 2], y = [3, 4])\ntabs = [Panel(title = 'Tab1', child = plot)]\ntabs.append(Panel(title = 'Tab2', child = p))\n\nsave(Column(Tabs(tabs = tabs, width = 600)), template = template)",
            "masked_line": "from bokeh.plotting import save, figure",
            "answer": "save",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_709"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-30",
            "description": "This code takes an input of shape [None, 3], reshapes it to [1, 1, 3], then broadcasts it to a larger shape [None, 5, 5, 3]. Finally, it creates a TensorFlow model that takes this reshaped and broadcasted input and outputs the shape (8, 5, 5, 3) when given a random input of size (8, 3).",
            "code": "import tensorflow as tf\nimport tensorflow.keras.layers as kl\nimport numpy as np\n\nx = tf.keras.Input([3])  # Shape [None, 3]\ny = kl.Reshape([1, 1, 3])(x)  # Need to add empty dims before broadcasting\n# Retain the batch and depth dimensions, but broadcast along H and W\nbroadcast_shape = tf.where([True, False, False, True],\n                           tf.shape(y), [0, 5, 5, 0])\ny = tf.broadcast_to(y, broadcast_shape)  # Broadcast to shape [None, 5, 5, 3]\n\nmodel = tf.keras.Model(inputs=x, outputs=y)\n\nprint(model(np.random.random(size=(8, 3))).shape)\n# prints: \"(8, 5, 5, 3)\"",
            "masked_code": "import tensorflow as tf\nimport tensorflow.keras.layers as kl\nimport numpy as np\n\nx = tf.keras.Input([3])  # Shape [None, 3]\ny = kl.Reshape([1, 1, 3])(x)  # Need to add empty dims before broadcasting\n# Retain the batch and depth dimensions, but broadcast along H and W\nbroadcast_shape = tf.where([True, False, False, True],\n                           tf.shape(y), [0, 5, 5, 0])\ny = tf.broadcast_to(y, broadcast_shape)  # Broadcast to shape [None, 5, 5, 3]\n\nmodel = tf.keras.Model(inputs=x, outputs=y)\n\n<line_mask>\n# prints: \"(8, 5, 5, 3)\"",
            "masked_line": "print(model(np.random.random(size=(8, 3))).shape)",
            "answer": "model",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_710"
        },
        {
            "dependency": "seaborn",
            "version": ">=0.9",
            "time": "2019-08-25",
            "description": "This code generates a PairGrid plot using seaborn with a dataset containing columns 'mpg', 'horsepower', 'weight', and 'origin'. It then plots regression and residual plots in the upper and lower triangles of the grid, and histograms on the diagonal.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd \n\ndf = sns.load_dataset('mpg')\n\ng = sns.PairGrid(data=df[[\"mpg\", \"horsepower\", \"weight\", \"origin\"]], hue=\"origin\")\ng.map_upper(sns.regplot)\ng.map_lower(sns.residplot)\n\n# below for the histograms on the diagonal\nd = {}\ndef func(x, **kwargs):\n    ax = plt.gca()\n\n    if not ax in d.keys():\n        d[ax] = {\"data\" : [], \"color\" : []}\n    d[ax][\"data\"].append(x)\n    d[ax][\"color\"].append(kwargs.get(\"color\"))\n\ng.map_diag(func)\nfor ax, dic in d.items():\n    ax.hist(dic[\"data\"], color=dic[\"color\"], histtype=\"barstacked\")\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd \n\n<line_mask>\n\ng = sns.PairGrid(data=df[[\"mpg\", \"horsepower\", \"weight\", \"origin\"]], hue=\"origin\")\ng.map_upper(sns.regplot)\ng.map_lower(sns.residplot)\n\n# below for the histograms on the diagonal\nd = {}\ndef func(x, **kwargs):\n    ax = plt.gca()\n\n    if not ax in d.keys():\n        d[ax] = {\"data\" : [], \"color\" : []}\n    d[ax][\"data\"].append(x)\n    d[ax][\"color\"].append(kwargs.get(\"color\"))\n\ng.map_diag(func)\nfor ax, dic in d.items():\n    ax.hist(dic[\"data\"], color=dic[\"color\"], histtype=\"barstacked\")\n\nplt.show()",
            "masked_line": "df = sns.load_dataset('mpg')",
            "answer": "load_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_711"
        },
        {
            "dependency": "dash",
            "version": "==1.6.0",
            "time": "2019-11-25",
            "description": "This code creates a dashboard using Dash, displaying a DataTable with randomly generated data for columns 'x' and 'y'. The data in the DataTable updates every 1 second using an interval component.",
            "code": "import dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport dash_table\nimport pandas as pd\nimport numpy as np\n\napp = dash.Dash(__name__)\n\ndef getData():\n    df = pd.DataFrame()\n    for idx in range(10):\n        data  = {'x': np.random.random(1)[0], 'y': np.random.random(1)[0]}\n        df = df.append(data, ignore_index=True)\n    return df.to_dict('records')\n\ntblcols=[{'name': 'x', 'id': 'x'},\n         {'name': 'y', 'id': 'y'}, ]\n\napp.layout = html.Div([\n      html.H4('Dashboard'),\n      dcc.Interval('graph-update', interval = 1000, n_intervals = 0),\n      dash_table.DataTable(\n          id = 'table',\n          data = getData(),\n          columns=tblcols)])\n\n@app.callback(\n        dash.dependencies.Output('table','data'),\n        [dash.dependencies.Input('graph-update', 'n_intervals')])\ndef updateTable(n):\n     return getData()\n\nif __name__ == '__main__':\n     app.run_server(debug=False)",
            "masked_code": "import dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport dash_table\nimport pandas as pd\nimport numpy as np\n\n<line_mask>\n\ndef getData():\n    df = pd.DataFrame()\n    for idx in range(10):\n        data  = {'x': np.random.random(1)[0], 'y': np.random.random(1)[0]}\n        df = df.append(data, ignore_index=True)\n    return df.to_dict('records')\n\ntblcols=[{'name': 'x', 'id': 'x'},\n         {'name': 'y', 'id': 'y'}, ]\n\napp.layout = html.Div([\n      html.H4('Dashboard'),\n      dcc.Interval('graph-update', interval = 1000, n_intervals = 0),\n      dash_table.DataTable(\n          id = 'table',\n          data = getData(),\n          columns=tblcols)])\n\n@app.callback(\n        dash.dependencies.Output('table','data'),\n        [dash.dependencies.Input('graph-update', 'n_intervals')])\ndef updateTable(n):\n     return getData()\n\nif __name__ == '__main__':\n     app.run_server(debug=False)",
            "masked_line": "app = dash.Dash(__name__)",
            "answer": "Dash",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_712"
        },
        {
            "dependency": "dash",
            "version": "==1.6.0",
            "time": "2019-11-14",
            "description": "The code is a Python script that uses Dash to create a web application for visualizing stock prices. It reads a dataset from an online source, sets up a graph layout with specific colors and axes titles, and plots the data as a scatter plot. The application allows users to interact with the plot by hovering over data points or adjusting the x-axis range.",
            "code": "import dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport pandas as pd\nimport plotly.graph_objs as go\nfrom dash.dependencies import Input, Output, State\n\nexternal_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\ndf = pd.read_csv(\"https://raw.githubusercontent.com/plotly/datasets/master/finance-charts-apple.csv\")\n\nlayout = go.Layout( colorway=[\"#5E0DAC\", '#FF4F00', '#375CB1', '#FF7400', '#FFF400', '#FF0056'],\n                    height=600,\n                    title=f\"Closing prices\",\n                    xaxis={\"title\": \"Date\",\n                           'rangeselector': {'buttons': list([{'count': 1, 'label': '1M',\n                                                               'step': 'month',\n                                                               'stepmode': 'backward'},\n                                                              {'count': 6, 'label': '6M',\n                                                               'step': 'month',\n                                                               'stepmode': 'backward'},\n                                                              {'step': 'all'}]\n                                              ),  \n                           },\n                           'rangeslider': {'visible': True}, \n                           'type': 'date',            \n                    },\n                    yaxis={\"title\": \"Price (USD)\"},\n)\n\ntraces = [go.Scatter(   x=df.Date,\n                        y=df['AAPL.High'],\n                        mode='lines',\n                        opacity=0.7,\n                        connectgaps=True\n)]\n\napp.layout = html.Div([\n    dcc.Graph(\n        id='stock-plot',\n        figure={\n            'data': traces,\n            'layout': layout\n        }        \n    ),\n], className=\"container\")\n\n@app.callback(\n    Output('stock-plot', 'figure'),\n    [Input('stock-plot', 'hoverData'),\n     Input('stock-plot', 'relayoutData')],\n    [State('stock-plot', 'figure')]\n)\ndef drawStockPrice(hoverData, selected, figure):\n    data = figure['data']\n    layout = figure['layout']\n\n    if selected is not None and 'xaxis.range' in selected:\n        layout['xaxis']['range'] = selected['xaxis.range']\n\n    return {'data': data,\n            'layout': layout\n    }\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "import dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport pandas as pd\nimport plotly.graph_objs as go\nfrom dash.dependencies import Input, Output, State\n\nexternal_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\ndf = pd.read_csv(\"https://raw.githubusercontent.com/plotly/datasets/master/finance-charts-apple.csv\")\n\nlayout = go.Layout( colorway=[\"#5E0DAC\", '#FF4F00', '#375CB1', '#FF7400', '#FFF400', '#FF0056'],\n                    height=600,\n                    title=f\"Closing prices\",\n                    xaxis={\"title\": \"Date\",\n                           'rangeselector': {'buttons': list([{'count': 1, 'label': '1M',\n                                                               'step': 'month',\n                                                               'stepmode': 'backward'},\n                                                              {'count': 6, 'label': '6M',\n                                                               'step': 'month',\n                                                               'stepmode': 'backward'},\n                                                              {'step': 'all'}]\n                                              ),  \n                           },\n                           'rangeslider': {'visible': True}, \n                           'type': 'date',            \n                    },\n                    yaxis={\"title\": \"Price (USD)\"},\n)\n\ntraces = [go.Scatter(   x=df.Date,\n                        y=df['AAPL.High'],\n                        mode='lines',\n                        opacity=0.7,\n                        connectgaps=True\n)]\n\napp.layout = html.Div([\n    dcc.Graph(\n        id='stock-plot',\n        figure={\n            'data': traces,\n            'layout': layout\n        }        \n    ),\n], className=\"container\")\n\n<line_mask>\n    Output('stock-plot', 'figure'),\n    [Input('stock-plot', 'hoverData'),\n     Input('stock-plot', 'relayoutData')],\n    [State('stock-plot', 'figure')]\n)\ndef drawStockPrice(hoverData, selected, figure):\n    data = figure['data']\n    layout = figure['layout']\n\n    if selected is not None and 'xaxis.range' in selected:\n        layout['xaxis']['range'] = selected['xaxis.range']\n\n    return {'data': data,\n            'layout': layout\n    }\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_line": "@app.callback(",
            "answer": "callback",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_713"
        },
        {
            "dependency": "osmnx",
            "version": "<0.15.0",
            "time": "2019-03-01",
            "description": "The code retrieves the geographic outline data for the city of Salzburg and the state of Salzburg using the OSMNx library.",
            "code": "import osmnx as ox\noutline_city = ox.gdf_from_place({'city':'Salzburg'})\noutline_state = ox.gdf_from_place({'state':'Salzburg'})",
            "masked_code": "import osmnx as ox\noutline_city = ox.gdf_from_place({'city':'Salzburg'})\n<line_mask>",
            "masked_line": "outline_state = ox.gdf_from_place({'state':'Salzburg'})",
            "answer": "gdf_from_place",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_714"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-08-28",
            "description": "This code defines a `MapFitter` class that fits a mapping transformation between pixel coordinates and longitude/latitude coordinates based on a list of coordinates. The `coeffs` property calculates the coefficients for the linear transformation using least squares method. The `transform` method applies the transformation to a given pixel coordinate to return the corresponding longitude and latitude coordinates.",
            "code": "from dataclasses import dataclass\nfrom typing import List, Dict\nimport numpy as np\nfrom cached_property import cached_property\n\n\n@dataclass\nclass MapFitter:\n    coords: List[Dict[str, object]]\n\n    @cached_property\n    def coeffs(self):\n        lnglat = np.vstack(tuple(\n            np.array([[coord['lnglat']['lng']], [coord['lnglat']['lat']]]) for coord in coords))\n\n        xy = np.vstack(tuple(\n            np.array([[coord['pixel']['x'], 0, 1, 0], [0, coord['pixel']['y'], 0, 1]]) for coord in coords))\n\n        coefficients, residuals, rank, singular_values = np.linalg.lstsq(\n            a=xy, b=lnglat, rcond=None)\n\n        return coefficients\n\n    def transform(self, xy_coord):\n        x, y = xy_coord\n        scale_lng, scale_lat, offset_lng, offset_lat = self.coeffs\n        return [scale_lng * x + offset_lng, scale_lat * y + offset_lat]",
            "masked_code": "from dataclasses import dataclass\nfrom typing import List, Dict\nimport numpy as np\nfrom cached_property import cached_property\n\n\n@dataclass\nclass MapFitter:\n    coords: List[Dict[str, object]]\n\n    @cached_property\n    def coeffs(self):\n        lnglat = np.vstack(tuple(\n            np.array([[coord['lnglat']['lng']], [coord['lnglat']['lat']]]) for coord in coords))\n\n        xy = np.vstack(tuple(\n            np.array([[coord['pixel']['x'], 0, 1, 0], [0, coord['pixel']['y'], 0, 1]]) for coord in coords))\n\n        <line_mask>\n            a=xy, b=lnglat, rcond=None)\n\n        return coefficients\n\n    def transform(self, xy_coord):\n        x, y = xy_coord\n        scale_lng, scale_lat, offset_lng, offset_lat = self.coeffs\n        return [scale_lng * x + offset_lng, scale_lat * y + offset_lat]",
            "masked_line": "coefficients, residuals, rank, singular_values = np.linalg.lstsq(",
            "answer": "lstsq",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_715"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4",
            "time": "2020-12-17",
            "description": "The code defines a custom model `MyModel` using TensorFlow's Keras API with two dense layers. It also defines a custom data generator `MyGenerator` that generates a single batch of data during training. The model is compiled with stochastic gradient descent optimizer and mean squared error loss function, and then trained on the data generated by the generator.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\nimport numpy as np\n\n\nclass MyModel(tf.keras.Model):\n\n    def __init__(self):\n        super(MyModel, self).__init__()\n        self.dense1 = tf.keras.layers.Dense(3, activation=tf.nn.relu)\n        self.dense2 = tf.keras.layers.Dense(3, activation=tf.nn.softmax)\n\n    def call(self, inputs, training=None, mask=None):\n        return self.dense2(self.dense1(inputs))\n\n\nclass MyGenerator(tf.keras.utils.Sequence):\n\n    def __len__(self):\n        # Number of batches per epoch\n        return 1\n\n    def __getitem__(self, _):\n        # Generate one batch of data\n        x = np.array([[1., 2., 3.]])\n        y = np.array([[0., 1., 0.5]])\n\n        return x, y\n\n\nif __name__ == '__main__':\n    m = MyModel()    \n    g = MyGenerator()\n\n    m.compile(tf.keras.optimizers.SGD(), loss=tf.keras.losses.mean_squared_error)\n    m.fit(g)",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\nimport numpy as np\n\n\nclass MyModel(tf.keras.Model):\n\n    def __init__(self):\n        super(MyModel, self).__init__()\n        <line_mask>\n        self.dense2 = tf.keras.layers.Dense(3, activation=tf.nn.softmax)\n\n    def call(self, inputs, training=None, mask=None):\n        return self.dense2(self.dense1(inputs))\n\n\nclass MyGenerator(tf.keras.utils.Sequence):\n\n    def __len__(self):\n        # Number of batches per epoch\n        return 1\n\n    def __getitem__(self, _):\n        # Generate one batch of data\n        x = np.array([[1., 2., 3.]])\n        y = np.array([[0., 1., 0.5]])\n\n        return x, y\n\n\nif __name__ == '__main__':\n    m = MyModel()    \n    g = MyGenerator()\n\n    m.compile(tf.keras.optimizers.SGD(), loss=tf.keras.losses.mean_squared_error)\n    m.fit(g)",
            "masked_line": "self.dense1 = tf.keras.layers.Dense(3, activation=tf.nn.relu)",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_716"
        },
        {
            "dependency": "scikit-image",
            "version": "==0.18.x",
            "time": "2021-06-28",
            "description": "The code calculates the structural similarity index between two grayscale images.",
            "code": "from skimage import metrics\n\nmetrics.structural_similarity(grayA, grayB, full=True)",
            "masked_code": "from skimage import metrics\n\n<line_mask>",
            "masked_line": "metrics.structural_similarity(grayA, grayB, full=True)",
            "answer": "structural_similarity",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_717"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20",
            "time": "2019-03-22",
            "description": "This code divides the dataset 'X' and target variable 'y' into training and testing sets, with 80% of the data being allocated for training and 20% for testing.",
            "code": "from sklearn.model_selection import train_test_split\n# [...]\nX_train, X_test, y_train, y_test=train_test_split(X,y,test_size=0.2)",
            "masked_code": "<line_mask>\n# [...]\nX_train, X_test, y_train, y_test=train_test_split(X,y,test_size=0.2)",
            "masked_line": "from sklearn.model_selection import train_test_split",
            "answer": "train_test_split",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_718"
        },
        {
            "dependency": "aiohttp",
            "version": "==1.0.0",
            "time": "2019-03-26",
            "description": "The code creates a Discord client that uses a proxy connector with basic authentication.",
            "code": "from aiohttp import ProxyConnector, BasicAuth\n\nbasic_auth = BasicAuth(USER_PROXY_LOGIN, USER_PROXY_PASS)\nconnector = ProxyConnector(USER_PROXY, proxy_auth=basic_auth)\n\ncient = discord.Client(connector=connector)",
            "masked_code": "from aiohttp import ProxyConnector, BasicAuth\n\nbasic_auth = BasicAuth(USER_PROXY_LOGIN, USER_PROXY_PASS)\n<line_mask>\n\ncient = discord.Client(connector=connector)",
            "masked_line": "connector = ProxyConnector(USER_PROXY, proxy_auth=basic_auth)",
            "answer": "ProxyConnector",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_719"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-01-20",
            "description": "The code calculates the roots of a nonlinear equation system using the fsolve function from the scipy.optimize package. The equations are defined in the func and derivative functions, and the roots are computed by minimizing the difference between func and K.",
            "code": "import numpy as np\nimport scipy.optimize as optimize\n\nnp.random.seed(123)\n\ndef func(x, f, g, K):\n    return np.sum(f * np.exp(-g*x[:, None]), axis=-1) - K\n\n\ndef derivative(x, f, g, K):\n    return np.sum(-g*f * np.exp(-g*x[:, None]), axis=-1)\n\n\nf = np.random.uniform(size=(47,))\ng = np.random.uniform(size=f.shape)\nK = np.random.uniform(size=(4072,3080))\nKshape = K.shape\nK = K.ravel()\n\nres = optimize.fsolve(func, x0=np.ones(K.shape).ravel(), args=(f, g, K))\nres = res.reshape(Kshape)\nprint(res)",
            "masked_code": "import numpy as np\nimport scipy.optimize as optimize\n\nnp.random.seed(123)\n\ndef func(x, f, g, K):\n    return np.sum(f * np.exp(-g*x[:, None]), axis=-1) - K\n\n\ndef derivative(x, f, g, K):\n    return np.sum(-g*f * np.exp(-g*x[:, None]), axis=-1)\n\n\nf = np.random.uniform(size=(47,))\ng = np.random.uniform(size=f.shape)\nK = np.random.uniform(size=(4072,3080))\nKshape = K.shape\nK = K.ravel()\n\n<line_mask>\nres = res.reshape(Kshape)\nprint(res)",
            "masked_line": "res = optimize.fsolve(func, x0=np.ones(K.shape).ravel(), args=(f, g, K))",
            "answer": "fsolve",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_720"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-30",
            "description": "This code generates a choropleth map using Bokeh library with random categories assigned to different geographical features. Each category is assigned a unique color and displayed on the map with a legend indicating the category. The map can be interactively viewed and the legend can be hidden by clicking on it. Additionally, there is a line of code for exporting the map as a PNG image file.",
            "code": "from bokeh.models import GeoJSONDataSource, CategoricalColorMapper\nfrom bokeh.plotting import figure, show\nfrom bokeh.io import export_png\nimport geopandas as gpd\nimport random\nimport json\n\ngdf = gpd.GeoDataFrame.from_file(\"Judete/Judete.shp\")\ngdf_json = gdf.to_json()\ngjson = json.loads(gdf_json)\n\ncategories = ['A', 'B', 'C', 'D', 'E']\nfor item in gjson['features']:\n    item['properties']['category'] = random.choice(categories)\n\nsource_shapes = {}\nfor category in categories:\n    source_shapes[category] = {\"type\": \"FeatureCollection\", \"features\": []}\n\nfor item in gjson['features']:\n    source_shapes[item['properties']['category']]['features'].append(item)\n\np = figure(match_aspect = True, min_border = 0,\n           h_symmetry = False, v_symmetry = False,\n           x_axis_location = None, y_axis_location = None)\n\ncmap = CategoricalColorMapper(palette = [\"orange\", \"purple\", \"pink\", \"brown\", \"blue\"], \n                              factors = ['A', 'B', 'C', 'D', 'E'])\nfor category in categories:\n    source_shape = GeoJSONDataSource(geojson = json.dumps(source_shapes[category]))\n    p.patches('xs', 'ys', fill_color = {'field': 'category', 'transform': cmap},\n                          line_color = 'black', line_width = 0.5,\n                          legend = category, source = source_shape,)\np.legend.click_policy = 'hide'\nshow(p) # export_png(p, filename = \"map.png\")",
            "masked_code": "from bokeh.models import GeoJSONDataSource, CategoricalColorMapper\nfrom bokeh.plotting import figure, show\nfrom bokeh.io import export_png\nimport geopandas as gpd\nimport random\nimport json\n\ngdf = gpd.GeoDataFrame.from_file(\"Judete/Judete.shp\")\ngdf_json = gdf.to_json()\ngjson = json.loads(gdf_json)\n\ncategories = ['A', 'B', 'C', 'D', 'E']\nfor item in gjson['features']:\n    item['properties']['category'] = random.choice(categories)\n\nsource_shapes = {}\nfor category in categories:\n    source_shapes[category] = {\"type\": \"FeatureCollection\", \"features\": []}\n\nfor item in gjson['features']:\n    source_shapes[item['properties']['category']]['features'].append(item)\n\n<line_mask>\n           h_symmetry = False, v_symmetry = False,\n           x_axis_location = None, y_axis_location = None)\n\ncmap = CategoricalColorMapper(palette = [\"orange\", \"purple\", \"pink\", \"brown\", \"blue\"], \n                              factors = ['A', 'B', 'C', 'D', 'E'])\nfor category in categories:\n    source_shape = GeoJSONDataSource(geojson = json.dumps(source_shapes[category]))\n    p.patches('xs', 'ys', fill_color = {'field': 'category', 'transform': cmap},\n                          line_color = 'black', line_width = 0.5,\n                          legend = category, source = source_shape,)\np.legend.click_policy = 'hide'\nshow(p) # export_png(p, filename = \"map.png\")",
            "masked_line": "p = figure(match_aspect = True, min_border = 0,",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_721"
        },
        {
            "dependency": "scipy",
            "version": "==0.18.1",
            "time": "2019-01-30",
            "description": "This code generates a 3D plot showing the interpolation of a theoretical function over a set of unstructured mesh nodes. The theoretical function is defined with the F(x, y) function and is calculated for the provided nodes. The code then creates a finer regular grid, interpolates the values using CloughTocher2DInterpolator, and plots the original mesh nodes as red points and the interpolated values as a wireframe in black.",
            "code": "import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nimport numpy as np\nfrom scipy.interpolate import CloughTocher2DInterpolator\nfrom scipy.spatial import Delaunay\n\n# Example unstructured mesh:\nnodes = np.array([[-1.        , -1.        ],\n       [ 1.        , -1.        ],\n       [ 1.        ,  1.        ],\n       [-1.        ,  1.        ],\n       [ 0.        ,  0.        ],\n       [-1.        ,  0.        ],\n       [ 0.        , -1.        ],\n       [-0.5       ,  0.        ],\n       [ 0.        ,  1.        ],\n       [-0.75      ,  0.4       ],\n       [-0.5       ,  1.        ],\n       [-1.        , -0.6       ],\n       [-0.25      , -0.5       ],\n       [-0.5       , -1.        ],\n       [-0.20833333,  0.5       ],\n       [ 1.        ,  0.        ],\n       [ 0.5       ,  1.        ],\n       [ 0.36174242,  0.44412879],\n       [ 0.5       , -0.03786566],\n       [ 0.2927264 , -0.5411368 ],\n       [ 0.5       , -1.        ],\n       [ 1.        ,  0.5       ],\n       [ 1.        , -0.5       ]])\n\n# Theoretical function:\ndef F(x, y):\n    return x + y -  x*y - (x*y)**2 - 2*x*y**2 + x**2*y + 3*np.exp( -((x+1)**2 + (y+1)**2)*5 )\n\nz = F(nodes[:, 0], nodes[:, 1])\n\n# Finer regular grid:\nN2 = 19\nx2, y2 = np.linspace(-1, 1, N2), np.linspace(-1, 1, N2)\nX2, Y2 = np.meshgrid(x2, y2)\n\n# Interpolation:\ntri = Delaunay(nodes)\nCT_interpolator = CloughTocher2DInterpolator(tri, z)\nz_interpolated = CT_interpolator(X2, Y2)\n\n# Plot\nfig = plt.figure(1, figsize=(8,14))\n\nax = fig.add_subplot(311, projection='3d')\nax.scatter3D(nodes[:, 0], nodes[:, 1], z, s=15, color='red', label='points')\n\nax.plot_wireframe(X2, Y2, z_interpolated, color='black', label='interpolated')\nplt.legend();",
            "masked_code": "import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nimport numpy as np\n<line_mask>\nfrom scipy.spatial import Delaunay\n\n# Example unstructured mesh:\nnodes = np.array([[-1.        , -1.        ],\n       [ 1.        , -1.        ],\n       [ 1.        ,  1.        ],\n       [-1.        ,  1.        ],\n       [ 0.        ,  0.        ],\n       [-1.        ,  0.        ],\n       [ 0.        , -1.        ],\n       [-0.5       ,  0.        ],\n       [ 0.        ,  1.        ],\n       [-0.75      ,  0.4       ],\n       [-0.5       ,  1.        ],\n       [-1.        , -0.6       ],\n       [-0.25      , -0.5       ],\n       [-0.5       , -1.        ],\n       [-0.20833333,  0.5       ],\n       [ 1.        ,  0.        ],\n       [ 0.5       ,  1.        ],\n       [ 0.36174242,  0.44412879],\n       [ 0.5       , -0.03786566],\n       [ 0.2927264 , -0.5411368 ],\n       [ 0.5       , -1.        ],\n       [ 1.        ,  0.5       ],\n       [ 1.        , -0.5       ]])\n\n# Theoretical function:\ndef F(x, y):\n    return x + y -  x*y - (x*y)**2 - 2*x*y**2 + x**2*y + 3*np.exp( -((x+1)**2 + (y+1)**2)*5 )\n\nz = F(nodes[:, 0], nodes[:, 1])\n\n# Finer regular grid:\nN2 = 19\nx2, y2 = np.linspace(-1, 1, N2), np.linspace(-1, 1, N2)\nX2, Y2 = np.meshgrid(x2, y2)\n\n# Interpolation:\ntri = Delaunay(nodes)\nCT_interpolator = CloughTocher2DInterpolator(tri, z)\nz_interpolated = CT_interpolator(X2, Y2)\n\n# Plot\nfig = plt.figure(1, figsize=(8,14))\n\nax = fig.add_subplot(311, projection='3d')\nax.scatter3D(nodes[:, 0], nodes[:, 1], z, s=15, color='red', label='points')\n\nax.plot_wireframe(X2, Y2, z_interpolated, color='black', label='interpolated')\nplt.legend();",
            "masked_line": "from scipy.interpolate import CloughTocher2DInterpolator",
            "answer": "CloughTocher2DInterpolator",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_722"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-12-24",
            "description": "The code creates a neural network classifier model using TensorFlow's Keras API with two dense layers. The model is compiled with the Adam optimizer and binary cross-entropy loss function. Finally, the trained model is saved in the TensorFlow SavedModel format at the specified path.",
            "code": "import pandas as pd\nimport tensorflow as tf;\n##Change.\nfrom tensorflow.keras import Sequential\nfrom tensorflow.keras.layers import Dense\nimport json;\nimport numpy as np;\n\nclassifier = Sequential()\nclassifier.add(Dense(4, activation='relu', kernel_initializer='random_normal', input_dim=4))\nclassifier.add(Dense(1, activation='sigmoid', kernel_initializer='random_normal'))\nclassifier.compile(optimizer ='adam',loss='binary_crossentropy', metrics = ['accuracy'])\n\nclassifier.save('/tmp/keras-model.pb', save_format='tf')",
            "masked_code": "import pandas as pd\nimport tensorflow as tf;\n##Change.\nfrom tensorflow.keras import Sequential\nfrom tensorflow.keras.layers import Dense\nimport json;\nimport numpy as np;\n\nclassifier = Sequential()\nclassifier.add(Dense(4, activation='relu', kernel_initializer='random_normal', input_dim=4))\nclassifier.add(Dense(1, activation='sigmoid', kernel_initializer='random_normal'))\n<line_mask>\n\nclassifier.save('/tmp/keras-model.pb', save_format='tf')",
            "masked_line": "classifier.compile(optimizer ='adam',loss='binary_crossentropy', metrics = ['accuracy'])",
            "answer": "compile",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_723"
        },
        {
            "dependency": "numpy",
            "version": "==1.5.x",
            "time": "2019-08-09",
            "description": "The code subtracts the elements of array 'vec' from the first column of matrix 'mt' and prints the updated 'mt' matrix.",
            "code": "import numpy as np\n\nvec=np.array([15.1,7.9,4.5,12.8,10.5],ndmin = 2)\nmt = np.matrix([[1,35.5,1.23],[1,40.8,1.89],[1,30.2,1.55],[1,4.3,1.18], [1,10.7,1.68]])\n\nmt[..., 0] = vec.T - mt[..., 0]\n#or\n#mt.T[0] = np.subtract(vec, mt.T[0])\n\nprint(mt)",
            "masked_code": "import numpy as np\n\n<line_mask>\nmt = np.matrix([[1,35.5,1.23],[1,40.8,1.89],[1,30.2,1.55],[1,4.3,1.18], [1,10.7,1.68]])\n\nmt[..., 0] = vec.T - mt[..., 0]\n#or\n#mt.T[0] = np.subtract(vec, mt.T[0])\n\nprint(mt)",
            "masked_line": "vec=np.array([15.1,7.9,4.5,12.8,10.5],ndmin = 2)",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_724"
        },
        {
            "dependency": "click",
            "version": "==7.x",
            "time": "2019-04-03",
            "description": "The code defines a command-line interface application using the Click library in Python. It defines a command \"foo\" that, when invoked, prints the number 1. The code includes a unit test that uses Click's CliRunner to test the functionality of the \"foo\" command by checking if it prints '1\\n' and exits with code 0.",
            "code": "import unittest\nimport click\nimport click.testing\n\n\n@click.command()\ndef foo():\n    print(1)\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        runner = click.testing.CliRunner()\n        result = runner.invoke(foo)\n        assert result.exit_code == 0\n        assert result.output == '1\\n'",
            "masked_code": "import unittest\nimport click\nimport click.testing\n\n\n@click.command()\ndef foo():\n    print(1)\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        <line_mask>\n        result = runner.invoke(foo)\n        assert result.exit_code == 0\n        assert result.output == '1\\n'",
            "masked_line": "runner = click.testing.CliRunner()",
            "answer": "CliRunner",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_725"
        },
        {
            "dependency": "pandas",
            "version": "==0.22.0",
            "time": "2019-01-17",
            "description": "The code creates a pandas DataFrame with columns 'foo', 'bar', 'baz', and 'zoo', then sets a multi-level index using columns 'foo' and 'bar'. Finally, it unstacks the second level of the index.",
            "code": "import pandas as pd\ndf = pd.DataFrame({'foo': ['one', 'one', 'one', 'two', 'two',\n                          'two'],\n                  'bar': ['A', 'B', 'C', 'A', 'B', 'C'],\n                   'baz': [1, 2, 3, 4, 5, 6],\n                   'zoo': ['x', 'y', 'z', 'q', 'w', 't']})\n\ndf.set_index(['foo','bar'],inplace=True)\ndf.unstack(level=1)",
            "masked_code": "import pandas as pd\n<line_mask>\n                          'two'],\n                  'bar': ['A', 'B', 'C', 'A', 'B', 'C'],\n                   'baz': [1, 2, 3, 4, 5, 6],\n                   'zoo': ['x', 'y', 'z', 'q', 'w', 't']})\n\ndf.set_index(['foo','bar'],inplace=True)\ndf.unstack(level=1)",
            "masked_line": "df = pd.DataFrame({'foo': ['one', 'one', 'one', 'two', 'two',",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_726"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-12-01",
            "description": "This function finds the closest background (zero) element for each element in the input image by calculating the distance to the nearest zero element using Euclidean distance transform. It then returns a dictionary mapping each non-zero element's position to its distance to the nearest zero element.",
            "code": "from scipy import ndimage\nimport pprint\n\ndef nearest_zero(image):\n    \" Finds closest background (zero) element for each element in image \"\n\n    # Find closest zero elements in the inverted image (same as closest non-zero for image)\n    edt = ndimage.distance_transform_edt(image, return_indices=False)\n\n    # Create dictionary of indexes\n    return {(r,c):edt[r][c] for r in range(image.shape[0]) for c in range(image.shape[1]) if image[r][c]}",
            "masked_code": "from scipy import ndimage\nimport pprint\n\ndef nearest_zero(image):\n    \" Finds closest background (zero) element for each element in image \"\n\n    # Find closest zero elements in the inverted image (same as closest non-zero for image)\n    <line_mask>\n\n    # Create dictionary of indexes\n    return {(r,c):edt[r][c] for r in range(image.shape[0]) for c in range(image.shape[1]) if image[r][c]}",
            "masked_line": "edt = ndimage.distance_transform_edt(image, return_indices=False)",
            "answer": "distance_transform_edt",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_727"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0beta",
            "time": "2019-06-23",
            "description": "This code loads a pre-trained ResNeXt50 model using Tensorflow's Keras API and checks if eager execution is enabled in the current session.",
            "code": "import tensorflow as tf\nresnext = tf.keras.applications.ResNeXt50(weights=None)\nprint(tf.executing_eagerly())",
            "masked_code": "import tensorflow as tf\n<line_mask>\nprint(tf.executing_eagerly())",
            "masked_line": "resnext = tf.keras.applications.ResNeXt50(weights=None)",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_728"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-04-05",
            "description": "The code creates a Bokeh application that displays a plot with interactive features. The plot includes arrows and segments, and allows for adding new arrows with a tap event. The plot has predefined annotation color, thickness, and transparency settings. ",
            "code": "from tornado.ioloop import IOLoop\nfrom bokeh.server.server import Server\nfrom bokeh.application import Application\nfrom bokeh.application.handlers.function import FunctionHandler\nfrom bokeh.plotting import figure, show\nfrom bokeh.models import CustomJS, ColumnDataSource, Arrow, NormalHead, Segment\n\ndef make_document(doc):\n        p = figure(plot_width = 1000, plot_height = 600, x_range = (0, 10),\n        y_range = (0, 6), tools = \"pan, wheel_zoom,box_zoom,reset,undo,redo\")\n        #### set up annotation color and thickness:\n        thick_ann = 10.0\n        col_ann = \"red\"\n        alpha_ann = 0.7\n        #### source dataset and associated code for for any added arrows\n        source = ColumnDataSource(data = {\"xs\":[1, 2, 3], \"ys\":[1, 2, 3], \"xe\":[4, 5, 6], \"ye\":[1, 2, 3], 'width': [30] * 3, 'color': [col_ann] * 3 })\n        a1 = Arrow(end = NormalHead(size = thick_ann * 3, fill_color = col_ann, line_color = col_ann, line_alpha = alpha_ann, fill_alpha = alpha_ann), x_start = 'xs', y_start = 'ys', x_end = 'xe', y_end = 'ye', source = source, line_color = col_ann, line_alpha = alpha_ann)\n        s1 = p.segment(x0 = 'xs', y0 = 'ys', x1 = 'xe', y1 = 'ye', color = 'color', source = source)\n        p.add_layout(a1)\n\n        code = \"\"\"  new_x = Number(cb_obj.x);\n                    new_y = Number(cb_obj.y);\n                    data = {xe: [new_x], ys: [new_y], ye: [new_y]};\n                    data['xs'] = [Number(data['xe']) - 3];\n                    data['color'] = ['red'];\n                    data['width'] = [90];\n                    source.stream(data); \"\"\"\n        p.js_on_event('tap', CustomJS(args = dict(source = source), code = code))\n        doc.add_root(p)\n\nio_loop = IOLoop.current()\nserver = Server(applications = {'/': Application(FunctionHandler(make_document))}, io_loop = io_loop, port = 5001)\nserver.start()\nserver.show('/')\nio_loop.start()",
            "masked_code": "from tornado.ioloop import IOLoop\nfrom bokeh.server.server import Server\nfrom bokeh.application import Application\nfrom bokeh.application.handlers.function import FunctionHandler\nfrom bokeh.plotting import figure, show\nfrom bokeh.models import CustomJS, ColumnDataSource, Arrow, NormalHead, Segment\n\ndef make_document(doc):\n        p = figure(plot_width = 1000, plot_height = 600, x_range = (0, 10),\n        y_range = (0, 6), tools = \"pan, wheel_zoom,box_zoom,reset,undo,redo\")\n        #### set up annotation color and thickness:\n        thick_ann = 10.0\n        col_ann = \"red\"\n        alpha_ann = 0.7\n        #### source dataset and associated code for for any added arrows\n        source = ColumnDataSource(data = {\"xs\":[1, 2, 3], \"ys\":[1, 2, 3], \"xe\":[4, 5, 6], \"ye\":[1, 2, 3], 'width': [30] * 3, 'color': [col_ann] * 3 })\n        <line_mask>\n        s1 = p.segment(x0 = 'xs', y0 = 'ys', x1 = 'xe', y1 = 'ye', color = 'color', source = source)\n        p.add_layout(a1)\n\n        code = \"\"\"  new_x = Number(cb_obj.x);\n                    new_y = Number(cb_obj.y);\n                    data = {xe: [new_x], ys: [new_y], ye: [new_y]};\n                    data['xs'] = [Number(data['xe']) - 3];\n                    data['color'] = ['red'];\n                    data['width'] = [90];\n                    source.stream(data); \"\"\"\n        p.js_on_event('tap', CustomJS(args = dict(source = source), code = code))\n        doc.add_root(p)\n\nio_loop = IOLoop.current()\nserver = Server(applications = {'/': Application(FunctionHandler(make_document))}, io_loop = io_loop, port = 5001)\nserver.start()\nserver.show('/')\nio_loop.start()",
            "masked_line": "a1 = Arrow(end = NormalHead(size = thick_ann * 3, fill_color = col_ann, line_color = col_ann, line_alpha = alpha_ann, fill_alpha = alpha_ann), x_start = 'xs', y_start = 'ys', x_end = 'xe', y_end = 'ye', source = source, line_color = col_ann, line_alpha = alpha_ann)",
            "answer": "NormalHead",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_729"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.0",
            "time": "2019-03-30",
            "description": "The code merges two dataframes, calculates the mean values of 'y' for each unique value of 'x', and returns arrays of 'x' and 'y' values in ascending order of 'x'.",
            "code": "import numpy as np \nimport pandas as pd \nx1 = np.asarray([ 1.2,  1.8,  2.3,  4.5, 20.0])\ny1 = np.asarray([10.3, 11.8, 12.3, 11.5, 11.5])\nx2 = np.asarray([ 0.2,  1.8,  5.3, 15.5, 17.2, 18.3, 20.0])\ny2 = np.asarray([10.3, 11.8, 12.3, 12.5, 15.2, 10.3, 10.0])\nc1 = pd.DataFrame({'x': x1, 'y': y1})\nc2 = pd.DataFrame({'x': x2, 'y': y2})\nc = pd.concat([c1, c2]).groupby('x').mean().reset_index()\nx = c['x'].values\ny = c['y'].values\n\n# Result:\nx = array([ 0.2,  1.2,  1.8,  2.3,  4.5,  5.3,  15.5, 17.2, 18.3, 20. ])\ny = array([10.3 , 10.3, 11.8, 12.3, 11.5, 12.3, 12.5, 15.2, 10.3, 10.75])",
            "masked_code": "import numpy as np \nimport pandas as pd \nx1 = np.asarray([ 1.2,  1.8,  2.3,  4.5, 20.0])\ny1 = np.asarray([10.3, 11.8, 12.3, 11.5, 11.5])\nx2 = np.asarray([ 0.2,  1.8,  5.3, 15.5, 17.2, 18.3, 20.0])\ny2 = np.asarray([10.3, 11.8, 12.3, 12.5, 15.2, 10.3, 10.0])\nc1 = pd.DataFrame({'x': x1, 'y': y1})\nc2 = pd.DataFrame({'x': x2, 'y': y2})\n<line_mask>\nx = c['x'].values\ny = c['y'].values\n\n# Result:\nx = array([ 0.2,  1.2,  1.8,  2.3,  4.5,  5.3,  15.5, 17.2, 18.3, 20. ])\ny = array([10.3 , 10.3, 11.8, 12.3, 11.5, 12.3, 12.5, 15.2, 10.3, 10.75])",
            "masked_line": "c = pd.concat([c1, c2]).groupby('x').mean().reset_index()",
            "answer": "reset_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_730"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-26",
            "description": "The code creates a Bokeh plot with two lines: one can be controlled by sliders for slope and intercept values, while the other line remains static. The slider values determine the equation of the 1st line, which is a linear function with the form y = slope * x + intercept. The plot is displayed in the notebook.",
            "code": "import numpy as np\nfrom bokeh.plotting import figure, show\nfrom bokeh.models import ColumnDataSource, Slider, CustomJS, Range1d\nfrom bokeh.layouts import column\n\nslider_slope = Slider(start = 0, end = 1, value = 0.5, step = 0.1)\nslider_intercept = Slider(start = 0, end = 20, value = 10, step = 1)\n\nslider_code = '''   i = slider_intercept.value\n                    s = slider_slope.value\n                    x = r.data_source.data['x'];\n                    y = [];\n\n                    for (index = 0; index < x.length; index ++)\n                        y.push((s * x[index]) + i);\n\n                    r.data_source.data['y'] = y\n                    r.data_source.change.emit(); '''\n\ns = slider_slope.value  # slope.\ni = slider_intercept.value  # intercept.\n\nx = np.linspace(-40, 20, 200)\ny = [(s * xx + i) for xx in x]\n\np = figure(title = \"simple line example\", plot_height = 500, plot_width = 600, y_range = Range1d(start = -80, end = 40), background_fill_color = '#efefef')\nr = p.line(x, y, color = \"red\", line_width = 1.5, alpha = 0.8)  # 1st line. This line can be controlled by sliders.\nq = p.line(x, 2 * x + 1.2, color = \"blue\", line_width = 1.9, alpha = 0.2)  # 2nd line.\n\nslider_callback = CustomJS(args = dict(slider_slope = slider_slope,\n                                slider_intercept = slider_intercept,\n                                r = r), code = slider_code)\n\nslider_slope.callback = slider_callback\nslider_intercept.callback = slider_callback\n\nlayout = column(p, slider_slope, slider_intercept)\nshow(layout, notebook_handle = True)",
            "masked_code": "import numpy as np\nfrom bokeh.plotting import figure, show\nfrom bokeh.models import ColumnDataSource, Slider, CustomJS, Range1d\nfrom bokeh.layouts import column\n\n<line_mask>\nslider_intercept = Slider(start = 0, end = 20, value = 10, step = 1)\n\nslider_code = '''   i = slider_intercept.value\n                    s = slider_slope.value\n                    x = r.data_source.data['x'];\n                    y = [];\n\n                    for (index = 0; index < x.length; index ++)\n                        y.push((s * x[index]) + i);\n\n                    r.data_source.data['y'] = y\n                    r.data_source.change.emit(); '''\n\ns = slider_slope.value  # slope.\ni = slider_intercept.value  # intercept.\n\nx = np.linspace(-40, 20, 200)\ny = [(s * xx + i) for xx in x]\n\np = figure(title = \"simple line example\", plot_height = 500, plot_width = 600, y_range = Range1d(start = -80, end = 40), background_fill_color = '#efefef')\nr = p.line(x, y, color = \"red\", line_width = 1.5, alpha = 0.8)  # 1st line. This line can be controlled by sliders.\nq = p.line(x, 2 * x + 1.2, color = \"blue\", line_width = 1.9, alpha = 0.2)  # 2nd line.\n\nslider_callback = CustomJS(args = dict(slider_slope = slider_slope,\n                                slider_intercept = slider_intercept,\n                                r = r), code = slider_code)\n\nslider_slope.callback = slider_callback\nslider_intercept.callback = slider_callback\n\nlayout = column(p, slider_slope, slider_intercept)\nshow(layout, notebook_handle = True)",
            "masked_line": "slider_slope = Slider(start = 0, end = 1, value = 0.5, step = 0.1)",
            "answer": "Slider",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_731"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-03",
            "description": "The code calculates the mean values of each row in the `arr` array and then stacks the `ids` array along with the computed mean values vertically to form a new array.",
            "code": "import numpy as np\n\nids = np.array([1, 2])  # this is just array2\narr = np.array([[99, 73, 97, 98],\n          [98, 71, 70, 99]])\nresult = np.vstack((ids, np.mean(arr, axis=1)))\nprint(result)",
            "masked_code": "import numpy as np\n\nids = np.array([1, 2])  # this is just array2\narr = np.array([[99, 73, 97, 98],\n          [98, 71, 70, 99]])\n<line_mask>\nprint(result)",
            "masked_line": "result = np.vstack((ids, np.mean(arr, axis=1)))",
            "answer": "vstack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_732"
        },
        {
            "dependency": "Flask",
            "version": "==1.1.2",
            "time": "2021-01-22",
            "description": "This code defines a function test_send_voucher that sends a voucher email to a specified email address, with a voucher code generated using UUID, an expiry date, and an attached image. The email content includes the voucher code and expiry date. The email is sent using Flask Mail and configured with SMTP details.",
            "code": "import uuid\nfrom flask import Flask\nfrom flask_mail import Mail, Message\nfrom pathlib import Path\n\napp = Flask(__name__)\napp.config.update(\n    MAIL_SERVER='smtp.gmail.com', MAIL_PORT=465, MAIL_USE_SSL=True,\n    MAIL_USERNAME=\"myfakeemail54858939@gmail.com\", MAIL_PASSWORD=\"myfakepw54858939\")\nflask_mail = Mail(app)\n\ndef test_send_voucher():\n    to_addr = \"myfakeemail54858939@gmail.com\"\n    expiry = \"29 February\"\n    voucher_png_path = Path(__file__).parent / \"static/Facebook.jpg\"\n    sendVoucherEmail(app, to_addr, expiry, voucher_png_path)\n\ndef sendVoucherEmail(app: Flask, to_addr: str, expiry: str, voucher_png_path: Path):\n    voucher_id = str(uuid.uuid4())\n    html = f\"\"\"\n    Congratulations on your voucher!Your voucher code is {voucher_id}. \n    The offer expires on {expiry}.\n    \n    \"\"\"\n    with app.app_context():\n        mail = Mail(app)\n        message: Message = Message(subject=\"my subject\", sender=\"myfakeemail54858939@gmail.com\", \n                                   recipients=[to_addr], html=html)\n        with app.open_resource(voucher_png_path) as fp:\n            message.attach(filename=\"myfilename.png\", content_type=\"image/png\", data=fp.read(), \n                           disposition=\"inline\", headers=[['Content-ID', '']])\n        mail.send(message)",
            "masked_code": "import uuid\nfrom flask import Flask\nfrom flask_mail import Mail, Message\nfrom pathlib import Path\n\napp = Flask(__name__)\n<line_mask>\n    MAIL_SERVER='smtp.gmail.com', MAIL_PORT=465, MAIL_USE_SSL=True,\n    MAIL_USERNAME=\"myfakeemail54858939@gmail.com\", MAIL_PASSWORD=\"myfakepw54858939\")\nflask_mail = Mail(app)\n\ndef test_send_voucher():\n    to_addr = \"myfakeemail54858939@gmail.com\"\n    expiry = \"29 February\"\n    voucher_png_path = Path(__file__).parent / \"static/Facebook.jpg\"\n    sendVoucherEmail(app, to_addr, expiry, voucher_png_path)\n\ndef sendVoucherEmail(app: Flask, to_addr: str, expiry: str, voucher_png_path: Path):\n    voucher_id = str(uuid.uuid4())\n    html = f\"\"\"\n    Congratulations on your voucher!Your voucher code is {voucher_id}. \n    The offer expires on {expiry}.\n    \n    \"\"\"\n    with app.app_context():\n        mail = Mail(app)\n        message: Message = Message(subject=\"my subject\", sender=\"myfakeemail54858939@gmail.com\", \n                                   recipients=[to_addr], html=html)\n        with app.open_resource(voucher_png_path) as fp:\n            message.attach(filename=\"myfilename.png\", content_type=\"image/png\", data=fp.read(), \n                           disposition=\"inline\", headers=[['Content-ID', '']])\n        mail.send(message)",
            "masked_line": "app.config.update(",
            "answer": "config",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_733"
        },
        {
            "dependency": "Flask-Mail",
            "version": "==0.9.1",
            "time": "2021-01-22",
            "description": "This code defines a function `test_send_voucher()` that sends a voucher email to a specified email address with a unique voucher code and expiry date. The email includes a congratulatory message, the voucher code, and the expiry date. The voucher is attached as a PNG file to the email. The email is sent using Flask-Mail with SMTP settings configured and the sender's Gmail account credentials provided in the configuration.",
            "code": "import uuid\nfrom flask import Flask\nfrom flask_mail import Mail, Message\nfrom pathlib import Path\n\napp = Flask(__name__)\napp.config.update(\n    MAIL_SERVER='smtp.gmail.com', MAIL_PORT=465, MAIL_USE_SSL=True,\n    MAIL_USERNAME=\"myfakeemail54858939@gmail.com\", MAIL_PASSWORD=\"myfakepw54858939\")\nflask_mail = Mail(app)\n\ndef test_send_voucher():\n    to_addr = \"myfakeemail54858939@gmail.com\"\n    expiry = \"29 February\"\n    voucher_png_path = Path(__file__).parent / \"static/Facebook.jpg\"\n    sendVoucherEmail(app, to_addr, expiry, voucher_png_path)\n\ndef sendVoucherEmail(app: Flask, to_addr: str, expiry: str, voucher_png_path: Path):\n    voucher_id = str(uuid.uuid4())\n    html = f\"\"\"\n    Congratulations on your voucher!Your voucher code is {voucher_id}. \n    The offer expires on {expiry}.\n    \n    \"\"\"\n    with app.app_context():\n        mail = Mail(app)\n        message: Message = Message(subject=\"my subject\", sender=\"myfakeemail54858939@gmail.com\", \n                                   recipients=[to_addr], html=html)\n        with app.open_resource(voucher_png_path) as fp:\n            message.attach(filename=\"myfilename.png\", content_type=\"image/png\", data=fp.read(), \n                           disposition=\"inline\", headers=[['Content-ID', '']])\n        mail.send(message)",
            "masked_code": "import uuid\nfrom flask import Flask\nfrom flask_mail import Mail, Message\nfrom pathlib import Path\n\napp = Flask(__name__)\napp.config.update(\n    MAIL_SERVER='smtp.gmail.com', MAIL_PORT=465, MAIL_USE_SSL=True,\n    MAIL_USERNAME=\"myfakeemail54858939@gmail.com\", MAIL_PASSWORD=\"myfakepw54858939\")\nflask_mail = Mail(app)\n\ndef test_send_voucher():\n    to_addr = \"myfakeemail54858939@gmail.com\"\n    expiry = \"29 February\"\n    voucher_png_path = Path(__file__).parent / \"static/Facebook.jpg\"\n    sendVoucherEmail(app, to_addr, expiry, voucher_png_path)\n\ndef sendVoucherEmail(app: Flask, to_addr: str, expiry: str, voucher_png_path: Path):\n    voucher_id = str(uuid.uuid4())\n    html = f\"\"\"\n    Congratulations on your voucher!Your voucher code is {voucher_id}. \n    The offer expires on {expiry}.\n    \n    \"\"\"\n    with app.app_context():\n        mail = Mail(app)\n        <line_mask>\n                                   recipients=[to_addr], html=html)\n        with app.open_resource(voucher_png_path) as fp:\n            message.attach(filename=\"myfilename.png\", content_type=\"image/png\", data=fp.read(), \n                           disposition=\"inline\", headers=[['Content-ID', '']])\n        mail.send(message)",
            "masked_line": "message: Message = Message(subject=\"my subject\", sender=\"myfakeemail54858939@gmail.com\",",
            "answer": "Message",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_734"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-19",
            "description": "The code generates a plot using Bokeh library, displaying an image of a 2D array with specified x and y ranges, and includes a color bar to represent the color mapping of the image data.",
            "code": "from bokeh.models.ranges import DataRange1d\nfrom bokeh.plotting import figure, show\nfrom bokeh.layouts import Row\nfrom bokeh.palettes import Greys\nfrom bokeh.models import LinearColorMapper, ColorBar\nimport numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nsx = 3\nsy = 2\n\nx_range = DataRange1d(start = 0, end = sx, bounds = (0, sx), range_padding = 5, range_padding_units = 'percent')\ny_range = DataRange1d(start = 0, end = sy, bounds = (0, sy), range_padding = 5, range_padding_units = 'percent')\n\npw = 400\nph = pw * sy / sx\nplot = figure(plot_width = pw,\n              plot_height = ph,\n              x_range = x_range,\n              y_range = y_range,\n              match_aspect = True)\nplot.image([arr], x = 0, y = 0, dw = sx, dh = sy)\n\ncolor_mapper = LinearColorMapper(palette = Greys[6], low = arr.min(), high = arr.max())\ncolorbar_plot = figure(plot_height = ph, plot_width = 69, x_axis_location = None, y_axis_location = None, title = None, tools = '', toolbar_location = None)\ncolorbar = ColorBar(color_mapper = color_mapper, location = (0, 0))\ncolorbar_plot.add_layout(colorbar, 'left')\n\nshow(Row(plot, colorbar_plot))",
            "masked_code": "from bokeh.models.ranges import DataRange1d\nfrom bokeh.plotting import figure, show\nfrom bokeh.layouts import Row\nfrom bokeh.palettes import Greys\n<line_mask>\nimport numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nsx = 3\nsy = 2\n\nx_range = DataRange1d(start = 0, end = sx, bounds = (0, sx), range_padding = 5, range_padding_units = 'percent')\ny_range = DataRange1d(start = 0, end = sy, bounds = (0, sy), range_padding = 5, range_padding_units = 'percent')\n\npw = 400\nph = pw * sy / sx\nplot = figure(plot_width = pw,\n              plot_height = ph,\n              x_range = x_range,\n              y_range = y_range,\n              match_aspect = True)\nplot.image([arr], x = 0, y = 0, dw = sx, dh = sy)\n\ncolor_mapper = LinearColorMapper(palette = Greys[6], low = arr.min(), high = arr.max())\ncolorbar_plot = figure(plot_height = ph, plot_width = 69, x_axis_location = None, y_axis_location = None, title = None, tools = '', toolbar_location = None)\ncolorbar = ColorBar(color_mapper = color_mapper, location = (0, 0))\ncolorbar_plot.add_layout(colorbar, 'left')\n\nshow(Row(plot, colorbar_plot))",
            "masked_line": "from bokeh.models import LinearColorMapper, ColorBar",
            "answer": "LinearColorMapper",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_735"
        },
        {
            "dependency": "plotly",
            "version": ">=1.9.4",
            "time": "2019-02-14",
            "description": "The code generates a simple table using the data contained in the dataframe \"df\", displays the table using Plotly offline mode, and saves the table as an image file named \"sample.png\" using Plotly.",
            "code": "from plotly.offline import plot as off\nimport plotly.figure_factory as ff\nimport plotly.io as pio\n\ntable = ff.create_table(df, index=True)\nfig = off(table, filename='simple_table')\npio.write_image(table, 'sample.png')",
            "masked_code": "from plotly.offline import plot as off\nimport plotly.figure_factory as ff\nimport plotly.io as pio\n\n<line_mask>\nfig = off(table, filename='simple_table')\npio.write_image(table, 'sample.png')",
            "masked_line": "table = ff.create_table(df, index=True)",
            "answer": "create_table",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_736"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-08-21",
            "description": "The code rounds the values in the 'SCORE' column of a pandas DataFrame to the nearest integer and converts them to integers. If the 'SCORE' column contains NaN values, it uses the 'Int64' data type, which is supported in pandas 0.24+. If the 'SCORE' column does not contain NaN values, it simply converts the rounded values to integers.",
            "code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({'SCORE':[100.000000,96.199205,np.nan,95.983358]})\nprint(df)\n\"\"\"\n   1. if series has NaN value, solution work for pandas 0.24+\n      df['SCORE'] = np.round(df.SCORE).astype('Int64')\n   https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html\n\n  2. If series has not NaN value, try this\n    df['SCORE'] = np.round(df.SCORE).astype(int)\n\n\"\"\"\ndf['SCORE'] = np.round(df.SCORE).astype('Int64')\nprint(df)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({'SCORE':[100.000000,96.199205,np.nan,95.983358]})\nprint(df)\n\"\"\"\n   1. if series has NaN value, solution work for pandas 0.24+\n      df['SCORE'] = np.round(df.SCORE).astype('Int64')\n   https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html\n\n  2. If series has not NaN value, try this\n    df['SCORE'] = np.round(df.SCORE).astype(int)\n\n\"\"\"\n<line_mask>\nprint(df)",
            "masked_line": "df['SCORE'] = np.round(df.SCORE).astype('Int64')",
            "answer": "round",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_737"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24",
            "time": "2019-08-21",
            "description": "The code rounds the values in the 'SCORE' column of a pandas DataFrame to the nearest whole number and converts them to integer type. If the 'SCORE' column contains NaN values, it uses the Int64 datatype to handle integer data with missing values starting from pandas version 0.24. If there are no NaN values in the 'SCORE' column, it simply converts the rounded values to integer type.",
            "code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({'SCORE':[100.000000,96.199205,np.nan,95.983358]})\nprint(df)\n\"\"\"\n   1. if series has NaN value, solution work for pandas 0.24+\n      df['SCORE'] = np.round(df.SCORE).astype('Int64')\n   https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html\n\n  2. If series has not NaN value, try this\n    df['SCORE'] = np.round(df.SCORE).astype(int)\n\n\"\"\"\ndf['SCORE'] = np.round(df.SCORE).astype('Int64')\nprint(df)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n<line_mask>\nprint(df)\n\"\"\"\n   1. if series has NaN value, solution work for pandas 0.24+\n      df['SCORE'] = np.round(df.SCORE).astype('Int64')\n   https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html\n\n  2. If series has not NaN value, try this\n    df['SCORE'] = np.round(df.SCORE).astype(int)\n\n\"\"\"\ndf['SCORE'] = np.round(df.SCORE).astype('Int64')\nprint(df)",
            "masked_line": "df = pd.DataFrame({'SCORE':[100.000000,96.199205,np.nan,95.983358]})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_738"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-04-05",
            "description": "The code creates a multi-line plot using the Bokeh library to visualize data from a pandas DataFrame. The plot displays multiple lines representing different columns of the DataFrame against the 'version' column on the x-axis. Each line is colored differently using a predefined color palette.",
            "code": "import pandas as pd\nimport numpy as np\nfrom bokeh.palettes import Spectral11\nfrom bokeh.plotting import figure, show\n\ntoy_df = pd.DataFrame(data = {'version': ['v1.0.0', 'v1.0.1', 'v1.0.2', 'v1.0.3'],\n                              '2x8x8': [10.2, 11.3, 9.5, 10.9],\n                              '2x8x10': [9.2, 10.4, 9.3, 9.9],\n                              '2x8x12': [8.2, 10.2, 9.1, 11.1]}, columns = ('version', '2x8x8' , '2x8x10', '2x8x12'))\n\nnumlines = len(toy_df.columns)\nmypalette = Spectral11[0:numlines]\n\np = figure(width = 500, height = 300, x_range = toy_df['version'])\np.multi_line(xs = [toy_df['version'].values] * numlines,\n             ys = [toy_df[name].values for name in toy_df],\n             line_color = mypalette,\n             line_width = 5)\nshow(p)",
            "masked_code": "import pandas as pd\nimport numpy as np\nfrom bokeh.palettes import Spectral11\nfrom bokeh.plotting import figure, show\n\ntoy_df = pd.DataFrame(data = {'version': ['v1.0.0', 'v1.0.1', 'v1.0.2', 'v1.0.3'],\n                              '2x8x8': [10.2, 11.3, 9.5, 10.9],\n                              '2x8x10': [9.2, 10.4, 9.3, 9.9],\n                              '2x8x12': [8.2, 10.2, 9.1, 11.1]}, columns = ('version', '2x8x8' , '2x8x10', '2x8x12'))\n\nnumlines = len(toy_df.columns)\nmypalette = Spectral11[0:numlines]\n\n<line_mask>\np.multi_line(xs = [toy_df['version'].values] * numlines,\n             ys = [toy_df[name].values for name in toy_df],\n             line_color = mypalette,\n             line_width = 5)\nshow(p)",
            "masked_line": "p = figure(width = 500, height = 300, x_range = toy_df['version'])",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_739"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-10-10",
            "description": "The code creates a 3D NumPy array with a shape of (100, 50, 50) where each element is randomly chosen from [0, 1] based on the probabilities [0.7, 0.3].",
            "code": "import numpy as np\nnp.array([np.random.choice([0, 1], p=[0.7, 0.3], size=(50, 50)) for _ in range(100)])",
            "masked_code": "import numpy as np\n<line_mask>",
            "masked_line": "np.array([np.random.choice([0, 1], p=[0.7, 0.3], size=(50, 50)) for _ in range(100)])",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_740"
        },
        {
            "dependency": "pendulum",
            "version": ">=2.0",
            "time": "2022-07-06",
            "description": "The code creates a `Duration` object representing a duration of 1000 minutes.",
            "code": "from pendulum import Duration\nDuration(minutes=1000)",
            "masked_code": "from pendulum import Duration\n<line_mask>",
            "masked_line": "Duration(minutes=1000)",
            "answer": "Duration",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_741"
        },
        {
            "dependency": "bokeh",
            "version": "==1.2.0",
            "time": "2019-07-13",
            "description": "This code generates a Bokeh plot showing a heatmap of randomly generated data over time, with the y-axis representing different data columns and the x-axis representing time. The plot includes tooltips displaying the exact date and corresponding column name when hovering over the data points.",
            "code": "from datetime import datetime\nimport pandas as pd\nimport numpy as np\nfrom bokeh.plotting import figure, show\nfrom bokeh.transform import linear_cmap\nfrom bokeh.io import output_notebook\nfrom bokeh.models import FuncTickFormatter\nfrom bokeh.models import ColumnDataSource\n\noutput_notebook()\n\n# build sample data\nindex = pd.date_range(start='1/1/2019', periods=1000, freq='T')\ndata = np.random.rand(1000,100)\ncolumns_labels = ['col'+ str(n) for n in range(100)]\ncolumns = [n for n in range(100)]\n\n# initial data format\ndf = pd.DataFrame(data=data, index=index, columns=columns)\n\n# bokeh\ndf = df.stack().reset_index()\ndf.rename(columns={'level_0':'x','level_1':'y', 0:'z'},inplace=True)\ndf.sort_values(by=['y'],inplace=True)\n\nx = [\n     date.to_datetime64().astype('M8[ms]').astype('O')\n     for date in df.x.to_list()\n]\n\ndata = {\n    'value': df.z.to_list(),\n    'x': x,\n    'y': df.y.to_list(), \n    'y_labels_tooltip' : [columns_labels[k] for k in df.y.to_list()],\n    'y_ticks' : columns_labels*1000,\n    'date' : df.x.to_list()\n}\n\ncd = ColumnDataSource(data=data)\n\ndef ticker(source=cd):\n    labels = source.data['y_ticks']\n    return \"{}\".format(labels[tick])\n\n#p = figure(x_axis_type='datetime', y_range=columns, width=900, tooltips=[(\"x\", \"@date{%F %T}\"), (\"y\", \"@y_labels\"), (\"value\", \"@value\")])\n\np = figure(x_axis_type='datetime', width=900, tooltips=[(\"x\", \"@date{%F %T}\"), (\"y\", \"@y_labels_tooltip\"), (\"value\", \"@value\")])\n\np.rect(x='x', y='y', width=60*1000, height=1, line_color=None, \n                   fill_color=linear_cmap('value', 'Viridis256', low=df.z.min(), high=df.z.max()), source=cd)\n\np.hover.formatters = {'date': 'datetime'}\np.yaxis.formatter = FuncTickFormatter.from_py_func(ticker)\np.yaxis[0].ticker.desired_num_ticks = 20\n\nshow(p)",
            "masked_code": "from datetime import datetime\nimport pandas as pd\nimport numpy as np\nfrom bokeh.plotting import figure, show\nfrom bokeh.transform import linear_cmap\nfrom bokeh.io import output_notebook\nfrom bokeh.models import FuncTickFormatter\nfrom bokeh.models import ColumnDataSource\n\noutput_notebook()\n\n# build sample data\nindex = pd.date_range(start='1/1/2019', periods=1000, freq='T')\ndata = np.random.rand(1000,100)\ncolumns_labels = ['col'+ str(n) for n in range(100)]\ncolumns = [n for n in range(100)]\n\n# initial data format\ndf = pd.DataFrame(data=data, index=index, columns=columns)\n\n# bokeh\ndf = df.stack().reset_index()\ndf.rename(columns={'level_0':'x','level_1':'y', 0:'z'},inplace=True)\ndf.sort_values(by=['y'],inplace=True)\n\nx = [\n     date.to_datetime64().astype('M8[ms]').astype('O')\n     for date in df.x.to_list()\n]\n\ndata = {\n    'value': df.z.to_list(),\n    'x': x,\n    'y': df.y.to_list(), \n    'y_labels_tooltip' : [columns_labels[k] for k in df.y.to_list()],\n    'y_ticks' : columns_labels*1000,\n    'date' : df.x.to_list()\n}\n\n<line_mask>\n\ndef ticker(source=cd):\n    labels = source.data['y_ticks']\n    return \"{}\".format(labels[tick])\n\n#p = figure(x_axis_type='datetime', y_range=columns, width=900, tooltips=[(\"x\", \"@date{%F %T}\"), (\"y\", \"@y_labels\"), (\"value\", \"@value\")])\n\np = figure(x_axis_type='datetime', width=900, tooltips=[(\"x\", \"@date{%F %T}\"), (\"y\", \"@y_labels_tooltip\"), (\"value\", \"@value\")])\n\np.rect(x='x', y='y', width=60*1000, height=1, line_color=None, \n                   fill_color=linear_cmap('value', 'Viridis256', low=df.z.min(), high=df.z.max()), source=cd)\n\np.hover.formatters = {'date': 'datetime'}\np.yaxis.formatter = FuncTickFormatter.from_py_func(ticker)\np.yaxis[0].ticker.desired_num_ticks = 20\n\nshow(p)",
            "masked_line": "cd = ColumnDataSource(data=data)",
            "answer": "ColumnDataSource",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_742"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-06-20",
            "description": "The code creates a graph using the NetworkX package and adds edges from a data frame. It then identifies connected components in the graph and returns a list of sets, where each set represents a group of nodes that are connected to each other.",
            "code": "import networkx as nx\n\nG=nx.Graph()\nG.add_edges_from(df.values.tolist())\ncc = list(nx.connected_components(G))\n# [{'A', 'B', 'C', 'D'}, {'L', 'M', 'N', 'O'}]",
            "masked_code": "import networkx as nx\n\nG=nx.Graph()\nG.add_edges_from(df.values.tolist())\n<line_mask>\n# [{'A', 'B', 'C', 'D'}, {'L', 'M', 'N', 'O'}]",
            "masked_line": "cc = list(nx.connected_components(G))",
            "answer": "connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_743"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.1",
            "time": "2019-12-20",
            "description": "The code generates a plot with two sets of data, one plotted on the main axis and another on an inset axis. It also adds a rectangle patch to the main plot and two connection patches connecting the main plot to the inset plot.",
            "code": "import matplotlib.pyplot as plt\nfrom  matplotlib.patches import ConnectionPatch\n\n\nfig, ax = plt.subplots()\nax.plot([1,3,5], [2,4,1])\nax.set_ylim([0, 10])\nax.set_ylabel(\"Some units\")\n\naxins = ax.inset_axes([.2, .7, .4, .25])\naxins.plot([100, 200], [5456, 4650])\naxins.set_ylabel(\"Other units\")\n\nrect = [2.1, 2.6, 1, 2]\nkw = dict(linestyle=\"--\", facecolor=\"none\", edgecolor=\"k\", linewidth=0.8)\nax.add_patch(plt.Rectangle(rect[:2], *rect[2:], **kw))\ncp1 = ConnectionPatch((rect[0], rect[1]+rect[3]), (0,0), coordsA=\"data\", axesA=ax,\n                      coordsB=\"axes fraction\", axesB=axins, clip_on=False, **kw)\ncp2 = ConnectionPatch((rect[0]+rect[2], rect[1]+rect[3]), (1,0), coordsA=\"data\", axesA=ax,\n                      coordsB=\"axes fraction\", axesB=axins, clip_on=False, **kw)\nax.add_patch(cp1)\nax.add_patch(cp2)\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nfrom  matplotlib.patches import ConnectionPatch\n\n\nfig, ax = plt.subplots()\n<line_mask>\nax.set_ylim([0, 10])\nax.set_ylabel(\"Some units\")\n\naxins = ax.inset_axes([.2, .7, .4, .25])\naxins.plot([100, 200], [5456, 4650])\naxins.set_ylabel(\"Other units\")\n\nrect = [2.1, 2.6, 1, 2]\nkw = dict(linestyle=\"--\", facecolor=\"none\", edgecolor=\"k\", linewidth=0.8)\nax.add_patch(plt.Rectangle(rect[:2], *rect[2:], **kw))\ncp1 = ConnectionPatch((rect[0], rect[1]+rect[3]), (0,0), coordsA=\"data\", axesA=ax,\n                      coordsB=\"axes fraction\", axesB=axins, clip_on=False, **kw)\ncp2 = ConnectionPatch((rect[0]+rect[2], rect[1]+rect[3]), (1,0), coordsA=\"data\", axesA=ax,\n                      coordsB=\"axes fraction\", axesB=axins, clip_on=False, **kw)\nax.add_patch(cp1)\nax.add_patch(cp2)\nplt.show()",
            "masked_line": "ax.plot([1,3,5], [2,4,1])",
            "answer": "plot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_744"
        },
        {
            "dependency": "cartopy",
            "version": "==0.15",
            "time": "2019-10-22",
            "description": "This code creates a map using latitude and longitude data and displays state borders on the map. The map extent is defined and features such as land, state borders, and province lines are added to the map. The latitude and longitude data points are plotted on the map with markers.",
            "code": "import cartopy.crs as ccrs\nimport cartopy.feature as cfeature\n\n#Create latitude and longitude data\nlat=np.array([43.53,43.49,43.45,43.42,43.39,43.38,43.37,43.37,43.38,43.4])\nlon=np.array([-116.16,-116.17,-116.23,-116.29,-116.36,-116.44,-116.52,-116.6,-116.68,-116.76])\n\n#define map extent\nextent = [-130, -90, 30, 60]\n\n#define state borders\nstates_borders = cfeature.NaturalEarthFeature(\n        category='cultural',\n        name='admin_0_countries',\n        scale='50m',\n        facecolor='none')\n\nstates_provinces = cfeature.NaturalEarthFeature(\n        category='cultural',\n        name='admin_1_states_provinces_lines',\n        scale='50m',\n        facecolor='none')\n\n\n#create figure\nfig = plt.figure(figsize=(10, 8))\nax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())\n#Add features\nax.add_feature(cfeature.LAND)\nax.add_feature(states_provinces, edgecolor='gray')\nax.add_feature(states_borders, edgecolor='black')\n#plot data\nax.plot(lon,lat, 'o',transform=ccrs.PlateCarree())\nax.set_extent(extent)\n\nplt.show()",
            "masked_code": "import cartopy.crs as ccrs\nimport cartopy.feature as cfeature\n\n#Create latitude and longitude data\nlat=np.array([43.53,43.49,43.45,43.42,43.39,43.38,43.37,43.37,43.38,43.4])\nlon=np.array([-116.16,-116.17,-116.23,-116.29,-116.36,-116.44,-116.52,-116.6,-116.68,-116.76])\n\n#define map extent\nextent = [-130, -90, 30, 60]\n\n#define state borders\n<line_mask>\n        category='cultural',\n        name='admin_0_countries',\n        scale='50m',\n        facecolor='none')\n\nstates_provinces = cfeature.NaturalEarthFeature(\n        category='cultural',\n        name='admin_1_states_provinces_lines',\n        scale='50m',\n        facecolor='none')\n\n\n#create figure\nfig = plt.figure(figsize=(10, 8))\nax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())\n#Add features\nax.add_feature(cfeature.LAND)\nax.add_feature(states_provinces, edgecolor='gray')\nax.add_feature(states_borders, edgecolor='black')\n#plot data\nax.plot(lon,lat, 'o',transform=ccrs.PlateCarree())\nax.set_extent(extent)\n\nplt.show()",
            "masked_line": "states_borders = cfeature.NaturalEarthFeature(",
            "answer": "NaturalEarthFeature",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_745"
        },
        {
            "dependency": "pyglet",
            "version": "==1.2",
            "time": "2019-08-20",
            "description": "The code plays an explosion sound on loop using the pyglet library in Python.",
            "code": "import pyglet\nimport time\n\npyglet.options['audio'] = ('openal', 'pulse', 'directsound', 'silent')\nsource = pyglet.media.StaticSource(pyglet.media.load('explosion.wav'))\n\nplayer = pyglet.media.Player()\nplayer.queue(source)\nplayer.EOS_LOOP = 'loop'\nplayer.play()\n\npyglet.app.run()",
            "masked_code": "import pyglet\nimport time\n\npyglet.options['audio'] = ('openal', 'pulse', 'directsound', 'silent')\n<line_mask>\n\nplayer = pyglet.media.Player()\nplayer.queue(source)\nplayer.EOS_LOOP = 'loop'\nplayer.play()\n\npyglet.app.run()",
            "masked_line": "source = pyglet.media.StaticSource(pyglet.media.load('explosion.wav'))",
            "answer": "StaticSource",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_746"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.0",
            "time": "2019-07-30",
            "description": "The code merges two dataframes (large and small) on columns 'Name' and 'Value', keeping all rows from the 'large' dataframe and appending matching rows from the 'small' dataframe. It adds a new column '_merge' to the resulting dataframe, where cells are set to 1 if the row was present in both dataframes, and 0 otherwise.",
            "code": "import pandas as pd\nnew_large = pd.merge(left=large,\n                     right=small,\n                     how='left',\n                     on=('Name', 'Value'),\n                     indicator=True)\n\nnew_large._merge = new_large._merge.apply(lambda x: 1 if x=='both' else 0)",
            "masked_code": "import pandas as pd\nnew_large = pd.merge(left=large,\n                     right=small,\n                     how='left',\n                     on=('Name', 'Value'),\n                     indicator=True)\n\n<line_mask>",
            "masked_line": "new_large._merge = new_large._merge.apply(lambda x: 1 if x=='both' else 0)",
            "answer": "apply",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_747"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-23",
            "description": "The code allows users to select a type of plot (line or scatter) and dynamically update the visualization on the web page using Bokeh library in Python. It defines a callback function that updates the plot based on the user's selection.",
            "code": "from bokeh.models import Select, Row, ColumnDataSource\nfrom bokeh.plotting import figure, curdoc\nimport numpy as np\n\nx = np.linspace(0, 4 * np.pi, 100)\nsource = ColumnDataSource(dict(x = x, y = np.cos(x)))\nglyphs = [\"line\", \"scatter\"]\nselect = Select(title = \"Select plot:\", value = \"\", options = [\"\"] + glyphs)\ncurdoc().add_root(Row(select, name = 'root'))\n\ndef callback(attr, old, new):\n    layouts = curdoc().get_model_by_name('root').children\n    for glyph in glyphs:\n        plot = curdoc().get_model_by_name(glyph)\n        if plot:\n            layouts.remove(plot)\n    if new:\n        p = figure(name = new)\n        exec(new + ' = p.' + new + '(\"x\", \"y\", source = source)')\n        layouts.append(p)\n\nselect.on_change('value', callback)",
            "masked_code": "<line_mask>\nfrom bokeh.plotting import figure, curdoc\nimport numpy as np\n\nx = np.linspace(0, 4 * np.pi, 100)\nsource = ColumnDataSource(dict(x = x, y = np.cos(x)))\nglyphs = [\"line\", \"scatter\"]\nselect = Select(title = \"Select plot:\", value = \"\", options = [\"\"] + glyphs)\ncurdoc().add_root(Row(select, name = 'root'))\n\ndef callback(attr, old, new):\n    layouts = curdoc().get_model_by_name('root').children\n    for glyph in glyphs:\n        plot = curdoc().get_model_by_name(glyph)\n        if plot:\n            layouts.remove(plot)\n    if new:\n        p = figure(name = new)\n        exec(new + ' = p.' + new + '(\"x\", \"y\", source = source)')\n        layouts.append(p)\n\nselect.on_change('value', callback)",
            "masked_line": "from bokeh.models import Select, Row, ColumnDataSource",
            "answer": "Row",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_748"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-03-18",
            "description": "The code calculates a weighted average of each element in the input array x, where each element is multiplied by the weight and added to the next element after being multiplied by (1 - weight). It then removes the last element from the result.",
            "code": "import numpy as np\nweight = 0.5\nx = np.array([4, 3, 2])\n(x*weight + np.roll(x, -1)*(1-weight))[:-1]",
            "masked_code": "import numpy as np\nweight = 0.5\nx = np.array([4, 3, 2])\n<line_mask>",
            "masked_line": "(x*weight + np.roll(x, -1)*(1-weight))[:-1]",
            "answer": "roll",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_749"
        },
        {
            "dependency": "pandas",
            "version": "==0.24",
            "time": "2019-02-06",
            "description": "The code generates a line plot showing the data values against the corresponding quarters.",
            "code": "import pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = {\n    'Quarter': ['Q1-2018', 'Q2-2018', 'Q3-2018', 'Q4-2018', 'Q1-2019'],\n    'Data': [1,3,2,4,1]\n}\ndf = pd.DataFrame(data=data)\n\nplt.plot(\"Quarter\", \"Data\", data=df)\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = {\n    'Quarter': ['Q1-2018', 'Q2-2018', 'Q3-2018', 'Q4-2018', 'Q1-2019'],\n    'Data': [1,3,2,4,1]\n}\n<line_mask>\n\nplt.plot(\"Quarter\", \"Data\", data=df)\n\nplt.show()",
            "masked_line": "df = pd.DataFrame(data=data)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_750"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-01-29",
            "description": "The code calculates the values of two variables 'a' and 'b' using TensorFlow, defines a function 'g(x)' that computes a normalized value between 0 and 1, generates a sequence 'X' using TensorFlow, uses an Adam optimizer to minimize the loss between a sigmoid function of 'X' and 'g(X)', and executes the training loop to optimize the values of 'a' and 'b'. Finally, it prints the time taken for the eager execution to complete.",
            "code": "import tensorflow as tf\nfrom time import time\n\ntf.enable_eager_execution()\n\nbeg = time()\n\n\n@tf.function\ndef train():\n    a = tf.Variable(-10, name='a', dtype=tf.float32)\n    b = tf.Variable(10, name='b', dtype=tf.float32)\n\n    def g(x):\n        return tf.clip_by_value((x - a) / (b - a), 0, 1)\n\n    X = tf.lin_space(-20., 20., 2000)\n    opt = tf.train.AdamOptimizer(learning_rate=1e-3)\n\n    for _ in range(int(1e4)):\n        with tf.GradientTape() as tape:\n            loss = tf.reduce_sum(tf.square(tf.math.sigmoid(X) - g(X)))\n            grads = tape.gradient(loss, [a, b])\n        opt.apply_gradients(\n            zip(grads, [a, b]),\n            global_step=tf.train.get_or_create_global_step())\n\n\ntrain()\nprint('Eager run in %.1f seconds' % (time() - beg))",
            "masked_code": "import tensorflow as tf\nfrom time import time\n\ntf.enable_eager_execution()\n\nbeg = time()\n\n\n@tf.function\ndef train():\n    a = tf.Variable(-10, name='a', dtype=tf.float32)\n    b = tf.Variable(10, name='b', dtype=tf.float32)\n\n    def g(x):\n        return tf.clip_by_value((x - a) / (b - a), 0, 1)\n\n    X = tf.lin_space(-20., 20., 2000)\n    opt = tf.train.AdamOptimizer(learning_rate=1e-3)\n\n    for _ in range(int(1e4)):\n        with tf.GradientTape() as tape:\n            <line_mask>\n            grads = tape.gradient(loss, [a, b])\n        opt.apply_gradients(\n            zip(grads, [a, b]),\n            global_step=tf.train.get_or_create_global_step())\n\n\ntrain()\nprint('Eager run in %.1f seconds' % (time() - beg))",
            "masked_line": "loss = tf.reduce_sum(tf.square(tf.math.sigmoid(X) - g(X)))",
            "answer": "square",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_751"
        },
        {
            "dependency": "django",
            "version": "==3.1",
            "time": "2020-08-07",
            "description": "This code defines a subclass TurnOnOffMonitor of the Process class from the multiprocessing module. The run method of TurnOnOffMonitor closes existing database connections, retrieves a database entry from the TurnOnOff model, and prints out either \"true\" or \"false\" based on the value of turnOnOff field. The PollsConfig class initializes a TurnOnOffMonitor instance and starts it as a separate process.",
            "code": "import time\nfrom multiprocessing import Process\n\nfrom django.apps import AppConfig\nfrom django import db\n\n\n\nclass TurnOnOffMonitor(Process):\n    def __init__(self):\n        super().__init__()\n        self.daemon = True\n\n    def run(self):\n        # This import needs to be delayed. It needs to happen after apps are\n        # loaded so we put it into the method here (it won't work as top-level\n        # import)\n        from .models import TurnOnOff\n\n        # Because this is a subprocess, we must ensure that we get new\n        # connections dedicated to this process to avoid interfering with the\n        # main connections. Closing any existing connection *should* ensure\n        # this.\n        db.connections.close_all()\n\n        # We can do an endless loop here because we flagged the process as\n        # being a \"daemon\". This ensures it will exit when the parent exists\n        while True:\n            value_change = TurnOnOff.objects.first()\n            if value_change.turnOnOff:\n                print(\"true\")\n            else:\n                print(\"false\")\n            time.sleep(10)\n\n\nclass PollsConfig(AppConfig):\n    name = 'polls'\n    def ready(self):\n        monitor = TurnOnOffMonitor()\n        monitor.start()",
            "masked_code": "import time\nfrom multiprocessing import Process\n\nfrom django.apps import AppConfig\nfrom django import db\n\n\n\nclass TurnOnOffMonitor(Process):\n    def __init__(self):\n        super().__init__()\n        self.daemon = True\n\n    def run(self):\n        # This import needs to be delayed. It needs to happen after apps are\n        # loaded so we put it into the method here (it won't work as top-level\n        # import)\n        from .models import TurnOnOff\n\n        # Because this is a subprocess, we must ensure that we get new\n        # connections dedicated to this process to avoid interfering with the\n        # main connections. Closing any existing connection *should* ensure\n        # this.\n        <line_mask>\n\n        # We can do an endless loop here because we flagged the process as\n        # being a \"daemon\". This ensures it will exit when the parent exists\n        while True:\n            value_change = TurnOnOff.objects.first()\n            if value_change.turnOnOff:\n                print(\"true\")\n            else:\n                print(\"false\")\n            time.sleep(10)\n\n\nclass PollsConfig(AppConfig):\n    name = 'polls'\n    def ready(self):\n        monitor = TurnOnOffMonitor()\n        monitor.start()",
            "masked_line": "db.connections.close_all()",
            "answer": "connections",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_752"
        },
        {
            "dependency": "altair",
            "version": "==4.0",
            "time": "2019-12-17",
            "description": "This code generates an interactive scatter plot using Altair, where the x-axis represents 'Horsepower', the y-axis represents 'Miles_per_Gallon', and the points are colored based on the 'Origin' of the cars.",
            "code": "import altair as alt\nfrom vega_datasets import data\n\nalt.renderers.set_embed_options(actions=False)\n\nalt.Chart(data.cars()).mark_point().encode(\n    x='Horsepower',\n    y='Miles_per_Gallon',\n    color='Origin',\n).interactive()",
            "masked_code": "import altair as alt\nfrom vega_datasets import data\n\nalt.renderers.set_embed_options(actions=False)\n\n<line_mask>\n    x='Horsepower',\n    y='Miles_per_Gallon',\n    color='Origin',\n).interactive()",
            "masked_line": "alt.Chart(data.cars()).mark_point().encode(",
            "answer": "Chart",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_753"
        },
        {
            "dependency": "pyspark",
            "version": "==2.4",
            "time": "2019-12-09",
            "description": "The code zips the columns 'lat' and 'lon' in a DataFrame called 'df' into a new column 'zipped_lat_lon' using the arrays_zip function from pyspark.sql.functions and displays the result.",
            "code": "from pyspark.sql.functions import arrays_zip\ndf.withColumn('zipped_lat_lon',arrays_zip(df.lat,df.lon)).show()",
            "masked_code": "<line_mask>\ndf.withColumn('zipped_lat_lon',arrays_zip(df.lat,df.lon)).show()",
            "masked_line": "from pyspark.sql.functions import arrays_zip",
            "answer": "arrays_zip",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_754"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-11-11",
            "description": "The code rounds the result of applying a custom function called function_calc to each row of a dataframe df, setting the 'value' column to the rounded values.",
            "code": "import numpy as np    \ndf['value'] = np.round(df.apply(function_calc, axis=1), decimals=0)",
            "masked_code": "import numpy as np    \n<line_mask>",
            "masked_line": "df['value'] = np.round(df.apply(function_calc, axis=1), decimals=0)",
            "answer": "apply",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_755"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-08-23",
            "description": "The code generates a signal consisting of a sine wave with added random noise. It then computes the number of samples per segment and the overlap for segmenting the signal. After calculating the sampling rate, it computes the Power Spectral Density (PSD) of the signal using the Welch method. Finally, it plots the original signal and the PSD on two separate figures, with the frequency axis on a logarithmic scale for the PSD plot.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import welch\n\n# Generate signal\nfreq = 1.0 # Hz\nt = np.linspace(0, 10, 1000)\ny = np.sin(2.*np.pi*freq*t) + 0.2*np.random.random(len(t))\n\n# Compute no. samples per segment\nnSegments = 3\noverlap = 0.5\n\nnPerSeg = np.round(len(y)//nSegments / overlap)\nif nSegments == 1:\n    nPerSeg = len(y)\nnOverlap = np.round(overlap * nPerSeg)\n\n# Compute sampling rate.\ndt = t[1] - t[0]\n\n# Compute PSD\nf, psd = welch(y, fs=1./dt,\n    window=\"hamm\", nperseg=nPerSeg, noverlap=nOverlap, nfft=None, detrend=\"constant\",\n    return_onesided=True, scaling=\"density\")\n\n# Plot\nplt.figure()\nplt.plot(t, y)\n\nplt.figure()\nplt.plot(f/freq, psd)\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.grid()\nplt.xlabel(\"f/freq\")\nplt.ylabel(\"PSD of y\")\n\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import welch\n\n# Generate signal\nfreq = 1.0 # Hz\nt = np.linspace(0, 10, 1000)\ny = np.sin(2.*np.pi*freq*t) + 0.2*np.random.random(len(t))\n\n# Compute no. samples per segment\nnSegments = 3\noverlap = 0.5\n\nnPerSeg = np.round(len(y)//nSegments / overlap)\nif nSegments == 1:\n    nPerSeg = len(y)\nnOverlap = np.round(overlap * nPerSeg)\n\n# Compute sampling rate.\ndt = t[1] - t[0]\n\n# Compute PSD\n<line_mask>\n    window=\"hamm\", nperseg=nPerSeg, noverlap=nOverlap, nfft=None, detrend=\"constant\",\n    return_onesided=True, scaling=\"density\")\n\n# Plot\nplt.figure()\nplt.plot(t, y)\n\nplt.figure()\nplt.plot(f/freq, psd)\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.grid()\nplt.xlabel(\"f/freq\")\nplt.ylabel(\"PSD of y\")\n\nplt.show()",
            "masked_line": "f, psd = welch(y, fs=1./dt,",
            "answer": "welch",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_756"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.21.2",
            "time": "2019-07-28",
            "description": "The code splits the Iris dataset into training and testing sets, fits a Decision Tree classifier with a maximum depth of 1 to the training data, predicts the classes of the test data, and plots the decision tree.",
            "code": "from sklearn.model_selection import train_test_split\nfrom sklearn.datasets import load_iris\nfrom sklearn.tree import plot_tree\n\ndataset = load_iris()\n\nX_train,X_test,y_train,y_test = train_test_split(dataset.data,\n                                                 dataset.target,\n                                                 test_size=0.3,\n                                                 random_state=0)\nfrom sklearn.tree import DecisionTreeClassifier\nclf = DecisionTreeClassifier(max_depth=1, random_state=1)\nclf.fit(X_train,y_train)\nprint(clf.predict(X_test))\n\nplot_tree(clf)",
            "masked_code": "from sklearn.model_selection import train_test_split\n<line_mask>\nfrom sklearn.tree import plot_tree\n\ndataset = load_iris()\n\nX_train,X_test,y_train,y_test = train_test_split(dataset.data,\n                                                 dataset.target,\n                                                 test_size=0.3,\n                                                 random_state=0)\nfrom sklearn.tree import DecisionTreeClassifier\nclf = DecisionTreeClassifier(max_depth=1, random_state=1)\nclf.fit(X_train,y_train)\nprint(clf.predict(X_test))\n\nplot_tree(clf)",
            "masked_line": "from sklearn.datasets import load_iris",
            "answer": "load_iris",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_757"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-06-12",
            "description": "This code is for training a neural network model using the IMDB movie reviews dataset. The code preprocesses the text data by tokenizing and padding the sequences, then builds a neural network model with layers for embedding, flattening, and dense layers for classification. Finally, the model is compiled and trained on the training data with binary crossentropy loss and Adam optimizer for 10 epochs.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\n\ntf.compat.v1.enable_eager_execution()\n\nimport tensorflow_datasets as tfds\nimdb, info = tfds.load(\"imdb_reviews\", with_info = True, as_supervised = True)\n\nimport numpy as np\ntrain_data, test_data = imdb['train'], imdb['test']\ntraining_sentences = []\ntraining_labels = []\ntesting_sentences = []\ntesting_labels = [] \n\nfor s, l in train_data:\n    training_sentences.append(str(s.numpy()))\n    training_labels.append(l.numpy())\n\nfor s, l in test_data:\n    testing_sentences.append(str(s.numpy()))\n    testing_labels.append(l.numpy())\n\ntraining_labels_final = np.array(training_labels)\ntesting_labels_final = np.array(testing_labels)\n\nvocab_size = 10000\nembedding_dim =16\nmax_length = 120\ntrunc_type = 'post'\noov_tok = \"\"\n\nfrom tensorflow.keras.preprocessing.text import Tokenizer\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\n\ntokenizer = Tokenizer(num_words = vocab_size, oov_token = oov_tok)\ntokenizer.fit_on_texts(training_sentences)\nword_index = tokenizer.word_index #key-value dictionary on training_sentences\n\nsequences = tokenizer.texts_to_sequences(training_sentences)\n\npadded = pad_sequences(sequences, maxlen = max_length, truncating = trunc_type)\n\ntesting_sequences = tokenizer.texts_to_sequences(testing_sentences)\n\ntesting_padded = pad_sequences(testing_sequences, maxlen = max_length)\n\nreverse_word_index = dict([(value, key) for (key,value) in word_index.items()])\ndef decode_review(text):\n    return ' '.join([reverse_word_index.get(i, '?') for i in text])\n\nprint(decode_review(padded[0]))\nprint(training_sentences[0])\n\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Embedding(vocab_size, embedding_dim, input_length=max_length),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(6, activation='relu'),\n    tf.keras.layers.Dense(1,activation = 'sigmoid'),\n])\n\nmodel.compile(loss=\"binary_crossentropy\", optimizer='adam', metrics=['accuracy'])\nmodel.summary\n\nnum_epochs = 10\nmodel.fit(padded, training_labels_final, epochs=num_epochs, validation_data=(testing_padded, testing_labels_final))",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\n\ntf.compat.v1.enable_eager_execution()\n\nimport tensorflow_datasets as tfds\nimdb, info = tfds.load(\"imdb_reviews\", with_info = True, as_supervised = True)\n\nimport numpy as np\ntrain_data, test_data = imdb['train'], imdb['test']\ntraining_sentences = []\ntraining_labels = []\ntesting_sentences = []\ntesting_labels = [] \n\nfor s, l in train_data:\n    training_sentences.append(str(s.numpy()))\n    training_labels.append(l.numpy())\n\nfor s, l in test_data:\n    testing_sentences.append(str(s.numpy()))\n    testing_labels.append(l.numpy())\n\ntraining_labels_final = np.array(training_labels)\ntesting_labels_final = np.array(testing_labels)\n\nvocab_size = 10000\nembedding_dim =16\nmax_length = 120\ntrunc_type = 'post'\noov_tok = \"\"\n\n<line_mask>\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\n\ntokenizer = Tokenizer(num_words = vocab_size, oov_token = oov_tok)\ntokenizer.fit_on_texts(training_sentences)\nword_index = tokenizer.word_index #key-value dictionary on training_sentences\n\nsequences = tokenizer.texts_to_sequences(training_sentences)\n\npadded = pad_sequences(sequences, maxlen = max_length, truncating = trunc_type)\n\ntesting_sequences = tokenizer.texts_to_sequences(testing_sentences)\n\ntesting_padded = pad_sequences(testing_sequences, maxlen = max_length)\n\nreverse_word_index = dict([(value, key) for (key,value) in word_index.items()])\ndef decode_review(text):\n    return ' '.join([reverse_word_index.get(i, '?') for i in text])\n\nprint(decode_review(padded[0]))\nprint(training_sentences[0])\n\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Embedding(vocab_size, embedding_dim, input_length=max_length),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(6, activation='relu'),\n    tf.keras.layers.Dense(1,activation = 'sigmoid'),\n])\n\nmodel.compile(loss=\"binary_crossentropy\", optimizer='adam', metrics=['accuracy'])\nmodel.summary\n\nnum_epochs = 10\nmodel.fit(padded, training_labels_final, epochs=num_epochs, validation_data=(testing_padded, testing_labels_final))",
            "masked_line": "from tensorflow.keras.preprocessing.text import Tokenizer",
            "answer": "Tokenizer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_758"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-06-28",
            "description": "This code snippet reorganizes a flat index into a multi-dimensional index by using numpy's unravel_index function. It then uses the reorganized index to retrieve values from the input array.",
            "code": "temp = np.unravel_index(flat_idx, inp.shape)\n#Output:\n(array([0, 0, 1, 1], dtype=int64),\n array([0, 1, 0, 1], dtype=int64),\n array([1, 0, 0, 0], dtype=int64))\n\ninp[temp]",
            "masked_code": "<line_mask>\n#Output:\n(array([0, 0, 1, 1], dtype=int64),\n array([0, 1, 0, 1], dtype=int64),\n array([1, 0, 0, 0], dtype=int64))\n\ninp[temp]",
            "masked_line": "temp = np.unravel_index(flat_idx, inp.shape)",
            "answer": "unravel_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_759"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-06-06",
            "description": "This code calculates the eigenvalues and right eigenvectors of a pair of square matrices A and B.",
            "code": "from scipy import linalg\nlinalg.eig(A, B)",
            "masked_code": "from scipy import linalg\n<line_mask>",
            "masked_line": "linalg.eig(A, B)",
            "answer": "eig",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_760"
        },
        {
            "dependency": "cartopy",
            "version": "==0.17",
            "time": "2019-05-10",
            "description": "The code defines a geographic coordinate reference system using the GRS80 ellipse to represent the shape of the Earth.",
            "code": "import cartopy.crs as ccrs\nglobe = ccrs.Globe(ellipse='GRS80')\ncrs = ccrs.Geodetic(globe=globe)",
            "masked_code": "import cartopy.crs as ccrs\nglobe = ccrs.Globe(ellipse='GRS80')\n<line_mask>",
            "masked_line": "crs = ccrs.Geodetic(globe=globe)",
            "answer": "Geodetic",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_761"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-05-03",
            "description": "The code allows the user to create a Bokeh application with a button for checking the status (active/inactive) of another button \"button3\" and a checkbox group \"cb\". The check status button, when clicked, prints the status of button3 and cb. Additionally, there is a toggle button \"button3\" to stop the loop and a periodic callback to continuously check and print the status of button3 and cb every 1000 milliseconds.",
            "code": "from bokeh.models import Column\nfrom bokeh.plotting import curdoc\nfrom bokeh.models.widgets import Button, Toggle, CheckboxGroup\nimport time\n\n# def start_loop():\n#     while (not button3.active) and (len(cb.active)):\n#         time.sleep(1)\n#         print(button3.active)\n#         print(cb.active)\n\ndef check_status():\n    print(button3.active)\n    print(cb.active)\n\n# button1 = Button(label = \"start\")\n# button1.on_click(start_loop)\n\nbutton2 = Button(label = \"check status\")\nbutton2.on_click(check_status)\n\nbutton3 = Toggle(label = \"stop\")\ncb = CheckboxGroup(labels = ['stop'], active = [0])\n\ncurdoc().add_root(Column(button2, button3, cb))\ncurdoc().add_periodic_callback(check_status, 1000)",
            "masked_code": "from bokeh.models import Column\nfrom bokeh.plotting import curdoc\n<line_mask>\nimport time\n\n# def start_loop():\n#     while (not button3.active) and (len(cb.active)):\n#         time.sleep(1)\n#         print(button3.active)\n#         print(cb.active)\n\ndef check_status():\n    print(button3.active)\n    print(cb.active)\n\n# button1 = Button(label = \"start\")\n# button1.on_click(start_loop)\n\nbutton2 = Button(label = \"check status\")\nbutton2.on_click(check_status)\n\nbutton3 = Toggle(label = \"stop\")\ncb = CheckboxGroup(labels = ['stop'], active = [0])\n\ncurdoc().add_root(Column(button2, button3, cb))\ncurdoc().add_periodic_callback(check_status, 1000)",
            "masked_line": "from bokeh.models.widgets import Button, Toggle, CheckboxGroup",
            "answer": "Toggle",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_762"
        },
        {
            "dependency": "dash",
            "version": "==0.38.0",
            "time": "2019-05-03",
            "description": "This code creates a Dash web application using JupyterDash and displays a Cytoscape network visualization with two nodes and one edge.",
            "code": "from jupyter_plotly_dash import JupyterDash\nimport dash\nimport dash_cytoscape as cyto\nimport dash_html_components as html\n\napp = JupyterDash('YourAppExample')\n\napp.layout = html.Div([\n    cyto.Cytoscape(\n        id='cytoscape',\n        elements=[\n            {'data': {'id': 'one', 'label': 'Node 1'}, 'position': {'x': 50, 'y': 50}},\n            {'data': {'id': 'two', 'label': 'Node 2'}, 'position': {'x': 200, 'y': 200}},\n            {'data': {'source': 'one', 'target': 'two','label': 'Node 1 to 2'}}\n        ],\n        layout={'name': 'preset'}\n    )\n])\n\napp",
            "masked_code": "from jupyter_plotly_dash import JupyterDash\nimport dash\nimport dash_cytoscape as cyto\nimport dash_html_components as html\n\napp = JupyterDash('YourAppExample')\n\n<line_mask>\n    cyto.Cytoscape(\n        id='cytoscape',\n        elements=[\n            {'data': {'id': 'one', 'label': 'Node 1'}, 'position': {'x': 50, 'y': 50}},\n            {'data': {'id': 'two', 'label': 'Node 2'}, 'position': {'x': 200, 'y': 200}},\n            {'data': {'source': 'one', 'target': 'two','label': 'Node 1 to 2'}}\n        ],\n        layout={'name': 'preset'}\n    )\n])\n\napp",
            "masked_line": "app.layout = html.Div([",
            "answer": "Div",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_763"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.13.1",
            "time": "2019-04-06",
            "description": "This code creates a TensorFlow dataset consisting of a range of 10000 integers. It applies optimization options to the dataset, maps a Python function `pr` to each element of the dataset, batches the dataset into groups of 3, creates an iterator, initializes variables, and iterates through the dataset for 2 steps while printing the fetched elements.",
            "code": "import tensorflow as tf\n\ndef pr(x):\n    print(x)\n    return x\n\n\ndataset = tf.data.Dataset.range(10000)\n\noptions = tf.data.Options()\noptions.experimental_optimization.apply_default_optimizations = False\ndataset = dataset.with_options(options)\n\ndataset = dataset.map(lambda x: tf.py_func(pr, [x], [tf.int64]))\n\ndataset = dataset.batch(3)\n\niterator = dataset.make_initializable_iterator()\n\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    sess.run(iterator.initializer)\n    next_element = iterator.get_next()\n\n    for i in range(2):\n        fetches = sess.run(next_element)\n        print(fetches)",
            "masked_code": "import tensorflow as tf\n\ndef pr(x):\n    print(x)\n    return x\n\n\ndataset = tf.data.Dataset.range(10000)\n\noptions = tf.data.Options()\noptions.experimental_optimization.apply_default_optimizations = False\ndataset = dataset.with_options(options)\n\n<line_mask>\n\ndataset = dataset.batch(3)\n\niterator = dataset.make_initializable_iterator()\n\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    sess.run(iterator.initializer)\n    next_element = iterator.get_next()\n\n    for i in range(2):\n        fetches = sess.run(next_element)\n        print(fetches)",
            "masked_line": "dataset = dataset.map(lambda x: tf.py_func(pr, [x], [tf.int64]))",
            "answer": "map",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_764"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-03-28",
            "description": "The code reads data from a website that provides predictions for football matches with over 1.5 goals. It then processes the data to extract information such as the date, time, football league, home team, and away team for each match. Finally, it renames the \"Logic\" column to \"Description\" for clarity.",
            "code": "import pandas as pd\n\ntables = pd.read_html('https://afootballreport.com/predictions/over-1.5-goals/')\ntable = tables[0]\n\ntable[['Date', 'Time']] = table['Home team - Away team'].str.split('  ', expand=True)\ntable = table.drop(['Home team - Away team'],axis=1)\ntable =  table.rename(columns={\"Logic\":\"Description\"})   \n\n\ntable[['Football League', 'Home Team', 'Away Team']] = table['Home team - Away team.1'].str.split('  ', expand=True)\ntable = table.drop(['Home team - Away team.1'],axis=1)",
            "masked_code": "import pandas as pd\n\n<line_mask>\ntable = tables[0]\n\ntable[['Date', 'Time']] = table['Home team - Away team'].str.split('  ', expand=True)\ntable = table.drop(['Home team - Away team'],axis=1)\ntable =  table.rename(columns={\"Logic\":\"Description\"})   \n\n\ntable[['Football League', 'Home Team', 'Away Team']] = table['Home team - Away team.1'].str.split('  ', expand=True)\ntable = table.drop(['Home team - Away team.1'],axis=1)",
            "masked_line": "tables = pd.read_html('https://afootballreport.com/predictions/over-1.5-goals/')",
            "answer": "read_html",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_765"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-12",
            "description": "This code reads data from a CSV file, extracts columns starting from the second column, and then calculates the maximum and minimum values for each column.",
            "code": "import numpy\narray = numpy.genfromtxt('Anaconda3JamesData/james_test_3.csv', delimiter=',')\narray[:, 1:].max()\narray[:, 1:].min()",
            "masked_code": "import numpy\narray = numpy.genfromtxt('Anaconda3JamesData/james_test_3.csv', delimiter=',')\n<line_mask>\narray[:, 1:].min()",
            "masked_line": "array[:, 1:].max()",
            "answer": "max",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_766"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-09-13",
            "description": "The code initializes a ResNet50 model using TensorFlow, generates a random image, and passes the random image through the ResNet50 model to get the model's output.",
            "code": "import tensorflow as tf\n\nmodel = tf.keras.applications.ResNet50()\n\ninit_op = tf.global_variables_initializer()\nwith tf.compat.v1.Session() as sess:\n    random_image, _ = sess.run([tf.random.normal(shape=[1, 224, 224, 3]), init_op])\n    outputs = sess.run(model.output, feed_dict={model.input:random_image})",
            "masked_code": "import tensorflow as tf\n\n<line_mask>\n\ninit_op = tf.global_variables_initializer()\nwith tf.compat.v1.Session() as sess:\n    random_image, _ = sess.run([tf.random.normal(shape=[1, 224, 224, 3]), init_op])\n    outputs = sess.run(model.output, feed_dict={model.input:random_image})",
            "masked_line": "model = tf.keras.applications.ResNet50()",
            "answer": "ResNet50",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_767"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-07-16",
            "description": "The code defines a piecewise constant decay learning rate schedule based on the specified parameters such as initial learning rate, decay factor, and milestones. The learning rate decreases at each milestone step defined by the boundaries, with each step decaying by a factor of the initial learning rate divided by the decay factor raised to the power of the milestone index.",
            "code": "import numpy as np\nfrom tensorflow.python.keras.optimizer_v2 import learning_rate_schedule\nn_step_epoch = 100\ninit_lr = 0.01\ndecay = 0.1\n\ndecay_type = 'multistep_15_25_100'\nmilestones = decay_type.split('_')\nmilestones.pop(0)\nmilestones = list(map(lambda x: int(x), milestones))\nboundaries = np.multiply(milestones,n_step_epoch)\nvalues = [init_lr] + [init_lr/(decay**-i) for i in  range(1,len(milestones)+1)]\nlearning_rate =learning_rate_schedule.PiecewiseConstantDecay(boundaries.tolist(), values)",
            "masked_code": "import numpy as np\nfrom tensorflow.python.keras.optimizer_v2 import learning_rate_schedule\nn_step_epoch = 100\ninit_lr = 0.01\ndecay = 0.1\n\ndecay_type = 'multistep_15_25_100'\nmilestones = decay_type.split('_')\nmilestones.pop(0)\nmilestones = list(map(lambda x: int(x), milestones))\nboundaries = np.multiply(milestones,n_step_epoch)\nvalues = [init_lr] + [init_lr/(decay**-i) for i in  range(1,len(milestones)+1)]\n<line_mask>",
            "masked_line": "learning_rate =learning_rate_schedule.PiecewiseConstantDecay(boundaries.tolist(), values)",
            "answer": "PiecewiseConstantDecay",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_768"
        },
        {
            "dependency": "scipy",
            "version": "==1.3.0",
            "time": "2019-06-25",
            "description": "This code defines a function called median_filter that applies a median filter to an input array using a specified footprint. It calculates the median value based on the size of the footprint and applies the filter accordingly. If the filter size is even, it handles ties by averaging the values. The function then returns the filtered output array.",
            "code": "from scipy.ndimage.filters import _rank_filter\n\ndef median_filter(input, footprint, output=None, mode=\"reflect\", cval=0.0, origin=0):\n    filter_size = np.where(footprint, 1, 0).sum()\n    rank = filter_size // 2\n    result = _rank_filter(\n        input, rank, None, footprint, output, mode, cval, origin, 'dummy')\n    if filter_size % 2 == 0:\n        if result is output:\n            tmp = result.copy()\n        else:\n            tmp = result\n        rank -= 1\n        assert rank > 0\n        result = _rank_filter(\n            input, rank, None, footprint, output, mode, cval, origin, 'dummy')\n        # fix up ties without creating any more garbage\n        result += tmp\n        result /= 2\n    return result",
            "masked_code": "from scipy.ndimage.filters import _rank_filter\n\ndef median_filter(input, footprint, output=None, mode=\"reflect\", cval=0.0, origin=0):\n    filter_size = np.where(footprint, 1, 0).sum()\n    rank = filter_size // 2\n    result = _rank_filter(\n        input, rank, None, footprint, output, mode, cval, origin, 'dummy')\n    if filter_size % 2 == 0:\n        if result is output:\n            <line_mask>\n        else:\n            tmp = result\n        rank -= 1\n        assert rank > 0\n        result = _rank_filter(\n            input, rank, None, footprint, output, mode, cval, origin, 'dummy')\n        # fix up ties without creating any more garbage\n        result += tmp\n        result /= 2\n    return result",
            "masked_line": "tmp = result.copy()",
            "answer": "copy",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_769"
        },
        {
            "dependency": "kivy",
            "version": "<1.10.0",
            "time": "2019-04-07",
            "description": "This Python code creates a simple Kivy application that displays a list of messages with left-aligned labels and a text input field below the list. The messages displayed in the list are initially [\"a\", \"b\"] and an additional message \"sd\" is appended to the list.",
            "code": "from kivy.app import App\nfrom kivy.uix.button import Button\nfrom kivy.uix.boxlayout import BoxLayout\nfrom kivy.uix.listview import SimpleListAdapter\nfrom kivy.uix.listview import ListView\nfrom kivy.uix.label import Label\nfrom kivy.uix.textinput import TextInput\n\n\nclass LeftLabel(Label):\n    def __init__(self, **kwargs):\n        super(LeftLabel, self).__init__(**kwargs)\n        # https://kivy.org/doc/stable/api-kivy.uix.label.html#text-alignment-and-wrapping\n        self.halign = \"left\"\n        self.bind(size=self.setter(\"text_size\"))\n\n\nclass TestApp(App):\n    def build(self):\n        messages = [\"a\", \"b\"]\n        layout = BoxLayout(orientation=\"vertical\")\n        btn1 = Button(text=\"Hello\")\n        textinput = TextInput(text=\"Hello world\", size_hint=(1, 0.1))\n        messages.append(\"sd\")\n        simple_list_adapter = SimpleListAdapter(data=messages, cls=LeftLabel)\n        list_view = ListView(adapter=simple_list_adapter)\n        layout.add_widget(list_view)\n        layout.add_widget(textinput)\n        return layout\n\n\nTestApp().run()",
            "masked_code": "from kivy.app import App\nfrom kivy.uix.button import Button\n<line_mask>\nfrom kivy.uix.listview import SimpleListAdapter\nfrom kivy.uix.listview import ListView\nfrom kivy.uix.label import Label\nfrom kivy.uix.textinput import TextInput\n\n\nclass LeftLabel(Label):\n    def __init__(self, **kwargs):\n        super(LeftLabel, self).__init__(**kwargs)\n        # https://kivy.org/doc/stable/api-kivy.uix.label.html#text-alignment-and-wrapping\n        self.halign = \"left\"\n        self.bind(size=self.setter(\"text_size\"))\n\n\nclass TestApp(App):\n    def build(self):\n        messages = [\"a\", \"b\"]\n        layout = BoxLayout(orientation=\"vertical\")\n        btn1 = Button(text=\"Hello\")\n        textinput = TextInput(text=\"Hello world\", size_hint=(1, 0.1))\n        messages.append(\"sd\")\n        simple_list_adapter = SimpleListAdapter(data=messages, cls=LeftLabel)\n        list_view = ListView(adapter=simple_list_adapter)\n        layout.add_widget(list_view)\n        layout.add_widget(textinput)\n        return layout\n\n\nTestApp().run()",
            "masked_line": "from kivy.uix.boxlayout import BoxLayout",
            "answer": "BoxLayout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_770"
        },
        {
            "dependency": "django",
            "version": "==2.2",
            "time": "2019-04-05",
            "description": "This code defines a class TradePlantPage that extends the RoutablePageMixin and PlantPage classes. It specifies that instances of TradePlantPage can only be children of TradePlantIndexPage instances and cannot have any subpages. The trade method within the class takes a request and a plant_slug as parameters, retrieves a PlantPage object with the given slug, and renders a template with trade-related information including the plant object and the current page object.",
            "code": "from django.shortcuts import get_object_or_404, render\n\nclass TradePlantPage(RoutablePageMixin, PlantPage):\n    parent_page_types = ['TradePlantIndexPage']\n    subpage_types = []\n\n    @route(r'^([-\\w]+)/$')\n    def trade(self, request, plant_slug):\n        plant = get_object_or_404(PlantPage, slug=plant_slug)\n\n        return render(request, 'plants/plant_page.html', {\n            'trade': True,\n            'plant': plant,\n            'page': self,\n        })",
            "masked_code": "<line_mask>\n\nclass TradePlantPage(RoutablePageMixin, PlantPage):\n    parent_page_types = ['TradePlantIndexPage']\n    subpage_types = []\n\n    @route(r'^([-\\w]+)/$')\n    def trade(self, request, plant_slug):\n        plant = get_object_or_404(PlantPage, slug=plant_slug)\n\n        return render(request, 'plants/plant_page.html', {\n            'trade': True,\n            'plant': plant,\n            'page': self,\n        })",
            "masked_line": "from django.shortcuts import get_object_or_404, render",
            "answer": "render",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_771"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-03-03",
            "description": "The code defines a command-line interface using the click library in Python. It creates a CLI with a \"show\" group that has subcommands \"name\" and \"height\". When executed, it prints the Click library version, Python version, and runs commands specified in the \"commands\" list. It handles exceptions and prints the output of running the commands.",
            "code": "import click\n\n@click.group()\ndef cli():\n    pass\n\n@cli.group(cls=HelpAsArgs)\ndef show():\n    \"\"\" Define the environment of the product \"\"\"\n    pass\n\n@show.command()\ndef name():\n    click.echo(\"run show name command\")\n\n@show.command()\ndef height():\n    click.echo(\"run show height command\")\n\nif __name__ == \"__main__\":\n    commands = (\n        'show',\n        'show --help',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for command in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + command)\n            time.sleep(0.1)\n            cli(command.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\n@click.group()\ndef cli():\n    pass\n\n@cli.group(cls=HelpAsArgs)\ndef show():\n    \"\"\" Define the environment of the product \"\"\"\n    pass\n\n@show.command()\ndef name():\n    <line_mask>\n\n@show.command()\ndef height():\n    click.echo(\"run show height command\")\n\nif __name__ == \"__main__\":\n    commands = (\n        'show',\n        'show --help',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for command in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + command)\n            time.sleep(0.1)\n            cli(command.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "click.echo(\"run show name command\")",
            "answer": "echo",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_772"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-17",
            "description": "The code creates a Bokeh plot with a line chart of specified coordinates, overlaid with an image of a dog head.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.models import CustomJS, Div, Row\n\np1 = figure(plot_width = 300, plot_height = 300, x_range = (0, 10), y_range = (0, 10), title = \"Doggy as background\")\np1.line([1, 2, 3, 5, 6, 7, 8, 9, 10], [4, 5, 6, 1, 2, 3, 7, 8, 9, 0], line_width = 5)\nurl = \"https://cdn3.iconfinder.com/data/icons/line/36/dog_head-512.png\"\nd1 = Div(text = '')\n\nshow(Row(p1, d1))",
            "masked_code": "from bokeh.plotting import figure, show\nfrom bokeh.models import CustomJS, Div, Row\n\np1 = figure(plot_width = 300, plot_height = 300, x_range = (0, 10), y_range = (0, 10), title = \"Doggy as background\")\np1.line([1, 2, 3, 5, 6, 7, 8, 9, 10], [4, 5, 6, 1, 2, 3, 7, 8, 9, 0], line_width = 5)\nurl = \"https://cdn3.iconfinder.com/data/icons/line/36/dog_head-512.png\"\nd1 = Div(text = '')\n\n<line_mask>",
            "masked_line": "show(Row(p1, d1))",
            "answer": "Row",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_773"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-05-06",
            "description": "The code creates two tabs (Tab 1 and Tab 2) with corresponding labels using Bokeh library. It also defines a function panelActive() that prints out the active panel whenever the active panel changes. Finally, it adds the tabs to the document root using curdoc().add_root().",
            "code": "from bokeh.layouts import widgetbox\nfrom bokeh.models import Div, Tabs, Panel\nfrom bokeh.plotting import curdoc\n\nlabel1 = Div(text = 'Tab 1')\nlabel2 = Div(text = 'Tab 2')\npanel1 = Panel(child = widgetbox(label1), title = 'Tab 1')\npanel2 = Panel(child = widgetbox(label2), title = 'Tab 2')\ntabs = Tabs(tabs = [panel1, panel2])\n\ndef panelActive(attr, old, new):\n    print(\"the active panel is \" + str(tabs.active))\n\ntabs.on_change('active', panelActive)\n\ncurdoc().add_root(tabs)",
            "masked_code": "<line_mask>\nfrom bokeh.models import Div, Tabs, Panel\nfrom bokeh.plotting import curdoc\n\nlabel1 = Div(text = 'Tab 1')\nlabel2 = Div(text = 'Tab 2')\npanel1 = Panel(child = widgetbox(label1), title = 'Tab 1')\npanel2 = Panel(child = widgetbox(label2), title = 'Tab 2')\ntabs = Tabs(tabs = [panel1, panel2])\n\ndef panelActive(attr, old, new):\n    print(\"the active panel is \" + str(tabs.active))\n\ntabs.on_change('active', panelActive)\n\ncurdoc().add_root(tabs)",
            "masked_line": "from bokeh.layouts import widgetbox",
            "answer": "widgetbox",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_774"
        },
        {
            "dependency": "soundfile",
            "version": "==0.8.1",
            "time": "2020-11-06",
            "description": "The code writes the 'reduced_noise' data to a stereo WAV file named 'stereo_file1.wav' at a sampling rate of 48000 Hz with a bit depth of 24-bit.",
            "code": "import soundfile as sf\nsf.write('stereo_file1.wav', reduced_noise, 48000, 'PCM_24')",
            "masked_code": "import soundfile as sf\n<line_mask>",
            "masked_line": "sf.write('stereo_file1.wav', reduced_noise, 48000, 'PCM_24')",
            "answer": "write",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_775"
        },
        {
            "dependency": "pymer4",
            "version": "==0.7.8",
            "time": "2021-04-07",
            "description": "This code fits a Bayesian logistic mixed effects model using the pymer4 library to predict the likelihood of survival based on age and passenger class in a dataset.",
            "code": "from pymer4.models import Lmer\n\nmodel = Lmer(\"Survived  ~ Age  + (1|Pclass)\",\n             data=titanic, family = 'binomial')\n\nprint(model.fit())",
            "masked_code": "from pymer4.models import Lmer\n\nmodel = Lmer(\"Survived  ~ Age  + (1|Pclass)\",\n             data=titanic, family = 'binomial')\n\n<line_mask>",
            "masked_line": "print(model.fit())",
            "answer": "fit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_776"
        },
        {
            "dependency": "plotly",
            "version": ">=4.9",
            "time": "2020-08-13",
            "description": "This code generates a line plot with multiple subplots showing the relationship between the values and dates for different variables. The data is first created with vastly different ranges and then melted from wide to long format. The plot is customized with facet columns, height, width, and title. Subplot y-axis and x-axis titles are hidden, and a single y-axis and x-axis title are added to the plot.",
            "code": "import pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport string\nimport plotly.graph_objects as go\n\n# create a dataframe\ncols = list(string.ascii_letters)\ncols[0]='zzz'\nn = 50\n\ndf = pd.DataFrame({'Date': pd.date_range('2021-01-01', periods=n)})\n\n# create data with vastly different ranges\nfor col in cols:\n    start = np.random.choice([1, 10, 100, 1000, 100000])\n    s = np.random.normal(loc=0, scale=0.01*start, size=n)\n    df[col] = start + s.cumsum()\n\n# melt data columns from wide to long\ndfm = df.melt(\"Date\")\n\nfig = px.line(\n    data_frame=dfm,\n    x = 'Date',\n    y = 'value',\n    facet_col = 'variable',\n    facet_col_wrap=6,\n    #facet_col_spacing=0.05,\n    #facet_row_spacing=0.035,\n    height = 1000,\n    width = 1000,\n    title = 'Value vs. Date'\n)\n\nfig.update_yaxes(matches=None, showticklabels=True, visible=True)\nfig.update_annotations(font=dict(size=16))\nfig.for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1]))\n\n# subplot titles\nfor anno in fig['layout']['annotations']:\n    anno['text']=''\n\n# hide subplot y-axis titles and x-axis titles\nfor axis in fig.layout:\n    if type(fig.layout[axis]) == go.layout.YAxis:\n        fig.layout[axis].title.text = ''\n    if type(fig.layout[axis]) == go.layout.XAxis:\n        fig.layout[axis].title.text = ''\n        \n# keep all other annotations and add single y-axis and x-axis title:\nfig.update_layout(\n    # keep the original annotations and add a list of new annotations:\n    annotations = list(fig.layout.annotations) + \n    [go.layout.Annotation(\n            x=-0.07,\n            y=0.5,\n            font=dict(\n                size=16, color = 'blue'\n            ),\n            showarrow=False,\n            text=\"single y-axis title\",\n            textangle=-90,\n            xref=\"paper\",\n            yref=\"paper\"\n        )\n    ] +\n    [go.layout.Annotation(\n            x=0.5,\n            y=-0.08,\n            font=dict(\n                size=16, color = 'blue'\n            ),\n            showarrow=False,\n            text=\"Dates\",\n            textangle=-0,\n            xref=\"paper\",\n            yref=\"paper\"\n        )\n    ]\n)\n\n\nfig.show()",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport string\nimport plotly.graph_objects as go\n\n# create a dataframe\ncols = list(string.ascii_letters)\ncols[0]='zzz'\nn = 50\n\ndf = pd.DataFrame({'Date': pd.date_range('2021-01-01', periods=n)})\n\n# create data with vastly different ranges\nfor col in cols:\n    start = np.random.choice([1, 10, 100, 1000, 100000])\n    s = np.random.normal(loc=0, scale=0.01*start, size=n)\n    df[col] = start + s.cumsum()\n\n# melt data columns from wide to long\ndfm = df.melt(\"Date\")\n\nfig = px.line(\n    data_frame=dfm,\n    x = 'Date',\n    y = 'value',\n    facet_col = 'variable',\n    facet_col_wrap=6,\n    #facet_col_spacing=0.05,\n    #facet_row_spacing=0.035,\n    height = 1000,\n    width = 1000,\n    title = 'Value vs. Date'\n)\n\nfig.update_yaxes(matches=None, showticklabels=True, visible=True)\n<line_mask>\nfig.for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1]))\n\n# subplot titles\nfor anno in fig['layout']['annotations']:\n    anno['text']=''\n\n# hide subplot y-axis titles and x-axis titles\nfor axis in fig.layout:\n    if type(fig.layout[axis]) == go.layout.YAxis:\n        fig.layout[axis].title.text = ''\n    if type(fig.layout[axis]) == go.layout.XAxis:\n        fig.layout[axis].title.text = ''\n        \n# keep all other annotations and add single y-axis and x-axis title:\nfig.update_layout(\n    # keep the original annotations and add a list of new annotations:\n    annotations = list(fig.layout.annotations) + \n    [go.layout.Annotation(\n            x=-0.07,\n            y=0.5,\n            font=dict(\n                size=16, color = 'blue'\n            ),\n            showarrow=False,\n            text=\"single y-axis title\",\n            textangle=-90,\n            xref=\"paper\",\n            yref=\"paper\"\n        )\n    ] +\n    [go.layout.Annotation(\n            x=0.5,\n            y=-0.08,\n            font=dict(\n                size=16, color = 'blue'\n            ),\n            showarrow=False,\n            text=\"Dates\",\n            textangle=-0,\n            xref=\"paper\",\n            yref=\"paper\"\n        )\n    ]\n)\n\n\nfig.show()",
            "masked_line": "fig.update_annotations(font=dict(size=16))",
            "answer": "update_annotations",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_777"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-05-23",
            "description": "This code is testing the speed of deserialization for a 500 MB numpy array. It compares the deserialization speed using pickle, directly from bytes, using numpy load from BytesIO, and using pyarrow.",
            "code": "\"\"\" Deserialization speed test \"\"\"\nimport numpy as np\nimport pickle\nimport time\nimport io\nimport pyarrow as pa\n\n\nsz = 524288000\nsample = np.random.randint(0, 255, size=sz, dtype=np.uint8)  # 500 MB data\npa_buf = pa.serialize(sample).to_buffer()\n\nserialized_sample = pickle.dumps(sample)\nserialized_bytes = sample.tobytes()\nserialized_bytesio = io.BytesIO()\nnp.save(serialized_bytesio, sample, allow_pickle=False)\nserialized_bytesio.seek(0)\n\nresult = None\n\nprint('Deserialize using pickle...')\nt0 = time.time()\nresult = pickle.loads(serialized_sample)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize from bytes...')\nt0 = time.time()\nresult = np.ndarray(shape=sz, dtype=np.uint8, buffer=serialized_bytes)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize using numpy load from BytesIO...')\nt0 = time.time()\nresult = np.load(serialized_bytesio, allow_pickle=False)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize pyarrow')\nt0 = time.time()\nrestored_data = pa.deserialize(pa_buf)\nprint('Time: {:.10f} sec'.format(time.time() - t0))",
            "masked_code": "\"\"\" Deserialization speed test \"\"\"\nimport numpy as np\nimport pickle\nimport time\nimport io\nimport pyarrow as pa\n\n\nsz = 524288000\n<line_mask>\npa_buf = pa.serialize(sample).to_buffer()\n\nserialized_sample = pickle.dumps(sample)\nserialized_bytes = sample.tobytes()\nserialized_bytesio = io.BytesIO()\nnp.save(serialized_bytesio, sample, allow_pickle=False)\nserialized_bytesio.seek(0)\n\nresult = None\n\nprint('Deserialize using pickle...')\nt0 = time.time()\nresult = pickle.loads(serialized_sample)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize from bytes...')\nt0 = time.time()\nresult = np.ndarray(shape=sz, dtype=np.uint8, buffer=serialized_bytes)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize using numpy load from BytesIO...')\nt0 = time.time()\nresult = np.load(serialized_bytesio, allow_pickle=False)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize pyarrow')\nt0 = time.time()\nrestored_data = pa.deserialize(pa_buf)\nprint('Time: {:.10f} sec'.format(time.time() - t0))",
            "masked_line": "sample = np.random.randint(0, 255, size=sz, dtype=np.uint8)  # 500 MB data",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_778"
        },
        {
            "dependency": "pyarrow",
            "version": "==1.0.1",
            "time": "2021-05-23",
            "description": "The code performs a speed test on deserialization methods in Python. It generates a 500 MB random integer array, serializes it using various methods including pickle, bytes, numpy load from BytesIO, and pyarrow, and then deserializes it to measure the time taken for each method.",
            "code": "\"\"\" Deserialization speed test \"\"\"\nimport numpy as np\nimport pickle\nimport time\nimport io\nimport pyarrow as pa\n\n\nsz = 524288000\nsample = np.random.randint(0, 255, size=sz, dtype=np.uint8)  # 500 MB data\npa_buf = pa.serialize(sample).to_buffer()\n\nserialized_sample = pickle.dumps(sample)\nserialized_bytes = sample.tobytes()\nserialized_bytesio = io.BytesIO()\nnp.save(serialized_bytesio, sample, allow_pickle=False)\nserialized_bytesio.seek(0)\n\nresult = None\n\nprint('Deserialize using pickle...')\nt0 = time.time()\nresult = pickle.loads(serialized_sample)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize from bytes...')\nt0 = time.time()\nresult = np.ndarray(shape=sz, dtype=np.uint8, buffer=serialized_bytes)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize using numpy load from BytesIO...')\nt0 = time.time()\nresult = np.load(serialized_bytesio, allow_pickle=False)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize pyarrow')\nt0 = time.time()\nrestored_data = pa.deserialize(pa_buf)\nprint('Time: {:.10f} sec'.format(time.time() - t0))",
            "masked_code": "\"\"\" Deserialization speed test \"\"\"\nimport numpy as np\nimport pickle\nimport time\nimport io\nimport pyarrow as pa\n\n\nsz = 524288000\nsample = np.random.randint(0, 255, size=sz, dtype=np.uint8)  # 500 MB data\npa_buf = pa.serialize(sample).to_buffer()\n\nserialized_sample = pickle.dumps(sample)\nserialized_bytes = sample.tobytes()\nserialized_bytesio = io.BytesIO()\nnp.save(serialized_bytesio, sample, allow_pickle=False)\nserialized_bytesio.seek(0)\n\nresult = None\n\nprint('Deserialize using pickle...')\nt0 = time.time()\nresult = pickle.loads(serialized_sample)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize from bytes...')\nt0 = time.time()\nresult = np.ndarray(shape=sz, dtype=np.uint8, buffer=serialized_bytes)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize using numpy load from BytesIO...')\nt0 = time.time()\nresult = np.load(serialized_bytesio, allow_pickle=False)\nprint('Time: {:.10f} sec'.format(time.time() - t0))\n\nprint('Deserialize pyarrow')\nt0 = time.time()\n<line_mask>\nprint('Time: {:.10f} sec'.format(time.time() - t0))",
            "masked_line": "restored_data = pa.deserialize(pa_buf)",
            "answer": "deserialize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_779"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-04-03",
            "description": "The code converts a Keras model into a frozen graph, saves it to hard drive, and provides a function to load and wrap the frozen graph for inference.",
            "code": "import tensorflow as tf\nimport os\nfrom tensorflow.python.tools import freeze_graph\nfrom tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2\n\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(64, input_shape=(1,)))\nmodel.add(tf.keras.layers.Dense(32, activation='relu'))\nmodel.add(tf.keras.layers.Dense(16, activation='relu'))\nmodel.add(tf.keras.layers.Dense(1, activation='softmax'))\nmodel.compile(optimizer='adam', loss='mse')\nmodel.summary()\n\n# Convert Keras model to ConcreteFunction\nfull_model = tf.function(lambda x: model(x))\nfull_model = full_model.get_concrete_function(\n    tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype, name=\"yourInputName\"))\n# Get frozen ConcreteFunction\nfrozen_func = convert_variables_to_constants_v2(full_model)\nfrozen_func.graph.as_graph_def()\nlayers = [op.name for op in frozen_func.graph.get_operations()]\nprint(\"-\" * 50)\nprint(\"Frozen model layers: \")\nfor layer in layers:\n    print(layer)\nprint(\"-\" * 50)\nprint(\"Frozen model inputs: \")\nprint(frozen_func.inputs)\nprint(\"Frozen model outputs: \")\nprint(frozen_func.outputs)\n# Save frozen graph from frozen ConcreteFunction to hard drive\ntf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n                  logdir=\"./frozen_models\",\n                  name=\"frozen_graph.pb\",\n                  as_text=False)\n\n### USAGE ##\ndef wrap_frozen_graph(graph_def, inputs, outputs, print_graph=False):\n    def _imports_graph_def():\n        tf.compat.v1.import_graph_def(graph_def, name=\"\")\n\n    wrapped_import = tf.compat.v1.wrap_function(_imports_graph_def, [])\n    import_graph = wrapped_import.graph\n\n    print(\"-\" * 50)\n    print(\"Frozen model layers: \")\n    layers = [op.name for op in import_graph.get_operations()]\n    if print_graph == True:\n        for layer in layers:\n            print(layer)\n    print(\"-\" * 50)\n\n    return wrapped_import.prune(\n        tf.nest.map_structure(import_graph.as_graph_element, inputs),\n        tf.nest.map_structure(import_graph.as_graph_element, outputs))\n\n## Example Usage ###\n# Load frozen graph using TensorFlow 1.x functions\nwith tf.io.gfile.GFile(\"./frozen_models/frozen_graph.pb\", \"rb\") as f:\n    graph_def = tf.compat.v1.GraphDef()\n    loaded = graph_def.ParseFromString(f.read())\n\n# Wrap frozen graph to ConcreteFunctions\nfrozen_func = wrap_frozen_graph(graph_def=graph_def,\n                                inputs=[\"yourInputName:0\"],\n                                outputs=[\"Identity:0\"],\n                                print_graph=True)\nprint(\"-\" * 50)\nprint(\"Frozen model inputs: \")\nprint(frozen_func.inputs)\nprint(\"Frozen model outputs: \")\nprint(frozen_func.outputs)\n# Get predictions for test images\npredictions = frozen_func(yourInputName=tf.constant([[3.]]))\n# Print the prediction for the first image\nprint(\"-\" * 50)\nprint(\"Example prediction reference:\")\nprint(predictions[0].numpy())",
            "masked_code": "import tensorflow as tf\nimport os\nfrom tensorflow.python.tools import freeze_graph\nfrom tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2\n\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(64, input_shape=(1,)))\nmodel.add(tf.keras.layers.Dense(32, activation='relu'))\nmodel.add(tf.keras.layers.Dense(16, activation='relu'))\n<line_mask>\nmodel.compile(optimizer='adam', loss='mse')\nmodel.summary()\n\n# Convert Keras model to ConcreteFunction\nfull_model = tf.function(lambda x: model(x))\nfull_model = full_model.get_concrete_function(\n    tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype, name=\"yourInputName\"))\n# Get frozen ConcreteFunction\nfrozen_func = convert_variables_to_constants_v2(full_model)\nfrozen_func.graph.as_graph_def()\nlayers = [op.name for op in frozen_func.graph.get_operations()]\nprint(\"-\" * 50)\nprint(\"Frozen model layers: \")\nfor layer in layers:\n    print(layer)\nprint(\"-\" * 50)\nprint(\"Frozen model inputs: \")\nprint(frozen_func.inputs)\nprint(\"Frozen model outputs: \")\nprint(frozen_func.outputs)\n# Save frozen graph from frozen ConcreteFunction to hard drive\ntf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n                  logdir=\"./frozen_models\",\n                  name=\"frozen_graph.pb\",\n                  as_text=False)\n\n### USAGE ##\ndef wrap_frozen_graph(graph_def, inputs, outputs, print_graph=False):\n    def _imports_graph_def():\n        tf.compat.v1.import_graph_def(graph_def, name=\"\")\n\n    wrapped_import = tf.compat.v1.wrap_function(_imports_graph_def, [])\n    import_graph = wrapped_import.graph\n\n    print(\"-\" * 50)\n    print(\"Frozen model layers: \")\n    layers = [op.name for op in import_graph.get_operations()]\n    if print_graph == True:\n        for layer in layers:\n            print(layer)\n    print(\"-\" * 50)\n\n    return wrapped_import.prune(\n        tf.nest.map_structure(import_graph.as_graph_element, inputs),\n        tf.nest.map_structure(import_graph.as_graph_element, outputs))\n\n## Example Usage ###\n# Load frozen graph using TensorFlow 1.x functions\nwith tf.io.gfile.GFile(\"./frozen_models/frozen_graph.pb\", \"rb\") as f:\n    graph_def = tf.compat.v1.GraphDef()\n    loaded = graph_def.ParseFromString(f.read())\n\n# Wrap frozen graph to ConcreteFunctions\nfrozen_func = wrap_frozen_graph(graph_def=graph_def,\n                                inputs=[\"yourInputName:0\"],\n                                outputs=[\"Identity:0\"],\n                                print_graph=True)\nprint(\"-\" * 50)\nprint(\"Frozen model inputs: \")\nprint(frozen_func.inputs)\nprint(\"Frozen model outputs: \")\nprint(frozen_func.outputs)\n# Get predictions for test images\npredictions = frozen_func(yourInputName=tf.constant([[3.]]))\n# Print the prediction for the first image\nprint(\"-\" * 50)\nprint(\"Example prediction reference:\")\nprint(predictions[0].numpy())",
            "masked_line": "model.add(tf.keras.layers.Dense(1, activation='softmax'))",
            "answer": "Dense",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_780"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-07-16",
            "description": "The code visualizes a network graph with nodes and edges. The nodes are represented as black circles with labels, and the edges are represented as light blue lines with varying thickness based on their weights. The layout of the graph follows a shell structure.",
            "code": "import networkx as nx\nfrom matplotlib import pyplot as plt\n\nwidths = nx.get_edge_attributes(G, 'weight')\nnodelist = G.nodes()\n\nplt.figure(figsize=(12,8))\n\npos = nx.shell_layout(G)\nnx.draw_networkx_nodes(G,pos,\n                       nodelist=nodelist,\n                       node_size=1500,\n                       node_color='black',\n                       alpha=0.7)\nnx.draw_networkx_edges(G,pos,\n                       edgelist = widths.keys(),\n                       width=list(widths.values()),\n                       edge_color='lightblue',\n                       alpha=0.6)\nnx.draw_networkx_labels(G, pos=pos,\n                        labels=dict(zip(nodelist,nodelist)),\n                        font_color='white')\nplt.box(False)\nplt.show()",
            "masked_code": "import networkx as nx\nfrom matplotlib import pyplot as plt\n\nwidths = nx.get_edge_attributes(G, 'weight')\nnodelist = G.nodes()\n\nplt.figure(figsize=(12,8))\n\n<line_mask>\nnx.draw_networkx_nodes(G,pos,\n                       nodelist=nodelist,\n                       node_size=1500,\n                       node_color='black',\n                       alpha=0.7)\nnx.draw_networkx_edges(G,pos,\n                       edgelist = widths.keys(),\n                       width=list(widths.values()),\n                       edge_color='lightblue',\n                       alpha=0.6)\nnx.draw_networkx_labels(G, pos=pos,\n                        labels=dict(zip(nodelist,nodelist)),\n                        font_color='white')\nplt.box(False)\nplt.show()",
            "masked_line": "pos = nx.shell_layout(G)",
            "answer": "shell_layout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_781"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-03-09",
            "description": "The code defines a neural network model in Python using TensorFlow's Keras library. The initial model is trained and its weights are saved. Then, a new model is created by adding additional layers on top of the initial model. The new model is combined with the initial model to create a full model. Finally, the full model is compiled and trained.",
            "code": "from tensorflow.keras.models import Model\nfrom tensorflow.keras.layers import Dense, Input\n\n# Train your initial model\ndef get_initial_model():\n    ...\n    return model\n\nmodel = get_initial_model()\nmodel.fit(...)\nmodel.save_weights('initial_model_weights.h5')\n\n# Use Model API to create another model, built on your initial model\ninitial_model = get_initial_model()\ninitial_model.load_weights('initial_model_weights.h5')\n\nnn_input = Input(...)\nx = initial_model(nn_input)\nx = Dense(...)(x)  # This is the additional layer, connected to your initial model\nnn_output = Dense(...)(x)\n\n# Combine your model\nfull_model = Model(inputs=nn_input, outputs=nn_output)\n\n# Compile and train as usual\nfull_model.compile(...)\nfull_model.fit(...)",
            "masked_code": "from tensorflow.keras.models import Model\nfrom tensorflow.keras.layers import Dense, Input\n\n# Train your initial model\ndef get_initial_model():\n    ...\n    return model\n\nmodel = get_initial_model()\nmodel.fit(...)\nmodel.save_weights('initial_model_weights.h5')\n\n# Use Model API to create another model, built on your initial model\ninitial_model = get_initial_model()\ninitial_model.load_weights('initial_model_weights.h5')\n\nnn_input = Input(...)\nx = initial_model(nn_input)\n<line_mask>\nnn_output = Dense(...)(x)\n\n# Combine your model\nfull_model = Model(inputs=nn_input, outputs=nn_output)\n\n# Compile and train as usual\nfull_model.compile(...)\nfull_model.fit(...)",
            "masked_line": "x = Dense(...)(x)  # This is the additional layer, connected to your initial model",
            "answer": "Dense",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_782"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1",
            "time": "2020-02-13",
            "description": "The code trains a neural network model using the training data to predict total earnings. It defines a sequential model with multiple dense layers and compiles it using mean squared error loss and adam optimizer. It then uses TensorBoard for logging and trains the model for 50 epochs. Finally, it evaluates the model using the test data set and prints the mean squared error for the test data set.",
            "code": "import pandas as pd\nimport keras\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import *\n\ntraining_data_df = pd.read_csv(\"sales_data_training_scaled.csv\")\n\nX = training_data_df.drop('total_earnings', axis=1).values\nY = training_data_df[['total_earnings']].values\n\n# Define the model\nmodel = Sequential()\nmodel.add(Dense(50, input_dim=9, activation='relu', name='layer_1'))\nmodel.add(Dense(100, activation='relu', name='layer_2'))\nmodel.add(Dense(50, activation='relu', name='layer_3'))\nmodel.add(Dense(1, activation='linear', name='output_layer'))\nmodel.compile(loss='mean_squared_error', optimizer='adam')\n\n# Create a TensorBoard logger\nlogger = tf.keras.callbacks.TensorBoard(\n    log_dir='logs',\n    write_graph=True,\n    histogram_freq=5\n)\n\n# Train the model\nmodel.fit(\n    X,\n    Y,\n    epochs=50,\n    shuffle=True,\n    verbose=2,\n    callbacks=[logger]\n)\n\n# Load the separate test data set\ntest_data_df = pd.read_csv(\"sales_data_test_scaled.csv\")\n\nX_test = test_data_df.drop('total_earnings', axis=1).values\nY_test = test_data_df[['total_earnings']].values\n\ntest_error_rate = model.evaluate(X_test, Y_test, verbose=0)\nprint(\"The mean squared error (MSE) for the test data set is: {}\".format(test_error_rate))",
            "masked_code": "import pandas as pd\nimport keras\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import *\n\ntraining_data_df = pd.read_csv(\"sales_data_training_scaled.csv\")\n\nX = training_data_df.drop('total_earnings', axis=1).values\nY = training_data_df[['total_earnings']].values\n\n# Define the model\n<line_mask>\nmodel.add(Dense(50, input_dim=9, activation='relu', name='layer_1'))\nmodel.add(Dense(100, activation='relu', name='layer_2'))\nmodel.add(Dense(50, activation='relu', name='layer_3'))\nmodel.add(Dense(1, activation='linear', name='output_layer'))\nmodel.compile(loss='mean_squared_error', optimizer='adam')\n\n# Create a TensorBoard logger\nlogger = tf.keras.callbacks.TensorBoard(\n    log_dir='logs',\n    write_graph=True,\n    histogram_freq=5\n)\n\n# Train the model\nmodel.fit(\n    X,\n    Y,\n    epochs=50,\n    shuffle=True,\n    verbose=2,\n    callbacks=[logger]\n)\n\n# Load the separate test data set\ntest_data_df = pd.read_csv(\"sales_data_test_scaled.csv\")\n\nX_test = test_data_df.drop('total_earnings', axis=1).values\nY_test = test_data_df[['total_earnings']].values\n\ntest_error_rate = model.evaluate(X_test, Y_test, verbose=0)\nprint(\"The mean squared error (MSE) for the test data set is: {}\".format(test_error_rate))",
            "masked_line": "model = Sequential()",
            "answer": "Sequential",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_783"
        },
        {
            "dependency": "gitpython",
            "version": "==2.28.0",
            "time": "2020-10-21",
            "description": "The code initializes a new Git repository in the '/tmp/some-repo/' directory with the initial branch set to 'main'.",
            "code": "from git import Repo\n\nRepo.init('/tmp/some-repo/', initial_branch='main')",
            "masked_code": "from git import Repo\n\n<line_mask>",
            "masked_line": "Repo.init('/tmp/some-repo/', initial_branch='main')",
            "answer": "init",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_784"
        },
        {
            "dependency": "django",
            "version": "==3.0",
            "time": "2020-04-02",
            "description": "This code resets the queries made to the database if the Django project is running in DEBUG mode.",
            "code": "from django.db import reset_queries\nif settings.DEBUG:\n    reset_queries()",
            "masked_code": "<line_mask>\nif settings.DEBUG:\n    reset_queries()",
            "masked_line": "from django.db import reset_queries",
            "answer": "reset_queries",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_785"
        },
        {
            "dependency": "toml",
            "version": "==0.10.1",
            "time": "2020-09-29",
            "description": "The code defines a nested dictionary structure called 'data', which contains keys 'network_server' and 'gateway', where 'gateway' contains additional nested dictionaries. The code then attempts to convert the 'data' dictionary to a TOML-formatted string, but encounters a 'ValueError' due to a circular reference detected in the data structure.",
            "code": "data = { \n        \"network_server\":{\n                \"downlink_data_delay\":{},\n                \"gateway\":{\"key3\":{\"key4\":{}}\n                }   \n        }   \n}\n\nimport toml\nprint(toml.dumps(data)) # ValueError: Circular reference detected",
            "masked_code": "data = { \n        \"network_server\":{\n                \"downlink_data_delay\":{},\n                \"gateway\":{\"key3\":{\"key4\":{}}\n                }   \n        }   \n}\n\nimport toml\n<line_mask>",
            "masked_line": "print(toml.dumps(data)) # ValueError: Circular reference detected",
            "answer": "dumps",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_786"
        },
        {
            "dependency": "pyproj",
            "version": "==2.4.1",
            "time": "2020-07-01",
            "description": "The code calculates the distance in kilometers between two sets of geographical coordinates given in EPSG:3857 projection using the WGS84 ellipsoid.",
            "code": "import pyproj  #v2.4.1\nx1, y1 = (12875996.563923, -3940011.116702)\nx2, y2 = (12872802.929335, -3937989.118438)\nlon1, lat1 = pyproj.Proj(\"epsg:3857\")(x1, y1, inverse=True)\nlon2, lat2 = pyproj.Proj(\"epsg:3857\")(x2, y2, inverse=True)\n_,_,dist_km = pyproj.Geod(ellps='WGS84').inv(lon1, lat1, lon2, lat2)\ndist_km   # 3157.214113925091",
            "masked_code": "import pyproj  #v2.4.1\nx1, y1 = (12875996.563923, -3940011.116702)\nx2, y2 = (12872802.929335, -3937989.118438)\n<line_mask>\nlon2, lat2 = pyproj.Proj(\"epsg:3857\")(x2, y2, inverse=True)\n_,_,dist_km = pyproj.Geod(ellps='WGS84').inv(lon1, lat1, lon2, lat2)\ndist_km   # 3157.214113925091",
            "masked_line": "lon1, lat1 = pyproj.Proj(\"epsg:3857\")(x1, y1, inverse=True)",
            "answer": "Proj",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_787"
        },
        {
            "dependency": "selenium",
            "version": "==3.141.0",
            "time": "2020-11-15",
            "description": "This code launches a headless Chrome browser with specified options and navigates to the Google website.",
            "code": "from selenium import webdriver\n\noptions = webdriver.ChromeOptions() \noptions.add_argument('--headless')\noptions.add_argument('--window-size=1920,1080')\n# options.add_argument('--profile-directory=Profile 1')\noptions.add_argument(r\"--user-data-dir=C:\\Users\\Soma Bhattacharjee\\AppData\\Local\\Google\\Chrome\\User Data\\Default\")\noptions.add_argument(\"--remote-debugging-port=9222\")\ndriver = webdriver.Chrome(options=options, executable_path=r'C:\\WebDrivers\\chromedriver.exe')\ndriver.get('https://www.google.com/')\nprint(\"Chrome Headless launched\")",
            "masked_code": "from selenium import webdriver\n\noptions = webdriver.ChromeOptions() \noptions.add_argument('--headless')\noptions.add_argument('--window-size=1920,1080')\n# options.add_argument('--profile-directory=Profile 1')\noptions.add_argument(r\"--user-data-dir=C:\\Users\\Soma Bhattacharjee\\AppData\\Local\\Google\\Chrome\\User Data\\Default\")\noptions.add_argument(\"--remote-debugging-port=9222\")\ndriver = webdriver.Chrome(options=options, executable_path=r'C:\\WebDrivers\\chromedriver.exe')\n<line_mask>\nprint(\"Chrome Headless launched\")",
            "masked_line": "driver.get('https://www.google.com/')",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_788"
        },
        {
            "dependency": "matplotlib",
            "version": "<3.2",
            "time": "2020-01-10",
            "description": "The code generates a diverging color plot (pcolormesh) of a 2D grid with values ranging from -2 to 4, using the \"RdBu_r\" colormap. A colorbar is added to indicate the mapping of values to colors, and the plot is displayed using matplotlib.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import DivergingNorm\n\nx, y = np.meshgrid(np.linspace(0,50,51), np.linspace(0,50,51))\nz = np.linspace(-2,4,50*50).reshape(50,50)\n\nnorm = DivergingNorm(vmin=z.min(), vcenter=0, vmax=z.max())\npc = plt.pcolormesh(x,y,z, norm=norm, cmap=\"RdBu_r\")\nplt.colorbar(pc)\n\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import DivergingNorm\n\nx, y = np.meshgrid(np.linspace(0,50,51), np.linspace(0,50,51))\nz = np.linspace(-2,4,50*50).reshape(50,50)\n\nnorm = DivergingNorm(vmin=z.min(), vcenter=0, vmax=z.max())\n<line_mask>\nplt.colorbar(pc)\n\nplt.show()",
            "masked_line": "pc = plt.pcolormesh(x,y,z, norm=norm, cmap=\"RdBu_r\")",
            "answer": "pcolormesh",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_789"
        },
        {
            "dependency": "tabula-py",
            "version": "==2.0.4",
            "time": "2020-02-28",
            "description": "This code reads data from a PDF file using the tabula-py library. It first reads the data with columns interpreted as strings and then reads the data with the library guessing the column types. Finally, it prints out the data types and the head of the two dataframes.",
            "code": "import tabula\n\nprint(tabula.environment_info())\n\nfname = (\"https://github.com/chezou/tabula-py/raw/master/tests/resources/\"\n         \"data.pdf\")\n\n# Columns iterpreted as str\ncol2str = {'dtype': str}\nkwargs = {'output_format': 'dataframe',\n          'pandas_options': col2str,\n          'stream': True}\ndf1 = tabula.read_pdf(fname, **kwargs)\n\nprint(df1[0].dtypes)\nprint(df1[0].head())\n\n# Guessing column type\ncol2val = {'dtype': None}\nkwargs = {'output_format': 'dataframe',\n          'pandas_options': col2val,\n          'stream': True}\ndf2 = tabula.read_pdf(fname, **kwargs)\n\nprint(df2[0].dtypes)\nprint(df2[0].head())",
            "masked_code": "import tabula\n\nprint(tabula.environment_info())\n\nfname = (\"https://github.com/chezou/tabula-py/raw/master/tests/resources/\"\n         \"data.pdf\")\n\n# Columns iterpreted as str\ncol2str = {'dtype': str}\nkwargs = {'output_format': 'dataframe',\n          'pandas_options': col2str,\n          'stream': True}\n<line_mask>\n\nprint(df1[0].dtypes)\nprint(df1[0].head())\n\n# Guessing column type\ncol2val = {'dtype': None}\nkwargs = {'output_format': 'dataframe',\n          'pandas_options': col2val,\n          'stream': True}\ndf2 = tabula.read_pdf(fname, **kwargs)\n\nprint(df2[0].dtypes)\nprint(df2[0].head())",
            "masked_line": "df1 = tabula.read_pdf(fname, **kwargs)",
            "answer": "read_pdf",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_790"
        },
        {
            "dependency": "h5py",
            "version": "==2.9.0",
            "time": "2020-05-28",
            "description": "The function `storeFlagsFile` is designed to store time- and text-related data into an HDF5 file. It checks if a flag is set, then creates or modifies datasets within the file based on the flag status. The data includes the time elapsed since a specified start time (`t0`), as well as some text information.",
            "code": "import h5py, numpy as np\nimport time\n\ndef storeFlagsFile(FLAGS_F, file_name, t0, text, ID):\n    if not FLAGS_F:  # this flag doesnt work for mulitple users\n        with h5py.File(file_name, \"r+\") as f:\n            data_content = np.array([np.round(time.time() - t0, 3), text])\n            asciiList = np.array([str(n).encode(\"utf-8\", \"ignore\") for n in data_content]).reshape(1, 2)\n            #dt = h5py.string_dtype(encoding='utf-8') # for h5py 2.10.0\n            dt = h5py.special_dtype(vlen=str)   # for h5py 2.9.0\n            dset = f[str(ID)].create_dataset('AcqFlags', data=asciiList, compression=\"gzip\", chunks=True, maxshape=(None, 2), dtype=dt)\n            FLAGS_F = 1\n    else:\n        with h5py.File(file_name, \"r+\") as f:      \n            data_content = np.array([np.round(time.time() - t0, 3), text]) \n            asciiList = np.array([str(n).encode(\"utf-8\", \"ignore\") for n in data_content]).reshape(1, 2)\n            f[str(ID)+'/AcqFlags'].resize((f[str(ID)+'/AcqFlags'].shape[0] + 1), axis = 0)\n            f[str(ID)+'/AcqFlags'][-1:] = asciiList\n\nfile_name = 'SO_62064344.h5'\nID = 122\nwith h5py.File(file_name, 'w') as f:\n    f.create_group(str(ID))\n\nstoreFlagsFile(False, file_name, 4.412, 'a', ID)       \nstoreFlagsFile(True, file_name, 5.412, 'b', ID)       \nstoreFlagsFile(True, file_name, 6.412, 'c', ID)       \nstoreFlagsFile(True, file_name, 8.226, 'd', ID)     \nstoreFlagsFile(True, file_name, 9.773, 'e', ID)",
            "masked_code": "import h5py, numpy as np\nimport time\n\ndef storeFlagsFile(FLAGS_F, file_name, t0, text, ID):\n    if not FLAGS_F:  # this flag doesnt work for mulitple users\n        with h5py.File(file_name, \"r+\") as f:\n            data_content = np.array([np.round(time.time() - t0, 3), text])\n            asciiList = np.array([str(n).encode(\"utf-8\", \"ignore\") for n in data_content]).reshape(1, 2)\n            #dt = h5py.string_dtype(encoding='utf-8') # for h5py 2.10.0\n            <line_mask>\n            dset = f[str(ID)].create_dataset('AcqFlags', data=asciiList, compression=\"gzip\", chunks=True, maxshape=(None, 2), dtype=dt)\n            FLAGS_F = 1\n    else:\n        with h5py.File(file_name, \"r+\") as f:      \n            data_content = np.array([np.round(time.time() - t0, 3), text]) \n            asciiList = np.array([str(n).encode(\"utf-8\", \"ignore\") for n in data_content]).reshape(1, 2)\n            f[str(ID)+'/AcqFlags'].resize((f[str(ID)+'/AcqFlags'].shape[0] + 1), axis = 0)\n            f[str(ID)+'/AcqFlags'][-1:] = asciiList\n\nfile_name = 'SO_62064344.h5'\nID = 122\nwith h5py.File(file_name, 'w') as f:\n    f.create_group(str(ID))\n\nstoreFlagsFile(False, file_name, 4.412, 'a', ID)       \nstoreFlagsFile(True, file_name, 5.412, 'b', ID)       \nstoreFlagsFile(True, file_name, 6.412, 'c', ID)       \nstoreFlagsFile(True, file_name, 8.226, 'd', ID)     \nstoreFlagsFile(True, file_name, 9.773, 'e', ID)",
            "masked_line": "dt = h5py.special_dtype(vlen=str)   # for h5py 2.9.0",
            "answer": "special_dtype",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_791"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2020-02-10",
            "description": "The code creates a DataFrame using pandas with columns 'Col1' and 'Value'. It then generates a random value for each row in the 'random' column using a Dirichlet distribution. It finally calculates a new value by multiplying the 'Value' column with the 'random' column and rounding it to the nearest integer.",
            "code": "import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'Col1': list(\"ABC\"), 'Value': [100]*3})\ndf['random'] = np.around(np.random.dirichlet\n                        (np.ones(df.shape[0]),size=1)[0],\n                         decimals = 1)\ndf['New value'] = (df['Value']*df['random']).astype(int)\nprint(df)",
            "masked_code": "import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'Col1': list(\"ABC\"), 'Value': [100]*3})\ndf['random'] = np.around(np.random.dirichlet\n                        <line_mask>\n                         decimals = 1)\ndf['New value'] = (df['Value']*df['random']).astype(int)\nprint(df)",
            "masked_line": "(np.ones(df.shape[0]),size=1)[0],",
            "answer": "ones",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_792"
        },
        {
            "dependency": "bokeh",
            "version": "==2.2.1",
            "time": "2020-09-30",
            "description": "The code generates a bar plot using Bokeh library to visualize sales data for each weekday. Each bar represents the sales amount, with labels showing the actual sales value on top of each bar.",
            "code": "import pandas as pd\nfrom bokeh.models import LabelSet, ColumnDataSource, Range1d\nfrom bokeh.plotting import output_notebook, figure, show\n\noutput_notebook()\n\nvals = pd.DataFrame({'weekday': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n                     'Sales': [15, 25, 36, 17, 4],\n                     'index' : range(5)}\n                   )\n\nds = ColumnDataSource(vals)\n\n# extend the y-range a bit more to give space to top label\np = figure(y_range=Range1d(0, 42), x_range=vals['weekday'], height=300)\np.vbar(x='weekday', width=0.75, top='Sales', source=ds)\n\nlabels = LabelSet(x='index', y='Sales', text='Sales', source=ds, \n                  level='glyph',\n                  x_offset=5, \n                  y_offset=5, \n                  render_mode='canvas')\n\np.add_layout(labels)\n\nshow(p)",
            "masked_code": "import pandas as pd\nfrom bokeh.models import LabelSet, ColumnDataSource, Range1d\nfrom bokeh.plotting import output_notebook, figure, show\n\noutput_notebook()\n\nvals = pd.DataFrame({'weekday': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n                     'Sales': [15, 25, 36, 17, 4],\n                     'index' : range(5)}\n                   )\n\n<line_mask>\n\n# extend the y-range a bit more to give space to top label\np = figure(y_range=Range1d(0, 42), x_range=vals['weekday'], height=300)\np.vbar(x='weekday', width=0.75, top='Sales', source=ds)\n\nlabels = LabelSet(x='index', y='Sales', text='Sales', source=ds, \n                  level='glyph',\n                  x_offset=5, \n                  y_offset=5, \n                  render_mode='canvas')\n\np.add_layout(labels)\n\nshow(p)",
            "masked_line": "ds = ColumnDataSource(vals)",
            "answer": "ColumnDataSource",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_793"
        },
        {
            "dependency": "networkx",
            "version": "==2.3",
            "time": "2020-01-20",
            "description": "The code creates a directed graph and adds a path consisting of nodes 0, 1, 2, 3 to the graph. It then calculates and prints the average neighbor degree of the nodes in the graph using the in-neighbors as the source and target nodes.",
            "code": "import networkx as nx\n\nG = nx.DiGraph()\nG.add_path([0,1,2,3])\nprint(nx.average_neighbor_degree(G, source='in', target='in'))",
            "masked_code": "import networkx as nx\n\nG = nx.DiGraph()\nG.add_path([0,1,2,3])\n<line_mask>",
            "masked_line": "print(nx.average_neighbor_degree(G, source='in', target='in'))",
            "answer": "average_neighbor_degree",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_794"
        },
        {
            "dependency": "plotly",
            "version": "==4.10.0",
            "time": "2020-09-14",
            "description": "The code creates a Sankey diagram using Plotly library to visualize the flow of values between nodes labeled from 0 to 6.",
            "code": "import plotly.graph_objects as go\n\nsources = [0,  0,  1,  1,  2,  2] #indices correspond to labels\ntargets = [1,  2,  3,  4,  5,  6] \nvalues  = [45, 30, 15, 30, 20, 10]\nlabels = ['Node 0', 'Node 1', 'Node 2', 'Node 3', 'Node 4', 'Node 5', 'Node 6']\n\nlink = dict(source=sources, target=targets, value=values)\nnode = dict(label=labels)\ndata = go.Sankey(link=link, node=node)\nfig = go.Figure(data)\nfig.show()\n# fig.show(renderer=\"svg\", width=1000, height=500)",
            "masked_code": "import plotly.graph_objects as go\n\nsources = [0,  0,  1,  1,  2,  2] #indices correspond to labels\ntargets = [1,  2,  3,  4,  5,  6] \nvalues  = [45, 30, 15, 30, 20, 10]\nlabels = ['Node 0', 'Node 1', 'Node 2', 'Node 3', 'Node 4', 'Node 5', 'Node 6']\n\nlink = dict(source=sources, target=targets, value=values)\nnode = dict(label=labels)\ndata = go.Sankey(link=link, node=node)\nfig = go.Figure(data)\n<line_mask>\n# fig.show(renderer=\"svg\", width=1000, height=500)",
            "masked_line": "fig.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_795"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-06-18",
            "description": "This code defines a TensorFlow function named parTest that takes an input x_in and adds each integer from 0 to 4999 to x_in, returning the total sum.",
            "code": "import tensorflow as tf\n@tf.function\ndef parTest(x_in):\n    res = 0\n    for i in tf.range(5000):\n        res += x_in + i\n    return res",
            "masked_code": "import tensorflow as tf\n@tf.function\ndef parTest(x_in):\n    res = 0\n    <line_mask>\n        res += x_in + i\n    return res",
            "masked_line": "for i in tf.range(5000):",
            "answer": "range",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_796"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12",
            "time": "2020-05-16",
            "description": "The code generates random integer tensors of shape (2,512,512,1), flattens them using tf.keras.backend.flatten, creates another random integer tensor of shape (255,255), and then maps the values of tensor5 to indices from tensor3 and tensor4, and prints the result.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\nimport numpy as np\n\ntensor1 = tf.constant(np.random.randint(0,255, (2,512,512,1)), dtype='int32') #All elements in range [0,255]\ntensor2 = tf.constant(np.random.randint(0,255, (2,512,512,1)), dtype='int32') #All elements in range [0,255]\n\ntensor3 = tf.keras.backend.flatten(tensor1)\ntensor4 = tf.keras.backend.flatten(tensor2)\n\ntensor5 = tf.constant(np.random.randint(0,255, (255,255)), dtype='int32') #All elements in range [0,255]\n\nelems = (tensor3, tensor4)\na = tf.map_fn(lambda x: tensor5[x[0], x[1]], elems, dtype=tf.int32)\n\nprint(tf.Session().run(a))",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\nimport numpy as np\n\ntensor1 = tf.constant(np.random.randint(0,255, (2,512,512,1)), dtype='int32') #All elements in range [0,255]\ntensor2 = tf.constant(np.random.randint(0,255, (2,512,512,1)), dtype='int32') #All elements in range [0,255]\n\ntensor3 = tf.keras.backend.flatten(tensor1)\n<line_mask>\n\ntensor5 = tf.constant(np.random.randint(0,255, (255,255)), dtype='int32') #All elements in range [0,255]\n\nelems = (tensor3, tensor4)\na = tf.map_fn(lambda x: tensor5[x[0], x[1]], elems, dtype=tf.int32)\n\nprint(tf.Session().run(a))",
            "masked_line": "tensor4 = tf.keras.backend.flatten(tensor2)",
            "answer": "backend",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_797"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.2.1",
            "time": "2020-04-23",
            "description": "The code generates a plot with two x-axes, where the top x-axis uses the forward and backward functions for conversion, but it does not set the desired x-ticks.",
            "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndef forward(x):\n    return 10/x\n\ndef backward(y):\n    return 10/y\n\nfig, ax = plt.subplots()\nax.set_xlim([0.14, 1.4])\nsecax = ax.secondary_xaxis('top', functions=(forward, backward))\nsecax.set_xticks(np.array([10,20,40,70]))  # does not work!\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndef forward(x):\n    return 10/x\n\ndef backward(y):\n    return 10/y\n\nfig, ax = plt.subplots()\nax.set_xlim([0.14, 1.4])\nsecax = ax.secondary_xaxis('top', functions=(forward, backward))\nsecax.set_xticks(np.array([10,20,40,70]))  # does not work!\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_798"
        },
        {
            "dependency": "selenium",
            "version": "==3.5.3",
            "time": "2020-01-30",
            "description": "The code types the text \"hello'world\" into a textbox on the website \"https://google.com\" using a WebDriver instance.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver.get(\"https://google.com\")\ntext = \"hello'world\"\ntextbox = WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.NAME, \"q\")))\nfor i in text:\n    textbox.send_keys(i)",
            "masked_code": "from selenium import webdriver\n<line_mask>\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver.get(\"https://google.com\")\ntext = \"hello'world\"\ntextbox = WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.NAME, \"q\")))\nfor i in text:\n    textbox.send_keys(i)",
            "masked_line": "from selenium.webdriver.support.ui import WebDriverWait",
            "answer": "WebDriverWait",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_799"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.5",
            "time": "2020-08-12",
            "description": "This code generates a DataFrame with a multiindex, performs various loc operations on the DataFrame, and measures the time taken for each operation using the timeit module. The operations include locating values using a single level multiindex with tuple, single level multiindex without tuple, explicitly sorted single level multiindex with tuple, explicitly sorted single level multiindex without tuple, searching by column value, and locating values from a DataFrame with a non-unique index.",
            "code": "import string\nimport itertools\nimport numpy as np\nimport timeit\n\nindex = list(itertools.product(range(100_000), string.ascii_uppercase))\n\ndf = pd.DataFrame(index, columns=['i', 'p'])\ndf['n'] = np.random.randn(len(df))\ndf_2 = df.set_index('i', drop=False)\ndf = df.set_index(['i', 'p'], drop=False)\ndf3 = df.copy().sort_index(level=0)\n\nprint('One level multiindex loc with tuple', timeit.timeit(lambda: df.loc[(1000, )], number=100))\nprint('One level multiindex loc', timeit.timeit(lambda: df.loc[1000], number=100))\nprint('Explicitly sorted one level multiindex loc', timeit.timeit(lambda: df3.loc[(1000, )], number=100))\nprint('Explicitly sorted one level multiindex loc with tuple', timeit.timeit(lambda: df3.loc[1000], number=100))\nprint('Search by column',         timeit.timeit(lambda: df[df.i == 1000], number=100))\nprint('Non unique index loc',     timeit.timeit(lambda: df_2.loc[1000], number=100))\n\n# One level multiindex loc with tuple 0.05624850000003789\n# One level multiindex loc 0.029734599999983402\n# Explicitly sorted one level multiindex loc 0.03403290000005654\n# Explicitly sorted one level multiindex loc with tuple 0.028620700000146826\n# Search by column 0.5066366999999445\n# Non unique index loc 0.0468722999999045",
            "masked_code": "import string\nimport itertools\nimport numpy as np\nimport timeit\n\nindex = list(itertools.product(range(100_000), string.ascii_uppercase))\n\ndf = pd.DataFrame(index, columns=['i', 'p'])\ndf['n'] = np.random.randn(len(df))\ndf_2 = df.set_index('i', drop=False)\n<line_mask>\ndf3 = df.copy().sort_index(level=0)\n\nprint('One level multiindex loc with tuple', timeit.timeit(lambda: df.loc[(1000, )], number=100))\nprint('One level multiindex loc', timeit.timeit(lambda: df.loc[1000], number=100))\nprint('Explicitly sorted one level multiindex loc', timeit.timeit(lambda: df3.loc[(1000, )], number=100))\nprint('Explicitly sorted one level multiindex loc with tuple', timeit.timeit(lambda: df3.loc[1000], number=100))\nprint('Search by column',         timeit.timeit(lambda: df[df.i == 1000], number=100))\nprint('Non unique index loc',     timeit.timeit(lambda: df_2.loc[1000], number=100))\n\n# One level multiindex loc with tuple 0.05624850000003789\n# One level multiindex loc 0.029734599999983402\n# Explicitly sorted one level multiindex loc 0.03403290000005654\n# Explicitly sorted one level multiindex loc with tuple 0.028620700000146826\n# Search by column 0.5066366999999445\n# Non unique index loc 0.0468722999999045",
            "masked_line": "df = df.set_index(['i', 'p'], drop=False)",
            "answer": "set_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_800"
        },
        {
            "dependency": "dash",
            "version": "==0.0.12",
            "time": "2020-05-24",
            "description": "This code saves a scatter plot figure object as a JSON file, creates a Dash web application with a button and a graph component, and updates the graph figure when the button is clicked by loading the figure data from the JSON file.",
            "code": "import json\nimport dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport plotly.express as px\nfrom dash.dependencies import Output, Input\n\ncache = \"fig.json\"\n# Construct a figure object and save it as json.\ndf = px.data.iris()\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\")\nwith open(cache, 'w') as f:\n    f.write(fig.to_json())\n# Create example app.\napp = dash.Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([dcc.Graph(id=\"graph\"), html.Button(\"Click me\", id=\"btn\")])\n\n\n@app.callback(Output(\"graph\", \"figure\"), [Input(\"btn\", \"n_clicks\")])\ndef func(n_clicks):\n    with open(cache, 'r') as f:\n        return json.load(f)\n\n\nif __name__ == '__main__':\n    app.run_server()",
            "masked_code": "import json\nimport dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport plotly.express as px\nfrom dash.dependencies import Output, Input\n\ncache = \"fig.json\"\n# Construct a figure object and save it as json.\ndf = px.data.iris()\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\")\nwith open(cache, 'w') as f:\n    f.write(fig.to_json())\n# Create example app.\napp = dash.Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([dcc.Graph(id=\"graph\"), html.Button(\"Click me\", id=\"btn\")])\n\n\n@app.callback(Output(\"graph\", \"figure\"), [Input(\"btn\", \"n_clicks\")])\ndef func(n_clicks):\n    with open(cache, 'r') as f:\n        return json.load(f)\n\n\nif __name__ == '__main__':\n    <line_mask>",
            "masked_line": "app.run_server()",
            "answer": "run_server",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_801"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.4.3",
            "time": "2020-08-25",
            "description": "The code generates a color palette using the 'RdYlGn' colors scheme from matplotlib and then reverses the order of the colors in the palette.",
            "code": "import matplotlib.pyplot as plt\npalette=plt.get_cmap('RdYlGn').reversed()",
            "masked_code": "import matplotlib.pyplot as plt\n<line_mask>",
            "masked_line": "palette=plt.get_cmap('RdYlGn').reversed()",
            "answer": "reversed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_802"
        },
        {
            "dependency": "ray",
            "version": "==1.0",
            "time": "2020-06-18",
            "description": "The code defines a TensorFlow model class using Ray Serve for serving the model. It creates a backend for the TensorFlow model, configures resources and replicas for the backend, creates an endpoint, and performs inference on a list of input data using the defined TensorFlow model.",
            "code": "from ray import serve\nclient = serve.start()\n\nclass MyTFModel:\n    def __init__(self, model_path):\n        self.model = ... # load model\n\n    @serve.accept_batch\n    def __call__(self, input_batch):\n        assert isinstance(input_batch, list)\n\n        # forward pass\n        self.model([item.data for item in input_batch])\n\n        # return a list of response\n        return [...]\n\nclient.create_backend(\"tf\", MyTFModel, \n    # configure resources\n    ray_actor_options={\"num_cpus\": 2, \"num_gpus\": 1},\n    # configure replicas\n    config={\n        \"num_replicas\": 2, \n        \"max_batch_size\": 24,\n        \"batch_wait_timeout\": 0.5\n    }\n)\nclient.create_endpoint(\"tf\", backend=\"tf\")\nhandle = serve.get_handle(\"tf\")\n\n# perform inference on a list of input\nfutures = [handle.remote(data) for data in fields]\nresult = ray.get(futures)",
            "masked_code": "from ray import serve\nclient = serve.start()\n\nclass MyTFModel:\n    def __init__(self, model_path):\n        self.model = ... # load model\n\n    @serve.accept_batch\n    def __call__(self, input_batch):\n        assert isinstance(input_batch, list)\n\n        # forward pass\n        self.model([item.data for item in input_batch])\n\n        # return a list of response\n        return [...]\n\nclient.create_backend(\"tf\", MyTFModel, \n    # configure resources\n    ray_actor_options={\"num_cpus\": 2, \"num_gpus\": 1},\n    # configure replicas\n    config={\n        \"num_replicas\": 2, \n        \"max_batch_size\": 24,\n        \"batch_wait_timeout\": 0.5\n    }\n)\n<line_mask>\nhandle = serve.get_handle(\"tf\")\n\n# perform inference on a list of input\nfutures = [handle.remote(data) for data in fields]\nresult = ray.get(futures)",
            "masked_line": "client.create_endpoint(\"tf\", backend=\"tf\")",
            "answer": "create_endpoint",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_803"
        },
        {
            "dependency": "pandas",
            "version": ">=1.1.0",
            "time": "2020-08-03",
            "description": "The code calculates the mean of the 'feet' column based on the 'ratio' column divided into 10 equal intervals, and plots the result as a bar graph.",
            "code": "import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'ratio':np.random.rand(100), 'feet': np.random.rand(100)*10})\ndf.groupby(pd.cut(df.ratio, np.linspace(0,1,11))).feet.mean().plot.bar()",
            "masked_code": "import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'ratio':np.random.rand(100), 'feet': np.random.rand(100)*10})\n<line_mask>",
            "masked_line": "df.groupby(pd.cut(df.ratio, np.linspace(0,1,11))).feet.mean().plot.bar()",
            "answer": "mean",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_804"
        },
        {
            "dependency": "scipy",
            "version": "==1.4.1",
            "time": "2020-05-08",
            "description": "This code generates a list of 100 sparse matrices, each containing random binary values with a shape of 1x200. It then vertically stacks these sparse matrices into a single matrix and returns the shape of the resulting matrix.",
            "code": "from scipy.sparse import csr_matrix, vstack\nimport numpy as np\n\nvec_list = []\nfor i in range(100):\n    vec_list.append(csr_matrix(np.random.randint(2,size=(1,200))))\nvec_mat = vstack(vec_list)\nvec_mat.shape",
            "masked_code": "from scipy.sparse import csr_matrix, vstack\nimport numpy as np\n\nvec_list = []\nfor i in range(100):\n    vec_list.append(csr_matrix(np.random.randint(2,size=(1,200))))\n<line_mask>\nvec_mat.shape",
            "masked_line": "vec_mat = vstack(vec_list)",
            "answer": "vstack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_805"
        },
        {
            "dependency": "sympy",
            "version": ">1.5",
            "time": "2020-02-20",
            "description": "The code creates a parametric plot of a circle using the cosine and sine functions with x ranging from 0 to 2*pi. It then creates a figure with two subplots and plots an arrow on one subplot while moving the parametric plot to the other subplot. Finally, it displays the figure with both subplots showing the arrow and the parametric plot of the circle.",
            "code": "import matplotlib.pyplot as plt\n\nfrom sympy.plotting.plot import plot_parametric\nfrom sympy import *\nfrom sympy.abc import x,y,z\n\ndef move_sympyplot_to_axes(p, ax):\n    backend = p.backend(p)\n    backend.ax = ax\n    # Fix for > sympy v1.5\n    backend._process_series(backend.parent._series, ax, backend.parent)\n    backend.ax.spines['right'].set_color('none')\n    backend.ax.spines['bottom'].set_position('zero')\n    backend.ax.spines['top'].set_color('none')\n    plt.close(backend.fig)\n\np2 = plot_parametric(cos(x), sin(x), (x, 0, 2*pi), show=False)\n\nfig, (ax, ax2) = plt.subplots(ncols=2)\n\nax.arrow(0,0,0.5,0.5,head_width = 0.05, head_length=0.05,length_includes_head=True)\nmove_sympyplot_to_axes(p2, ax2)\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\n\nfrom sympy.plotting.plot import plot_parametric\nfrom sympy import *\nfrom sympy.abc import x,y,z\n\ndef move_sympyplot_to_axes(p, ax):\n    backend = p.backend(p)\n    backend.ax = ax\n    # Fix for > sympy v1.5\n    backend._process_series(backend.parent._series, ax, backend.parent)\n    backend.ax.spines['right'].set_color('none')\n    backend.ax.spines['bottom'].set_position('zero')\n    backend.ax.spines['top'].set_color('none')\n    plt.close(backend.fig)\n\n<line_mask>\n\nfig, (ax, ax2) = plt.subplots(ncols=2)\n\nax.arrow(0,0,0.5,0.5,head_width = 0.05, head_length=0.05,length_includes_head=True)\nmove_sympyplot_to_axes(p2, ax2)\n\nplt.show()",
            "masked_line": "p2 = plot_parametric(cos(x), sin(x), (x, 0, 2*pi), show=False)",
            "answer": "plot_parametric",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_806"
        },
        {
            "dependency": "matplotlib",
            "version": "<3.2",
            "time": "2020-06-07",
            "description": "This code generates a contour plot of the function z = -2*cos(2*r) - 1, where r is the distance from the origin. The plot represents the values of z over a grid of x and y values ranging from -3.1 to 3.1. The colormap used is RdBu_r, indicating a diverging color scheme with blue representing lower values and red representing higher values. The contour levels are specified and a color bar is added to the plot for reference. The resulting plot shows the distribution of z values over the grid.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import DivergingNorm\n\nt = np.linspace(-3.1, 3.1, 63)\nx, y = np.meshgrid(t, t)\nr = np.sqrt(x**2+y**2)\nz = -2*np.cos(2*r)-1 # max = 1, min = -3\n\nfig, ax = plt.subplots()\nax.set_aspect(1)\nimg = ax.contourf(x, y, z, levels=[-3,-2.5,-2,-1.5,-1,-0.5,0,0.25,0.5, 0.75, 1],\n                  cmap='RdBu_r',\n                  norm=DivergingNorm(0))\nplt.colorbar(img)\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import DivergingNorm\n\nt = np.linspace(-3.1, 3.1, 63)\nx, y = np.meshgrid(t, t)\nr = np.sqrt(x**2+y**2)\nz = -2*np.cos(2*r)-1 # max = 1, min = -3\n\n<line_mask>\nax.set_aspect(1)\nimg = ax.contourf(x, y, z, levels=[-3,-2.5,-2,-1.5,-1,-0.5,0,0.25,0.5, 0.75, 1],\n                  cmap='RdBu_r',\n                  norm=DivergingNorm(0))\nplt.colorbar(img)\nplt.show()",
            "masked_line": "fig, ax = plt.subplots()",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_807"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-05-10",
            "description": "This code generates samples of Maxwell distribution, calculates histogram of the data, plots the histogram and the Maxwell probability density function, and displays the plot.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.stats import maxwell\n\ndef maxw(size = None):\n    \"\"\"Generates size samples of maxwell\"\"\"\n    vx = np.random.normal(size=size)\n    vy = np.random.normal(size=size)\n    vz = np.random.normal(size=size)\n    return np.sqrt(vx*vx + vy*vy + vz*vz)\n\nmdata = maxw(100000)\nh, bins = np.histogram(mdata, bins = 101, range=(0.0, 10.0))\n\nx = np.linspace(0.0, 10.0, 100)\nrv = maxwell()\n\nfig, ax = plt.subplots(1, 1)\n\nax.hist(mdata, bins = bins, density=True)\nax.plot(x, rv.pdf(x), 'k-', lw=2, label='Maxwell pdf')\nplt.title(\"Maxwell\")\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n<line_mask>\n\ndef maxw(size = None):\n    \"\"\"Generates size samples of maxwell\"\"\"\n    vx = np.random.normal(size=size)\n    vy = np.random.normal(size=size)\n    vz = np.random.normal(size=size)\n    return np.sqrt(vx*vx + vy*vy + vz*vz)\n\nmdata = maxw(100000)\nh, bins = np.histogram(mdata, bins = 101, range=(0.0, 10.0))\n\nx = np.linspace(0.0, 10.0, 100)\nrv = maxwell()\n\nfig, ax = plt.subplots(1, 1)\n\nax.hist(mdata, bins = bins, density=True)\nax.plot(x, rv.pdf(x), 'k-', lw=2, label='Maxwell pdf')\nplt.title(\"Maxwell\")\nplt.show()",
            "masked_line": "from scipy.stats import maxwell",
            "answer": "maxwell",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_808"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.6",
            "time": "2021-09-16",
            "description": "The code defines a ResNet101V2 model using TensorFlow with specified configuration including input shape (224, 224, 3) and no top layer. The model is compiled with mean squared error loss and Adam optimizer. It then fits the model to dummy image and result data for 2 epochs.",
            "code": "import tensorflow as tf\n\ndef dummy_image_float(w,h):\n    return tf.constant([0.,]*(h*w*3), shape=[1,w,h,3], dtype=tf.float32)\ndef dummy_result(w,h,nfeature):\n    return tf.constant([0,]*(h*w*nfeature), shape=[1,w,h,nfeature], dtype=tf.float32)\n\nmodel = tf.keras.applications.ResNet101V2(\n        include_top=False,\n        #input_tensor=x1,\n        weights='imagenet',\n        input_shape=(224, 224, 3),\n        pooling=None\n        )\n\nmodel.compile(optimizer='adam', loss=\"mean_squared_error\", run_eagerly=True)\n\n#train_ds = [ (dummy_image_float(224,224), dummy_result(7,7,2048)) ]\nmodel.fit(dummy_image_float(224,224), dummy_result(7,7,2048), epochs=2)",
            "masked_code": "import tensorflow as tf\n\ndef dummy_image_float(w,h):\n    return tf.constant([0.,]*(h*w*3), shape=[1,w,h,3], dtype=tf.float32)\ndef dummy_result(w,h,nfeature):\n    return tf.constant([0,]*(h*w*nfeature), shape=[1,w,h,nfeature], dtype=tf.float32)\n\n<line_mask>\n        include_top=False,\n        #input_tensor=x1,\n        weights='imagenet',\n        input_shape=(224, 224, 3),\n        pooling=None\n        )\n\nmodel.compile(optimizer='adam', loss=\"mean_squared_error\", run_eagerly=True)\n\n#train_ds = [ (dummy_image_float(224,224), dummy_result(7,7,2048)) ]\nmodel.fit(dummy_image_float(224,224), dummy_result(7,7,2048), epochs=2)",
            "masked_line": "model = tf.keras.applications.ResNet101V2(",
            "answer": "applications",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_809"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.2.2",
            "time": "2020-06-29",
            "description": "The code generates animated histograms for four different random distributions (normal, gamma, exponential, uniform) with specified parameters. It uses matplotlib and numpy to plot the histograms and update them in real-time as the animation progresses.",
            "code": "from matplotlib import numpy as np\nfrom matplotlib import animation\nfrom matplotlib import pyplot as plt\n\nx1 = np.random.normal(-2.5, 1, 10000)\nx2 = np.random.gamma(2, 1.5, 10000)\nx3 = np.random.exponential(2, 10000)+7\nx4 = np.random.uniform(14,20, 10000)\nxs=[x1,x2,x3,x4]\nbins=[\n    np.linspace(-6,1, num=21),\n    np.linspace(0,15, num=21),\n    np.linspace(7,20, num=21),\n    np.linspace(14, 20, num=21)\n]\n\n\ndef update1(curr):\n    if curr==10000:\n        ani.event_source.stop()\n    for ax in axs:\n        ax.cla()\n    axs[0].hist(xs[0][:curr], bins=bins[0], normed=True)\n    axs[1].hist(xs[1][:curr], bins=bins[1], normed=True)\n    axs[2].hist(xs[2][:curr], bins=bins[2], normed=True)\n    axs[3].hist(xs[3][:curr], bins=bins[3], normed=True)\nfig, ((ax1,ax2),(ax3,ax4))=plt.subplots(2,2, sharex=True)\naxs=[ax1,ax2,ax3,ax4]\nani = animation.FuncAnimation(fig, update1, interval=50)\nplt.show()\n\n\ndef update2(curr):\n    if curr==10000:\n        ani.event_source.stop()\n    for i in range(len(axs)):\n        axs[i].cla()\n    for i in range(len(axs)):\n        x=xs[i]\n        axs[i].hist(x[:curr], bins=bins[i], normed=True)\nfig, ((ax1,ax2),(ax3,ax4))=plt.subplots(2,2, sharex=True)\naxs=[ax1,ax2,ax3,ax4]\nani=animation.FuncAnimation(fig, update2,interval=50)\nplt.show()",
            "masked_code": "from matplotlib import numpy as np\nfrom matplotlib import animation\nfrom matplotlib import pyplot as plt\n\nx1 = np.random.normal(-2.5, 1, 10000)\nx2 = np.random.gamma(2, 1.5, 10000)\nx3 = np.random.exponential(2, 10000)+7\nx4 = np.random.uniform(14,20, 10000)\nxs=[x1,x2,x3,x4]\nbins=[\n    np.linspace(-6,1, num=21),\n    np.linspace(0,15, num=21),\n    np.linspace(7,20, num=21),\n    <line_mask>\n]\n\n\ndef update1(curr):\n    if curr==10000:\n        ani.event_source.stop()\n    for ax in axs:\n        ax.cla()\n    axs[0].hist(xs[0][:curr], bins=bins[0], normed=True)\n    axs[1].hist(xs[1][:curr], bins=bins[1], normed=True)\n    axs[2].hist(xs[2][:curr], bins=bins[2], normed=True)\n    axs[3].hist(xs[3][:curr], bins=bins[3], normed=True)\nfig, ((ax1,ax2),(ax3,ax4))=plt.subplots(2,2, sharex=True)\naxs=[ax1,ax2,ax3,ax4]\nani = animation.FuncAnimation(fig, update1, interval=50)\nplt.show()\n\n\ndef update2(curr):\n    if curr==10000:\n        ani.event_source.stop()\n    for i in range(len(axs)):\n        axs[i].cla()\n    for i in range(len(axs)):\n        x=xs[i]\n        axs[i].hist(x[:curr], bins=bins[i], normed=True)\nfig, ((ax1,ax2),(ax3,ax4))=plt.subplots(2,2, sharex=True)\naxs=[ax1,ax2,ax3,ax4]\nani=animation.FuncAnimation(fig, update2,interval=50)\nplt.show()",
            "masked_line": "np.linspace(14, 20, num=21)",
            "answer": "linspace",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_810"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.0",
            "time": "2020-06-29",
            "description": "The code generates four different sets of random data and plots histograms of these data sets in four subplots. The animation gradually updates the histograms as more data points are included until a total of 10,000 points are reached, at which point the animation stops.",
            "code": "from matplotlib import numpy as np\nfrom matplotlib import animation\nfrom matplotlib import pyplot as plt\n\nx1 = np.random.normal(-2.5, 1, 10000)\nx2 = np.random.gamma(2, 1.5, 10000)\nx3 = np.random.exponential(2, 10000)+7\nx4 = np.random.uniform(14,20, 10000)\nxs=[x1,x2,x3,x4]\nbins=[\n    np.linspace(-6,1, num=21),\n    np.linspace(0,15, num=21),\n    np.linspace(7,20, num=21),\n    np.linspace(14, 20, num=21)\n]\n\n\ndef update1(curr):\n    if curr==10000:\n        ani.event_source.stop()\n    for ax in axs:\n        ax.cla()\n    axs[0].hist(xs[0][:curr], bins=bins[0], normed=True)\n    axs[1].hist(xs[1][:curr], bins=bins[1], normed=True)\n    axs[2].hist(xs[2][:curr], bins=bins[2], normed=True)\n    axs[3].hist(xs[3][:curr], bins=bins[3], normed=True)\nfig, ((ax1,ax2),(ax3,ax4))=plt.subplots(2,2, sharex=True)\naxs=[ax1,ax2,ax3,ax4]\nani = animation.FuncAnimation(fig, update1, interval=50)\nplt.show()\n\n\ndef update2(curr):\n    if curr==10000:\n        ani.event_source.stop()\n    for i in range(len(axs)):\n        axs[i].cla()\n    for i in range(len(axs)):\n        x=xs[i]\n        axs[i].hist(x[:curr], bins=bins[i], normed=True)\nfig, ((ax1,ax2),(ax3,ax4))=plt.subplots(2,2, sharex=True)\naxs=[ax1,ax2,ax3,ax4]\nani=animation.FuncAnimation(fig, update2,interval=50)\nplt.show()",
            "masked_code": "from matplotlib import numpy as np\nfrom matplotlib import animation\nfrom matplotlib import pyplot as plt\n\nx1 = np.random.normal(-2.5, 1, 10000)\nx2 = np.random.gamma(2, 1.5, 10000)\nx3 = np.random.exponential(2, 10000)+7\n<line_mask>\nxs=[x1,x2,x3,x4]\nbins=[\n    np.linspace(-6,1, num=21),\n    np.linspace(0,15, num=21),\n    np.linspace(7,20, num=21),\n    np.linspace(14, 20, num=21)\n]\n\n\ndef update1(curr):\n    if curr==10000:\n        ani.event_source.stop()\n    for ax in axs:\n        ax.cla()\n    axs[0].hist(xs[0][:curr], bins=bins[0], normed=True)\n    axs[1].hist(xs[1][:curr], bins=bins[1], normed=True)\n    axs[2].hist(xs[2][:curr], bins=bins[2], normed=True)\n    axs[3].hist(xs[3][:curr], bins=bins[3], normed=True)\nfig, ((ax1,ax2),(ax3,ax4))=plt.subplots(2,2, sharex=True)\naxs=[ax1,ax2,ax3,ax4]\nani = animation.FuncAnimation(fig, update1, interval=50)\nplt.show()\n\n\ndef update2(curr):\n    if curr==10000:\n        ani.event_source.stop()\n    for i in range(len(axs)):\n        axs[i].cla()\n    for i in range(len(axs)):\n        x=xs[i]\n        axs[i].hist(x[:curr], bins=bins[i], normed=True)\nfig, ((ax1,ax2),(ax3,ax4))=plt.subplots(2,2, sharex=True)\naxs=[ax1,ax2,ax3,ax4]\nani=animation.FuncAnimation(fig, update2,interval=50)\nplt.show()",
            "masked_line": "x4 = np.random.uniform(14,20, 10000)",
            "answer": "uniform",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_811"
        },
        {
            "dependency": "bokeh",
            "version": "<=0.12.7",
            "time": "2020-06-19",
            "description": "The code creates a scatter plot using Bokeh library to visualize the \"X\" and \"Y\" values stored in a pandas DataFrame. It sets the title and axis labels for the plot and saves the plot as an HTML file named \"scatter.html\". Finally, it displays the plot in a web browser.",
            "code": "from bokeh.plotting import figure, output_file, show\nimport pandas as pd\n\ndf = pd.DataFrame(columns=[\"X\",\"Y\"])\ndf[\"X\"] = [1,2,3,4,5]\ndf[\"Y\"] = [5,6,4,5,3]\n\np = figure(title=\"temp observations\", x_axis_label=\"Day\", y_axis_label=\"Temp\")\np.scatter(x=\"X\", y=\"Y\", source=df)\n\noutput_file(\"scatter.html\")\nshow(p)",
            "masked_code": "from bokeh.plotting import figure, output_file, show\nimport pandas as pd\n\ndf = pd.DataFrame(columns=[\"X\",\"Y\"])\ndf[\"X\"] = [1,2,3,4,5]\ndf[\"Y\"] = [5,6,4,5,3]\n\np = figure(title=\"temp observations\", x_axis_label=\"Day\", y_axis_label=\"Temp\")\np.scatter(x=\"X\", y=\"Y\", source=df)\n\n<line_mask>\nshow(p)",
            "masked_line": "output_file(\"scatter.html\")",
            "answer": "output_file",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_812"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0.0",
            "time": "2020-03-24",
            "description": "The code builds a simple LSTM-based MNIST model for recognizing handwritten digits. The model is trained using the MNIST dataset, and after training, it is exported to a TFLite model for deployment on mobile devices. The model consists of LSTM layers for processing sequential data, and the training process includes optimizing the model using the Adam optimizer and calculating the loss and accuracy. The exported TFLite model can be used for inference on mobile and embedded devices.",
            "code": "import os\nos.environ['TF_ENABLE_CONTROL_FLOW_V2'] = '1'\nimport sys\nimport tensorflow as tf\nimport argparse\ntf.compat.v1.disable_eager_execution()\n\nclass MnistLstmModel(object):\n  \"\"\"Build a simple LSTM based MNIST model.\n\n  Attributes:\n    time_steps: The maximum length of the time_steps, but since we're just using\n      the 'width' dimension as time_steps, it's actually a fixed number.\n    input_size: The LSTM layer input size.\n    num_lstm_layer: Number of LSTM layers for the stacked LSTM cell case.\n    num_lstm_units: Number of units in the LSTM cell.\n    units: The units for the last layer.\n    num_class: Number of classes to predict.\n  \"\"\"\n\n  def __init__(self, time_steps, input_size, num_lstm_layer, num_lstm_units,\n               units, num_class):\n    self.time_steps = time_steps\n    self.input_size = input_size\n    self.num_lstm_layer = num_lstm_layer\n    self.num_lstm_units = num_lstm_units\n    self.units = units\n    self.num_class = num_class\n\n  def build_model(self):\n    \"\"\"Build the model using the given configs.\n\n    Returns:\n      x: The input placeholder tensor.\n      logits: The logits of the output.\n      output_class: The prediction.\n    \"\"\"\n    x = tf.compat.v1.placeholder(\n        'float32', [None, self.time_steps, self.input_size], name='INPUT')\n    lstm_layers = []\n    for _ in range(self.num_lstm_layer):\n      lstm_layers.append(\n          # Important:\n          #\n          # Note here, we use `tf.lite.experimental.nn.TFLiteLSTMCell`\n          # (OpHinted LSTMCell).\n          tf.compat.v1.lite.experimental.nn.TFLiteLSTMCell(\n              self.num_lstm_units, forget_bias=0))\n    # Weights and biases for output softmax layer.\n    out_weights = tf.Variable(tf.random.normal([self.units, self.num_class]))\n    out_bias = tf.Variable(tf.zeros([self.num_class]))\n\n    # Transpose input x to make it time major.\n    lstm_inputs = tf.transpose(x, perm=[1, 0, 2])\n    lstm_cells = tf.keras.layers.StackedRNNCells(lstm_layers)\n    # Important:\n    #\n    # Note here, we use `tf.lite.experimental.nn.dynamic_rnn` and `time_major`\n    # is set to True.\n    outputs, _ = tf.compat.v1.lite.experimental.nn.dynamic_rnn(\n        lstm_cells, lstm_inputs, dtype='float32', time_major=True)\n\n    # Transpose the outputs back to [batch, time, output]\n    outputs = tf.transpose(outputs, perm=[1, 0, 2])\n    outputs = tf.unstack(outputs, axis=1)\n    logits = tf.matmul(outputs[-1], out_weights) + out_bias\n    output_class = tf.nn.softmax(logits, name='OUTPUT_CLASS')\n\n    return x, logits, output_class\n\ndef train(model,\n      model_dir,\n      batch_size=20,\n      learning_rate=0.001,\n      train_steps=200,\n      eval_steps=500,\n      save_every_n_steps=1000):\n  \"\"\"Train & save the MNIST recognition model.\"\"\"\n  # Train & test dataset.\n  (x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()\n  train_dataset = tf.compat.v1.data.Dataset.from_tensor_slices((x_train, y_train))\n  train_iterator = train_dataset.shuffle(\n      buffer_size=1000).batch(batch_size).repeat().make_one_shot_iterator()\n  x, logits, output_class = model.build_model()\n  test_dataset = tf.compat.v1.data.Dataset.from_tensor_slices((x_test, y_test))\n  test_iterator = test_dataset.batch(\n      batch_size).repeat().make_one_shot_iterator()\n  # input label placeholder\n  y = tf.compat.v1.placeholder(tf.int32, [\n      None,\n  ])\n  one_hot_labels = tf.one_hot(y, depth=model.num_class)\n  # Loss function\n  loss = tf.reduce_mean(\n      tf.nn.softmax_cross_entropy_with_logits(\n          logits=logits, labels=one_hot_labels))\n  correct = tf.compat.v1.nn.in_top_k(output_class, y, 1)\n  accuracy = tf.reduce_mean(tf.cast(correct, tf.float32))\n  # Optimization\n  opt = tf.compat.v1.train.AdamOptimizer(learning_rate=learning_rate).minimize(loss)\n\n  # Initialize variables\n  init = tf.compat.v1.global_variables_initializer()\n  saver = tf.compat.v1.train.Saver()\n  batch_x, batch_y = train_iterator.get_next()\n  batch_test_x, batch_test_y = test_iterator.get_next()\n  with tf.compat.v1.Session() as sess:\n    sess.run([init])\n    for i in range(train_steps):\n      batch_x_value, batch_y_value = sess.run([batch_x, batch_y])\n      _, loss_value = sess.run([opt, loss],\n                               feed_dict={\n                                   x: batch_x_value,\n                                   y: batch_y_value\n                               })\n      if i % 100 == 0:\n        tf.compat.v1.logging.info('Training step %d, loss is %f' % (i, loss_value))\n      if i > 0 and i % save_every_n_steps == 0:\n        accuracy_sum = 0.0\n        for _ in range(eval_steps):\n          test_x_value, test_y_value = sess.run([batch_test_x, batch_test_y])\n          accuracy_value = sess.run(\n              accuracy, feed_dict={\n                  x: test_x_value,\n                  y: test_y_value\n              })\n          accuracy_sum += accuracy_value\n        tf.compat.v1.logging.info('Training step %d, accuracy is %f' %\n                        (i, accuracy_sum / (eval_steps * 1.0)))\n        saver.save(sess, model_dir)\n\ndef export(model, model_dir, tflite_model_file,\n           use_post_training_quantize=True):\n  \"\"\"Export trained model to tflite model.\"\"\"\n  tf.compat.v1.reset_default_graph()\n  x, _, output_class = model.build_model()\n  saver = tf.compat.v1.train.Saver()\n  sess = tf.compat.v1.Session()\n  saver.restore(sess, model_dir)\n  # Convert to Tflite model.\n  converter = tf.compat.v1.lite.TFLiteConverter.from_session(sess, [x], [output_class])\n  #converter.post_training_quantize = use_post_training_quantize\n  tflite = converter.convert()\n  with open(tflite_model_file, 'wb') as f:\n    f.write(tflite)\n\ndef train_and_export(parsed_flags):\n  \"\"\"Train the MNIST LSTM model and export to TfLite.\"\"\"\n  model = MnistLstmModel(\n      time_steps=28,\n      input_size=28,\n      num_lstm_layer=2,\n      num_lstm_units=64,\n      units=64,\n      num_class=10)\n  tf.compat.v1.logging.info('Starts training...')\n  train(model, parsed_flags.model_dir)\n  tf.compat.v1.logging.info('Finished training, starts exporting to tflite to %s ...' %\n                  parsed_flags.tflite_model_file)\n  export(model, parsed_flags.model_dir, parsed_flags.tflite_model_file,\n         parsed_flags.use_post_training_quantize)\n  tf.compat.v1.logging.info(\n      'Finished exporting, model is %s' % parsed_flags.tflite_model_file)\n\ndef run_main(_):\n  \"\"\"Main in the TfLite LSTM tutorial.\"\"\"\n  parser = argparse.ArgumentParser(\n      description=('Train a MNIST recognition model then export to TfLite.'))\n  parser.add_argument(\n      '--model_dir',\n      type=str,\n      help='Directory where the models will store.',\n      required=True)\n  parser.add_argument(\n      '--tflite_model_file',\n      type=str,\n      help='Full filepath to the exported tflite model file.',\n      required=True)\n  parser.add_argument(\n      '--use_post_training_quantize',\n      action='store_true',\n      default=True,\n      help='Whether or not to use post_training_quantize.')\n  parsed_flags, _ = parser.parse_known_args()\n  train_and_export(parsed_flags)\n\n\ndef main():\n  tf.compat.v1.app.run(main=run_main, argv=sys.argv[:1])\n\n\nif __name__ == '__main__':\n  main()",
            "masked_code": "import os\nos.environ['TF_ENABLE_CONTROL_FLOW_V2'] = '1'\nimport sys\nimport tensorflow as tf\nimport argparse\ntf.compat.v1.disable_eager_execution()\n\nclass MnistLstmModel(object):\n  \"\"\"Build a simple LSTM based MNIST model.\n\n  Attributes:\n    time_steps: The maximum length of the time_steps, but since we're just using\n      the 'width' dimension as time_steps, it's actually a fixed number.\n    input_size: The LSTM layer input size.\n    num_lstm_layer: Number of LSTM layers for the stacked LSTM cell case.\n    num_lstm_units: Number of units in the LSTM cell.\n    units: The units for the last layer.\n    num_class: Number of classes to predict.\n  \"\"\"\n\n  def __init__(self, time_steps, input_size, num_lstm_layer, num_lstm_units,\n               units, num_class):\n    self.time_steps = time_steps\n    self.input_size = input_size\n    self.num_lstm_layer = num_lstm_layer\n    self.num_lstm_units = num_lstm_units\n    self.units = units\n    self.num_class = num_class\n\n  def build_model(self):\n    \"\"\"Build the model using the given configs.\n\n    Returns:\n      x: The input placeholder tensor.\n      logits: The logits of the output.\n      output_class: The prediction.\n    \"\"\"\n    x = tf.compat.v1.placeholder(\n        'float32', [None, self.time_steps, self.input_size], name='INPUT')\n    lstm_layers = []\n    for _ in range(self.num_lstm_layer):\n      lstm_layers.append(\n          # Important:\n          #\n          # Note here, we use `tf.lite.experimental.nn.TFLiteLSTMCell`\n          # (OpHinted LSTMCell).\n          tf.compat.v1.lite.experimental.nn.TFLiteLSTMCell(\n              self.num_lstm_units, forget_bias=0))\n    # Weights and biases for output softmax layer.\n    out_weights = tf.Variable(tf.random.normal([self.units, self.num_class]))\n    out_bias = tf.Variable(tf.zeros([self.num_class]))\n\n    # Transpose input x to make it time major.\n    lstm_inputs = tf.transpose(x, perm=[1, 0, 2])\n    lstm_cells = tf.keras.layers.StackedRNNCells(lstm_layers)\n    # Important:\n    #\n    # Note here, we use `tf.lite.experimental.nn.dynamic_rnn` and `time_major`\n    # is set to True.\n    outputs, _ = tf.compat.v1.lite.experimental.nn.dynamic_rnn(\n        lstm_cells, lstm_inputs, dtype='float32', time_major=True)\n\n    # Transpose the outputs back to [batch, time, output]\n    outputs = tf.transpose(outputs, perm=[1, 0, 2])\n    outputs = tf.unstack(outputs, axis=1)\n    logits = tf.matmul(outputs[-1], out_weights) + out_bias\n    output_class = tf.nn.softmax(logits, name='OUTPUT_CLASS')\n\n    return x, logits, output_class\n\ndef train(model,\n      model_dir,\n      batch_size=20,\n      learning_rate=0.001,\n      train_steps=200,\n      eval_steps=500,\n      save_every_n_steps=1000):\n  \"\"\"Train & save the MNIST recognition model.\"\"\"\n  # Train & test dataset.\n  (x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()\n  train_dataset = tf.compat.v1.data.Dataset.from_tensor_slices((x_train, y_train))\n  train_iterator = train_dataset.shuffle(\n      buffer_size=1000).batch(batch_size).repeat().make_one_shot_iterator()\n  x, logits, output_class = model.build_model()\n  test_dataset = tf.compat.v1.data.Dataset.from_tensor_slices((x_test, y_test))\n  test_iterator = test_dataset.batch(\n      batch_size).repeat().make_one_shot_iterator()\n  # input label placeholder\n  y = tf.compat.v1.placeholder(tf.int32, [\n      None,\n  ])\n  one_hot_labels = tf.one_hot(y, depth=model.num_class)\n  # Loss function\n  loss = tf.reduce_mean(\n      tf.nn.softmax_cross_entropy_with_logits(\n          logits=logits, labels=one_hot_labels))\n  correct = tf.compat.v1.nn.in_top_k(output_class, y, 1)\n  accuracy = tf.reduce_mean(tf.cast(correct, tf.float32))\n  # Optimization\n  opt = tf.compat.v1.train.AdamOptimizer(learning_rate=learning_rate).minimize(loss)\n\n  # Initialize variables\n  init = tf.compat.v1.global_variables_initializer()\n  saver = tf.compat.v1.train.Saver()\n  batch_x, batch_y = train_iterator.get_next()\n  batch_test_x, batch_test_y = test_iterator.get_next()\n  with tf.compat.v1.Session() as sess:\n    sess.run([init])\n    for i in range(train_steps):\n      batch_x_value, batch_y_value = sess.run([batch_x, batch_y])\n      <line_mask>\n                               feed_dict={\n                                   x: batch_x_value,\n                                   y: batch_y_value\n                               })\n      if i % 100 == 0:\n        tf.compat.v1.logging.info('Training step %d, loss is %f' % (i, loss_value))\n      if i > 0 and i % save_every_n_steps == 0:\n        accuracy_sum = 0.0\n        for _ in range(eval_steps):\n          test_x_value, test_y_value = sess.run([batch_test_x, batch_test_y])\n          accuracy_value = sess.run(\n              accuracy, feed_dict={\n                  x: test_x_value,\n                  y: test_y_value\n              })\n          accuracy_sum += accuracy_value\n        tf.compat.v1.logging.info('Training step %d, accuracy is %f' %\n                        (i, accuracy_sum / (eval_steps * 1.0)))\n        saver.save(sess, model_dir)\n\ndef export(model, model_dir, tflite_model_file,\n           use_post_training_quantize=True):\n  \"\"\"Export trained model to tflite model.\"\"\"\n  tf.compat.v1.reset_default_graph()\n  x, _, output_class = model.build_model()\n  saver = tf.compat.v1.train.Saver()\n  sess = tf.compat.v1.Session()\n  saver.restore(sess, model_dir)\n  # Convert to Tflite model.\n  converter = tf.compat.v1.lite.TFLiteConverter.from_session(sess, [x], [output_class])\n  #converter.post_training_quantize = use_post_training_quantize\n  tflite = converter.convert()\n  with open(tflite_model_file, 'wb') as f:\n    f.write(tflite)\n\ndef train_and_export(parsed_flags):\n  \"\"\"Train the MNIST LSTM model and export to TfLite.\"\"\"\n  model = MnistLstmModel(\n      time_steps=28,\n      input_size=28,\n      num_lstm_layer=2,\n      num_lstm_units=64,\n      units=64,\n      num_class=10)\n  tf.compat.v1.logging.info('Starts training...')\n  train(model, parsed_flags.model_dir)\n  tf.compat.v1.logging.info('Finished training, starts exporting to tflite to %s ...' %\n                  parsed_flags.tflite_model_file)\n  export(model, parsed_flags.model_dir, parsed_flags.tflite_model_file,\n         parsed_flags.use_post_training_quantize)\n  tf.compat.v1.logging.info(\n      'Finished exporting, model is %s' % parsed_flags.tflite_model_file)\n\ndef run_main(_):\n  \"\"\"Main in the TfLite LSTM tutorial.\"\"\"\n  parser = argparse.ArgumentParser(\n      description=('Train a MNIST recognition model then export to TfLite.'))\n  parser.add_argument(\n      '--model_dir',\n      type=str,\n      help='Directory where the models will store.',\n      required=True)\n  parser.add_argument(\n      '--tflite_model_file',\n      type=str,\n      help='Full filepath to the exported tflite model file.',\n      required=True)\n  parser.add_argument(\n      '--use_post_training_quantize',\n      action='store_true',\n      default=True,\n      help='Whether or not to use post_training_quantize.')\n  parsed_flags, _ = parser.parse_known_args()\n  train_and_export(parsed_flags)\n\n\ndef main():\n  tf.compat.v1.app.run(main=run_main, argv=sys.argv[:1])\n\n\nif __name__ == '__main__':\n  main()",
            "masked_line": "_, loss_value = sess.run([opt, loss],",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_813"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20",
            "time": "2020-11-20",
            "description": "The code creates a ColumnTransformer object, which applies transformations to columns in a dataset. It includes OneHotEncoder transformation for a specific column and applies \"passthrough\" transformation to the remaining columns. The ColumnTransformer object is then fitted and transforms the input data x.",
            "code": "from sklearn.compose import ColumnTransformer\n\nct = ColumnTransformer([\n    ('', OneHotEncoder(), x)], remainder=\"passthrough\")\nct.fit_transform(x)",
            "masked_code": "<line_mask>\n\nct = ColumnTransformer([\n    ('', OneHotEncoder(), x)], remainder=\"passthrough\")\nct.fit_transform(x)",
            "masked_line": "from sklearn.compose import ColumnTransformer",
            "answer": "ColumnTransformer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_814"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-12-29",
            "description": "This code checks if there is a GPU available and if so, it sets the memory growth to be dynamic for the first GPU device.",
            "code": "import tensorflow as tf\nphysical_devices = tf.config.experimental.list_physical_devices('GPU')\nif len(physical_devices) > 0:\n    tf.config.experimental.set_memory_growth(physical_devices[0], True)",
            "masked_code": "import tensorflow as tf\n<line_mask>\nif len(physical_devices) > 0:\n    tf.config.experimental.set_memory_growth(physical_devices[0], True)",
            "masked_line": "physical_devices = tf.config.experimental.list_physical_devices('GPU')",
            "answer": "experimental",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_815"
        },
        {
            "dependency": "discord.py",
            "version": "==1.5",
            "time": "2020-10-21",
            "description": "The code sets up a bot using the Discord API with all intents enabled, allowing the bot to connect to a Discord server, receive events, and interact with users through commands specified by the given prefix.",
            "code": "import discord\n\nintents = discord.Intents.all()\n\n\nbot = discord.Client(intents=intents)\n\n# or \n\nfrom discord.ext import commands\nbot = commands.Bot(command_prefix = \".\", intents=intents)",
            "masked_code": "import discord\n\n<line_mask>\n\n\nbot = discord.Client(intents=intents)\n\n# or \n\nfrom discord.ext import commands\nbot = commands.Bot(command_prefix = \".\", intents=intents)",
            "masked_line": "intents = discord.Intents.all()",
            "answer": "all",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_816"
        },
        {
            "dependency": "PySimpleGUI",
            "version": "==4.18.0",
            "time": "2020-04-07",
            "description": "This code creates a GUI window with a text input field for entering a filename, a browse button for selecting a file, and OK and Cancel buttons. The window allows the user to input a filename and interact with the buttons.",
            "code": "import PySimpleGUI as sg\n\nsg.theme('Dark Blue 3')  # please make your creations colorful\n\nlayout = [  [sg.Text('Filename')],\n            [sg.Input(), sg.FileBrowse()], \n            [sg.OK(), sg.Cancel()]] \n\nwindow = sg.Window('Get filename example', layout)\n\nevent, values = window.Read()\nwindow.close()",
            "masked_code": "import PySimpleGUI as sg\n\nsg.theme('Dark Blue 3')  # please make your creations colorful\n\n<line_mask>\n            [sg.Input(), sg.FileBrowse()], \n            [sg.OK(), sg.Cancel()]] \n\nwindow = sg.Window('Get filename example', layout)\n\nevent, values = window.Read()\nwindow.close()",
            "masked_line": "layout = [  [sg.Text('Filename')],",
            "answer": "Text",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_817"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.4",
            "time": "2020-03-13",
            "description": "The code reads an Excel file located at a specified path and prints out the contents of the file.",
            "code": "import pandas as pd\n\ndf = pd.read_excel (r'Path where the Excel file is stored\\File name.xlsx', sheet_name='your Excel sheet name')\nprint (df)",
            "masked_code": "import pandas as pd\n\n<line_mask>\nprint (df)",
            "masked_line": "df = pd.read_excel (r'Path where the Excel file is stored\\File name.xlsx', sheet_name='your Excel sheet name')",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_818"
        },
        {
            "dependency": "scipy",
            "version": "==0.16.0",
            "time": "2020-01-31",
            "description": "This code labels different connected components in the data and assigns a cluster to each data point based on the row max of the connected components.",
            "code": "import numpy as np\nfrom scipy import ndimage\n\n#labels the different connected components in the data\nx_components, _ = ndimage.measurements.label(df.drop('ID', 1).fillna(0))\n#finds the actual \"cluster\" to which each data points bellongs by returning the row max\ndf['cluster'] = x_components.max(1)",
            "masked_code": "import numpy as np\nfrom scipy import ndimage\n\n#labels the different connected components in the data\n<line_mask>\n#finds the actual \"cluster\" to which each data points bellongs by returning the row max\ndf['cluster'] = x_components.max(1)",
            "masked_line": "x_components, _ = ndimage.measurements.label(df.drop('ID', 1).fillna(0))",
            "answer": "measurements",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_819"
        },
        {
            "dependency": "numpy",
            "version": "==1.13",
            "time": "2020-09-08",
            "description": "This code takes user input to create a 2D array, converts it to a numpy array, set numpy print options, and then prints the mean along each row, the variance along each column, and the standard deviation of the entire array.",
            "code": "import numpy as np \n\nn,m = map(int, input().split())\nb = []\nfor i in range(n):\n    a = list(map(int, input().split()))\n    b.append(a)\n\nb = np.array(b)\n\nnp.set_printoptions(legacy='1.13')\nprint(np.mean(b, axis = 1))\nprint(np.var(b, axis = 0))\nprint(np.std(b))",
            "masked_code": "import numpy as np \n\nn,m = map(int, input().split())\nb = []\nfor i in range(n):\n    a = list(map(int, input().split()))\n    b.append(a)\n\n<line_mask>\n\nnp.set_printoptions(legacy='1.13')\nprint(np.mean(b, axis = 1))\nprint(np.var(b, axis = 0))\nprint(np.std(b))",
            "masked_line": "b = np.array(b)",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_820"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2021-05-03",
            "description": "The code initializes a TensorFlow constant named 'aa' with a value of 1, and then prints out the operations and tensor associated with it from the default graph.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\ntf.compat.v1.disable_eager_execution() # disable eager execution\n\na = tf.constant([1],name='aa')\nprint(tf.compat.v1.get_default_graph().get_operations())\nprint(tf.compat.v1.get_default_graph().get_tensor_by_name('aa:0'))",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\ntf.compat.v1.disable_eager_execution() # disable eager execution\n\na = tf.constant([1],name='aa')\nprint(tf.compat.v1.get_default_graph().get_operations())\n<line_mask>",
            "masked_line": "print(tf.compat.v1.get_default_graph().get_tensor_by_name('aa:0'))",
            "answer": "get_tensor_by_name",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_821"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.0",
            "time": "2020-08-07",
            "description": "This code creates a DataFrame named `asdf` with a single column labeled 'number' and two rows. It then selects all rows and the column with the label '1'.",
            "code": "import pandas as pd\ntuples = [(1,), (2,)]\ncolumns = pd.MultiIndex.from_tuples(tuples, names=['number'])\nasdf = pd.DataFrame(columns=columns, index=[0, 1])\nasdf.loc[:, (1,)]",
            "masked_code": "import pandas as pd\ntuples = [(1,), (2,)]\ncolumns = pd.MultiIndex.from_tuples(tuples, names=['number'])\n<line_mask>\nasdf.loc[:, (1,)]",
            "masked_line": "asdf = pd.DataFrame(columns=columns, index=[0, 1])",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_822"
        },
        {
            "dependency": "scrapy",
            "version": "==2.2",
            "time": "2020-07-23",
            "description": "This code is a Python web scraping script using the Scrapy framework. It defines a Spider subclass named TestSpider that sends a request to a specific URL from the Woolworths website and extracts product names from the response data in JSON format. The extracted product names are then yielded as output.",
            "code": "import scrapy\n\n\nclass TestSpider(scrapy.Spider):\n    name = 'test'\n    allowed_domains = ['woolworths.com']\n\n\n    data = {\n    'excludeUnavailable': 'true',\n    'source': 'RR-Best Sellers'}\n\n    def start_requests(self):\n        url = 'https://www.woolworths.com.au/apis/ui/products/58520,341057,305224,70660,208073,69391,69418,65416,305227,305084,305223,427068,201688,427069,341058,305195,201689,317793,714860,57624'\n        yield scrapy.Request(url=url,meta=self.data,callback=self.parse)\n    def parse(self, response):\n        data = response.json()\n\n        for a in data: \n            yield { \n                'name': a['Name'],\n\n            }",
            "masked_code": "import scrapy\n\n\nclass TestSpider(scrapy.Spider):\n    name = 'test'\n    allowed_domains = ['woolworths.com']\n\n\n    data = {\n    'excludeUnavailable': 'true',\n    'source': 'RR-Best Sellers'}\n\n    def start_requests(self):\n        url = 'https://www.woolworths.com.au/apis/ui/products/58520,341057,305224,70660,208073,69391,69418,65416,305227,305084,305223,427068,201688,427069,341058,305195,201689,317793,714860,57624'\n        <line_mask>\n    def parse(self, response):\n        data = response.json()\n\n        for a in data: \n            yield { \n                'name': a['Name'],\n\n            }",
            "masked_line": "yield scrapy.Request(url=url,meta=self.data,callback=self.parse)",
            "answer": "Request",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_823"
        },
        {
            "dependency": "cartopy",
            "version": "<0.18",
            "time": "2020-06-11",
            "description": "The code creates a map using the Cartopy library with specified latitude and longitude coordinates, and adds features such as land and ocean. The map is displayed with a black background and a red line representing the specified latitude and longitude coordinates.",
            "code": "import matplotlib.pyplot as plt\nimport cartopy\nimport cartopy.crs as ccrs\n\nlatitude = [0, 10]\nlongitude = [0, 20]\n\nfig = plt.figure(figsize=(12, 6))\nax = fig.add_subplot(1, 1, 1, projection=ccrs.EckertIV())\n\nax.set_global()\n# set_extent([-180, 180, -90, 90], crs=ccrs.PlateCarree())\n\nax.patch.set_facecolor(color='black')\n# or\n# ax.background_patch.set_facecolor(color='black')   # cartopy < v0.18\n# or\n# ax.add_feature(cartopy.feature.OCEAN, color='black')\n\nax.add_feature(cartopy.feature.LAND, color='white')\n\nax.plot(longitude, latitude, color='red', transform=ccrs.PlateCarree())",
            "masked_code": "import matplotlib.pyplot as plt\nimport cartopy\nimport cartopy.crs as ccrs\n\nlatitude = [0, 10]\nlongitude = [0, 20]\n\nfig = plt.figure(figsize=(12, 6))\n<line_mask>\n\nax.set_global()\n# set_extent([-180, 180, -90, 90], crs=ccrs.PlateCarree())\n\nax.patch.set_facecolor(color='black')\n# or\n# ax.background_patch.set_facecolor(color='black')   # cartopy < v0.18\n# or\n# ax.add_feature(cartopy.feature.OCEAN, color='black')\n\nax.add_feature(cartopy.feature.LAND, color='white')\n\nax.plot(longitude, latitude, color='red', transform=ccrs.PlateCarree())",
            "masked_line": "ax = fig.add_subplot(1, 1, 1, projection=ccrs.EckertIV())",
            "answer": "EckertIV",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_824"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-05-27",
            "description": "This code generates connected components in a graph created from a dataframe where nodes are assigned to different component ids based on their connection. The output is a dictionary mapping nodes to their respective component ids.",
            "code": "import networkx as nx\n\n# Create the graph from the dataframe\ng = nx.Graph()\ng.add_edges_from(df[['id','source_id']].dropna().itertuples(index=False))\n\nconnected_components = nx.connected_components(g)\n# Find the component id of the nodes\nnode2id = {}\nfor cid, component in enumerate(connected_components):\n    for node in component:\n        node2id[node] = cid + 1\n\nprint (node2id)\n{'a6': 1, 'a5': 1, 'a1': 1, 'a2': 2, 'a4': 2, 'a8': 3, 'a3': 3}",
            "masked_code": "import networkx as nx\n\n# Create the graph from the dataframe\n<line_mask>\ng.add_edges_from(df[['id','source_id']].dropna().itertuples(index=False))\n\nconnected_components = nx.connected_components(g)\n# Find the component id of the nodes\nnode2id = {}\nfor cid, component in enumerate(connected_components):\n    for node in component:\n        node2id[node] = cid + 1\n\nprint (node2id)\n{'a6': 1, 'a5': 1, 'a1': 1, 'a2': 2, 'a4': 2, 'a8': 3, 'a3': 3}",
            "masked_line": "g = nx.Graph()",
            "answer": "Graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_825"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-05-19",
            "description": "This code finds the local minima in the 'col1' column of the dataframe 'df' and creates a new column 'min' which stores the minimum values of 'col1'.",
            "code": "from scipy.signal import argrelmin\ndf['min'] = df.col1.dropna().iloc[argrelmin(df.col1.dropna().values)[0]]",
            "masked_code": "<line_mask>\ndf['min'] = df.col1.dropna().iloc[argrelmin(df.col1.dropna().values)[0]]",
            "masked_line": "from scipy.signal import argrelmin",
            "answer": "argrelmin",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_826"
        },
        {
            "dependency": "stellargraph",
            "version": "==0.11.0",
            "time": "2020-03-30",
            "description": "The code performs graph representation learning using the GraphSAGE algorithm. It loads a graph dataset (Cora dataset), defines the graph structure and node features, creates a GraphSAGE model, specifies training parameters, compiles the model, and fits the model to the data. Finally, it generates node embeddings using the trained model.",
            "code": "import networkx as nx\nimport stellargraph as sg\nimport pandas as pd\nimport numpy as np\n\n# UPDATED: import from tensorflow.keras instead of keras\nfrom tensorflow.keras import layers, optimizers, losses, metrics, Model\n\nfrom stellargraph.mapper import GraphSAGENodeGenerator, GraphSAGELinkGenerator\nfrom stellargraph.layer import GraphSAGE, link_classification\nfrom stellargraph.data import UnsupervisedSampler\n\n\nfrom sklearn import preprocessing\nimport matplotlib.pyplot as plt\n\n\nfrom sklearn.decomposition import PCA\nfrom sklearn.manifold import TSNE\n\n\n# Loading Data --------------\n\n# Define Edges and Nodes (from_pandas_edgelist creates Nodes automatically from the parsed edgelist)\nedgelist= pd.read_csv(\"./data/cora/cora.cites\", sep='\\t', header=None, names=['target', 'source'])\nedgelist['label'] = 'cites'\nGnx = nx.from_pandas_edgelist(edgelist, edge_attr='label')\nnx.set_node_attributes(Gnx, 'paper', 'label')\n\n# Define Node features\nfeature_names = [\"w_{}\".format(ii) for ii in range(1433)]\ncolumn_names = feature_names + ['subject']\nnode_data = pd.read_csv(\"./data/cora/cora.content\", sep='\\t', header=None, names=column_names)\nnode_with_features = node_data[feature_names]\n\n# Create StellarGraph object\nG = sg.StellarGraph(Gnx, node_features=node_with_features)\n\n\n# Specify model and training parameter\nnodes = list(G.nodes())\nnumber_of_walks = 1\nlength = 5\nbatch_size = 50\nepochs = 4\nnum_samples = [10, 5]\n\nunsupervised_samples = UnsupervisedSampler(G, nodes=nodes, length=length, number_of_walks=number_of_walks)\ntrain_gen = GraphSAGELinkGenerator(G,batch_size, num_samples)\n\n\n# Creating GraphSAGE model\nlayer_sizes =[50,50]\ngraphsage = GraphSAGE(layer_sizes=layer_sizes, generator=train_gen, bias=True, dropout=0.0, normalize='l2')\n\nx_inp, x_out = graphsage.build()\nprediction = link_classification(output_dim=1, output_act='hard_sigmoid', edge_embedding_method='ip')(x_out)\n\n# UPDATED: `inputs` and `outputs` instead of `input` and `output`\nmodel = Model(inputs=x_inp, outputs=prediction)\n\nmodel.compile(\n    # UPDATED: parameter name `optimizer` instead of `optimizers`\n    optimizer=optimizers.Adam(lr=1e-3),\n    loss=losses.binary_crossentropy,\n    metrics=[metrics.binary_accuracy],\n)\n\n\nhistory = model.fit_generator(\n    # UPDATED: we need to call .flow before passing it to `fit_generator`\n    train_gen.flow(unsupervised_samples), \n    epochs=epochs,\n    verbose=1,\n    use_multiprocessing=False,\n    workers=4,\n    shuffle=True,\n)\n\n# Node Embedding\nx_inp_src = x_inp[0::2]\nx_out_src = x_out[0]\nembedding_model = Model(inputs=x_inp_src, outputs=x_out_src)\nnode_ids = node_data.index\nnode_gen = GraphSAGENodeGenerator(G, batch_size,num_samples).flow(node_ids)\nnode_embeddings = embedding_model.predict_generator(node_gen, workers=4, verbose=1)\n\nprint(node_embeddings)",
            "masked_code": "import networkx as nx\nimport stellargraph as sg\nimport pandas as pd\nimport numpy as np\n\n# UPDATED: import from tensorflow.keras instead of keras\nfrom tensorflow.keras import layers, optimizers, losses, metrics, Model\n\nfrom stellargraph.mapper import GraphSAGENodeGenerator, GraphSAGELinkGenerator\nfrom stellargraph.layer import GraphSAGE, link_classification\nfrom stellargraph.data import UnsupervisedSampler\n\n\nfrom sklearn import preprocessing\nimport matplotlib.pyplot as plt\n\n\nfrom sklearn.decomposition import PCA\nfrom sklearn.manifold import TSNE\n\n\n# Loading Data --------------\n\n# Define Edges and Nodes (from_pandas_edgelist creates Nodes automatically from the parsed edgelist)\nedgelist= pd.read_csv(\"./data/cora/cora.cites\", sep='\\t', header=None, names=['target', 'source'])\nedgelist['label'] = 'cites'\nGnx = nx.from_pandas_edgelist(edgelist, edge_attr='label')\nnx.set_node_attributes(Gnx, 'paper', 'label')\n\n# Define Node features\nfeature_names = [\"w_{}\".format(ii) for ii in range(1433)]\ncolumn_names = feature_names + ['subject']\nnode_data = pd.read_csv(\"./data/cora/cora.content\", sep='\\t', header=None, names=column_names)\nnode_with_features = node_data[feature_names]\n\n# Create StellarGraph object\nG = sg.StellarGraph(Gnx, node_features=node_with_features)\n\n\n# Specify model and training parameter\n<line_mask>\nnumber_of_walks = 1\nlength = 5\nbatch_size = 50\nepochs = 4\nnum_samples = [10, 5]\n\nunsupervised_samples = UnsupervisedSampler(G, nodes=nodes, length=length, number_of_walks=number_of_walks)\ntrain_gen = GraphSAGELinkGenerator(G,batch_size, num_samples)\n\n\n# Creating GraphSAGE model\nlayer_sizes =[50,50]\ngraphsage = GraphSAGE(layer_sizes=layer_sizes, generator=train_gen, bias=True, dropout=0.0, normalize='l2')\n\nx_inp, x_out = graphsage.build()\nprediction = link_classification(output_dim=1, output_act='hard_sigmoid', edge_embedding_method='ip')(x_out)\n\n# UPDATED: `inputs` and `outputs` instead of `input` and `output`\nmodel = Model(inputs=x_inp, outputs=prediction)\n\nmodel.compile(\n    # UPDATED: parameter name `optimizer` instead of `optimizers`\n    optimizer=optimizers.Adam(lr=1e-3),\n    loss=losses.binary_crossentropy,\n    metrics=[metrics.binary_accuracy],\n)\n\n\nhistory = model.fit_generator(\n    # UPDATED: we need to call .flow before passing it to `fit_generator`\n    train_gen.flow(unsupervised_samples), \n    epochs=epochs,\n    verbose=1,\n    use_multiprocessing=False,\n    workers=4,\n    shuffle=True,\n)\n\n# Node Embedding\nx_inp_src = x_inp[0::2]\nx_out_src = x_out[0]\nembedding_model = Model(inputs=x_inp_src, outputs=x_out_src)\nnode_ids = node_data.index\nnode_gen = GraphSAGENodeGenerator(G, batch_size,num_samples).flow(node_ids)\nnode_embeddings = embedding_model.predict_generator(node_gen, workers=4, verbose=1)\n\nprint(node_embeddings)",
            "masked_line": "nodes = list(G.nodes())",
            "answer": "nodes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_827"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-04-01",
            "description": "The function calculates the Huber loss for a given input x with a specified delta value. If the absolute value of x is less than or equal to delta, it computes the squared value of x divided by (2 * delta). If the absolute value of x is greater than delta, it returns the absolute value of x minus delta divided by 2.0. It then calculates the gradient of the output with respect to x and performs a reduction operation on the resulting gradient multiplied by a constant z. Finally, it computes the gradient of this result with respect to x and prints both intermediate gradients.",
            "code": "import tensorflow as tf     # Tensorflow 2.1.0\nimport os\n\n\ndef huber(x, delta):\n  if tf.abs(x) <= delta:\n    return x*x/ (2*delta)  ## x^2  / 2*delta  \n                           ## x / delta   - 1st derivative\n                           ## 1 / delta   - 2nd derivative\n  else:\n    return tf.abs(x)-delta/2.0 \n\n\nx = tf.constant ([2.0 ])         \nz = tf.constant ([1.0 ])\n\nwith tf.GradientTape (persistent=True) as g0:\n  g0.watch(x)\n\n  with tf.GradientTape (persistent=True) as g :\n    g.watch (x)\n    # y = tf.py_function(func=huber, inp=[x, 3.0] , Tout=tf.float32  )  # once-differentiable\n    y= huber(x, 3.0)\n  dy_dx = g.gradient(y, x)\n  aa = tf.reduce_sum(dy_dx *z)\n\naa_x = g0.gradient(aa, x)\n\nprint (dy_dx)  #  tf.Tensor([0.6666667], shape=(1,), dtype=float32)\nprint (aa_x)   #  tf.Tensor([0.33333334], shape=(1,), dtype=float32)",
            "masked_code": "import tensorflow as tf     # Tensorflow 2.1.0\nimport os\n\n\ndef huber(x, delta):\n  <line_mask>\n    return x*x/ (2*delta)  ## x^2  / 2*delta  \n                           ## x / delta   - 1st derivative\n                           ## 1 / delta   - 2nd derivative\n  else:\n    return tf.abs(x)-delta/2.0 \n\n\nx = tf.constant ([2.0 ])         \nz = tf.constant ([1.0 ])\n\nwith tf.GradientTape (persistent=True) as g0:\n  g0.watch(x)\n\n  with tf.GradientTape (persistent=True) as g :\n    g.watch (x)\n    # y = tf.py_function(func=huber, inp=[x, 3.0] , Tout=tf.float32  )  # once-differentiable\n    y= huber(x, 3.0)\n  dy_dx = g.gradient(y, x)\n  aa = tf.reduce_sum(dy_dx *z)\n\naa_x = g0.gradient(aa, x)\n\nprint (dy_dx)  #  tf.Tensor([0.6666667], shape=(1,), dtype=float32)\nprint (aa_x)   #  tf.Tensor([0.33333334], shape=(1,), dtype=float32)",
            "masked_line": "if tf.abs(x) <= delta:",
            "answer": "abs",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_828"
        },
        {
            "dependency": "tensorflow",
            "version": ">=1.x",
            "time": "2020-05-04",
            "description": "This code trains a linear regression model using Tensorflow to predict the relationship between the input data (X) and the output data (y) with added random noise. It uses the mean squared error (MSE) as the loss function and the Adam optimizer to minimize the loss. The code also logs the MSE loss, model weights, and biases to a file for visualization.",
            "code": "import tensorflow as tf\nimport tensorflow.compat.v1 as tfc\nimport numpy as np\nfrom datetime import datetime\n\nnp.random.seed(10)\ntfc.set_random_seed(10)\n\n# Line: y = W*X + b\nW, b = 0.5, 1.4\n\n# 100 item data sample set\nX = np.linspace(0, 100, num=100)\n# add random noise to y\ny = np.random.normal(loc=W * X + b, scale=2.0, size=len(X))\n\n# Tensorflow\ngr = tf.Graph()\nwith gr.as_default():\n    x_ph = tfc.placeholder(shape=[None, ], dtype=tf.float32)\n    y_ph = tfc.placeholder(shape=[None, ], dtype=tf.float32)\n\n    v_weight = tfc.get_variable(\"weight\", shape=[1], dtype=tf.float32)\n    v_bias = tfc.get_variable(\"bias\", shape=[1], dtype=tf.float32)\n\n    # Line computation\n    out = v_weight * x_ph + v_bias\n    # compute mean squared error\n    loss = tf.reduce_mean((out - y_ph) ** 2)\n    # minimize MSE loss\n    opt = tfc.train.AdamOptimizer(0.4).minimize(loss)\n\n    tf.summary.scalar('MSEloss', loss)\n    tfc.summary.histogram('model_weight', v_weight)\n    tfc.summary.histogram('model_bias', v_bias)\n\n    # merge summary\n    all_summary = tfc.summary.merge_all()\n\n    # log summary to file\n    now = datetime.now()\n    clock_time = f'{now.day}_{now.hour}.{now.minute}.{now.second}'\n    file_writer = tfc.summary.FileWriter('log_dir\\\\' + clock_time, tfc.get_default_graph())\n\n    # create session\n    session = tfc.Session(graph=gr)\n    session.run(tfc.global_variables_initializer())\n\n    # loop to train the parameters\n    for ep in range(210):\n        # run optimizer\n        train_loss, _, train_summary = session.run([loss, opt, all_summary], feed_dict={x_ph: X, y_ph: y})\n        file_writer.add_summary(train_summary, ep)\n\n        # print epoch and loss\n        if ep % 40 == 0:\n            print(f'Epoch: {ep}'.ljust(13) + f'MSE: {train_loss:.4f}'.ljust(16) + f'W: {session.run(v_weight)[0]:.3f}'.ljust(11) + f'b: {session.run(v_bias)[0]:.3f}')\n\n    print(f'Final weight: {session.run(v_weight)[0]:.3f},  bias: {session.run(v_bias)[0]:.3f}')\n    file_writer.close()\n\nsession.close()",
            "masked_code": "import tensorflow as tf\nimport tensorflow.compat.v1 as tfc\nimport numpy as np\nfrom datetime import datetime\n\nnp.random.seed(10)\ntfc.set_random_seed(10)\n\n# Line: y = W*X + b\nW, b = 0.5, 1.4\n\n# 100 item data sample set\nX = np.linspace(0, 100, num=100)\n# add random noise to y\ny = np.random.normal(loc=W * X + b, scale=2.0, size=len(X))\n\n# Tensorflow\ngr = tf.Graph()\nwith gr.as_default():\n    x_ph = tfc.placeholder(shape=[None, ], dtype=tf.float32)\n    y_ph = tfc.placeholder(shape=[None, ], dtype=tf.float32)\n\n    v_weight = tfc.get_variable(\"weight\", shape=[1], dtype=tf.float32)\n    v_bias = tfc.get_variable(\"bias\", shape=[1], dtype=tf.float32)\n\n    # Line computation\n    out = v_weight * x_ph + v_bias\n    # compute mean squared error\n    <line_mask>\n    # minimize MSE loss\n    opt = tfc.train.AdamOptimizer(0.4).minimize(loss)\n\n    tf.summary.scalar('MSEloss', loss)\n    tfc.summary.histogram('model_weight', v_weight)\n    tfc.summary.histogram('model_bias', v_bias)\n\n    # merge summary\n    all_summary = tfc.summary.merge_all()\n\n    # log summary to file\n    now = datetime.now()\n    clock_time = f'{now.day}_{now.hour}.{now.minute}.{now.second}'\n    file_writer = tfc.summary.FileWriter('log_dir\\\\' + clock_time, tfc.get_default_graph())\n\n    # create session\n    session = tfc.Session(graph=gr)\n    session.run(tfc.global_variables_initializer())\n\n    # loop to train the parameters\n    for ep in range(210):\n        # run optimizer\n        train_loss, _, train_summary = session.run([loss, opt, all_summary], feed_dict={x_ph: X, y_ph: y})\n        file_writer.add_summary(train_summary, ep)\n\n        # print epoch and loss\n        if ep % 40 == 0:\n            print(f'Epoch: {ep}'.ljust(13) + f'MSE: {train_loss:.4f}'.ljust(16) + f'W: {session.run(v_weight)[0]:.3f}'.ljust(11) + f'b: {session.run(v_bias)[0]:.3f}')\n\n    print(f'Final weight: {session.run(v_weight)[0]:.3f},  bias: {session.run(v_bias)[0]:.3f}')\n    file_writer.close()\n\nsession.close()",
            "masked_line": "loss = tf.reduce_mean((out - y_ph) ** 2)",
            "answer": "reduce_mean",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_829"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-03-18",
            "description": "This code generates TFRecords from a CSV input file containing information about images and bounding boxes. The CSV input file should have columns for filenames, class labels, and bounding box coordinates. The code converts the images and bounding box information into TFRecord format, which is commonly used in TensorFlow for training object detection models.",
            "code": "from __future__ import division\nfrom __future__ import print_function\nfrom __future__ import absolute_import\n\nimport os\nimport io\nimport pandas as pd\nimport tensorflow as tf\n\nfrom PIL import Image\nfrom object_detection.utils import dataset_util\nfrom collections import namedtuple, OrderedDict\n\nflags = tf.compat.v1.app.flags\nflags.DEFINE_string('csv_input', '', 'Path to the CSV input')\nflags.DEFINE_string('output_path', '', 'Path to output TFRecord')\nflags.DEFINE_string('image_dir', '', 'Path to images')\nFLAGS = flags.FLAGS\n\n\n# TO-DO replace this with label map\ndef class_text_to_int(row_label):\n    if row_label == 'Button':\n        return 1\n    if row_label == 'Text Box':\n        return 2\n    if row_label == 'Check Box':\n        return 3\n    if row_label == 'Link':\n        return 4\n    if row_label == 'Hyperlink':\n        return 5\n    if row_label == 'Icon':\n        return 6\n    if row_label == 'Text':\n        return 7\n    if row_label == 'Image':\n        return 8\n    else:\n        None\n\ndef split(df, group):\n    data = namedtuple('data', ['filename', 'object'])\n    gb = df.groupby(group)\n    return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]\n\n\ndef create_tf_example(group, path):\n    with tf.io.gfile.GFile(os.path.join(path, '{}'.format(group.filename)), 'rb') as fid:\n        encoded_jpg = fid.read()\n    encoded_jpg_io = io.BytesIO(encoded_jpg)\n    image = Image.open(encoded_jpg_io)\n    width, height = image.size\n\n    filename = group.filename.encode('utf8')\n    image_format = b'jpg'\n    xmins = []\n    xmaxs = []\n    ymins = []\n    ymaxs = []\n    classes_text = []\n    classes = []\n\n    for index, row in group.object.iterrows():\n        xmins.append(row['xmin'] / width)\n        xmaxs.append(row['xmax'] / width)\n        ymins.append(row['ymin'] / height)\n        ymaxs.append(row['ymax'] / height)\n        classes_text.append(row['class'].encode('utf8'))\n        classes.append(class_text_to_int(row['class']))\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature={\n        'image/height': dataset_util.int64_feature(height),\n        'image/width': dataset_util.int64_feature(width),\n        'image/filename': dataset_util.bytes_feature(filename),\n        'image/source_id': dataset_util.bytes_feature(filename),\n        'image/encoded': dataset_util.bytes_feature(encoded_jpg),\n        'image/format': dataset_util.bytes_feature(image_format),\n        'image/object/bbox/xmin': dataset_util.float_list_feature(xmins),\n        'image/object/bbox/xmax': dataset_util.float_list_feature(xmaxs),\n        'image/object/bbox/ymin': dataset_util.float_list_feature(ymins),\n        'image/object/bbox/ymax': dataset_util.float_list_feature(ymaxs),\n        'image/object/class/text': dataset_util.bytes_list_feature(classes_text),\n        'image/object/class/label': dataset_util.int64_list_feature(classes),\n    }))\n    return tf_example\n\n\ndef main(_):\n    writer = tf.io.TFRecordWriter(FLAGS.output_path)\n    path = os.path.join(FLAGS.image_dir)\n    examples = pd.read_csv(FLAGS.csv_input)\n    grouped = split(examples, 'filename')\n    for group in grouped:\n        tf_example = create_tf_example(group, path)\n        writer.write(tf_example.SerializeToString())\n\n    writer.close()\n    output_path = os.path.join(os.getcwd(), FLAGS.output_path)\n    print('Successfully created the TFRecords: {}'.format(output_path))\n\n\nif __name__ == '__main__':\n    tf.compat.v1.app.run()",
            "masked_code": "from __future__ import division\nfrom __future__ import print_function\nfrom __future__ import absolute_import\n\nimport os\nimport io\nimport pandas as pd\nimport tensorflow as tf\n\nfrom PIL import Image\nfrom object_detection.utils import dataset_util\nfrom collections import namedtuple, OrderedDict\n\nflags = tf.compat.v1.app.flags\nflags.DEFINE_string('csv_input', '', 'Path to the CSV input')\nflags.DEFINE_string('output_path', '', 'Path to output TFRecord')\nflags.DEFINE_string('image_dir', '', 'Path to images')\nFLAGS = flags.FLAGS\n\n\n# TO-DO replace this with label map\ndef class_text_to_int(row_label):\n    if row_label == 'Button':\n        return 1\n    if row_label == 'Text Box':\n        return 2\n    if row_label == 'Check Box':\n        return 3\n    if row_label == 'Link':\n        return 4\n    if row_label == 'Hyperlink':\n        return 5\n    if row_label == 'Icon':\n        return 6\n    if row_label == 'Text':\n        return 7\n    if row_label == 'Image':\n        return 8\n    else:\n        None\n\ndef split(df, group):\n    data = namedtuple('data', ['filename', 'object'])\n    gb = df.groupby(group)\n    return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]\n\n\ndef create_tf_example(group, path):\n    with tf.io.gfile.GFile(os.path.join(path, '{}'.format(group.filename)), 'rb') as fid:\n        encoded_jpg = fid.read()\n    encoded_jpg_io = io.BytesIO(encoded_jpg)\n    image = Image.open(encoded_jpg_io)\n    width, height = image.size\n\n    filename = group.filename.encode('utf8')\n    image_format = b'jpg'\n    xmins = []\n    xmaxs = []\n    ymins = []\n    ymaxs = []\n    classes_text = []\n    classes = []\n\n    for index, row in group.object.iterrows():\n        xmins.append(row['xmin'] / width)\n        xmaxs.append(row['xmax'] / width)\n        ymins.append(row['ymin'] / height)\n        ymaxs.append(row['ymax'] / height)\n        classes_text.append(row['class'].encode('utf8'))\n        classes.append(class_text_to_int(row['class']))\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature={\n        'image/height': dataset_util.int64_feature(height),\n        'image/width': dataset_util.int64_feature(width),\n        'image/filename': dataset_util.bytes_feature(filename),\n        'image/source_id': dataset_util.bytes_feature(filename),\n        'image/encoded': dataset_util.bytes_feature(encoded_jpg),\n        'image/format': dataset_util.bytes_feature(image_format),\n        'image/object/bbox/xmin': dataset_util.float_list_feature(xmins),\n        'image/object/bbox/xmax': dataset_util.float_list_feature(xmaxs),\n        'image/object/bbox/ymin': dataset_util.float_list_feature(ymins),\n        'image/object/bbox/ymax': dataset_util.float_list_feature(ymaxs),\n        'image/object/class/text': dataset_util.bytes_list_feature(classes_text),\n        'image/object/class/label': dataset_util.int64_list_feature(classes),\n    }))\n    return tf_example\n\n\ndef main(_):\n    writer = tf.io.TFRecordWriter(FLAGS.output_path)\n    path = os.path.join(FLAGS.image_dir)\n    examples = pd.read_csv(FLAGS.csv_input)\n    grouped = split(examples, 'filename')\n    for group in grouped:\n        tf_example = create_tf_example(group, path)\n        writer.write(tf_example.SerializeToString())\n\n    writer.close()\n    output_path = os.path.join(os.getcwd(), FLAGS.output_path)\n    print('Successfully created the TFRecords: {}'.format(output_path))\n\n\nif __name__ == '__main__':\n    <line_mask>",
            "masked_line": "tf.compat.v1.app.run()",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_830"
        },
        {
            "dependency": "selenium",
            "version": "==3.141.0",
            "time": "2020-02-17",
            "description": "This code opens a headless web browser with PhantomJS, sets the window size to 1920x1080, navigates to a specific url, prints the page source, and then closes the browser.",
            "code": "from selenium import webdriver\n\ndriver = webdriver.PhantomJS(executable_path=r'C:\\WebDrivers\\phantomjs.exe', service_args=['--ignore-ssl-errors=true', '--ssl-protocol=tslv1.0'])\ndriver.set_window_size(1920, 1080)\ndriver.get(\"https://account.booking.com/register?op_token=EgVvYXV0aCJ7ChQ2Wjcyb0hPZDM2Tm43emszcGlyaBIJYXV0aG9yaXplGhpodHRwczovL2FkbWluLmJvb2tpbmcuY29tLyo2eyJwYWdlIjoiL3JlZGlyZWN0LXRvLWpvaW5hcHAtbHA_bGFuZz1pdCZhaWQ9MTE4NzM2MCJ9QgRjb2RlKg4QAToAQgBY5dGK8gVgAQ\")\nprint(driver.page_source)\ndriver.quit()",
            "masked_code": "from selenium import webdriver\n\ndriver = webdriver.PhantomJS(executable_path=r'C:\\WebDrivers\\phantomjs.exe', service_args=['--ignore-ssl-errors=true', '--ssl-protocol=tslv1.0'])\ndriver.set_window_size(1920, 1080)\ndriver.get(\"https://account.booking.com/register?op_token=EgVvYXV0aCJ7ChQ2Wjcyb0hPZDM2Tm43emszcGlyaBIJYXV0aG9yaXplGhpodHRwczovL2FkbWluLmJvb2tpbmcuY29tLyo2eyJwYWdlIjoiL3JlZGlyZWN0LXRvLWpvaW5hcHAtbHA_bGFuZz1pdCZhaWQ9MTE4NzM2MCJ9QgRjb2RlKg4QAToAQgBY5dGK8gVgAQ\")\nprint(driver.page_source)\n<line_mask>",
            "masked_line": "driver.quit()",
            "answer": "quit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_831"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-03-31",
            "description": "This code converts a binary bit array to integers using TensorFlow. It iterates through the input binary array, converts each group of 8 bits to an integer, and stores the result in a NumPy array. Finally, it converts the NumPy array to a TensorFlow tensor with integer data type.",
            "code": "import tensorflow as tf  # TensorFlow 2.1.0\nimport numpy as np\n\n\ndef convert_bits(storage, bit_array, bit_size):\n  for n_bit in range(bit_size):\n    storage.assign_add(tf.reverse(bit_array, axis = [-1])[n_bit]*(2**n_bit))\n\ndata = [0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0]\ntf_data = tf.convert_to_tensor(data)\n\nbit_size = 8 ## int8\nnp_array = np.array([])\n\nfor index in range(int(len(data)/bit_size)):\n  temp_storage = tf.Variable(initial_value=0)\n  convert_bits(temp_storage, tf_data[int(index*bit_size):int((index+1)*bit_size)], bit_size)\n  np_array = np.append(np_array, temp_storage.numpy())\n  print(np_array)\n\ntf_array = tf.convert_to_tensor(np_array, dtype = tf.int32)\n\nprint(tf_array) # tf.Tensor([65 10], shape=(2,), dtype=int32)",
            "masked_code": "import tensorflow as tf  # TensorFlow 2.1.0\nimport numpy as np\n\n\ndef convert_bits(storage, bit_array, bit_size):\n  for n_bit in range(bit_size):\n    <line_mask>\n\ndata = [0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0]\ntf_data = tf.convert_to_tensor(data)\n\nbit_size = 8 ## int8\nnp_array = np.array([])\n\nfor index in range(int(len(data)/bit_size)):\n  temp_storage = tf.Variable(initial_value=0)\n  convert_bits(temp_storage, tf_data[int(index*bit_size):int((index+1)*bit_size)], bit_size)\n  np_array = np.append(np_array, temp_storage.numpy())\n  print(np_array)\n\ntf_array = tf.convert_to_tensor(np_array, dtype = tf.int32)\n\nprint(tf_array) # tf.Tensor([65 10], shape=(2,), dtype=int32)",
            "masked_line": "storage.assign_add(tf.reverse(bit_array, axis = [-1])[n_bit]*(2**n_bit))",
            "answer": "reverse",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_832"
        },
        {
            "dependency": "pytest-asyncio",
            "version": "==0.16.0",
            "time": "2021-11-18",
            "description": "This code defines an asynchronous test named test_simple that waits for 0.5 seconds using asyncio.sleep() function.",
            "code": "import asyncio\nimport pytest\n\npytest_plugins = ('pytest_asyncio',)\n\n@pytest.mark.asyncio\nasync def test_simple():\n    await asyncio.sleep(0.5)",
            "masked_code": "import asyncio\nimport pytest\n\npytest_plugins = ('pytest_asyncio',)\n\n@pytest.mark.asyncio\nasync def test_simple():\n    <line_mask>",
            "masked_line": "await asyncio.sleep(0.5)",
            "answer": "sleep",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_833"
        },
        {
            "dependency": "plotly",
            "version": ">=4.12",
            "time": "2021-01-22",
            "description": "The code generates a scatter plot using the iris dataset, with petal length on the x-axis and petal width on the y-axis. It adds a vertical line at x=2.5 with green dash formatting and a horizontal rectangle with red fill color and 0.2 opacity between y=0.9 and y=2.6. Finally, it displays the plot.",
            "code": "import plotly.express as px\ndf = px.data.iris()\nfig = px.scatter(df, x=\"petal_length\", y=\"petal_width\")\nfig.add_vline(x=2.5, line_width=3, line_dash=\"dash\", line_color=\"green\")\nfig.add_hrect(y0=0.9, y1=2.6, line_width=0, fillcolor=\"red\", opacity=0.2)\nfig.show()",
            "masked_code": "import plotly.express as px\ndf = px.data.iris()\nfig = px.scatter(df, x=\"petal_length\", y=\"petal_width\")\nfig.add_vline(x=2.5, line_width=3, line_dash=\"dash\", line_color=\"green\")\n<line_mask>\nfig.show()",
            "masked_line": "fig.add_hrect(y0=0.9, y1=2.6, line_width=0, fillcolor=\"red\", opacity=0.2)",
            "answer": "add_hrect",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_834"
        },
        {
            "dependency": "spacy",
            "version": "==3.2",
            "time": "2021-09-17",
            "description": "This code customizes a spaCy pipeline component by training it with specific data to recognize entities in text. It disables all pipeline components except named entity recognition (ner) during training, shuffles the training data, updates the model with the optimizer, and then enables the disabled components after training. The code finally prints the entities recognized in a sample text before and after training.",
            "code": "import spacy\nimport random\nfrom spacy import util\nfrom spacy.tokens import Doc\nfrom spacy.training import Example\nfrom spacy.language import Language\n\ndef print_doc_entities(_doc: Doc):\n    if _doc.ents:\n        for _ent in _doc.ents:\n            print(f\"     {_ent.text} {_ent.label_}\")\n    else:\n        print(\"     NONE\")\n\ndef customizing_pipeline_component(nlp: Language):\n    # NOTE: Starting from Spacy 3.0, training via Python API was changed. For information see - https://spacy.io/usage/v3#migrating-training-python\n    train_data = [\n        ('We need to deliver it to Festy.', [(25, 30, 'DISTRICT')]),\n        ('I like red oranges', [])\n    ]\n\n    # Result before training\n    print(f\"\\nResult BEFORE training:\")\n    doc = nlp(u'I need a taxi to Festy.')\n    print_doc_entities(doc)\n\n    # Disable all pipe components except 'ner'\n    disabled_pipes = []\n    for pipe_name in nlp.pipe_names:\n        if pipe_name != 'ner':\n            nlp.disable_pipes(pipe_name)\n            disabled_pipes.append(pipe_name)\n\n    print(\"   Training ...\")\n    optimizer = nlp.create_optimizer()\n    for _ in range(25):\n        random.shuffle(train_data)\n        for raw_text, entity_offsets in train_data:\n            doc = nlp.make_doc(raw_text)\n            example = Example.from_dict(doc, {\"entities\": entity_offsets})\n            nlp.update([example], sgd=optimizer)\n\n    # Enable all previously disabled pipe components\n    for pipe_name in disabled_pipes:\n        nlp.enable_pipe(pipe_name)\n\n    # Result after training\n    print(f\"Result AFTER training:\")\n    doc = nlp(u'I need a taxi to Festy.')\n    print_doc_entities(doc)\n\ndef main():\n    nlp = spacy.load('en_core_web_sm')\n    customizing_pipeline_component(nlp)\n\n\nif __name__ == '__main__':\n    main()",
            "masked_code": "import spacy\nimport random\nfrom spacy import util\nfrom spacy.tokens import Doc\nfrom spacy.training import Example\nfrom spacy.language import Language\n\ndef print_doc_entities(_doc: Doc):\n    if _doc.ents:\n        for _ent in _doc.ents:\n            print(f\"     {_ent.text} {_ent.label_}\")\n    else:\n        print(\"     NONE\")\n\ndef customizing_pipeline_component(nlp: Language):\n    # NOTE: Starting from Spacy 3.0, training via Python API was changed. For information see - https://spacy.io/usage/v3#migrating-training-python\n    train_data = [\n        ('We need to deliver it to Festy.', [(25, 30, 'DISTRICT')]),\n        ('I like red oranges', [])\n    ]\n\n    # Result before training\n    print(f\"\\nResult BEFORE training:\")\n    <line_mask>\n    print_doc_entities(doc)\n\n    # Disable all pipe components except 'ner'\n    disabled_pipes = []\n    for pipe_name in nlp.pipe_names:\n        if pipe_name != 'ner':\n            nlp.disable_pipes(pipe_name)\n            disabled_pipes.append(pipe_name)\n\n    print(\"   Training ...\")\n    optimizer = nlp.create_optimizer()\n    for _ in range(25):\n        random.shuffle(train_data)\n        for raw_text, entity_offsets in train_data:\n            doc = nlp.make_doc(raw_text)\n            example = Example.from_dict(doc, {\"entities\": entity_offsets})\n            nlp.update([example], sgd=optimizer)\n\n    # Enable all previously disabled pipe components\n    for pipe_name in disabled_pipes:\n        nlp.enable_pipe(pipe_name)\n\n    # Result after training\n    print(f\"Result AFTER training:\")\n    doc = nlp(u'I need a taxi to Festy.')\n    print_doc_entities(doc)\n\ndef main():\n    nlp = spacy.load('en_core_web_sm')\n    customizing_pipeline_component(nlp)\n\n\nif __name__ == '__main__':\n    main()",
            "masked_line": "doc = nlp(u'I need a taxi to Festy.')",
            "answer": "nlp",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_835"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.5",
            "time": "2022-01-05",
            "description": "This code generates a grayscale image plot of the data retrieved from a FITS file containing an astronomical image of the HorseHead nebula. The code sets the style of the plot to not display grid lines, then reads in the image data from the FITS file, and finally displays the image with a colorbar indicating the intensity values.",
            "code": "import matplotlib.pyplot as plt\nfrom astropy.visualization import astropy_mpl_style\nastropy_mpl_style['axes.grid'] = False\nplt.style.use(astropy_mpl_style)\n\nfrom astropy.utils.data import get_pkg_data_filename\nfrom astropy.io import fits\n\nimage_file = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\nfits.info(image_file)\n\nimage_data = fits.getdata(image_file, ext=0)\n\nprint(image_data.shape)\n\nplt.figure()\nplt.imshow(image_data, cmap='gray')\n\nplt.colorbar()",
            "masked_code": "import matplotlib.pyplot as plt\nfrom astropy.visualization import astropy_mpl_style\nastropy_mpl_style['axes.grid'] = False\nplt.style.use(astropy_mpl_style)\n\nfrom astropy.utils.data import get_pkg_data_filename\nfrom astropy.io import fits\n\nimage_file = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\nfits.info(image_file)\n\nimage_data = fits.getdata(image_file, ext=0)\n\nprint(image_data.shape)\n\nplt.figure()\n<line_mask>\n\nplt.colorbar()",
            "masked_line": "plt.imshow(image_data, cmap='gray')",
            "answer": "imshow",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_836"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.6",
            "time": "2022-08-31",
            "description": "The code calculates the difference between a ragged tensor X and the expanded y tensor along a new axis.",
            "code": "import tensorflow as tf # TensorFlow 2.6\nprint(\"TensorFlow version:\", tf. version )\nX = tf.ragged.constant([[[3, 1], [3]],\n                        [[2], [3, 4]]], ragged_rank=2)\ny = tf.constant([[1], [2]])\nprint(X-tf.expand_dims(y, axis=2))",
            "masked_code": "import tensorflow as tf # TensorFlow 2.6\nprint(\"TensorFlow version:\", tf. version )\n<line_mask>\n                        [[2], [3, 4]]], ragged_rank=2)\ny = tf.constant([[1], [2]])\nprint(X-tf.expand_dims(y, axis=2))",
            "masked_line": "X = tf.ragged.constant([[[3, 1], [3]],",
            "answer": "ragged",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_837"
        },
        {
            "dependency": "bokeh",
            "version": "==2.3.2",
            "time": "2021-07-26",
            "description": "This code generates a Bokeh plot with a red circle at specific coordinates and sets up a tooltip that displays the x and y values of the circle when hovered over. It limits the number of tooltips shown to 1 maximum and only displays the tooltip if the cursor is over the circle.",
            "code": "from bokeh.plotting import figure, show, output_notebook\nfrom bokeh.models import HoverTool, Range1d, CustomJSHover\noutput_notebook()\n\np = figure(tools='')\np.circle(x=[0.75,0.75,1.25,1.25], y=[0.75,1.25,0.75,1.25], size=230, color='red', fill_alpha=0.2)\np.y_range = p.x_range = Range1d(0,2)\n\nt = \"\"\"\n\n    X:  @x \n    Y:  @y\n\n\"\"\"\n\n# define how many tooltips you want to show as maximum\nnum = 1\n\nf = CustomJSHover(code=f\"\"\"\nspecial_vars.indices = special_vars.indices.slice(0,{num})\nreturn special_vars.indices.includes(special_vars.index) ? \" \" : \" hidden \"\n\"\"\")\n\np.add_tools(HoverTool(tooltips=t, formatters={'@x': f}))\n\nshow(p)",
            "masked_code": "<line_mask>\nfrom bokeh.models import HoverTool, Range1d, CustomJSHover\noutput_notebook()\n\np = figure(tools='')\np.circle(x=[0.75,0.75,1.25,1.25], y=[0.75,1.25,0.75,1.25], size=230, color='red', fill_alpha=0.2)\np.y_range = p.x_range = Range1d(0,2)\n\nt = \"\"\"\n\n    X:  @x \n    Y:  @y\n\n\"\"\"\n\n# define how many tooltips you want to show as maximum\nnum = 1\n\nf = CustomJSHover(code=f\"\"\"\nspecial_vars.indices = special_vars.indices.slice(0,{num})\nreturn special_vars.indices.includes(special_vars.index) ? \" \" : \" hidden \"\n\"\"\")\n\np.add_tools(HoverTool(tooltips=t, formatters={'@x': f}))\n\nshow(p)",
            "masked_line": "from bokeh.plotting import figure, show, output_notebook",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_838"
        },
        {
            "dependency": "numpy",
            "version": "==1.20.0",
            "time": "2021-01-08",
            "description": "The code calculates the ranks of a rolling window of size 100 for a randomly generated array using both pandas and numpy, and compares the time taken for each method.",
            "code": "import pandas as pd\nimport numpy as np\nfrom time import time\nfrom scipy.stats import rankdata\nfrom numpy.lib.stride_tricks import sliding_window_view\n\nnp.random.seed()\narray = np.random.rand(100000)\n\nt0 = time()\nranks = pd.Series(array).rolling(100).apply(lambda x: x.rank().iloc[-1])\nt1 = time()\nprint(f'With pandas: {t1-t0} sec.')\n\nt0 = time()\nranks = [rankdata(x)[-1] for x in sliding_window_view(array, window_shape=100)]\nt1 = time()\nprint(f'With numpy: {t1-t0} sec.')",
            "masked_code": "import pandas as pd\nimport numpy as np\nfrom time import time\nfrom scipy.stats import rankdata\nfrom numpy.lib.stride_tricks import sliding_window_view\n\n<line_mask>\narray = np.random.rand(100000)\n\nt0 = time()\nranks = pd.Series(array).rolling(100).apply(lambda x: x.rank().iloc[-1])\nt1 = time()\nprint(f'With pandas: {t1-t0} sec.')\n\nt0 = time()\nranks = [rankdata(x)[-1] for x in sliding_window_view(array, window_shape=100)]\nt1 = time()\nprint(f'With numpy: {t1-t0} sec.')",
            "masked_line": "np.random.seed()",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_839"
        },
        {
            "dependency": "dash",
            "version": "==1.18.1",
            "time": "2021-01-30",
            "description": "The code creates a Dash web application with two buttons (\"Button 1\" and \"Button 2\") and a log area. When either of the buttons is clicked, it triggers a clientside callback function that updates the log area with a message saying \"Hello from [triggered button]\".",
            "code": "import dash_html_components as html\nfrom dash import Dash\nfrom dash.dependencies import Output, Input\n\n# Create app.\napp = Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([\n    html.Button(\"Button 1\", id=\"btn1\"), html.Button(\"Button 2\", id=\"btn2\"), html.Div(id=\"log\")\n])\napp.clientside_callback(\n    \"\"\"\n    function(x, y){\n        const triggered = dash_clientside.callback_context.triggered.map(t => t.prop_id);\n        return \"Hello from [\" + triggered + \"]\";\n    }\n    \"\"\", Output(\"log\", \"children\"), [Input(\"btn1\", \"n_clicks\"), Input(\"btn2\", \"n_clicks\")])\n\nif __name__ == '__main__':\n    app.run_server()",
            "masked_code": "import dash_html_components as html\nfrom dash import Dash\nfrom dash.dependencies import Output, Input\n\n# Create app.\napp = Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([\n    <line_mask>\n])\napp.clientside_callback(\n    \"\"\"\n    function(x, y){\n        const triggered = dash_clientside.callback_context.triggered.map(t => t.prop_id);\n        return \"Hello from [\" + triggered + \"]\";\n    }\n    \"\"\", Output(\"log\", \"children\"), [Input(\"btn1\", \"n_clicks\"), Input(\"btn2\", \"n_clicks\")])\n\nif __name__ == '__main__':\n    app.run_server()",
            "masked_line": "html.Button(\"Button 1\", id=\"btn1\"), html.Button(\"Button 2\", id=\"btn2\"), html.Div(id=\"log\")",
            "answer": "Button",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_840"
        },
        {
            "dependency": "cryptography",
            "version": ">=0.6",
            "time": "2021-04-29",
            "description": "The code loads an encrypted private key using PKCS#8 format and a specified password, returning the private key object.",
            "code": "from cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import serialization\n\npkcs8Encrypted = b\"\"\"-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIICzzBJB...\n-----END ENCRYPTED PRIVATE KEY-----\"\"\"\n\nprivateKey = serialization.load_pem_private_key(\n    pkcs8Encrypted, \n    b'mypassword',\n    default_backend()\n)",
            "masked_code": "from cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import serialization\n\npkcs8Encrypted = b\"\"\"-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIICzzBJB...\n-----END ENCRYPTED PRIVATE KEY-----\"\"\"\n\n<line_mask>\n    pkcs8Encrypted, \n    b'mypassword',\n    default_backend()\n)",
            "masked_line": "privateKey = serialization.load_pem_private_key(",
            "answer": "load_pem_private_key",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_841"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-02-27",
            "description": "The code generates two dataframes with velocity values and dates, combines them, and then creates a heatmap visualization using seaborn library in Python. The y-axis of the heatmap is labeled with date strings formatted as 'YYYY-MM-DD'.",
            "code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nv1 = np.array([1671., 1756., 1704., 1574., 1589., 1772., 1652., 1778., 1719., 1699.])\ndv1 = np.array(['2015-01-21T00:00:00.032000000', '2015-01-29T00:00:00.016000000',\n                '2014-06-11T00:00:00.544000000', '2014-12-20T00:00:00.160000000',\n                '2014-12-28T00:00:00.144000000', '2015-01-05T00:00:00.192000000',\n                '2014-07-29T00:00:00.512000000', '2015-03-02T00:00:00.080000256',\n                '2015-07-08T00:00:00.112000000', '2015-08-25T00:00:00.272000000'],\n               dtype='datetime64[ns]')\n    \nv2 = np.array([1647., 1758., 1722.], dtype=float)\ndv2 = np.array(['2015-08-10T00:00:00.032000000', '2015-02-18T00:00:00.016000000',\n                '2014-09-19T00:00:00.544000000'],\n               dtype='datetime64[ns]')\n\ndf1 = pd.DataFrame({'Velocity0': v1}, index=dv1)\ndf2 = pd.DataFrame({'Velocity1': v2}, index=dv2)\ndf1 = df1.append(df2).sort_index()\n\nax = sns.heatmap(df1)\nax.figure.set_size_inches(6,6)\nticklabels = [df1.index[int(tick)].strftime('%Y-%m-%d') for tick in ax.get_yticks()]\nax.set_yticklabels(ticklabels);",
            "masked_code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nv1 = np.array([1671., 1756., 1704., 1574., 1589., 1772., 1652., 1778., 1719., 1699.])\ndv1 = np.array(['2015-01-21T00:00:00.032000000', '2015-01-29T00:00:00.016000000',\n                '2014-06-11T00:00:00.544000000', '2014-12-20T00:00:00.160000000',\n                '2014-12-28T00:00:00.144000000', '2015-01-05T00:00:00.192000000',\n                '2014-07-29T00:00:00.512000000', '2015-03-02T00:00:00.080000256',\n                '2015-07-08T00:00:00.112000000', '2015-08-25T00:00:00.272000000'],\n               dtype='datetime64[ns]')\n    \nv2 = np.array([1647., 1758., 1722.], dtype=float)\n<line_mask>\n                '2014-09-19T00:00:00.544000000'],\n               dtype='datetime64[ns]')\n\ndf1 = pd.DataFrame({'Velocity0': v1}, index=dv1)\ndf2 = pd.DataFrame({'Velocity1': v2}, index=dv2)\ndf1 = df1.append(df2).sort_index()\n\nax = sns.heatmap(df1)\nax.figure.set_size_inches(6,6)\nticklabels = [df1.index[int(tick)].strftime('%Y-%m-%d') for tick in ax.get_yticks()]\nax.set_yticklabels(ticklabels);",
            "masked_line": "dv2 = np.array(['2015-08-10T00:00:00.032000000', '2015-02-18T00:00:00.016000000',",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_842"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-27",
            "description": "The code creates two DataFrame objects from numpy arrays containing velocity values and corresponding dates, and appends them together. It then generates a heatmap plot using seaborn library to visualize the data.",
            "code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nv1 = np.array([1671., 1756., 1704., 1574., 1589., 1772., 1652., 1778., 1719., 1699.])\ndv1 = np.array(['2015-01-21T00:00:00.032000000', '2015-01-29T00:00:00.016000000',\n                '2014-06-11T00:00:00.544000000', '2014-12-20T00:00:00.160000000',\n                '2014-12-28T00:00:00.144000000', '2015-01-05T00:00:00.192000000',\n                '2014-07-29T00:00:00.512000000', '2015-03-02T00:00:00.080000256',\n                '2015-07-08T00:00:00.112000000', '2015-08-25T00:00:00.272000000'],\n               dtype='datetime64[ns]')\n    \nv2 = np.array([1647., 1758., 1722.], dtype=float)\ndv2 = np.array(['2015-08-10T00:00:00.032000000', '2015-02-18T00:00:00.016000000',\n                '2014-09-19T00:00:00.544000000'],\n               dtype='datetime64[ns]')\n\ndf1 = pd.DataFrame({'Velocity0': v1}, index=dv1)\ndf2 = pd.DataFrame({'Velocity1': v2}, index=dv2)\ndf1 = df1.append(df2).sort_index()\n\nax = sns.heatmap(df1)\nax.figure.set_size_inches(6,6)\nticklabels = [df1.index[int(tick)].strftime('%Y-%m-%d') for tick in ax.get_yticks()]\nax.set_yticklabels(ticklabels);",
            "masked_code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nv1 = np.array([1671., 1756., 1704., 1574., 1589., 1772., 1652., 1778., 1719., 1699.])\ndv1 = np.array(['2015-01-21T00:00:00.032000000', '2015-01-29T00:00:00.016000000',\n                '2014-06-11T00:00:00.544000000', '2014-12-20T00:00:00.160000000',\n                '2014-12-28T00:00:00.144000000', '2015-01-05T00:00:00.192000000',\n                '2014-07-29T00:00:00.512000000', '2015-03-02T00:00:00.080000256',\n                '2015-07-08T00:00:00.112000000', '2015-08-25T00:00:00.272000000'],\n               dtype='datetime64[ns]')\n    \nv2 = np.array([1647., 1758., 1722.], dtype=float)\ndv2 = np.array(['2015-08-10T00:00:00.032000000', '2015-02-18T00:00:00.016000000',\n                '2014-09-19T00:00:00.544000000'],\n               dtype='datetime64[ns]')\n\ndf1 = pd.DataFrame({'Velocity0': v1}, index=dv1)\ndf2 = pd.DataFrame({'Velocity1': v2}, index=dv2)\n<line_mask>\n\nax = sns.heatmap(df1)\nax.figure.set_size_inches(6,6)\nticklabels = [df1.index[int(tick)].strftime('%Y-%m-%d') for tick in ax.get_yticks()]\nax.set_yticklabels(ticklabels);",
            "masked_line": "df1 = df1.append(df2).sort_index()",
            "answer": "sort_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_843"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-27",
            "description": "The code generates two dataframes 'df1' and 'df2' with velocity values and corresponding timestamps. It appends 'df2' to 'df1', sorts the index, and creates a heatmap visualization using seaborn. The heatmap visualizes the velocity values over time.",
            "code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nv1 = np.array([1671., 1756., 1704., 1574., 1589., 1772., 1652., 1778., 1719., 1699.])\ndv1 = np.array(['2015-01-21T00:00:00.032000000', '2015-01-29T00:00:00.016000000',\n                '2014-06-11T00:00:00.544000000', '2014-12-20T00:00:00.160000000',\n                '2014-12-28T00:00:00.144000000', '2015-01-05T00:00:00.192000000',\n                '2014-07-29T00:00:00.512000000', '2015-03-02T00:00:00.080000256',\n                '2015-07-08T00:00:00.112000000', '2015-08-25T00:00:00.272000000'],\n               dtype='datetime64[ns]')\n    \nv2 = np.array([1647., 1758., 1722.], dtype=float)\ndv2 = np.array(['2015-08-10T00:00:00.032000000', '2015-02-18T00:00:00.016000000',\n                '2014-09-19T00:00:00.544000000'],\n               dtype='datetime64[ns]')\n\ndf1 = pd.DataFrame({'Velocity0': v1}, index=dv1)\ndf2 = pd.DataFrame({'Velocity1': v2}, index=dv2)\ndf1 = df1.append(df2).sort_index()\n\nax = sns.heatmap(df1)\nax.figure.set_size_inches(6,6)\nticklabels = [df1.index[int(tick)].strftime('%Y-%m-%d') for tick in ax.get_yticks()]\nax.set_yticklabels(ticklabels);",
            "masked_code": "import numpy as np     # v 1.19.2\nimport pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nv1 = np.array([1671., 1756., 1704., 1574., 1589., 1772., 1652., 1778., 1719., 1699.])\ndv1 = np.array(['2015-01-21T00:00:00.032000000', '2015-01-29T00:00:00.016000000',\n                '2014-06-11T00:00:00.544000000', '2014-12-20T00:00:00.160000000',\n                '2014-12-28T00:00:00.144000000', '2015-01-05T00:00:00.192000000',\n                '2014-07-29T00:00:00.512000000', '2015-03-02T00:00:00.080000256',\n                '2015-07-08T00:00:00.112000000', '2015-08-25T00:00:00.272000000'],\n               dtype='datetime64[ns]')\n    \nv2 = np.array([1647., 1758., 1722.], dtype=float)\ndv2 = np.array(['2015-08-10T00:00:00.032000000', '2015-02-18T00:00:00.016000000',\n                '2014-09-19T00:00:00.544000000'],\n               dtype='datetime64[ns]')\n\ndf1 = pd.DataFrame({'Velocity0': v1}, index=dv1)\ndf2 = pd.DataFrame({'Velocity1': v2}, index=dv2)\ndf1 = df1.append(df2).sort_index()\n\nax = sns.heatmap(df1)\nax.figure.set_size_inches(6,6)\n<line_mask>\nax.set_yticklabels(ticklabels);",
            "masked_line": "ticklabels = [df1.index[int(tick)].strftime('%Y-%m-%d') for tick in ax.get_yticks()]",
            "answer": "get_yticks",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_844"
        },
        {
            "dependency": "geopandas",
            "version": "==0.10.1",
            "time": "2021-10-11",
            "description": "The code downloads NYC subway entrance and exit data, processes the data to create a GeoDataFrame, filters the entrances where entry is allowed, and then randomly selects a subway entrance point to find the nearest subway entrance point to it.",
            "code": "# https://www.kaggle.com/new-york-state/nys-nyc-transit-subway-entrance-and-exit-data\nimport kaggle.cli\nimport sys, requests, urllib\nimport pandas as pd\nfrom pathlib import Path\nfrom zipfile import ZipFile\n\n# fmt: off\n# download data set\nurl = \"https://www.kaggle.com/new-york-state/nys-nyc-transit-subway-entrance-and-exit-data\"\nsys.argv = [sys.argv[0]] + f\"datasets download {urllib.parse.urlparse(url).path[1:]}\".split(\" \")\nkaggle.cli.main()\nzfile = ZipFile(f'{urllib.parse.urlparse(url).path.split(\"/\")[-1]}.zip')\ndfs = {f.filename: pd.read_csv(zfile.open(f)) for f in zfile.infolist() if Path(f.filename).suffix in [\".csv\"]}\n# fmt: on\n\ndf_subway = dfs['nyc-transit-subway-entrance-and-exit-data.csv']\n\nfrom shapely.geometry import Point, MultiPoint\nfrom shapely.ops import nearest_points\nimport geopandas as gpd\n\ngeometry = [Point(xy) for xy in zip(df_subway['Station Longitude'], df_subway['Station Latitude'])]\n\n# Coordinate reference system :\ncrs = {'init': 'EPSG:4326'}\n\n# Creating a Geographic data frame \ngdf_subway_entrance_geometry = gpd.GeoDataFrame(df_subway, crs=crs, geometry=geometry).to_crs('EPSG:5234')\ngdf_subway_entrance_geometry\n\ndf_yes_entry = gdf_subway_entrance_geometry\ndf_yes_entry = gdf_subway_entrance_geometry[gdf_subway_entrance_geometry.Entry=='YES']\ndf_yes_entry\n\n# randomly select a point....\ngpdPoint = gdf_subway_entrance_geometry.sample(1).geometry.tolist()[0]\npts = MultiPoint(df_yes_entry['geometry'].values) # does not work with a geopandas series, works with a numpy array\npt = Point(gpdPoint.x, gpdPoint.y)\n#[o.wkt for o in nearest_points(pt, pts)]\nfor o in nearest_points(pt, pts):\n  print(o)",
            "masked_code": "# https://www.kaggle.com/new-york-state/nys-nyc-transit-subway-entrance-and-exit-data\nimport kaggle.cli\nimport sys, requests, urllib\nimport pandas as pd\nfrom pathlib import Path\nfrom zipfile import ZipFile\n\n# fmt: off\n# download data set\nurl = \"https://www.kaggle.com/new-york-state/nys-nyc-transit-subway-entrance-and-exit-data\"\nsys.argv = [sys.argv[0]] + f\"datasets download {urllib.parse.urlparse(url).path[1:]}\".split(\" \")\nkaggle.cli.main()\nzfile = ZipFile(f'{urllib.parse.urlparse(url).path.split(\"/\")[-1]}.zip')\ndfs = {f.filename: pd.read_csv(zfile.open(f)) for f in zfile.infolist() if Path(f.filename).suffix in [\".csv\"]}\n# fmt: on\n\ndf_subway = dfs['nyc-transit-subway-entrance-and-exit-data.csv']\n\nfrom shapely.geometry import Point, MultiPoint\nfrom shapely.ops import nearest_points\nimport geopandas as gpd\n\ngeometry = [Point(xy) for xy in zip(df_subway['Station Longitude'], df_subway['Station Latitude'])]\n\n# Coordinate reference system :\ncrs = {'init': 'EPSG:4326'}\n\n# Creating a Geographic data frame \n<line_mask>\ngdf_subway_entrance_geometry\n\ndf_yes_entry = gdf_subway_entrance_geometry\ndf_yes_entry = gdf_subway_entrance_geometry[gdf_subway_entrance_geometry.Entry=='YES']\ndf_yes_entry\n\n# randomly select a point....\ngpdPoint = gdf_subway_entrance_geometry.sample(1).geometry.tolist()[0]\npts = MultiPoint(df_yes_entry['geometry'].values) # does not work with a geopandas series, works with a numpy array\npt = Point(gpdPoint.x, gpdPoint.y)\n#[o.wkt for o in nearest_points(pt, pts)]\nfor o in nearest_points(pt, pts):\n  print(o)",
            "masked_line": "gdf_subway_entrance_geometry = gpd.GeoDataFrame(df_subway, crs=crs, geometry=geometry).to_crs('EPSG:5234')",
            "answer": "GeoDataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_845"
        },
        {
            "dependency": "plotly",
            "version": "==5.1.0",
            "time": "2021-08-12",
            "description": "The code creates a Sankey diagram using Plotly graph objects to visualize the flow of data. It includes nodes with labels and positions along the x and y axes, as well as links between nodes with specified source, target, and values. Lastly, the diagram is displayed using the `show()` function.",
            "code": "import plotly.graph_objects as go\n\nfig = go.Figure(data=[go.Sankey(\n    arrangement = \"snap\",\n    node = {\n        \"label\": demo_df[\"name\"],\n        \"x\": [1e-9, 1e-9, 0.5, 0.5, 0.5, 1, 1, 1],  # A 'column' based on the year\n        \"y\": [1e-9, 0.5, 1e-9, 0.5, 1, 1e-9, 0.5, 1],  # A 'row' based on rank for that year\n        \"color\": \"blue\"\n    },\n    link = {\n        \"source\": [0, 1, 2, 3, 4],\n        \"target\": [2, 3, 7, 5, 6],\n        \"value\": [1, 1, 1, 1, 1]\n    }\n  )])\n\n\nfig.show()",
            "masked_code": "import plotly.graph_objects as go\n\nfig = go.Figure(data=[go.Sankey(\n    arrangement = \"snap\",\n    node = {\n        \"label\": demo_df[\"name\"],\n        \"x\": [1e-9, 1e-9, 0.5, 0.5, 0.5, 1, 1, 1],  # A 'column' based on the year\n        \"y\": [1e-9, 0.5, 1e-9, 0.5, 1, 1e-9, 0.5, 1],  # A 'row' based on rank for that year\n        \"color\": \"blue\"\n    },\n    link = {\n        \"source\": [0, 1, 2, 3, 4],\n        \"target\": [2, 3, 7, 5, 6],\n        \"value\": [1, 1, 1, 1, 1]\n    }\n  )])\n\n\n<line_mask>",
            "masked_line": "fig.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_846"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.4.2",
            "time": "2021-08-24",
            "description": "The code generates a 3D plot of a mathematical function and saves it as an image file. It then creates a new plot, adds the saved image to it, adjusts the size and appearance of the plot, and finally deletes the saved image file.",
            "code": "from mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\nplt.close()\n\n# your code starts here, with a little modification\nfig = plt.figure(figsize=(5,5))\nax = fig.add_subplot(projection='3d')\n\nu = v = np.linspace(0, 2 * np.pi, 50)\nu, v = np.meshgrid(u, v)\nX = np.cos(v) * (6 - (5/4 + np.sin(3 * u)) * np.sin(u - 3 * v))\nY = (6 - (5/4 + np.sin(3 * u)) * np.sin(u - 3 * v)) * np.sin(v)\nZ = -np.cos(u - 3 * v) * (5/4 + np.sin(3 * u))\nax.plot_surface(X, Y, Z, rstride=1, cstride=1, color=[0.7] * 3, linewidth=0.25, edgecolor=\"k\")\n\n# set the axes limits\nleft, right = plt.xlim()\nax.set_zlim(left, right)\nax.set_ylim(left, right)\n\n# zoom in to the plot\nax.dist = 6\n\n# make everything other than the plot itself transparent\nfig.patch.set_alpha(0)\nax.patch.set_alpha(0)\nax.axis('off')\nplt.tight_layout()\n\n# save plot as image\nplt.savefig('plotted.png')\n\n# remove the axes where the image was plotted\nax.remove()\n\n# resize figsize\nfig = matplotlib.pyplot.gcf()\nfig.set_size_inches(5, 2.5)\n\n# add fake axes for gridlines as in 3d plot to make it look like a real plot\n# skip this part if the gridlines are unnecessary\nax_bg = fig.add_subplot(111, projection='3d')\nax_bg.dist = 3\n\n# add axes in cartesian coordinates (xy-plane) for the image\nax = fig.add_subplot(111)\nfig.patch.set_alpha(1)\nfig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)\nim = plt.imread('plotted.png')\n\nh, w, dc = im.shape # (height=500, width=500, depth/color=4)\nim_cropped = im[120:390, :, :] # this is manually adjusted\nax.axis('off')\nax.imshow(im_cropped)\n\n# delete the saved image\nos.remove('plotted.png')",
            "masked_code": "from mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\nplt.close()\n\n# your code starts here, with a little modification\nfig = plt.figure(figsize=(5,5))\nax = fig.add_subplot(projection='3d')\n\nu = v = np.linspace(0, 2 * np.pi, 50)\nu, v = np.meshgrid(u, v)\nX = np.cos(v) * (6 - (5/4 + np.sin(3 * u)) * np.sin(u - 3 * v))\nY = (6 - (5/4 + np.sin(3 * u)) * np.sin(u - 3 * v)) * np.sin(v)\nZ = -np.cos(u - 3 * v) * (5/4 + np.sin(3 * u))\nax.plot_surface(X, Y, Z, rstride=1, cstride=1, color=[0.7] * 3, linewidth=0.25, edgecolor=\"k\")\n\n# set the axes limits\nleft, right = plt.xlim()\nax.set_zlim(left, right)\nax.set_ylim(left, right)\n\n# zoom in to the plot\nax.dist = 6\n\n# make everything other than the plot itself transparent\nfig.patch.set_alpha(0)\nax.patch.set_alpha(0)\nax.axis('off')\nplt.tight_layout()\n\n# save plot as image\nplt.savefig('plotted.png')\n\n# remove the axes where the image was plotted\nax.remove()\n\n# resize figsize\nfig = matplotlib.pyplot.gcf()\nfig.set_size_inches(5, 2.5)\n\n# add fake axes for gridlines as in 3d plot to make it look like a real plot\n# skip this part if the gridlines are unnecessary\nax_bg = fig.add_subplot(111, projection='3d')\nax_bg.dist = 3\n\n# add axes in cartesian coordinates (xy-plane) for the image\nax = fig.add_subplot(111)\nfig.patch.set_alpha(1)\nfig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)\nim = plt.imread('plotted.png')\n\nh, w, dc = im.shape # (height=500, width=500, depth/color=4)\nim_cropped = im[120:390, :, :] # this is manually adjusted\n<line_mask>\nax.imshow(im_cropped)\n\n# delete the saved image\nos.remove('plotted.png')",
            "masked_line": "ax.axis('off')",
            "answer": "axis",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_847"
        },
        {
            "dependency": "click",
            "version": "==7.1.2",
            "time": "2021-04-19",
            "description": "This code defines a command-line interface (CLI) using the click library in Python. It sets up options for flags (-x, -y) and a parameter (-z) for the command line. When the CLI is run, it displays the values of the flags and parameter provided by the user. The script also includes a loop to test different commands with the CLI and prints out the Click version and Python version.",
            "code": "import click\n\n@click.command()\n@click.option('-x', is_flag=True)\n@click.option('-y', is_flag=True)\n@click.option('-z')\ndef cli(x, y, z):\n    click.echo(f'x:{x}  y:{y}  z:{z}')\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '-x',\n        '-y',\n        '-z 1',\n        '-xz 2',\n        '-yz 3',\n        '-xyz 4',\n        '-yx',\n        '--help',\n    )\n\n    import sys, time\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\n<line_mask>\n@click.option('-x', is_flag=True)\n@click.option('-y', is_flag=True)\n@click.option('-z')\ndef cli(x, y, z):\n    click.echo(f'x:{x}  y:{y}  z:{z}')\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '-x',\n        '-y',\n        '-z 1',\n        '-xz 2',\n        '-yz 3',\n        '-xyz 4',\n        '-yx',\n        '--help',\n    )\n\n    import sys, time\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.command()",
            "answer": "command",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_848"
        },
        {
            "dependency": "keras",
            "version": "==2.2.4",
            "time": "2021-05-07",
            "description": "This code defines an input layer for a neural network with a shape of [1] and data type of float32. The name of the input layer is set to '1'. It then prints the shape of the input layer, which is (None, 1).",
            "code": "import tensorflow as tf\nfrom keras.layers import Input\n\ns = Input(shape=[1], dtype=tf.float32, name='1')\nprint(\"shape of s is: \",s._keras_shape) # (None, 1)",
            "masked_code": "import tensorflow as tf\nfrom keras.layers import Input\n\n<line_mask>\nprint(\"shape of s is: \",s._keras_shape) # (None, 1)",
            "masked_line": "s = Input(shape=[1], dtype=tf.float32, name='1')",
            "answer": "Input",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_849"
        },
        {
            "dependency": "connexion",
            "version": "==2.6.0",
            "time": "2021-07-20",
            "description": "This Python code initializes a server using the Connexion library to serve a RESTful API defined in a Swagger specification file. The server runs on the specified endpoint with JSON encoding.",
            "code": "#!/usr/bin/env python3\nimport connexion\nfrom swagger_server import encoder\n\napp = connexion.App(__name__, specification_dir='./swagger/')\napp.app.json_encoder = encoder.JSONEncoder\napp.add_api('swagger.yaml', arguments={'title': 'Docuware end point'}, pythonic_params=True)\n\nif __name__ == '__main__':\n    app.run()",
            "masked_code": "#!/usr/bin/env python3\nimport connexion\nfrom swagger_server import encoder\n\napp = connexion.App(__name__, specification_dir='./swagger/')\napp.app.json_encoder = encoder.JSONEncoder\n<line_mask>\n\nif __name__ == '__main__':\n    app.run()",
            "masked_line": "app.add_api('swagger.yaml', arguments={'title': 'Docuware end point'}, pythonic_params=True)",
            "answer": "add_api",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_850"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.1",
            "time": "2021-02-10",
            "description": "The code plots a dummy dataframe 'df' with a datetime index using pandas and matplotlib. It adds vertical lines at specific dates using pandas timestamp and datetime object.",
            "code": "from datetime import datetime\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\n# dummy dataframe with a datetime index:\ndf = pd.DataFrame({'v': range(12)},\n                  index=pd.date_range('2020', periods=12, freq='MS'))\n\ndf.plot()\n# using a pandas timestamp:\nplt.axvline(pd.Timestamp(\"2020-06-01\"), color='r')\n# using a datetime object:\nplt.axvline(datetime(2020,8,1), color='g')",
            "masked_code": "from datetime import datetime\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\n# dummy dataframe with a datetime index:\ndf = pd.DataFrame({'v': range(12)},\n                  <line_mask>\n\ndf.plot()\n# using a pandas timestamp:\nplt.axvline(pd.Timestamp(\"2020-06-01\"), color='r')\n# using a datetime object:\nplt.axvline(datetime(2020,8,1), color='g')",
            "masked_line": "index=pd.date_range('2020', periods=12, freq='MS'))",
            "answer": "date_range",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_851"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.3",
            "time": "2021-02-10",
            "description": "The code generates a dummy dataframe with a datetime index and plots the values in the dataframe. It also adds vertical lines to the plot at specific dates using pandas timestamp and datetime object.",
            "code": "from datetime import datetime\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\n# dummy dataframe with a datetime index:\ndf = pd.DataFrame({'v': range(12)},\n                  index=pd.date_range('2020', periods=12, freq='MS'))\n\ndf.plot()\n# using a pandas timestamp:\nplt.axvline(pd.Timestamp(\"2020-06-01\"), color='r')\n# using a datetime object:\nplt.axvline(datetime(2020,8,1), color='g')",
            "masked_code": "from datetime import datetime\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\n# dummy dataframe with a datetime index:\ndf = pd.DataFrame({'v': range(12)},\n                  index=pd.date_range('2020', periods=12, freq='MS'))\n\ndf.plot()\n# using a pandas timestamp:\n<line_mask>\n# using a datetime object:\nplt.axvline(datetime(2020,8,1), color='g')",
            "masked_line": "plt.axvline(pd.Timestamp(\"2020-06-01\"), color='r')",
            "answer": "axvline",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_852"
        },
        {
            "dependency": "dash",
            "version": "==2.3.0",
            "time": "2022-08-11",
            "description": "This code allows the user to download a pandas DataFrame as an Excel file when clicking a button on a Dash web application. The DataFrame is created with columns \"a\", \"b\", and \"c\", and the callback function writes this DataFrame to an Excel file and provides a download link for the user to download the generated Excel file named \"mydf.xlsx\".",
            "code": "import dash\nfrom dash.dependencies import Output, Input\nfrom dash import dcc, html\nimport pandas as pd\nimport io\n\napp = dash.Dash(__name__)\napp.layout = html.Div([\n    html.Button(\"Download Excel\", id=\"btn_xlsx\"),\n    dcc.Download(id=\"download-dataframe-xlsx\"),\n])\n\n\ndf = pd.DataFrame({\"a\": [1, 2, 3, 4], \"b\": [2, 1, 5, 6], \"c\": [\"x\", \"x\", \"y\", \"y\"]})\n\n\n@app.callback(\n    Output(\"download-dataframe-xlsx\", \"data\"),\n    Input(\"btn_xlsx\", \"n_clicks\"),\n    prevent_initial_call=True,\n)\ndef func(n_clicks):\n    output = io.BytesIO()\n    writer = pd.ExcelWriter(output, engine='xlsxwriter')\n\n    # do your formatting here\n\n    df.to_excel(writer, sheet_name='Sheet_name_1', index=False)  # writes to BytesIO buffer\n    writer.save()\n    data = output.getvalue()\n    return dcc.send_bytes(data, 'mydf.xlsx')\n\n\nif __name__ == \"__main__\":\n    app.run_server(debug=True)",
            "masked_code": "import dash\nfrom dash.dependencies import Output, Input\nfrom dash import dcc, html\nimport pandas as pd\nimport io\n\napp = dash.Dash(__name__)\napp.layout = html.Div([\n    html.Button(\"Download Excel\", id=\"btn_xlsx\"),\n    <line_mask>\n])\n\n\ndf = pd.DataFrame({\"a\": [1, 2, 3, 4], \"b\": [2, 1, 5, 6], \"c\": [\"x\", \"x\", \"y\", \"y\"]})\n\n\n@app.callback(\n    Output(\"download-dataframe-xlsx\", \"data\"),\n    Input(\"btn_xlsx\", \"n_clicks\"),\n    prevent_initial_call=True,\n)\ndef func(n_clicks):\n    output = io.BytesIO()\n    writer = pd.ExcelWriter(output, engine='xlsxwriter')\n\n    # do your formatting here\n\n    df.to_excel(writer, sheet_name='Sheet_name_1', index=False)  # writes to BytesIO buffer\n    writer.save()\n    data = output.getvalue()\n    return dcc.send_bytes(data, 'mydf.xlsx')\n\n\nif __name__ == \"__main__\":\n    app.run_server(debug=True)",
            "masked_line": "dcc.Download(id=\"download-dataframe-xlsx\"),",
            "answer": "Download",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_853"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-02-16",
            "description": "The code generates a figure with a set size, plots a rectangle with specified dimensions and color, plots a point with a marker at a specific location, and adds a vector with a specified direction and properties to the plot. The x and y ticks are set to a specific range and the axis is turned off before displaying the plot.",
            "code": "import numpy as np               # v 1.19.2\nimport matplotlib.pyplot as plt  # v 3.3.2\n\nfigure=plt.figure(figsize=(6,4))  \nax=plt.gca()\nplt.xticks(np.arange(-20,20,1))\nplt.yticks(np.arange(-20,20,1))\nrect=plt.Rectangle((1,1),10,10,facecolor='#32CD32',alpha=0.8)\nax.plot(2,2,marker='o',alpha=1,color='red')\nax.quiver( 2,2, 20,20, color='black', scale_units='inches', scale=10, width=0.015,\n          headlength=5,headwidth=3,alpha=1)\nax.add_patch(rect)\nplt.axis('off')\nplt.show()",
            "masked_code": "import numpy as np               # v 1.19.2\nimport matplotlib.pyplot as plt  # v 3.3.2\n\nfigure=plt.figure(figsize=(6,4))  \nax=plt.gca()\nplt.xticks(np.arange(-20,20,1))\n<line_mask>\nrect=plt.Rectangle((1,1),10,10,facecolor='#32CD32',alpha=0.8)\nax.plot(2,2,marker='o',alpha=1,color='red')\nax.quiver( 2,2, 20,20, color='black', scale_units='inches', scale=10, width=0.015,\n          headlength=5,headwidth=3,alpha=1)\nax.add_patch(rect)\nplt.axis('off')\nplt.show()",
            "masked_line": "plt.yticks(np.arange(-20,20,1))",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_854"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-16",
            "description": "The code creates a plot with a rectangle at (1,1) of size 10x10, a red marker at (2,2), and a black arrow at (2,2) pointing towards (20,20). The plot has ticks along the x and y axes from -20 to 20. The plot has a green background color and the axis is turned off.",
            "code": "import numpy as np               # v 1.19.2\nimport matplotlib.pyplot as plt  # v 3.3.2\n\nfigure=plt.figure(figsize=(6,4))  \nax=plt.gca()\nplt.xticks(np.arange(-20,20,1))\nplt.yticks(np.arange(-20,20,1))\nrect=plt.Rectangle((1,1),10,10,facecolor='#32CD32',alpha=0.8)\nax.plot(2,2,marker='o',alpha=1,color='red')\nax.quiver( 2,2, 20,20, color='black', scale_units='inches', scale=10, width=0.015,\n          headlength=5,headwidth=3,alpha=1)\nax.add_patch(rect)\nplt.axis('off')\nplt.show()",
            "masked_code": "import numpy as np               # v 1.19.2\nimport matplotlib.pyplot as plt  # v 3.3.2\n\nfigure=plt.figure(figsize=(6,4))  \nax=plt.gca()\nplt.xticks(np.arange(-20,20,1))\n<line_mask>\nrect=plt.Rectangle((1,1),10,10,facecolor='#32CD32',alpha=0.8)\nax.plot(2,2,marker='o',alpha=1,color='red')\nax.quiver( 2,2, 20,20, color='black', scale_units='inches', scale=10, width=0.015,\n          headlength=5,headwidth=3,alpha=1)\nax.add_patch(rect)\nplt.axis('off')\nplt.show()",
            "masked_line": "plt.yticks(np.arange(-20,20,1))",
            "answer": "yticks",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_855"
        },
        {
            "dependency": "pandas",
            "version": ">=1.3.0",
            "time": "2021-11-11",
            "description": "This code creates a pandas DataFrame with two columns: 'Number' and 'Date'. The 'Number' column contains values 100.00 and -100.00, while the 'Date' column contains dates one year before and one year ahead of the current year, respectively. The purpose is to create a reproducible example where styles will always be consistent even in future years, although the date values will change.",
            "code": "import datetime as dt\n\nimport numpy as np\nimport pandas as pd\n\n# Reproducible example with year offset so styles will always\n# be reproducible same even in future years \n# (even though date values will change) \ndf = pd.DataFrame({\n    'Number': [100.00, -100.00],\n    'Date': pd.to_datetime(\n        [dt.date(dt.datetime.now().year - 1, 1, 1),\n         dt.date(dt.datetime.now().year + 1, 1, 1)]\n    ).date\n})",
            "masked_code": "import datetime as dt\n\nimport numpy as np\nimport pandas as pd\n\n# Reproducible example with year offset so styles will always\n# be reproducible same even in future years \n# (even though date values will change) \ndf = pd.DataFrame({\n    'Number': [100.00, -100.00],\n    <line_mask>\n        [dt.date(dt.datetime.now().year - 1, 1, 1),\n         dt.date(dt.datetime.now().year + 1, 1, 1)]\n    ).date\n})",
            "masked_line": "'Date': pd.to_datetime(",
            "answer": "to_datetime",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_856"
        },
        {
            "dependency": "plotly",
            "version": "==4.7.0",
            "time": "2021-09-01",
            "description": "The code generates a Dash web application that allows users to select multiple capsule IDs and view a scatter plot of relative humidity vs. TCD values. The scatter plot is interactive and includes a slider for selecting the time range. The application updates the scatter plot based on the selected capsule IDs and the range selected on the slider.",
            "code": "import pandas as pd\nimport plotly.express as px  # (version 4.7.0)\nimport plotly.graph_objects as go\nimport numpy as np\n\nimport openpyxl\nimport dash  # (version 1.12.0) pip install dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\nfrom dash.exceptions import PreventUpdate\nfrom jupyter_dash import JupyterDash\n\n# app = dash.Dash(__name__)\n# server = app.server\napp = JupyterDash(__name__)\n\n\n# df = pd.read_excel(\"tcd vs rh 2.xlsx\")\n# print(df)\n\ncapsuleID = df[\"Capsule_ID\"].unique()\n# print(capsuleID)\n\ncapsuleID_names = sorted(list(capsuleID))\n# print(capsuleID_names)\n\ncapsuleID_names_1 = [{\"label\": k, \"value\": k} for k in sorted(capsuleID)]\ncapsuleID_names_2 = [{\"label\": \"(Select All)\", \"value\": \"All\"}]\ncapsuleID_names_all = capsuleID_names_1 + capsuleID_names_2\n\ndef slider_fig(df):\n    return px.scatter(\n                df.groupby(\"Wallclock\", as_index=False).size(), x=\"Wallclock\", y=\"size\"\n            ).update_layout(\n                xaxis={\"rangeslider\": {\"visible\": True}, \"title\":None},\n                height=125,\n                yaxis={\"tickmode\": \"array\", \"tickvals\": [], \"title\": None},\n                margin={\"l\": 0, \"r\": 0, \"t\": 0, \"b\": 0},\n            )\n\napp.layout = html.Div(\n    [\n        html.H1(\"Relative Humidity vs TCD\", style={\"text-align\": \"center\"}),\n        dcc.Dropdown(\n            id=\"capsule_select\",\n            options=capsuleID_names_all,\n            optionHeight=25,\n            multi=True,\n            searchable=True,\n            placeholder=\"Please select...\",\n            clearable=True,\n            value=[\"All\"],\n            style={\"width\": \"100%\"},\n        ),\n        dcc.Graph(\n            id=\"slider\",\n            figure=slider_fig(df),\n        ),\n        html.Div(\n            [\n                dcc.Graph(id=\"the_graph\"),\n            ]\n        ),\n    ]\n)\n\n# -----------------------------------------------------------\n@app.callback(\n    Output(\"the_graph\", \"figure\"),\n    Output(\"capsule_select\", \"value\"),\n    Output(\"slider\", \"figure\"),\n    Input(\"capsule_select\", \"value\"),\n    Input('slider', 'relayoutData'),\n    State(\"slider\", \"figure\")\n)\ndef update_graph(capsule_chosen, slider, sfig):\n    dropdown_values = capsule_chosen\n\n    if \"All\" in capsule_chosen:\n        dropdown_values = capsuleID_names\n        dff = df\n    else:\n        dff = df[\n            df[\"Capsule_ID\"].isin(capsule_chosen)\n        ]  # filter all rows where capsule ID is the capsule ID selected\n\n    \n    if slider and \"xaxis.range\" in slider.keys():\n        dff = dff.loc[dff[\"Wallclock\"].between(*slider[\"xaxis.range\"])]\n    else:\n        # update slider based on selected capsules\n        sfig = slider_fig(dff)\n        \n    scatterplot = px.scatter(\n        data_frame=dff,\n        x=\"tcd\",\n        y=\"humidity\",\n        hover_name=\"Wallclock\",\n    )\n\n    scatterplot.update_traces(textposition=\"top center\")\n\n    return scatterplot, dropdown_values, sfig\n\n\n# ------------------------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    #     app.run_server(debug=True)\n    app.run_server(mode=\"inline\")",
            "masked_code": "import pandas as pd\nimport plotly.express as px  # (version 4.7.0)\nimport plotly.graph_objects as go\nimport numpy as np\n\nimport openpyxl\nimport dash  # (version 1.12.0) pip install dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\nfrom dash.exceptions import PreventUpdate\nfrom jupyter_dash import JupyterDash\n\n# app = dash.Dash(__name__)\n# server = app.server\napp = JupyterDash(__name__)\n\n\n# df = pd.read_excel(\"tcd vs rh 2.xlsx\")\n# print(df)\n\ncapsuleID = df[\"Capsule_ID\"].unique()\n# print(capsuleID)\n\ncapsuleID_names = sorted(list(capsuleID))\n# print(capsuleID_names)\n\ncapsuleID_names_1 = [{\"label\": k, \"value\": k} for k in sorted(capsuleID)]\ncapsuleID_names_2 = [{\"label\": \"(Select All)\", \"value\": \"All\"}]\ncapsuleID_names_all = capsuleID_names_1 + capsuleID_names_2\n\ndef slider_fig(df):\n    return px.scatter(\n                df.groupby(\"Wallclock\", as_index=False).size(), x=\"Wallclock\", y=\"size\"\n            ).update_layout(\n                xaxis={\"rangeslider\": {\"visible\": True}, \"title\":None},\n                height=125,\n                yaxis={\"tickmode\": \"array\", \"tickvals\": [], \"title\": None},\n                margin={\"l\": 0, \"r\": 0, \"t\": 0, \"b\": 0},\n            )\n\napp.layout = html.Div(\n    [\n        html.H1(\"Relative Humidity vs TCD\", style={\"text-align\": \"center\"}),\n        dcc.Dropdown(\n            id=\"capsule_select\",\n            options=capsuleID_names_all,\n            optionHeight=25,\n            multi=True,\n            searchable=True,\n            placeholder=\"Please select...\",\n            clearable=True,\n            value=[\"All\"],\n            style={\"width\": \"100%\"},\n        ),\n        dcc.Graph(\n            id=\"slider\",\n            figure=slider_fig(df),\n        ),\n        html.Div(\n            [\n                dcc.Graph(id=\"the_graph\"),\n            ]\n        ),\n    ]\n)\n\n# -----------------------------------------------------------\n@app.callback(\n    Output(\"the_graph\", \"figure\"),\n    Output(\"capsule_select\", \"value\"),\n    Output(\"slider\", \"figure\"),\n    Input(\"capsule_select\", \"value\"),\n    Input('slider', 'relayoutData'),\n    State(\"slider\", \"figure\")\n)\ndef update_graph(capsule_chosen, slider, sfig):\n    dropdown_values = capsule_chosen\n\n    if \"All\" in capsule_chosen:\n        dropdown_values = capsuleID_names\n        dff = df\n    else:\n        dff = df[\n            df[\"Capsule_ID\"].isin(capsule_chosen)\n        ]  # filter all rows where capsule ID is the capsule ID selected\n\n    \n    if slider and \"xaxis.range\" in slider.keys():\n        dff = dff.loc[dff[\"Wallclock\"].between(*slider[\"xaxis.range\"])]\n    else:\n        # update slider based on selected capsules\n        sfig = slider_fig(dff)\n        \n    <line_mask>\n        data_frame=dff,\n        x=\"tcd\",\n        y=\"humidity\",\n        hover_name=\"Wallclock\",\n    )\n\n    scatterplot.update_traces(textposition=\"top center\")\n\n    return scatterplot, dropdown_values, sfig\n\n\n# ------------------------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    #     app.run_server(debug=True)\n    app.run_server(mode=\"inline\")",
            "masked_line": "scatterplot = px.scatter(",
            "answer": "scatter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_857"
        },
        {
            "dependency": "dash",
            "version": "==1.12.0",
            "time": "2021-09-01",
            "description": "The code generates a dashboard that displays a scatter plot of Relative Humidity vs TCD data. Users can select specific capsule IDs from a dropdown menu, and the scatter plot will update accordingly. Additionally, there is a slider that allows users to filter the data based on the Wallclock values. The dashboard is built using Dash and Plotly libraries in Python.",
            "code": "import pandas as pd\nimport plotly.express as px  # (version 4.7.0)\nimport plotly.graph_objects as go\nimport numpy as np\n\nimport openpyxl\nimport dash  # (version 1.12.0) pip install dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\nfrom dash.exceptions import PreventUpdate\nfrom jupyter_dash import JupyterDash\n\n# app = dash.Dash(__name__)\n# server = app.server\napp = JupyterDash(__name__)\n\n\n# df = pd.read_excel(\"tcd vs rh 2.xlsx\")\n# print(df)\n\ncapsuleID = df[\"Capsule_ID\"].unique()\n# print(capsuleID)\n\ncapsuleID_names = sorted(list(capsuleID))\n# print(capsuleID_names)\n\ncapsuleID_names_1 = [{\"label\": k, \"value\": k} for k in sorted(capsuleID)]\ncapsuleID_names_2 = [{\"label\": \"(Select All)\", \"value\": \"All\"}]\ncapsuleID_names_all = capsuleID_names_1 + capsuleID_names_2\n\ndef slider_fig(df):\n    return px.scatter(\n                df.groupby(\"Wallclock\", as_index=False).size(), x=\"Wallclock\", y=\"size\"\n            ).update_layout(\n                xaxis={\"rangeslider\": {\"visible\": True}, \"title\":None},\n                height=125,\n                yaxis={\"tickmode\": \"array\", \"tickvals\": [], \"title\": None},\n                margin={\"l\": 0, \"r\": 0, \"t\": 0, \"b\": 0},\n            )\n\napp.layout = html.Div(\n    [\n        html.H1(\"Relative Humidity vs TCD\", style={\"text-align\": \"center\"}),\n        dcc.Dropdown(\n            id=\"capsule_select\",\n            options=capsuleID_names_all,\n            optionHeight=25,\n            multi=True,\n            searchable=True,\n            placeholder=\"Please select...\",\n            clearable=True,\n            value=[\"All\"],\n            style={\"width\": \"100%\"},\n        ),\n        dcc.Graph(\n            id=\"slider\",\n            figure=slider_fig(df),\n        ),\n        html.Div(\n            [\n                dcc.Graph(id=\"the_graph\"),\n            ]\n        ),\n    ]\n)\n\n# -----------------------------------------------------------\n@app.callback(\n    Output(\"the_graph\", \"figure\"),\n    Output(\"capsule_select\", \"value\"),\n    Output(\"slider\", \"figure\"),\n    Input(\"capsule_select\", \"value\"),\n    Input('slider', 'relayoutData'),\n    State(\"slider\", \"figure\")\n)\ndef update_graph(capsule_chosen, slider, sfig):\n    dropdown_values = capsule_chosen\n\n    if \"All\" in capsule_chosen:\n        dropdown_values = capsuleID_names\n        dff = df\n    else:\n        dff = df[\n            df[\"Capsule_ID\"].isin(capsule_chosen)\n        ]  # filter all rows where capsule ID is the capsule ID selected\n\n    \n    if slider and \"xaxis.range\" in slider.keys():\n        dff = dff.loc[dff[\"Wallclock\"].between(*slider[\"xaxis.range\"])]\n    else:\n        # update slider based on selected capsules\n        sfig = slider_fig(dff)\n        \n    scatterplot = px.scatter(\n        data_frame=dff,\n        x=\"tcd\",\n        y=\"humidity\",\n        hover_name=\"Wallclock\",\n    )\n\n    scatterplot.update_traces(textposition=\"top center\")\n\n    return scatterplot, dropdown_values, sfig\n\n\n# ------------------------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    #     app.run_server(debug=True)\n    app.run_server(mode=\"inline\")",
            "masked_code": "import pandas as pd\nimport plotly.express as px  # (version 4.7.0)\nimport plotly.graph_objects as go\nimport numpy as np\n\nimport openpyxl\nimport dash  # (version 1.12.0) pip install dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\nfrom dash.exceptions import PreventUpdate\nfrom jupyter_dash import JupyterDash\n\n# app = dash.Dash(__name__)\n# server = app.server\napp = JupyterDash(__name__)\n\n\n# df = pd.read_excel(\"tcd vs rh 2.xlsx\")\n# print(df)\n\ncapsuleID = df[\"Capsule_ID\"].unique()\n# print(capsuleID)\n\ncapsuleID_names = sorted(list(capsuleID))\n# print(capsuleID_names)\n\ncapsuleID_names_1 = [{\"label\": k, \"value\": k} for k in sorted(capsuleID)]\ncapsuleID_names_2 = [{\"label\": \"(Select All)\", \"value\": \"All\"}]\ncapsuleID_names_all = capsuleID_names_1 + capsuleID_names_2\n\ndef slider_fig(df):\n    return px.scatter(\n                df.groupby(\"Wallclock\", as_index=False).size(), x=\"Wallclock\", y=\"size\"\n            ).update_layout(\n                xaxis={\"rangeslider\": {\"visible\": True}, \"title\":None},\n                height=125,\n                yaxis={\"tickmode\": \"array\", \"tickvals\": [], \"title\": None},\n                margin={\"l\": 0, \"r\": 0, \"t\": 0, \"b\": 0},\n            )\n\napp.layout = html.Div(\n    [\n        html.H1(\"Relative Humidity vs TCD\", style={\"text-align\": \"center\"}),\n        dcc.Dropdown(\n            id=\"capsule_select\",\n            options=capsuleID_names_all,\n            optionHeight=25,\n            multi=True,\n            searchable=True,\n            placeholder=\"Please select...\",\n            clearable=True,\n            value=[\"All\"],\n            style={\"width\": \"100%\"},\n        ),\n        dcc.Graph(\n            id=\"slider\",\n            figure=slider_fig(df),\n        ),\n        html.Div(\n            [\n                dcc.Graph(id=\"the_graph\"),\n            ]\n        ),\n    ]\n)\n\n# -----------------------------------------------------------\n@app.callback(\n    Output(\"the_graph\", \"figure\"),\n    Output(\"capsule_select\", \"value\"),\n    Output(\"slider\", \"figure\"),\n    Input(\"capsule_select\", \"value\"),\n    Input('slider', 'relayoutData'),\n    State(\"slider\", \"figure\")\n)\ndef update_graph(capsule_chosen, slider, sfig):\n    dropdown_values = capsule_chosen\n\n    if \"All\" in capsule_chosen:\n        dropdown_values = capsuleID_names\n        dff = df\n    else:\n        dff = df[\n            df[\"Capsule_ID\"].isin(capsule_chosen)\n        ]  # filter all rows where capsule ID is the capsule ID selected\n\n    \n    if slider and \"xaxis.range\" in slider.keys():\n        dff = dff.loc[dff[\"Wallclock\"].between(*slider[\"xaxis.range\"])]\n    else:\n        # update slider based on selected capsules\n        sfig = slider_fig(dff)\n        \n    scatterplot = px.scatter(\n        data_frame=dff,\n        x=\"tcd\",\n        y=\"humidity\",\n        hover_name=\"Wallclock\",\n    )\n\n    scatterplot.update_traces(textposition=\"top center\")\n\n    return scatterplot, dropdown_values, sfig\n\n\n# ------------------------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    #     app.run_server(debug=True)\n    <line_mask>",
            "masked_line": "app.run_server(mode=\"inline\")",
            "answer": "run_server",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_858"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.1",
            "time": "2021-08-02",
            "description": "The code reads a JSON string with user data, creates a pandas DataFrame from it, fills missing values with forward fill, calculates the sum of each row, and then calculates the unique values after applying different rolling window mean functions.",
            "code": "import pandas as pd\nimport numpy as np\nimport json\nimport sys\nprint(sys.version)\nprint(pd.__version__)\njsn_str = '{\"user_1\":{\"77\":4514.0,\"44\":7867.54,\"67\":10406.54,\"12\":7151.0,\"56\":1921.0,\"36\":9471.0,\"47\":2021.0,\"25\":3211.0,\"26\":2021.0,\"15\":4651.0,\"71\":8805.0,\"62\":352.0}}'\ndf = pd.DataFrame(json.loads(jsn_str), index=(str(x) for x in range(93))).fillna(method='ffill').fillna(0).sum(axis=1)\nprint(len(df.rolling(window=1).mean().fillna(0).unique()))\nprint(len(df.rolling(window=1).apply(np.mean, raw=False).fillna(0).unique()))\nprint(len(df.rolling(window=1).apply(np.mean, raw=True).fillna(0).unique()))\nprint(len(df.rolling(window=1).apply(pd.Series.mean, raw=False).fillna(0).unique()))",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport json\nimport sys\nprint(sys.version)\nprint(pd.__version__)\njsn_str = '{\"user_1\":{\"77\":4514.0,\"44\":7867.54,\"67\":10406.54,\"12\":7151.0,\"56\":1921.0,\"36\":9471.0,\"47\":2021.0,\"25\":3211.0,\"26\":2021.0,\"15\":4651.0,\"71\":8805.0,\"62\":352.0}}'\ndf = pd.DataFrame(json.loads(jsn_str), index=(str(x) for x in range(93))).fillna(method='ffill').fillna(0).sum(axis=1)\nprint(len(df.rolling(window=1).mean().fillna(0).unique()))\nprint(len(df.rolling(window=1).apply(np.mean, raw=False).fillna(0).unique()))\n<line_mask>\nprint(len(df.rolling(window=1).apply(pd.Series.mean, raw=False).fillna(0).unique()))",
            "masked_line": "print(len(df.rolling(window=1).apply(np.mean, raw=True).fillna(0).unique()))",
            "answer": "rolling",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_859"
        },
        {
            "dependency": "scipy",
            "version": "==0.19.1",
            "time": "2021-07-11",
            "description": "The code finds the nearest neighbors and distances between points in a given matrix A using a KDTree data structure from the scipy library.",
            "code": "from scipy.spatial import KDTree\n\nnonzeros = np.transpose(np.nonzero(A))\nt = KDTree(nonzeros)\ndists, nns = t.query(nonzeros, 2)\n\nfor (i, j), d in zip(nns, dists[:,1]):\n    print(nonzeros[i], \"is closest to\", nonzeros[j], \"with distance\", d)",
            "masked_code": "from scipy.spatial import KDTree\n\nnonzeros = np.transpose(np.nonzero(A))\nt = KDTree(nonzeros)\n<line_mask>\n\nfor (i, j), d in zip(nns, dists[:,1]):\n    print(nonzeros[i], \"is closest to\", nonzeros[j], \"with distance\", d)",
            "masked_line": "dists, nns = t.query(nonzeros, 2)",
            "answer": "query",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_860"
        },
        {
            "dependency": "dash",
            "version": "==1.20.0",
            "time": "2021-05-17",
            "description": "This code sets up a Dash web application with two buttons (\"Button A\" and \"Button B\") and a container. When the buttons are clicked, it displays the JSON representation of the callback context, which includes states, triggered elements, and inputs. If \"Button B\" is clicked more times than \"Button A\", the n_clicks values for both buttons are reset to 0.",
            "code": "import json\nimport dash\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\n\napp = dash.Dash(__name__)\n\napp.layout = html.Div(\n    [\n        html.Button(\"Button A\", id=\"btn-a\"),\n        html.Button(\"Button B\", id=\"btn-b\"),\n        html.Div(id=\"container\"),\n    ]\n)\n\n\n@app.callback(\n    Output(\"container\", \"children\"),\n    Output(\"btn-a\", \"n_clicks\"),\n    Output(\"btn-b\", \"n_clicks\"),\n    Input(\"btn-a\", \"n_clicks\"),\n    Input(\"btn-b\", \"n_clicks\"),\n    prevent_initial_call=True,\n)\ndef display(n_clicks_a, n_clicks_b):\n    ctx = dash.callback_context\n\n    ctx_msg = json.dumps(\n        {\"states\": ctx.states, \"triggered\": ctx.triggered, \"inputs\": ctx.inputs},\n        indent=2,\n    )\n\n    if n_clicks_a is not None and n_clicks_b is not None and n_clicks_b > n_clicks_a:\n        return html.Pre(ctx_msg), 0, 0\n\n    return html.Pre(ctx_msg), n_clicks_a, n_clicks_b\n\n\nif __name__ == \"__main__\":\n    app.run_server(debug=True)",
            "masked_code": "import json\nimport dash\nimport dash_html_components as html\nfrom dash.dependencies import Input, Output, State\n\napp = dash.Dash(__name__)\n\napp.layout = html.Div(\n    [\n        html.Button(\"Button A\", id=\"btn-a\"),\n        html.Button(\"Button B\", id=\"btn-b\"),\n        html.Div(id=\"container\"),\n    ]\n)\n\n\n<line_mask>\n    Output(\"container\", \"children\"),\n    Output(\"btn-a\", \"n_clicks\"),\n    Output(\"btn-b\", \"n_clicks\"),\n    Input(\"btn-a\", \"n_clicks\"),\n    Input(\"btn-b\", \"n_clicks\"),\n    prevent_initial_call=True,\n)\ndef display(n_clicks_a, n_clicks_b):\n    ctx = dash.callback_context\n\n    ctx_msg = json.dumps(\n        {\"states\": ctx.states, \"triggered\": ctx.triggered, \"inputs\": ctx.inputs},\n        indent=2,\n    )\n\n    if n_clicks_a is not None and n_clicks_b is not None and n_clicks_b > n_clicks_a:\n        return html.Pre(ctx_msg), 0, 0\n\n    return html.Pre(ctx_msg), n_clicks_a, n_clicks_b\n\n\nif __name__ == \"__main__\":\n    app.run_server(debug=True)",
            "masked_line": "@app.callback(",
            "answer": "callback",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_861"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-10",
            "description": "The code plots a scatter plot with x-axis values at positions [2, 15, 120] and y-axis values at [0, 0, 0]. The x-axis tick labels are formatted to have 4 digits, aligning the values to the left and filling empty spaces with nines. The title of the plot explains the formatting of the x-axis tick labels.",
            "code": "import matplotlib.pyplot as plt    # v 3.3.2\n\nx = [2, 15, 120]\ny = [0, 0, 0]\n\nfig, ax = plt.subplots(figsize=(8,4))\nax.scatter(x, y)\nax.set_xticks(x)\n\n# Format tick labels by aligning values to the left and filling space beyond\n# value precision with nines\nax.xaxis.set_major_formatter('{x:9<5.1f}')\n\ntitle = 'x-axis values are shown with 4 digits by using the x-axis major formatter'\nax.set_title(title, pad=10)\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt    # v 3.3.2\n\nx = [2, 15, 120]\ny = [0, 0, 0]\n\nfig, ax = plt.subplots(figsize=(8,4))\nax.scatter(x, y)\nax.set_xticks(x)\n\n# Format tick labels by aligning values to the left and filling space beyond\n# value precision with nines\n<line_mask>\n\ntitle = 'x-axis values are shown with 4 digits by using the x-axis major formatter'\nax.set_title(title, pad=10)\n\nplt.show()",
            "masked_line": "ax.xaxis.set_major_formatter('{x:9<5.1f}')",
            "answer": "xaxis",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_862"
        },
        {
            "dependency": "pytest",
            "version": "==3.10.1",
            "time": "2021-12-19",
            "description": "The function calculates the total pay for an employee based on their hourly rate and number of hours worked. It then deducts a 20% tax from the total pay to calculate the net pay. Finally, it returns a list containing the number of hours worked, hourly rate, total pay, tax amount, and net pay. The test function verifies the correctness of the calculations by comparing the results with expected values.",
            "code": "liste_paie = []\ndef calculer_paie_employe(tauxh,heures):\n    total = tauxh * heures\n    impot = total * 0.20\n    net = total - impot\n    liste_paie = [heures, tauxh, total, impot, net]\n    return liste_paie\n\nimport pytest\n\n@pytest.mark.parametrize(\n    \"var1,var2,expected_1,expected_2,expected_3\", [\n        (14.7, 25,   367.5,  73.5,   294),\n        (20,   15,   300,    60,     240),\n        (15.6, 23.9, 372.84, 75.568, 300)\n    ])\ndef test_calculer_paie_employe(var1,var2, expected_1, expected_2, expected_3):\n    liste_paie = calculer_paie_employe(var1,var2)\n    assert liste_paie[2] == expected_1 and liste_paie[3] == expected_2 and liste_paie[4] == expected_3",
            "masked_code": "liste_paie = []\ndef calculer_paie_employe(tauxh,heures):\n    total = tauxh * heures\n    impot = total * 0.20\n    net = total - impot\n    liste_paie = [heures, tauxh, total, impot, net]\n    return liste_paie\n\nimport pytest\n\n<line_mask>\n    \"var1,var2,expected_1,expected_2,expected_3\", [\n        (14.7, 25,   367.5,  73.5,   294),\n        (20,   15,   300,    60,     240),\n        (15.6, 23.9, 372.84, 75.568, 300)\n    ])\ndef test_calculer_paie_employe(var1,var2, expected_1, expected_2, expected_3):\n    liste_paie = calculer_paie_employe(var1,var2)\n    assert liste_paie[2] == expected_1 and liste_paie[3] == expected_2 and liste_paie[4] == expected_3",
            "masked_line": "@pytest.mark.parametrize(",
            "answer": "mark",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_863"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.5.0",
            "time": "2021-11-24",
            "description": "This code generates a heatmap plot of the function Z = 10*exp(-X**2 - Y**2) using numpy and matplotlib in Python. It also includes a colorbar with logarithmic scale and specific ticks.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as colors\n\nX, Y = np.mgrid[-3:3:100j, -2:2:100j]\nZ = 10*np.exp(-X**2 - Y**2)\n\nfig, ax = plt.subplots()\npcm = ax.pcolor(X, Y, Z, norm=colors.LogNorm(vmin=.1, vmax=10), cmap='jet')\nfig.colorbar(pcm, ax=ax)\n\ncb = fig.axes[-1]\nticks = [.1,.2,.5,1,2,5,10]\ncb.yaxis.set_ticks(ticks, labels=[f\"{t:g}\" for t in ticks])\ncb.minorticks_off()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as colors\n\nX, Y = np.mgrid[-3:3:100j, -2:2:100j]\nZ = 10*np.exp(-X**2 - Y**2)\n\nfig, ax = plt.subplots()\n<line_mask>\nfig.colorbar(pcm, ax=ax)\n\ncb = fig.axes[-1]\nticks = [.1,.2,.5,1,2,5,10]\ncb.yaxis.set_ticks(ticks, labels=[f\"{t:g}\" for t in ticks])\ncb.minorticks_off()",
            "masked_line": "pcm = ax.pcolor(X, Y, Z, norm=colors.LogNorm(vmin=.1, vmax=10), cmap='jet')",
            "answer": "LogNorm",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_864"
        },
        {
            "dependency": "tqdm",
            "version": "==4.66.1",
            "time": "2021-08-03",
            "description": "The code sends a series of show commands to a networking device specified by the variable 'device', using the ConnectHandler class. The output of each command is collected and stored, and a progress bar is displayed. Finally, the message \"Done!\" is printed to indicate the completion of the process.",
            "code": "rendered_template = [\"show ip interface brief\", \"show running-config\", \"show inventory\"]\n\nwith ConnectHandler(**device) as net_connect:\n    for command in tqdm(iterable=rendered_template, unit=\"command\", desc=\"show commands\"):\n        output = net_connect.send_command(command, cmd_verify=False, read_timeout=60)\nprint(\"Done!\")",
            "masked_code": "rendered_template = [\"show ip interface brief\", \"show running-config\", \"show inventory\"]\n\nwith ConnectHandler(**device) as net_connect:\n    <line_mask>\n        output = net_connect.send_command(command, cmd_verify=False, read_timeout=60)\nprint(\"Done!\")",
            "masked_line": "for command in tqdm(iterable=rendered_template, unit=\"command\", desc=\"show commands\"):",
            "answer": "tqdm",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_865"
        },
        {
            "dependency": "bokeh",
            "version": "==2.1.1",
            "time": "2021-07-22",
            "description": "This code creates a scatter plot with interactive tooltips using Bokeh library in Python. It generates a plot with random data points and customizes the tooltips to display at a specific location within the plot area. It hides the arrow in the tooltips and displays the plot with the customized tooltips.",
            "code": "from bokeh.models import CustomJS\nfrom bokeh.models import HoverTool\nfrom bokeh.plotting import show, figure\nimport numpy as np\n\np = figure(plot_width = 300, plot_height = 300, tooltips = [('value X', '@x'), ('value Y', '@y')])\ncircles = p.circle(x=np.random.rand(10)*10, y=np.random.rand(10)*10, size=10)\n\ncallback = CustomJS(args={'p': p}, code=\"\"\"\n    var tooltips = document.getElementsByClassName(\"bk-tooltip\");\n    const tw = 100;\n    for (var i = 0; i < tooltips.length; i++) {\n        tooltips[i].style.top = '5px'; \n        tooltips[i].style.left = p.width/2 - tw/2 + 'px'; \n        tooltips[i].style.width = tw + 'px'; \n    } \"\"\")\n\nhover = p.select_one(HoverTool)\nhover.renderers = [circles]\nhover.callback = callback\nhover.show_arrow = False\n\nshow(p)",
            "masked_code": "from bokeh.models import CustomJS\nfrom bokeh.models import HoverTool\nfrom bokeh.plotting import show, figure\nimport numpy as np\n\np = figure(plot_width = 300, plot_height = 300, tooltips = [('value X', '@x'), ('value Y', '@y')])\ncircles = p.circle(x=np.random.rand(10)*10, y=np.random.rand(10)*10, size=10)\n\ncallback = CustomJS(args={'p': p}, code=\"\"\"\n    var tooltips = document.getElementsByClassName(\"bk-tooltip\");\n    const tw = 100;\n    for (var i = 0; i < tooltips.length; i++) {\n        tooltips[i].style.top = '5px'; \n        tooltips[i].style.left = p.width/2 - tw/2 + 'px'; \n        tooltips[i].style.width = tw + 'px'; \n    } \"\"\")\n\n<line_mask>\nhover.renderers = [circles]\nhover.callback = callback\nhover.show_arrow = False\n\nshow(p)",
            "masked_line": "hover = p.select_one(HoverTool)",
            "answer": "select_one",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_866"
        },
        {
            "dependency": "bokeh",
            "version": "==2.1.1",
            "time": "2021-05-19",
            "description": "The code generates two separate plots, one showing the relationship between 'abspos' and 'val1', and the other showing the relationship between 'val1_q' and 'val1'. Additionally, it displays two data tables containing the values of 'abspos', 'val1', and 'val1_q'. The plots and data tables are displayed using the Bokeh library in a single output.",
            "code": "from bokeh.plotting import show, figure\nfrom bokeh.models import ColumnDataSource, Row, Column, CustomJS, DataTable, TableColumn\nimport numpy as np\nimport pandas as pd\n\ndf2 = pd.DataFrame(np.array([[1, 3.280, 3.3925], [2, 3.3012, 3.4303], [3, 3.5972, 3.8696]]),\n                   columns=['abspos', 'val1', 'val1_q'])\n\nsource = ColumnDataSource(data=df2)\n\np1 = figure(title=\"Plot1\",plot_width=900, plot_height=500, tools=\"tap,pan,box_zoom,wheel_zoom,save,reset\")\np1.circle('abspos', 'val1', source=source, line_color=None, color='blue', size=10)\n\np2 = figure(title=\"Plot2\",plot_width=900, plot_height=500, tools=\"tap,pan,box_zoom,wheel_zoom,save,reset\")\np2.circle('val1_q', 'val1', source=source, line_color=None, color='blue', size=10)\n\ncolumns = [\n        TableColumn(field=\"abspos\", title=\"abspos\"),\n        TableColumn(field=\"val1\", title=\"val1\"),\n        TableColumn(field=\"val1_q\", title=\"val1_q\")\n    ]\ndt1 = DataTable(source=source, columns=columns, width=900, height=300)\ndt2 = DataTable(source=source, columns=columns, width=900, height=300)\n\nshow(Column(Row(p1, p2), Row(dt1, dt2)))",
            "masked_code": "from bokeh.plotting import show, figure\nfrom bokeh.models import ColumnDataSource, Row, Column, CustomJS, DataTable, TableColumn\nimport numpy as np\nimport pandas as pd\n\ndf2 = pd.DataFrame(np.array([[1, 3.280, 3.3925], [2, 3.3012, 3.4303], [3, 3.5972, 3.8696]]),\n                   columns=['abspos', 'val1', 'val1_q'])\n\nsource = ColumnDataSource(data=df2)\n\np1 = figure(title=\"Plot1\",plot_width=900, plot_height=500, tools=\"tap,pan,box_zoom,wheel_zoom,save,reset\")\np1.circle('abspos', 'val1', source=source, line_color=None, color='blue', size=10)\n\np2 = figure(title=\"Plot2\",plot_width=900, plot_height=500, tools=\"tap,pan,box_zoom,wheel_zoom,save,reset\")\np2.circle('val1_q', 'val1', source=source, line_color=None, color='blue', size=10)\n\ncolumns = [\n        TableColumn(field=\"abspos\", title=\"abspos\"),\n        TableColumn(field=\"val1\", title=\"val1\"),\n        TableColumn(field=\"val1_q\", title=\"val1_q\")\n    ]\ndt1 = DataTable(source=source, columns=columns, width=900, height=300)\ndt2 = DataTable(source=source, columns=columns, width=900, height=300)\n\n<line_mask>",
            "masked_line": "show(Column(Row(p1, p2), Row(dt1, dt2)))",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_867"
        },
        {
            "dependency": "Flask",
            "version": "==1.1.1",
            "time": "2021-07-20",
            "description": "The code defines a Flask endpoint that streams data by yielding chunks of \"something\" 1000 times within a generator function. The endpoint uses a decorator and context for the generator function, and is set up to stream the generated data as a response.",
            "code": "from flask import stream_with_context\n\n@app.route(\"/streamed\")\n@mydecorator\ndef streamed_endpoint():\n    def mygenerator():\n       print(\"start generator\")\n       random_function_that_need_the_decorator_context()\n       for _ in range(1000):\n          yield \"something\"\n       print(\"end generator\")\n\n    return Response(stream_with_context(mygenerator()))",
            "masked_code": "from flask import stream_with_context\n\n@app.route(\"/streamed\")\n@mydecorator\ndef streamed_endpoint():\n    def mygenerator():\n       print(\"start generator\")\n       random_function_that_need_the_decorator_context()\n       for _ in range(1000):\n          yield \"something\"\n       print(\"end generator\")\n\n    <line_mask>",
            "masked_line": "return Response(stream_with_context(mygenerator()))",
            "answer": "stream_with_context",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_868"
        },
        {
            "dependency": "plotly",
            "version": "<5.5.0",
            "time": "2022-01-25",
            "description": "The code creates a Sankey diagram using Plotly library, showing flow between two nodes with equal value.",
            "code": "import plotly.graph_objects as go\nfig = go.Figure(go.Sankey(\n    node = {\"label\": [\"First node\", \"Last node\"],\n        \"x\": [0.6, 0.2],\n        \"y\": [0.2, 0.6]},\n    link = {\n        \"source\": [0, 1],\n        \"target\": [1, 0],\n        \"value\":  [1, 1]\n}))\nfig.show()",
            "masked_code": "import plotly.graph_objects as go\n<line_mask>\n    node = {\"label\": [\"First node\", \"Last node\"],\n        \"x\": [0.6, 0.2],\n        \"y\": [0.2, 0.6]},\n    link = {\n        \"source\": [0, 1],\n        \"target\": [1, 0],\n        \"value\":  [1, 1]\n}))\nfig.show()",
            "masked_line": "fig = go.Figure(go.Sankey(",
            "answer": "Sankey",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_869"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.5",
            "time": "2021-06-17",
            "description": "The code defines a convolutional neural network model, it uses VGG16 as a base model with ImageNet weights for feature extraction. It then adds layers like flatten, GRU, dense with relu activation, and dropout for regularization. Finally, it creates a decision network with softmax activation for classification.",
            "code": "import tensorflow as tf\n#from keras.layers import TimeDistributed, GRU, Dense, Dropout\nfrom tensorflow.keras.layers import Flatten, GRU, Dropout, TimeDistributed, Dense\n\ndef build_convnet():\n\n    prevModel = tf.keras.applications.vgg16.VGG16(\n        include_top=False,\n        input_shape=(112, 112, 3),\n        weights='imagenet'  # ImageNet weights\n    )\n\n    model = tf.keras.models.Sequential()\n\n    model.add(prevModel)\n    model.add(Flatten())\n\n    return model\n\ndef action_model(shape=(5, 112, 112, 3), nbout=3):\n  # Create our convnet with (112, 112, 3) input shape\n  convnet = build_convnet()\n\n  # then create our final model\n  model = tf.keras.models.Sequential()\n  # add the convnet with (5, 112, 112, 3) shape\n  model.add(TimeDistributed(convnet, input_shape=shape))\n  # here, you can also use GRU or LSTM\n  model.add(GRU(64))\n  # and finally, we make a decision network\n  model.add(Dense(1024, activation='relu'))\n  model.add(Dropout(.5))\n  model.add(Dense(512, activation='relu'))\n  model.add(Dropout(.5))\n  model.add(Dense(128, activation='relu'))\n  model.add(Dropout(.5))\n  model.add(Dense(64, activation='relu'))\n  model.add(Dense(nbout, activation='softmax'))\n  return model\n\nmod=action_model()\nmod.summary()",
            "masked_code": "import tensorflow as tf\n#from keras.layers import TimeDistributed, GRU, Dense, Dropout\nfrom tensorflow.keras.layers import Flatten, GRU, Dropout, TimeDistributed, Dense\n\ndef build_convnet():\n\n    prevModel = tf.keras.applications.vgg16.VGG16(\n        include_top=False,\n        input_shape=(112, 112, 3),\n        weights='imagenet'  # ImageNet weights\n    )\n\n    model = tf.keras.models.Sequential()\n\n    model.add(prevModel)\n    model.add(Flatten())\n\n    return model\n\ndef action_model(shape=(5, 112, 112, 3), nbout=3):\n  # Create our convnet with (112, 112, 3) input shape\n  convnet = build_convnet()\n\n  # then create our final model\n  model = tf.keras.models.Sequential()\n  # add the convnet with (5, 112, 112, 3) shape\n  <line_mask>\n  # here, you can also use GRU or LSTM\n  model.add(GRU(64))\n  # and finally, we make a decision network\n  model.add(Dense(1024, activation='relu'))\n  model.add(Dropout(.5))\n  model.add(Dense(512, activation='relu'))\n  model.add(Dropout(.5))\n  model.add(Dense(128, activation='relu'))\n  model.add(Dropout(.5))\n  model.add(Dense(64, activation='relu'))\n  model.add(Dense(nbout, activation='softmax'))\n  return model\n\nmod=action_model()\nmod.summary()",
            "masked_line": "model.add(TimeDistributed(convnet, input_shape=shape))",
            "answer": "TimeDistributed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_870"
        },
        {
            "dependency": "pyarrow",
            "version": "==2.0.0",
            "time": "2021-02-23",
            "description": "Read a zipped shapefile from an HDFS directory, extract the shapefile, create a GeoDataFrame from the shapefile, and print the shape of the GeoDataFrame.",
            "code": "# import packages\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\nimport pyarrow\n\n# establish a connection to HDFS\nfs = pyarrow.hdfs.connect()\n\n# read zipped shapefile\nwith fiona.io.ZipMemoryFile(fs.open('hdfs://my_hdfs_directory/my_zipped_shapefile.zip')) as z:\n    with z.open('my_shp_file_within_zip.shp') as collection:\n        gdf = gpd.GeoDataFrame.from_features(collection)\n        print(gdf.shape)",
            "masked_code": "# import packages\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\nimport pyarrow\n\n# establish a connection to HDFS\nfs = pyarrow.hdfs.connect()\n\n# read zipped shapefile\n<line_mask>\n    with z.open('my_shp_file_within_zip.shp') as collection:\n        gdf = gpd.GeoDataFrame.from_features(collection)\n        print(gdf.shape)",
            "masked_line": "with fiona.io.ZipMemoryFile(fs.open('hdfs://my_hdfs_directory/my_zipped_shapefile.zip')) as z:",
            "answer": "open",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_871"
        },
        {
            "dependency": "fiona",
            "version": "==1.8.18",
            "time": "2021-02-23",
            "description": "This code reads a zipped shapefile from a specified HDFS directory, extracts the shapefile within the zip file, converts it to a GeoDataFrame, and then prints the shape of the GeoDataFrame.",
            "code": "# import packages\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\nimport pyarrow\n\n# establish a connection to HDFS\nfs = pyarrow.hdfs.connect()\n\n# read zipped shapefile\nwith fiona.io.ZipMemoryFile(fs.open('hdfs://my_hdfs_directory/my_zipped_shapefile.zip')) as z:\n    with z.open('my_shp_file_within_zip.shp') as collection:\n        gdf = gpd.GeoDataFrame.from_features(collection)\n        print(gdf.shape)",
            "masked_code": "# import packages\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\nimport pyarrow\n\n# establish a connection to HDFS\nfs = pyarrow.hdfs.connect()\n\n# read zipped shapefile\n<line_mask>\n    with z.open('my_shp_file_within_zip.shp') as collection:\n        gdf = gpd.GeoDataFrame.from_features(collection)\n        print(gdf.shape)",
            "masked_line": "with fiona.io.ZipMemoryFile(fs.open('hdfs://my_hdfs_directory/my_zipped_shapefile.zip')) as z:",
            "answer": "io",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_872"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.4",
            "time": "2021-02-03",
            "description": "The code generates a bar plot comparing the probability of an event S and the conditional probability of event S given event X for different values of event S. The plot is displayed using matplotlib.",
            "code": "from matplotlib import pyplot as plt\nimport pandas as pd\n\n\nif __name__ == '__main__':\n    s = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    p_s = [0.05, 0.15, 0.20, 0.30, 0.20, 0.10]\n    p_s_x = [0.06005163309361129, 0.4378503494734475,0.3489460783665687,0.1404287057633398,0.012362455732360653,0.00036077757067209113]\n    \n    df_to_plot = pd.DataFrame(data={\"P(S)\": p_s,\n                                    \"P(S|X)\": p_s_x,\n                                    \"S\": s})\n    \n    df_to_plot.plot.bar(y=['P(S)', 'P(S|X)'],\n                    x='S',\n                    alpha=0.7,\n                    color=['red', 'green'],\n                    figsize=(8,5))\n    plt.show()",
            "masked_code": "from matplotlib import pyplot as plt\nimport pandas as pd\n\n\nif __name__ == '__main__':\n    s = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    p_s = [0.05, 0.15, 0.20, 0.30, 0.20, 0.10]\n    p_s_x = [0.06005163309361129, 0.4378503494734475,0.3489460783665687,0.1404287057633398,0.012362455732360653,0.00036077757067209113]\n    \n    df_to_plot = pd.DataFrame(data={\"P(S)\": p_s,\n                                    \"P(S|X)\": p_s_x,\n                                    \"S\": s})\n    \n    df_to_plot.plot.bar(y=['P(S)', 'P(S|X)'],\n                    x='S',\n                    alpha=0.7,\n                    color=['red', 'green'],\n                    figsize=(8,5))\n    <line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_873"
        },
        {
            "dependency": "h5py",
            "version": "==2.10.0",
            "time": "2021-01-13",
            "description": "This code generates multiple HDF5 files, each containing a dataset with random values, and attributes associated with the dataset. It also creates external links in another HDF5 file to the datasets in the previously created files. Finally, it reads and prints out the attributes of the datasets and links.",
            "code": "import h5py\nimport numpy as np\n\nfor fcnt in range(1,4,1):\n    fname = 'file' + str(fcnt) + '.h5'\n    arr = np.random.random(50).reshape(10,5)\n    with h5py.File(fname,'w') as h5fw :\n        h5fw.create_dataset('data_'+str(fcnt),data=arr)\n        h5fw['data_'+str(fcnt)].attrs['ds_attr']='attribute '+str(fcnt)\n     \nwith h5py.File('SO_65705770.h5',mode='w') as h5fw:\n    for fcnt in range(1,4,1):    \n        h5name = 'file' + str(fcnt) + '.h5'\n        link_obj = h5py.ExternalLink(h5name,'/')\n        h5fw['link'+str(fcnt)] = h5py.ExternalLink(h5name,'/')\n        h5fw['link'+str(fcnt)].attrs['link_attr']='attr '+str(fcnt)\n\nfor fcnt in range(1,4,1):\n    fname = 'file' + str(fcnt) + '.h5'\n    print (fname)\n    with h5py.File(fname,'r') as h5fr :\n        print( h5fr['data_'+str(fcnt)].attrs['ds_attr'] )\n\nwith h5py.File('SO_65705770.h5',mode='r') as h5fr:\n    for fcnt in range(1,4,1):    \n        print ('file',fcnt,\":\")\n        print('link attr:', h5fr['link'+str(fcnt)].attrs['link_attr'] )\n        print('linked ds attr:', h5fr['link'+str(fcnt)]['data_'+str(fcnt)].attrs['ds_attr'] )",
            "masked_code": "import h5py\nimport numpy as np\n\nfor fcnt in range(1,4,1):\n    fname = 'file' + str(fcnt) + '.h5'\n    arr = np.random.random(50).reshape(10,5)\n    with h5py.File(fname,'w') as h5fw :\n        <line_mask>\n        h5fw['data_'+str(fcnt)].attrs['ds_attr']='attribute '+str(fcnt)\n     \nwith h5py.File('SO_65705770.h5',mode='w') as h5fw:\n    for fcnt in range(1,4,1):    \n        h5name = 'file' + str(fcnt) + '.h5'\n        link_obj = h5py.ExternalLink(h5name,'/')\n        h5fw['link'+str(fcnt)] = h5py.ExternalLink(h5name,'/')\n        h5fw['link'+str(fcnt)].attrs['link_attr']='attr '+str(fcnt)\n\nfor fcnt in range(1,4,1):\n    fname = 'file' + str(fcnt) + '.h5'\n    print (fname)\n    with h5py.File(fname,'r') as h5fr :\n        print( h5fr['data_'+str(fcnt)].attrs['ds_attr'] )\n\nwith h5py.File('SO_65705770.h5',mode='r') as h5fr:\n    for fcnt in range(1,4,1):    \n        print ('file',fcnt,\":\")\n        print('link attr:', h5fr['link'+str(fcnt)].attrs['link_attr'] )\n        print('linked ds attr:', h5fr['link'+str(fcnt)]['data_'+str(fcnt)].attrs['ds_attr'] )",
            "masked_line": "h5fw.create_dataset('data_'+str(fcnt),data=arr)",
            "answer": "create_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_874"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.24.1",
            "time": "2021-11-06",
            "description": "The code fetches the Olivetti Faces dataset and splits it into training and testing sets for machine learning analysis.",
            "code": "from sklearn.datasets import fetch_olivetti_faces\n\ndata = fetch_olivetti_faces()\nXtrain, Xtest, Ytrain, Ytest = train_test_split(data.data, data.target, test_size=0.3, random_state=0)",
            "masked_code": "<line_mask>\n\ndata = fetch_olivetti_faces()\nXtrain, Xtest, Ytrain, Ytest = train_test_split(data.data, data.target, test_size=0.3, random_state=0)",
            "masked_line": "from sklearn.datasets import fetch_olivetti_faces",
            "answer": "fetch_olivetti_faces",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_875"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4",
            "time": "2021-03-24",
            "description": "This code defines a TensorFlow function that uses a GradientTape to calculate gradients for the trainable weights of a TensorFlow model named \"encode\" using some input data. Then, it prints the output of the model for the input data.",
            "code": "import numpy as np\n\ndata = np.zeros((1, 4))\n\n@tf.function\ndef run():\n    with tf.GradientTape( watch_accessed_variables=False) as tape:\n        tape.watch(encode.trainable_weights)\n        y = encode([data, data, data], training=True)\n    tf.print(y)\n\nrun()\n\n# [[-0.799545228]]",
            "masked_code": "import numpy as np\n\ndata = np.zeros((1, 4))\n\n@tf.function\ndef run():\n    with tf.GradientTape( watch_accessed_variables=False) as tape:\n        tape.watch(encode.trainable_weights)\n        y = encode([data, data, data], training=True)\n    <line_mask>\n\nrun()\n\n# [[-0.799545228]]",
            "masked_line": "tf.print(y)",
            "answer": "print",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_876"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4.1",
            "time": "2021-02-28",
            "description": "This code uses TensorFlow Probability to perform Hamiltonian Monte Carlo sampling to infer the parameters of a Bayesian model. The model consists of a mixture distribution with a categorical variable determining the component, and it is applied to a dataset generated from a normal distribution. The code initializes the model parameters, sets up the Hamiltonian Monte Carlo kernel with adaptation, and performs sampling to estimate the posterior distribution of the model parameters. The final output includes histograms of the sampled parameter values and prints the mean values of these parameters.",
            "code": "import os\nos.environ['CUDA_VISIBLE_DEVICES'] = '-1'\nimport tensorflow as tf\nimport tensorflow_probability as tfp\nimport matplotlib.pyplot as plt\ntfd = tfp.distributions\ntfb = tfp.bijectors\n\nimport numpy as np\nfrom time import time\n\nnumdata = 10000\ndata = np.random.normal(0.0,1.0,numdata).astype(np.float32)\ndata[int(numdata/2):] = 0.0\n_=plt.hist(data,30,density=True)\n\nroot = tfd.JointDistributionCoroutine.Root\ndef dist_fn(rv_p,rv_mu):\n    rv_cat = tfd.Categorical(probs=tf.stack([rv_p, 1.-rv_p],-1))\n    rv_norm  = tfd.Normal(rv_mu,1.0)\n    rv_zero =  tfd.Deterministic(tf.zeros_like(rv_mu))\n    \n    rv_mix = tfd.Independent(\n                tfd.Mixture(cat=rv_cat,\n                            components=[rv_norm,rv_zero]),\n                reinterpreted_batch_ndims=1)\n    return rv_mix\n\n\ndef model_fn():\n    rv_p    = yield root(tfd.Sample(tfd.Uniform(0.0,1.0),1))\n    rv_mu   = yield root(tfd.Sample(tfd.Uniform(-1.,1. ),1))\n    \n    rv_mix  = yield dist_fn(rv_p,rv_mu)\n    \njd = tfd.JointDistributionCoroutine(model_fn)\nunnormalized_posterior_log_prob = lambda *args: jd.log_prob(args + (data,))\n\nn_chains = 1\n\np_init = [0.3]\np_init = tf.cast(p_init,dtype=tf.float32)\n\nmu_init = 0.1\nmu_init = tf.stack([mu_init]*n_chains,axis=0)\n\ninitial_chain_state = [\n    p_init,\n    mu_init,\n]\n\nbijectors = [\n    tfb.Sigmoid(),  # p\n    tfb.Identity(),  # mu\n]\n\nstep_size = 0.01\n\nnum_results = 50000\nnum_burnin_steps = 50000\n\n\nkernel=tfp.mcmc.TransformedTransitionKernel(\n    inner_kernel=tfp.mcmc.HamiltonianMonteCarlo(\n    target_log_prob_fn=unnormalized_posterior_log_prob,\n    num_leapfrog_steps=2,\n    step_size=step_size,\n    state_gradients_are_stopped=True),\n    bijector=bijectors)\n\nkernel = tfp.mcmc.SimpleStepSizeAdaptation(\n    inner_kernel=kernel, num_adaptation_steps=int(num_burnin_steps * 0.8))\n\n#XLA optim\n@tf.function(autograph=False, experimental_compile=True)\ndef graph_sample_chain(*args, **kwargs):\n  return tfp.mcmc.sample_chain(*args, **kwargs)\n\n\nst = time()\ntrace,stats = graph_sample_chain(\n      num_results=num_results,\n      num_burnin_steps=num_burnin_steps,\n      current_state=initial_chain_state,\n      kernel=kernel)\net = time()\nprint(et-st)\n\n\nptrace, mutrace = trace\nplt.subplot(121)\n_=plt.hist(ptrace.numpy(),100,density=True)\nplt.subplot(122)\n_=plt.hist(mutrace.numpy(),100,density=True)\nprint(np.mean(ptrace),np.mean(mutrace))",
            "masked_code": "import os\nos.environ['CUDA_VISIBLE_DEVICES'] = '-1'\nimport tensorflow as tf\nimport tensorflow_probability as tfp\nimport matplotlib.pyplot as plt\ntfd = tfp.distributions\ntfb = tfp.bijectors\n\nimport numpy as np\nfrom time import time\n\nnumdata = 10000\ndata = np.random.normal(0.0,1.0,numdata).astype(np.float32)\ndata[int(numdata/2):] = 0.0\n_=plt.hist(data,30,density=True)\n\nroot = tfd.JointDistributionCoroutine.Root\ndef dist_fn(rv_p,rv_mu):\n    rv_cat = tfd.Categorical(probs=tf.stack([rv_p, 1.-rv_p],-1))\n    rv_norm  = tfd.Normal(rv_mu,1.0)\n    rv_zero =  tfd.Deterministic(tf.zeros_like(rv_mu))\n    \n    rv_mix = tfd.Independent(\n                tfd.Mixture(cat=rv_cat,\n                            components=[rv_norm,rv_zero]),\n                reinterpreted_batch_ndims=1)\n    return rv_mix\n\n\ndef model_fn():\n    rv_p    = yield root(tfd.Sample(tfd.Uniform(0.0,1.0),1))\n    rv_mu   = yield root(tfd.Sample(tfd.Uniform(-1.,1. ),1))\n    \n    rv_mix  = yield dist_fn(rv_p,rv_mu)\n    \njd = tfd.JointDistributionCoroutine(model_fn)\nunnormalized_posterior_log_prob = lambda *args: jd.log_prob(args + (data,))\n\nn_chains = 1\n\np_init = [0.3]\np_init = tf.cast(p_init,dtype=tf.float32)\n\nmu_init = 0.1\nmu_init = tf.stack([mu_init]*n_chains,axis=0)\n\ninitial_chain_state = [\n    p_init,\n    mu_init,\n]\n\nbijectors = [\n    tfb.Sigmoid(),  # p\n    tfb.Identity(),  # mu\n]\n\nstep_size = 0.01\n\nnum_results = 50000\nnum_burnin_steps = 50000\n\n\nkernel=tfp.mcmc.TransformedTransitionKernel(\n    <line_mask>\n    target_log_prob_fn=unnormalized_posterior_log_prob,\n    num_leapfrog_steps=2,\n    step_size=step_size,\n    state_gradients_are_stopped=True),\n    bijector=bijectors)\n\nkernel = tfp.mcmc.SimpleStepSizeAdaptation(\n    inner_kernel=kernel, num_adaptation_steps=int(num_burnin_steps * 0.8))\n\n#XLA optim\n@tf.function(autograph=False, experimental_compile=True)\ndef graph_sample_chain(*args, **kwargs):\n  return tfp.mcmc.sample_chain(*args, **kwargs)\n\n\nst = time()\ntrace,stats = graph_sample_chain(\n      num_results=num_results,\n      num_burnin_steps=num_burnin_steps,\n      current_state=initial_chain_state,\n      kernel=kernel)\net = time()\nprint(et-st)\n\n\nptrace, mutrace = trace\nplt.subplot(121)\n_=plt.hist(ptrace.numpy(),100,density=True)\nplt.subplot(122)\n_=plt.hist(mutrace.numpy(),100,density=True)\nprint(np.mean(ptrace),np.mean(mutrace))",
            "masked_line": "inner_kernel=tfp.mcmc.HamiltonianMonteCarlo(",
            "answer": "HamiltonianMonteCarlo",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_877"
        },
        {
            "dependency": "tensorflow-probability",
            "version": "==0.12.1",
            "time": "2021-02-28",
            "description": "The code implements a Bayesian inference using Hamiltonian Monte Carlo (HMC) to sample from a joint distribution. Specifically, it models a mixture distribution of a categorical and normal distribution. It uses TensorFlow Probability (tfp) to define the joint distribution coroutine, set up the initial chain state, specify bijectors for the variables, configure the HMC kernel with adapted step size, and perform sampling using the TransformedTransitionKernel with SimpleStepSizeAdaptation. Finally, it generates posterior samples for the parameters (p and mu) and plots histograms of the samples.",
            "code": "import os\nos.environ['CUDA_VISIBLE_DEVICES'] = '-1'\nimport tensorflow as tf\nimport tensorflow_probability as tfp\nimport matplotlib.pyplot as plt\ntfd = tfp.distributions\ntfb = tfp.bijectors\n\nimport numpy as np\nfrom time import time\n\nnumdata = 10000\ndata = np.random.normal(0.0,1.0,numdata).astype(np.float32)\ndata[int(numdata/2):] = 0.0\n_=plt.hist(data,30,density=True)\n\nroot = tfd.JointDistributionCoroutine.Root\ndef dist_fn(rv_p,rv_mu):\n    rv_cat = tfd.Categorical(probs=tf.stack([rv_p, 1.-rv_p],-1))\n    rv_norm  = tfd.Normal(rv_mu,1.0)\n    rv_zero =  tfd.Deterministic(tf.zeros_like(rv_mu))\n    \n    rv_mix = tfd.Independent(\n                tfd.Mixture(cat=rv_cat,\n                            components=[rv_norm,rv_zero]),\n                reinterpreted_batch_ndims=1)\n    return rv_mix\n\n\ndef model_fn():\n    rv_p    = yield root(tfd.Sample(tfd.Uniform(0.0,1.0),1))\n    rv_mu   = yield root(tfd.Sample(tfd.Uniform(-1.,1. ),1))\n    \n    rv_mix  = yield dist_fn(rv_p,rv_mu)\n    \njd = tfd.JointDistributionCoroutine(model_fn)\nunnormalized_posterior_log_prob = lambda *args: jd.log_prob(args + (data,))\n\nn_chains = 1\n\np_init = [0.3]\np_init = tf.cast(p_init,dtype=tf.float32)\n\nmu_init = 0.1\nmu_init = tf.stack([mu_init]*n_chains,axis=0)\n\ninitial_chain_state = [\n    p_init,\n    mu_init,\n]\n\nbijectors = [\n    tfb.Sigmoid(),  # p\n    tfb.Identity(),  # mu\n]\n\nstep_size = 0.01\n\nnum_results = 50000\nnum_burnin_steps = 50000\n\n\nkernel=tfp.mcmc.TransformedTransitionKernel(\n    inner_kernel=tfp.mcmc.HamiltonianMonteCarlo(\n    target_log_prob_fn=unnormalized_posterior_log_prob,\n    num_leapfrog_steps=2,\n    step_size=step_size,\n    state_gradients_are_stopped=True),\n    bijector=bijectors)\n\nkernel = tfp.mcmc.SimpleStepSizeAdaptation(\n    inner_kernel=kernel, num_adaptation_steps=int(num_burnin_steps * 0.8))\n\n#XLA optim\n@tf.function(autograph=False, experimental_compile=True)\ndef graph_sample_chain(*args, **kwargs):\n  return tfp.mcmc.sample_chain(*args, **kwargs)\n\n\nst = time()\ntrace,stats = graph_sample_chain(\n      num_results=num_results,\n      num_burnin_steps=num_burnin_steps,\n      current_state=initial_chain_state,\n      kernel=kernel)\net = time()\nprint(et-st)\n\n\nptrace, mutrace = trace\nplt.subplot(121)\n_=plt.hist(ptrace.numpy(),100,density=True)\nplt.subplot(122)\n_=plt.hist(mutrace.numpy(),100,density=True)\nprint(np.mean(ptrace),np.mean(mutrace))",
            "masked_code": "import os\nos.environ['CUDA_VISIBLE_DEVICES'] = '-1'\nimport tensorflow as tf\nimport tensorflow_probability as tfp\nimport matplotlib.pyplot as plt\ntfd = tfp.distributions\ntfb = tfp.bijectors\n\nimport numpy as np\nfrom time import time\n\nnumdata = 10000\ndata = np.random.normal(0.0,1.0,numdata).astype(np.float32)\ndata[int(numdata/2):] = 0.0\n_=plt.hist(data,30,density=True)\n\nroot = tfd.JointDistributionCoroutine.Root\ndef dist_fn(rv_p,rv_mu):\n    rv_cat = tfd.Categorical(probs=tf.stack([rv_p, 1.-rv_p],-1))\n    rv_norm  = tfd.Normal(rv_mu,1.0)\n    rv_zero =  tfd.Deterministic(tf.zeros_like(rv_mu))\n    \n    rv_mix = tfd.Independent(\n                tfd.Mixture(cat=rv_cat,\n                            components=[rv_norm,rv_zero]),\n                reinterpreted_batch_ndims=1)\n    return rv_mix\n\n\ndef model_fn():\n    rv_p    = yield root(tfd.Sample(tfd.Uniform(0.0,1.0),1))\n    rv_mu   = yield root(tfd.Sample(tfd.Uniform(-1.,1. ),1))\n    \n    rv_mix  = yield dist_fn(rv_p,rv_mu)\n    \njd = tfd.JointDistributionCoroutine(model_fn)\nunnormalized_posterior_log_prob = lambda *args: jd.log_prob(args + (data,))\n\nn_chains = 1\n\np_init = [0.3]\np_init = tf.cast(p_init,dtype=tf.float32)\n\nmu_init = 0.1\nmu_init = tf.stack([mu_init]*n_chains,axis=0)\n\ninitial_chain_state = [\n    p_init,\n    mu_init,\n]\n\nbijectors = [\n    tfb.Sigmoid(),  # p\n    tfb.Identity(),  # mu\n]\n\nstep_size = 0.01\n\nnum_results = 50000\nnum_burnin_steps = 50000\n\n\nkernel=tfp.mcmc.TransformedTransitionKernel(\n    <line_mask>\n    target_log_prob_fn=unnormalized_posterior_log_prob,\n    num_leapfrog_steps=2,\n    step_size=step_size,\n    state_gradients_are_stopped=True),\n    bijector=bijectors)\n\nkernel = tfp.mcmc.SimpleStepSizeAdaptation(\n    inner_kernel=kernel, num_adaptation_steps=int(num_burnin_steps * 0.8))\n\n#XLA optim\n@tf.function(autograph=False, experimental_compile=True)\ndef graph_sample_chain(*args, **kwargs):\n  return tfp.mcmc.sample_chain(*args, **kwargs)\n\n\nst = time()\ntrace,stats = graph_sample_chain(\n      num_results=num_results,\n      num_burnin_steps=num_burnin_steps,\n      current_state=initial_chain_state,\n      kernel=kernel)\net = time()\nprint(et-st)\n\n\nptrace, mutrace = trace\nplt.subplot(121)\n_=plt.hist(ptrace.numpy(),100,density=True)\nplt.subplot(122)\n_=plt.hist(mutrace.numpy(),100,density=True)\nprint(np.mean(ptrace),np.mean(mutrace))",
            "masked_line": "inner_kernel=tfp.mcmc.HamiltonianMonteCarlo(",
            "answer": "HamiltonianMonteCarlo",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_878"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-26",
            "description": "This code reads a dataset from a CSV file, converts the 'date' column to datetime format, creates a bar plot with 'date' on the x-axis and 'tickqty' on the y-axis, formats the x-axis to display time in hours and minutes, and displays the plot.",
            "code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\ndataset = pd.read_csv('data.csv')\ndataset['date'] = pd.to_datetime(dataset['date'])\nplt.bar(dataset['date'], dataset['tickqty'], width=0.002)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.show()",
            "masked_code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\n<line_mask>\ndataset['date'] = pd.to_datetime(dataset['date'])\nplt.bar(dataset['date'], dataset['tickqty'], width=0.002)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.show()",
            "masked_line": "dataset = pd.read_csv('data.csv')",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_879"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-26",
            "description": "The code reads a dataset from a CSV file, converts the 'date' column to datetime format, and then plots a bar chart showing the 'tickqty' values against the 'date' values. The x-axis of the plot is formatted to display hours and minutes. Finally, the plot is displayed.",
            "code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\ndataset = pd.read_csv('data.csv')\ndataset['date'] = pd.to_datetime(dataset['date'])\nplt.bar(dataset['date'], dataset['tickqty'], width=0.002)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.show()",
            "masked_code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\ndataset = pd.read_csv('data.csv')\ndataset['date'] = pd.to_datetime(dataset['date'])\n<line_mask>\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.show()",
            "masked_line": "plt.bar(dataset['date'], dataset['tickqty'], width=0.002)",
            "answer": "bar",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_880"
        },
        {
            "dependency": "requests",
            "version": "==2.26.0",
            "time": "2021-12-13",
            "description": "The code sends a GET request to the specified URL 'https://www.overstock.com/api/product.json?prod_id=10897789', using the provided headers, and retrieves the JSON response from the server. Finally, it prints the JSON data to the console.",
            "code": "import requests\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15',\n    'Accept': 'application/json',\n    'Connection': 'keep-alive',\n    'Accept-Encoding': 'gzip, deflate, br'\n}\n\n\nwith requests.Session() as session:\n    (r := session.get('https://www.overstock.com/api/product.json?prod_id=10897789', headers=headers)).raise_for_status()\n    print(r.json())",
            "masked_code": "import requests\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15',\n    'Accept': 'application/json',\n    'Connection': 'keep-alive',\n    'Accept-Encoding': 'gzip, deflate, br'\n}\n\n\n<line_mask>\n    (r := session.get('https://www.overstock.com/api/product.json?prod_id=10897789', headers=headers)).raise_for_status()\n    print(r.json())",
            "masked_line": "with requests.Session() as session:",
            "answer": "Session",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_881"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.0.1",
            "time": "2021-07-06",
            "description": "This code reads data from three separate files ('fx.dat', 'fy.dat', 'fz.dat') and stores them in arrays Fx, Fy, and Fz respectively. It then takes the first N elements from each array, where N is set to 10.",
            "code": "from mpl_toolkits.mplot3d import axes3d\nimport matplotlib.pyplot as plt\nimport numpy as np\nfig = plt.figure()\nax = fig.gca(projection='3d')\n\nfx = np.genfromtxt('fx.dat')\nfy = np.genfromtxt('fy.dat')\nfz = np.genfromtxt('fz.dat')\n\nN = 10\nFx = fx[:N]\nFy = fy[:N]\nFz = fz[:N]",
            "masked_code": "from mpl_toolkits.mplot3d import axes3d\nimport matplotlib.pyplot as plt\nimport numpy as np\nfig = plt.figure()\n<line_mask>\n\nfx = np.genfromtxt('fx.dat')\nfy = np.genfromtxt('fy.dat')\nfz = np.genfromtxt('fz.dat')\n\nN = 10\nFx = fx[:N]\nFy = fy[:N]\nFz = fz[:N]",
            "masked_line": "ax = fig.gca(projection='3d')",
            "answer": "gca",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_882"
        },
        {
            "dependency": "beautifulsoup4",
            "version": ">=4.7.0",
            "time": "2021-05-27",
            "description": "The code scrapes the Pastebin website's archive page and extracts the titles and IDs of the pastes listed on the page. It sets a custom User-Agent header for the requests and uses BeautifulSoup to parse the HTML content of the page. It then loops through the selected elements to extract the title and ID of each paste and prints them out.",
            "code": "import requests\nfrom bs4 import BeautifulSoup\n\nlink = 'https://pastebin.com/archive'\n\nwith requests.Session() as s:\n    s.headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36'\n    res = s.get(link)\n    soup = BeautifulSoup(res.text,\"lxml\")\n    for item in soup.select(\"table.maintable tr:has(> td > a[href]) > td:nth-of-type(1) > a\"):\n        title = item.text\n        _id = item.get(\"href\").lstrip(\"/\")\n        print(title,\" -> \",_id)",
            "masked_code": "import requests\nfrom bs4 import BeautifulSoup\n\nlink = 'https://pastebin.com/archive'\n\nwith requests.Session() as s:\n    s.headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36'\n    res = s.get(link)\n    soup = BeautifulSoup(res.text,\"lxml\")\n    <line_mask>\n        title = item.text\n        _id = item.get(\"href\").lstrip(\"/\")\n        print(title,\" -> \",_id)",
            "masked_line": "for item in soup.select(\"table.maintable tr:has(> td > a[href]) > td:nth-of-type(1) > a\"):",
            "answer": "select",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_883"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.4",
            "time": "2021-05-11",
            "description": "The code is performing text classification using a Naive Bayes model with CountVectorizer as the feature extraction method. It preprocesses the data, splits it into training and testing sets, trains the model, makes predictions, calculates accuracy, and visualizes the feature importance.",
            "code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.naive_bayes import MultinomialNB\n\n# Added\nfrom sklearn.compose import make_column_transformer\n\n# Create some test data to mimic OP's example\n\nbad_sentences = [\"I hated this restauraunt!\", \"I do not like Stack Overflow\", \"I am sad about the economy\", \n                 \"I do not feel good about the new Python update\", \"I think I am allergic to hazelnut!\", \"I will never eat here\",\n                 \"I am never coming back!\", \"I feel really sad after hearing the news\", \"George is getting upset!\", \"Python!\"]\ngood_sentences = [\"I really liked this place\", \"Stack Overflow is a great resource\", \"I am glad we are getting vaccinated\",\n                  \"I love anime\", \"I miss you too!\", \"I am upset we don't hang out more, I love it!\", \n                  \"Why are we feeling sad? Be happy!\", \"Hi, my name is wundermahn, what is your name?\", \"Lol!\", \n                  \"I am the master of my domain\"]\n\n# Create things a bit more verbosely so OP understands what we are doing\n\nsentences = bad_sentences+good_sentences\n\na_bad = [1 for i in range(len(bad_sentences))]\na_good = [0 for i in range(len(good_sentences))]\na = a_bad+a_good\n\nb_bad = [1 for i in range(len(bad_sentences))]\nb_good = [0 for i in range(len(good_sentences))]\nb = b_bad+b_good\n\nc_bad = [1 for i in range(len(bad_sentences))]\nc_good = [0 for i in range(len(good_sentences))]\nc = c_bad+c_good\n\nlabel_bad = [1 for i in range(len(bad_sentences))]\nlabel_good = [0 for i in range(len(good_sentences))]\nlabel = label_bad+label_good\n\n# Create dataframe\ndf = pd.DataFrame({'Text': sentences, 'A': a, 'B': b, 'C': c, 'label': label})\n\n# NEVER mix your validation and testing data!\n# https://stackoverflow.com/questions/28556942/pandas-remove-rows-at-random-without-shuffling-dataset\n\nnp.random.seed(38)\nremove_n = 2\ndrop_indices = np.random.choice(df.index, remove_n, replace=False)\nvalid_df = df.iloc[drop_indices]\nremaining_df = df.drop(drop_indices)\n\nX_train, X_test, y_train, y_test = train_test_split(remaining_df[[col for col in remaining_df.columns if col != 'label']],\n                                                    remaining_df['label'], test_size=0.2, random_state=38)\n\n# Get CountVectorizer working as an example, you can add tfidf later on\n\n# Now, create your pipeline which should include your vectorizer, as well as your model you plan on training\nnb_pipeline = Pipeline([\n                        ('vectorizer', make_column_transformer((CountVectorizer(), 'Text'), remainder='passthrough')),\n                        ('classifier', MultinomialNB())\n                      ])\n\n# Now, we can effectively train our model using the proper feature set\nnb_pipeline.fit(X_train, y_train)\n\n\n# Now, get prediction\npredicted_nb = nb_pipeline.predict(X_test)\n\n# Print accuracy\nprint(np.mean(predicted_nb==y_test))\n\n# Get feature names\n\n# Note, we need to slightly edit how we get the names now that we are using a different transformation pipeline\n# https://stackoverflow.com/questions/54646709/sklearn-pipeline-get-feature-names-after-onehotencode-in-columntransformer\nfeature_names = nb_pipeline['vectorizer'].transformers_[0][1].get_feature_names()\ncoefs = nb_pipeline.named_steps[\"classifier\"].coef_.flatten()\n\n# Your code\nzipped = zip(feature_names, coefs)\nfeatures_df = pd.DataFrame(zipped, columns=[\"feature\", \"value\"])\nfeatures_df[\"ABS\"] = features_df[\"value\"].apply(lambda x: abs(x))\nfeatures_df[\"colors\"] = features_df[\"value\"].apply(lambda x: \"green\" if x > 0 else \"red\")\nfeatures_df = df.sort_values(\"ABS\", ascending=True)\n\n# See results on validation set\nvalid_preds = nb_pipeline.predict(valid_df[['Text', 'A', 'B', 'C']])\nprint(np.mean(valid_preds==valid_df['label']))",
            "masked_code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.naive_bayes import MultinomialNB\n\n# Added\nfrom sklearn.compose import make_column_transformer\n\n# Create some test data to mimic OP's example\n\nbad_sentences = [\"I hated this restauraunt!\", \"I do not like Stack Overflow\", \"I am sad about the economy\", \n                 \"I do not feel good about the new Python update\", \"I think I am allergic to hazelnut!\", \"I will never eat here\",\n                 \"I am never coming back!\", \"I feel really sad after hearing the news\", \"George is getting upset!\", \"Python!\"]\ngood_sentences = [\"I really liked this place\", \"Stack Overflow is a great resource\", \"I am glad we are getting vaccinated\",\n                  \"I love anime\", \"I miss you too!\", \"I am upset we don't hang out more, I love it!\", \n                  \"Why are we feeling sad? Be happy!\", \"Hi, my name is wundermahn, what is your name?\", \"Lol!\", \n                  \"I am the master of my domain\"]\n\n# Create things a bit more verbosely so OP understands what we are doing\n\nsentences = bad_sentences+good_sentences\n\na_bad = [1 for i in range(len(bad_sentences))]\na_good = [0 for i in range(len(good_sentences))]\na = a_bad+a_good\n\nb_bad = [1 for i in range(len(bad_sentences))]\nb_good = [0 for i in range(len(good_sentences))]\nb = b_bad+b_good\n\nc_bad = [1 for i in range(len(bad_sentences))]\nc_good = [0 for i in range(len(good_sentences))]\nc = c_bad+c_good\n\nlabel_bad = [1 for i in range(len(bad_sentences))]\nlabel_good = [0 for i in range(len(good_sentences))]\nlabel = label_bad+label_good\n\n# Create dataframe\ndf = pd.DataFrame({'Text': sentences, 'A': a, 'B': b, 'C': c, 'label': label})\n\n# NEVER mix your validation and testing data!\n# https://stackoverflow.com/questions/28556942/pandas-remove-rows-at-random-without-shuffling-dataset\n\nnp.random.seed(38)\nremove_n = 2\ndrop_indices = np.random.choice(df.index, remove_n, replace=False)\nvalid_df = df.iloc[drop_indices]\nremaining_df = df.drop(drop_indices)\n\nX_train, X_test, y_train, y_test = train_test_split(remaining_df[[col for col in remaining_df.columns if col != 'label']],\n                                                    remaining_df['label'], test_size=0.2, random_state=38)\n\n# Get CountVectorizer working as an example, you can add tfidf later on\n\n# Now, create your pipeline which should include your vectorizer, as well as your model you plan on training\nnb_pipeline = Pipeline([\n                        ('vectorizer', make_column_transformer((CountVectorizer(), 'Text'), remainder='passthrough')),\n                        ('classifier', MultinomialNB())\n                      ])\n\n# Now, we can effectively train our model using the proper feature set\nnb_pipeline.fit(X_train, y_train)\n\n\n# Now, get prediction\npredicted_nb = nb_pipeline.predict(X_test)\n\n# Print accuracy\nprint(np.mean(predicted_nb==y_test))\n\n# Get feature names\n\n# Note, we need to slightly edit how we get the names now that we are using a different transformation pipeline\n# https://stackoverflow.com/questions/54646709/sklearn-pipeline-get-feature-names-after-onehotencode-in-columntransformer\nfeature_names = nb_pipeline['vectorizer'].transformers_[0][1].get_feature_names()\ncoefs = nb_pipeline.named_steps[\"classifier\"].coef_.flatten()\n\n# Your code\nzipped = zip(feature_names, coefs)\nfeatures_df = pd.DataFrame(zipped, columns=[\"feature\", \"value\"])\nfeatures_df[\"ABS\"] = features_df[\"value\"].apply(lambda x: abs(x))\nfeatures_df[\"colors\"] = features_df[\"value\"].apply(lambda x: \"green\" if x > 0 else \"red\")\n<line_mask>\n\n# See results on validation set\nvalid_preds = nb_pipeline.predict(valid_df[['Text', 'A', 'B', 'C']])\nprint(np.mean(valid_preds==valid_df['label']))",
            "masked_line": "features_df = df.sort_values(\"ABS\", ascending=True)",
            "answer": "sort_values",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_884"
        },
        {
            "dependency": "numpy",
            "version": "==1.20.2",
            "time": "2021-05-11",
            "description": "The code is creating a pipeline to train a Multinomial Naive Bayes classifier using a CountVectorizer as the feature extraction method. The pipeline includes preprocessing steps such as splitting the dataset into training and testing sets, fitting the model, making predictions, and evaluating the model's accuracy. Additionally, the code generates feature names and coefficients for the model, sorts them based on importance, and visualizes the results. Finally, it makes predictions on a separate validation set and calculates the accuracy of the model on that set.",
            "code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.naive_bayes import MultinomialNB\n\n# Added\nfrom sklearn.compose import make_column_transformer\n\n# Create some test data to mimic OP's example\n\nbad_sentences = [\"I hated this restauraunt!\", \"I do not like Stack Overflow\", \"I am sad about the economy\", \n                 \"I do not feel good about the new Python update\", \"I think I am allergic to hazelnut!\", \"I will never eat here\",\n                 \"I am never coming back!\", \"I feel really sad after hearing the news\", \"George is getting upset!\", \"Python!\"]\ngood_sentences = [\"I really liked this place\", \"Stack Overflow is a great resource\", \"I am glad we are getting vaccinated\",\n                  \"I love anime\", \"I miss you too!\", \"I am upset we don't hang out more, I love it!\", \n                  \"Why are we feeling sad? Be happy!\", \"Hi, my name is wundermahn, what is your name?\", \"Lol!\", \n                  \"I am the master of my domain\"]\n\n# Create things a bit more verbosely so OP understands what we are doing\n\nsentences = bad_sentences+good_sentences\n\na_bad = [1 for i in range(len(bad_sentences))]\na_good = [0 for i in range(len(good_sentences))]\na = a_bad+a_good\n\nb_bad = [1 for i in range(len(bad_sentences))]\nb_good = [0 for i in range(len(good_sentences))]\nb = b_bad+b_good\n\nc_bad = [1 for i in range(len(bad_sentences))]\nc_good = [0 for i in range(len(good_sentences))]\nc = c_bad+c_good\n\nlabel_bad = [1 for i in range(len(bad_sentences))]\nlabel_good = [0 for i in range(len(good_sentences))]\nlabel = label_bad+label_good\n\n# Create dataframe\ndf = pd.DataFrame({'Text': sentences, 'A': a, 'B': b, 'C': c, 'label': label})\n\n# NEVER mix your validation and testing data!\n# https://stackoverflow.com/questions/28556942/pandas-remove-rows-at-random-without-shuffling-dataset\n\nnp.random.seed(38)\nremove_n = 2\ndrop_indices = np.random.choice(df.index, remove_n, replace=False)\nvalid_df = df.iloc[drop_indices]\nremaining_df = df.drop(drop_indices)\n\nX_train, X_test, y_train, y_test = train_test_split(remaining_df[[col for col in remaining_df.columns if col != 'label']],\n                                                    remaining_df['label'], test_size=0.2, random_state=38)\n\n# Get CountVectorizer working as an example, you can add tfidf later on\n\n# Now, create your pipeline which should include your vectorizer, as well as your model you plan on training\nnb_pipeline = Pipeline([\n                        ('vectorizer', make_column_transformer((CountVectorizer(), 'Text'), remainder='passthrough')),\n                        ('classifier', MultinomialNB())\n                      ])\n\n# Now, we can effectively train our model using the proper feature set\nnb_pipeline.fit(X_train, y_train)\n\n\n# Now, get prediction\npredicted_nb = nb_pipeline.predict(X_test)\n\n# Print accuracy\nprint(np.mean(predicted_nb==y_test))\n\n# Get feature names\n\n# Note, we need to slightly edit how we get the names now that we are using a different transformation pipeline\n# https://stackoverflow.com/questions/54646709/sklearn-pipeline-get-feature-names-after-onehotencode-in-columntransformer\nfeature_names = nb_pipeline['vectorizer'].transformers_[0][1].get_feature_names()\ncoefs = nb_pipeline.named_steps[\"classifier\"].coef_.flatten()\n\n# Your code\nzipped = zip(feature_names, coefs)\nfeatures_df = pd.DataFrame(zipped, columns=[\"feature\", \"value\"])\nfeatures_df[\"ABS\"] = features_df[\"value\"].apply(lambda x: abs(x))\nfeatures_df[\"colors\"] = features_df[\"value\"].apply(lambda x: \"green\" if x > 0 else \"red\")\nfeatures_df = df.sort_values(\"ABS\", ascending=True)\n\n# See results on validation set\nvalid_preds = nb_pipeline.predict(valid_df[['Text', 'A', 'B', 'C']])\nprint(np.mean(valid_preds==valid_df['label']))",
            "masked_code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.naive_bayes import MultinomialNB\n\n# Added\nfrom sklearn.compose import make_column_transformer\n\n# Create some test data to mimic OP's example\n\nbad_sentences = [\"I hated this restauraunt!\", \"I do not like Stack Overflow\", \"I am sad about the economy\", \n                 \"I do not feel good about the new Python update\", \"I think I am allergic to hazelnut!\", \"I will never eat here\",\n                 \"I am never coming back!\", \"I feel really sad after hearing the news\", \"George is getting upset!\", \"Python!\"]\ngood_sentences = [\"I really liked this place\", \"Stack Overflow is a great resource\", \"I am glad we are getting vaccinated\",\n                  \"I love anime\", \"I miss you too!\", \"I am upset we don't hang out more, I love it!\", \n                  \"Why are we feeling sad? Be happy!\", \"Hi, my name is wundermahn, what is your name?\", \"Lol!\", \n                  \"I am the master of my domain\"]\n\n# Create things a bit more verbosely so OP understands what we are doing\n\nsentences = bad_sentences+good_sentences\n\na_bad = [1 for i in range(len(bad_sentences))]\na_good = [0 for i in range(len(good_sentences))]\na = a_bad+a_good\n\nb_bad = [1 for i in range(len(bad_sentences))]\nb_good = [0 for i in range(len(good_sentences))]\nb = b_bad+b_good\n\nc_bad = [1 for i in range(len(bad_sentences))]\nc_good = [0 for i in range(len(good_sentences))]\nc = c_bad+c_good\n\nlabel_bad = [1 for i in range(len(bad_sentences))]\nlabel_good = [0 for i in range(len(good_sentences))]\nlabel = label_bad+label_good\n\n# Create dataframe\ndf = pd.DataFrame({'Text': sentences, 'A': a, 'B': b, 'C': c, 'label': label})\n\n# NEVER mix your validation and testing data!\n# https://stackoverflow.com/questions/28556942/pandas-remove-rows-at-random-without-shuffling-dataset\n\nnp.random.seed(38)\nremove_n = 2\ndrop_indices = np.random.choice(df.index, remove_n, replace=False)\nvalid_df = df.iloc[drop_indices]\nremaining_df = df.drop(drop_indices)\n\nX_train, X_test, y_train, y_test = train_test_split(remaining_df[[col for col in remaining_df.columns if col != 'label']],\n                                                    remaining_df['label'], test_size=0.2, random_state=38)\n\n# Get CountVectorizer working as an example, you can add tfidf later on\n\n# Now, create your pipeline which should include your vectorizer, as well as your model you plan on training\nnb_pipeline = Pipeline([\n                        ('vectorizer', make_column_transformer((CountVectorizer(), 'Text'), remainder='passthrough')),\n                        ('classifier', MultinomialNB())\n                      ])\n\n# Now, we can effectively train our model using the proper feature set\nnb_pipeline.fit(X_train, y_train)\n\n\n# Now, get prediction\npredicted_nb = nb_pipeline.predict(X_test)\n\n# Print accuracy\nprint(np.mean(predicted_nb==y_test))\n\n# Get feature names\n\n# Note, we need to slightly edit how we get the names now that we are using a different transformation pipeline\n# https://stackoverflow.com/questions/54646709/sklearn-pipeline-get-feature-names-after-onehotencode-in-columntransformer\nfeature_names = nb_pipeline['vectorizer'].transformers_[0][1].get_feature_names()\ncoefs = nb_pipeline.named_steps[\"classifier\"].coef_.flatten()\n\n# Your code\nzipped = zip(feature_names, coefs)\nfeatures_df = pd.DataFrame(zipped, columns=[\"feature\", \"value\"])\nfeatures_df[\"ABS\"] = features_df[\"value\"].apply(lambda x: abs(x))\nfeatures_df[\"colors\"] = features_df[\"value\"].apply(lambda x: \"green\" if x > 0 else \"red\")\nfeatures_df = df.sort_values(\"ABS\", ascending=True)\n\n# See results on validation set\nvalid_preds = nb_pipeline.predict(valid_df[['Text', 'A', 'B', 'C']])\n<line_mask>",
            "masked_line": "print(np.mean(valid_preds==valid_df['label']))",
            "answer": "mean",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_885"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.24.1",
            "time": "2021-05-11",
            "description": "The code builds a pipeline to train a Multinomial Naive Bayes classifier on text data to predict sentiment (positive or negative) based on the provided features A, B, and C. It splits the data into training and testing sets, trains the model with the training data, predicts sentiment on the test data, calculates and prints the accuracy of the predictions, and visualizes the most influential features in predicting sentiment. Finally, it evaluates the model's performance on a validation set.",
            "code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.naive_bayes import MultinomialNB\n\n# Added\nfrom sklearn.compose import make_column_transformer\n\n# Create some test data to mimic OP's example\n\nbad_sentences = [\"I hated this restauraunt!\", \"I do not like Stack Overflow\", \"I am sad about the economy\", \n                 \"I do not feel good about the new Python update\", \"I think I am allergic to hazelnut!\", \"I will never eat here\",\n                 \"I am never coming back!\", \"I feel really sad after hearing the news\", \"George is getting upset!\", \"Python!\"]\ngood_sentences = [\"I really liked this place\", \"Stack Overflow is a great resource\", \"I am glad we are getting vaccinated\",\n                  \"I love anime\", \"I miss you too!\", \"I am upset we don't hang out more, I love it!\", \n                  \"Why are we feeling sad? Be happy!\", \"Hi, my name is wundermahn, what is your name?\", \"Lol!\", \n                  \"I am the master of my domain\"]\n\n# Create things a bit more verbosely so OP understands what we are doing\n\nsentences = bad_sentences+good_sentences\n\na_bad = [1 for i in range(len(bad_sentences))]\na_good = [0 for i in range(len(good_sentences))]\na = a_bad+a_good\n\nb_bad = [1 for i in range(len(bad_sentences))]\nb_good = [0 for i in range(len(good_sentences))]\nb = b_bad+b_good\n\nc_bad = [1 for i in range(len(bad_sentences))]\nc_good = [0 for i in range(len(good_sentences))]\nc = c_bad+c_good\n\nlabel_bad = [1 for i in range(len(bad_sentences))]\nlabel_good = [0 for i in range(len(good_sentences))]\nlabel = label_bad+label_good\n\n# Create dataframe\ndf = pd.DataFrame({'Text': sentences, 'A': a, 'B': b, 'C': c, 'label': label})\n\n# NEVER mix your validation and testing data!\n# https://stackoverflow.com/questions/28556942/pandas-remove-rows-at-random-without-shuffling-dataset\n\nnp.random.seed(38)\nremove_n = 2\ndrop_indices = np.random.choice(df.index, remove_n, replace=False)\nvalid_df = df.iloc[drop_indices]\nremaining_df = df.drop(drop_indices)\n\nX_train, X_test, y_train, y_test = train_test_split(remaining_df[[col for col in remaining_df.columns if col != 'label']],\n                                                    remaining_df['label'], test_size=0.2, random_state=38)\n\n# Get CountVectorizer working as an example, you can add tfidf later on\n\n# Now, create your pipeline which should include your vectorizer, as well as your model you plan on training\nnb_pipeline = Pipeline([\n                        ('vectorizer', make_column_transformer((CountVectorizer(), 'Text'), remainder='passthrough')),\n                        ('classifier', MultinomialNB())\n                      ])\n\n# Now, we can effectively train our model using the proper feature set\nnb_pipeline.fit(X_train, y_train)\n\n\n# Now, get prediction\npredicted_nb = nb_pipeline.predict(X_test)\n\n# Print accuracy\nprint(np.mean(predicted_nb==y_test))\n\n# Get feature names\n\n# Note, we need to slightly edit how we get the names now that we are using a different transformation pipeline\n# https://stackoverflow.com/questions/54646709/sklearn-pipeline-get-feature-names-after-onehotencode-in-columntransformer\nfeature_names = nb_pipeline['vectorizer'].transformers_[0][1].get_feature_names()\ncoefs = nb_pipeline.named_steps[\"classifier\"].coef_.flatten()\n\n# Your code\nzipped = zip(feature_names, coefs)\nfeatures_df = pd.DataFrame(zipped, columns=[\"feature\", \"value\"])\nfeatures_df[\"ABS\"] = features_df[\"value\"].apply(lambda x: abs(x))\nfeatures_df[\"colors\"] = features_df[\"value\"].apply(lambda x: \"green\" if x > 0 else \"red\")\nfeatures_df = df.sort_values(\"ABS\", ascending=True)\n\n# See results on validation set\nvalid_preds = nb_pipeline.predict(valid_df[['Text', 'A', 'B', 'C']])\nprint(np.mean(valid_preds==valid_df['label']))",
            "masked_code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.naive_bayes import MultinomialNB\n\n# Added\nfrom sklearn.compose import make_column_transformer\n\n# Create some test data to mimic OP's example\n\nbad_sentences = [\"I hated this restauraunt!\", \"I do not like Stack Overflow\", \"I am sad about the economy\", \n                 \"I do not feel good about the new Python update\", \"I think I am allergic to hazelnut!\", \"I will never eat here\",\n                 \"I am never coming back!\", \"I feel really sad after hearing the news\", \"George is getting upset!\", \"Python!\"]\ngood_sentences = [\"I really liked this place\", \"Stack Overflow is a great resource\", \"I am glad we are getting vaccinated\",\n                  \"I love anime\", \"I miss you too!\", \"I am upset we don't hang out more, I love it!\", \n                  \"Why are we feeling sad? Be happy!\", \"Hi, my name is wundermahn, what is your name?\", \"Lol!\", \n                  \"I am the master of my domain\"]\n\n# Create things a bit more verbosely so OP understands what we are doing\n\nsentences = bad_sentences+good_sentences\n\na_bad = [1 for i in range(len(bad_sentences))]\na_good = [0 for i in range(len(good_sentences))]\na = a_bad+a_good\n\nb_bad = [1 for i in range(len(bad_sentences))]\nb_good = [0 for i in range(len(good_sentences))]\nb = b_bad+b_good\n\nc_bad = [1 for i in range(len(bad_sentences))]\nc_good = [0 for i in range(len(good_sentences))]\nc = c_bad+c_good\n\nlabel_bad = [1 for i in range(len(bad_sentences))]\nlabel_good = [0 for i in range(len(good_sentences))]\nlabel = label_bad+label_good\n\n# Create dataframe\ndf = pd.DataFrame({'Text': sentences, 'A': a, 'B': b, 'C': c, 'label': label})\n\n# NEVER mix your validation and testing data!\n# https://stackoverflow.com/questions/28556942/pandas-remove-rows-at-random-without-shuffling-dataset\n\nnp.random.seed(38)\nremove_n = 2\ndrop_indices = np.random.choice(df.index, remove_n, replace=False)\nvalid_df = df.iloc[drop_indices]\nremaining_df = df.drop(drop_indices)\n\nX_train, X_test, y_train, y_test = train_test_split(remaining_df[[col for col in remaining_df.columns if col != 'label']],\n                                                    remaining_df['label'], test_size=0.2, random_state=38)\n\n# Get CountVectorizer working as an example, you can add tfidf later on\n\n# Now, create your pipeline which should include your vectorizer, as well as your model you plan on training\nnb_pipeline = Pipeline([\n                        ('vectorizer', make_column_transformer((CountVectorizer(), 'Text'), remainder='passthrough')),\n                        ('classifier', MultinomialNB())\n                      ])\n\n# Now, we can effectively train our model using the proper feature set\nnb_pipeline.fit(X_train, y_train)\n\n\n# Now, get prediction\n<line_mask>\n\n# Print accuracy\nprint(np.mean(predicted_nb==y_test))\n\n# Get feature names\n\n# Note, we need to slightly edit how we get the names now that we are using a different transformation pipeline\n# https://stackoverflow.com/questions/54646709/sklearn-pipeline-get-feature-names-after-onehotencode-in-columntransformer\nfeature_names = nb_pipeline['vectorizer'].transformers_[0][1].get_feature_names()\ncoefs = nb_pipeline.named_steps[\"classifier\"].coef_.flatten()\n\n# Your code\nzipped = zip(feature_names, coefs)\nfeatures_df = pd.DataFrame(zipped, columns=[\"feature\", \"value\"])\nfeatures_df[\"ABS\"] = features_df[\"value\"].apply(lambda x: abs(x))\nfeatures_df[\"colors\"] = features_df[\"value\"].apply(lambda x: \"green\" if x > 0 else \"red\")\nfeatures_df = df.sort_values(\"ABS\", ascending=True)\n\n# See results on validation set\nvalid_preds = nb_pipeline.predict(valid_df[['Text', 'A', 'B', 'C']])\nprint(np.mean(valid_preds==valid_df['label']))",
            "masked_line": "predicted_nb = nb_pipeline.predict(X_test)",
            "answer": "predict",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_886"
        },
        {
            "dependency": "scipy",
            "version": "==1.6.0",
            "time": "2021-02-04",
            "description": "The code loads a MATLAB file called 'CameraParams.mat' using scipy.io, iterates over the key-value pairs in the loaded data, and prints out the key, type, and value. If the value is a numpy array, it prints ' --> Numpy array'.",
            "code": "import scipy.io as sio\nimport numpy as np\n\nMat = sio.loadmat('CameraParams.mat')\n\nfor k, v in Mat.items():\n    print(\"\\n\\n\", k, type(v), v)\n    if isinstance(v, np.ndarray):  # Numpy array?\n        print(' --> Numpy array')",
            "masked_code": "import scipy.io as sio\nimport numpy as np\n\n<line_mask>\n\nfor k, v in Mat.items():\n    print(\"\\n\\n\", k, type(v), v)\n    if isinstance(v, np.ndarray):  # Numpy array?\n        print(' --> Numpy array')",
            "masked_line": "Mat = sio.loadmat('CameraParams.mat')",
            "answer": "loadmat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_887"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.0",
            "time": "2021-02-02",
            "description": "This code generates a new dataframe by combining and filling missing values from the original dataframe based on instance ID, timestamp, CPU load, and memory load columns.",
            "code": "import pandas as pd\nimport io\nimport datetime as dt\nimport numpy as np\ndf = pd.read_csv(io.StringIO(\"\"\"id  creTimestamp    CPULoad instnceId\n0   2021-01-22 18:00:00 22.0    instanceA\n1   2021-01-22 19:00:00 22.0    instanceA\n2   2021-01-22 20:00:00 23.0    instanceB\n3   2021-01-23 18:00:00 24.0    instanceA\n4   2021-01-23 20:00:00 22.0    instanceA\n5   2021-01-24 18:00:00 23.0    instanceB\n6   2021-01-24 20:00:00 23.5    instanceA\n\"\"\"), sep=\"\\t\", index_col=0)\n\ndf.creTimestamp = pd.to_datetime(df.creTimestamp)\ndf[\"memload\"] = np.random.random(len(df))\n\n# generate a DF for each time in instance in each date\ndf2 = (pd.merge(\n    # for each time in instance\n    df.assign(timestamp=df.creTimestamp.dt.time)\n        .loc[:,[\"instnceId\",\"timestamp\"]]\n        .drop_duplicates()\n        .assign(foo=1),\n    # for each date\n    df.creTimestamp.dt.date.drop_duplicates().to_frame().assign(foo=1),\n    on=\"foo\"\n).assign(creTimestamp=lambda dfa: dfa.apply(lambda r: dt.datetime.combine(r[\"creTimestamp\"], r[\"timestamp\"]), axis=1))\n .drop(columns=\"foo\")\n       # merge values back..\n .merge(df, on=[\"creTimestamp\", \"instnceId\"], how=\"left\")\n)\n\n# now get values to fill NaN\ndf2 = (df2.merge(df2.dropna().drop_duplicates(subset=[\"instnceId\",\"timestamp\"], keep=\"last\"),\n         on=[\"timestamp\",\"instnceId\"], suffixes=(\"\",\"_pre\"))\n .assign(CPULoad=lambda dfa: dfa.CPULoad.fillna(dfa.CPULoad_pre))\n .assign(memload=lambda dfa: dfa.memload.fillna(dfa.memload_pre))\n\n)",
            "masked_code": "import pandas as pd\nimport io\nimport datetime as dt\nimport numpy as np\ndf = pd.read_csv(io.StringIO(\"\"\"id  creTimestamp    CPULoad instnceId\n0   2021-01-22 18:00:00 22.0    instanceA\n1   2021-01-22 19:00:00 22.0    instanceA\n2   2021-01-22 20:00:00 23.0    instanceB\n3   2021-01-23 18:00:00 24.0    instanceA\n4   2021-01-23 20:00:00 22.0    instanceA\n5   2021-01-24 18:00:00 23.0    instanceB\n6   2021-01-24 20:00:00 23.5    instanceA\n\"\"\"), sep=\"\\t\", index_col=0)\n\n<line_mask>\ndf[\"memload\"] = np.random.random(len(df))\n\n# generate a DF for each time in instance in each date\ndf2 = (pd.merge(\n    # for each time in instance\n    df.assign(timestamp=df.creTimestamp.dt.time)\n        .loc[:,[\"instnceId\",\"timestamp\"]]\n        .drop_duplicates()\n        .assign(foo=1),\n    # for each date\n    df.creTimestamp.dt.date.drop_duplicates().to_frame().assign(foo=1),\n    on=\"foo\"\n).assign(creTimestamp=lambda dfa: dfa.apply(lambda r: dt.datetime.combine(r[\"creTimestamp\"], r[\"timestamp\"]), axis=1))\n .drop(columns=\"foo\")\n       # merge values back..\n .merge(df, on=[\"creTimestamp\", \"instnceId\"], how=\"left\")\n)\n\n# now get values to fill NaN\ndf2 = (df2.merge(df2.dropna().drop_duplicates(subset=[\"instnceId\",\"timestamp\"], keep=\"last\"),\n         on=[\"timestamp\",\"instnceId\"], suffixes=(\"\",\"_pre\"))\n .assign(CPULoad=lambda dfa: dfa.CPULoad.fillna(dfa.CPULoad_pre))\n .assign(memload=lambda dfa: dfa.memload.fillna(dfa.memload_pre))\n\n)",
            "masked_line": "df.creTimestamp = pd.to_datetime(df.creTimestamp)",
            "answer": "to_datetime",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_888"
        },
        {
            "dependency": "apache-airflow",
            "version": "==1.10.15",
            "time": "2021-10-21",
            "description": "The code defines an Airflow DAG named \"parquet_load_to_bq\" that creates an external table in Google BigQuery from a Parquet file stored in a bucket. The DAG runs daily and includes tasks to create the external table and print the DAG run configuration in the Airflow logs.",
            "code": "import datetime\nimport airflow\nfrom airflow.operators import bash_operator\nfrom airflow.providers.google.cloud.operators.bigquery import BigQueryCreateExternalTableOperator\n\nYESTERDAY = datetime.datetime.now() - datetime.timedelta(days=1)\n\ndefault_args = {\n    'owner': 'Composer Example',\n    'depends_on_past': False,\n    'email': [''],\n    'email_on_failure': False,\n    'email_on_retry': False,\n    'retries': 1,\n    'retry_delay': datetime.timedelta(minutes=5),\n    'start_date': YESTERDAY,\n}\n\nwith airflow.DAG(\n        'parquet_load_to_bq',\n        'catchup=False',\n        default_args=default_args,\n        schedule_interval=datetime.timedelta(days=1)) as dag:\n\n    create_imp_external_table = BigQueryCreateExternalTableOperator(\n        task_id=f\"create_imp_external_table\",\n        bucket='my-bucket',\n        source_objects=[\"/data/userdata1.parquet\"], #pass a list\n        destination_project_dataset_table=f\"my-project.my_dataset.parquet_table\",\n        source_format='PARQUET', #use source_format instead of file_format\n    )\n\n    # Print the dag_run id from the Airflow logs\n    print_dag_run_conf = bash_operator.BashOperator(\n        task_id='print_dag_run_conf', bash_command='echo {{ dag_run.id }}')\n\ncreate_imp_external_table >> print_dag_run_conf",
            "masked_code": "import datetime\nimport airflow\nfrom airflow.operators import bash_operator\nfrom airflow.providers.google.cloud.operators.bigquery import BigQueryCreateExternalTableOperator\n\nYESTERDAY = datetime.datetime.now() - datetime.timedelta(days=1)\n\ndefault_args = {\n    'owner': 'Composer Example',\n    'depends_on_past': False,\n    'email': [''],\n    'email_on_failure': False,\n    'email_on_retry': False,\n    'retries': 1,\n    'retry_delay': datetime.timedelta(minutes=5),\n    'start_date': YESTERDAY,\n}\n\nwith airflow.DAG(\n        'parquet_load_to_bq',\n        'catchup=False',\n        default_args=default_args,\n        schedule_interval=datetime.timedelta(days=1)) as dag:\n\n    create_imp_external_table = BigQueryCreateExternalTableOperator(\n        task_id=f\"create_imp_external_table\",\n        bucket='my-bucket',\n        source_objects=[\"/data/userdata1.parquet\"], #pass a list\n        destination_project_dataset_table=f\"my-project.my_dataset.parquet_table\",\n        source_format='PARQUET', #use source_format instead of file_format\n    )\n\n    # Print the dag_run id from the Airflow logs\n    <line_mask>\n        task_id='print_dag_run_conf', bash_command='echo {{ dag_run.id }}')\n\ncreate_imp_external_table >> print_dag_run_conf",
            "masked_line": "print_dag_run_conf = bash_operator.BashOperator(",
            "answer": "BashOperator",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_889"
        },
        {
            "dependency": "pandas",
            "version": ">=1.5.0",
            "time": "2022-10-25",
            "description": "This code snippet updates the values in the first column of a Pandas DataFrame with new values stored in a NumPy array, while ignoring a future warning related to setting values in-place in Pandas.",
            "code": "import numpy as np\nimport pandas as pd\nimport warnings\n\ndf = pd.DataFrame({\"price\": [11.1, 12.2]}, index=[\"book1\", \"book2\"])\noriginal_prices = df[\"price\"]\nnew_prices = np.array([98, 99])\nwith warnings.catch_warnings():\n    # Setting values in-place is fine, ignore the warning in Pandas >= 1.5.0\n    # This can be removed, if Pandas 1.5.0 does not need to be supported any longer.\n    # See also: https://stackoverflow.com/q/74057367/859591\n    warnings.filterwarnings(\n        \"ignore\",\n        category=FutureWarning,\n        message=(\n            \".*will attempt to set the values inplace instead of always setting a new array. \"\n            \"To retain the old behavior, use either.*\"\n        ),\n    )\n\n    df.iloc[:, 0] = new_prices\n\ndf.iloc[:, 0]",
            "masked_code": "import numpy as np\nimport pandas as pd\nimport warnings\n\n<line_mask>\noriginal_prices = df[\"price\"]\nnew_prices = np.array([98, 99])\nwith warnings.catch_warnings():\n    # Setting values in-place is fine, ignore the warning in Pandas >= 1.5.0\n    # This can be removed, if Pandas 1.5.0 does not need to be supported any longer.\n    # See also: https://stackoverflow.com/q/74057367/859591\n    warnings.filterwarnings(\n        \"ignore\",\n        category=FutureWarning,\n        message=(\n            \".*will attempt to set the values inplace instead of always setting a new array. \"\n            \"To retain the old behavior, use either.*\"\n        ),\n    )\n\n    df.iloc[:, 0] = new_prices\n\ndf.iloc[:, 0]",
            "masked_line": "df = pd.DataFrame({\"price\": [11.1, 12.2]}, index=[\"book1\", \"book2\"])",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_890"
        },
        {
            "dependency": "hypothesis",
            "version": "==6.48.1",
            "time": "2022-06-28",
            "description": "The code defines a fixture named 'stuff' that returns the string \"kittens\". It also defines a test function 'test_stuff' that takes two arguments 'a' and 'stuff'. The test asserts that 'a' is None and that 'stuff' is equal to \"kittens\".",
            "code": "from hypothesis import given, strategies as st, settings, HealthCheck\nfrom pytest import fixture\n\n\n@fixture\ndef stuff():\n    return \"kittens\"\n\n\n@given(a=st.none())\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_stuff(a, stuff):\n    assert a is None\n    assert stuff == \"kittens\"",
            "masked_code": "<line_mask>\nfrom pytest import fixture\n\n\n@fixture\ndef stuff():\n    return \"kittens\"\n\n\n@given(a=st.none())\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_stuff(a, stuff):\n    assert a is None\n    assert stuff == \"kittens\"",
            "masked_line": "from hypothesis import given, strategies as st, settings, HealthCheck",
            "answer": "settings",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_891"
        },
        {
            "dependency": "numpy",
            "version": "==1.22",
            "time": "2022-01-26",
            "description": "The code imports NumPy and OpenCV libraries to access and retrieve information about the datatypes \"float32\" and \"float64\".",
            "code": "import numpy as np\n\nnp.finfo(np.dtype(\"float32\"))\nnp.finfo(np.dtype(\"float64\"))\nimport cv2",
            "masked_code": "import numpy as np\n\nnp.finfo(np.dtype(\"float32\"))\n<line_mask>\nimport cv2",
            "masked_line": "np.finfo(np.dtype(\"float64\"))",
            "answer": "finfo",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_892"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.15.5",
            "time": "2022-10-10",
            "description": "The provided Python code defines an attention-based RNN decoder for a sequence-to-sequence model. The attention mechanism allows the decoder to focus on specific parts of the input sequence during decoding. The decoder takes decoder inputs, initial state, attention states, RNN cell, output size, number of attention heads, loop function, and other parameters as input, and returns a tuple of outputs and the final state of each decoder cell.\n\nThe decoder uses the attention mechanism based on the Bahdanau et al. model (http://arxiv.org/abs/1412.7449) to generate outputs. It calculates attention weights, applies them to the hidden features, and combines them with the RNN cell output to produce the final outputs. The decoder supports multiple attention heads and can handle complex sequence-to-sequence tasks effectively.",
            "code": "# https://github.com/tensorflow/tensorflow/blob/v1.15.5/tensorflow/contrib/legacy_seq2seq/python/ops/seq2seq.py#L537\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import variable_scope\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import nn_ops\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.ops import init_ops\nfrom tensorflow.python.framework import constant_op\n\nimport tensorflow as tf\n\n\nclass Linear:\n    \"\"\"Linear map: sum_i(args[i] * W[i]), where W[i] is a variable.\n  Args:\n    args: a 2D Tensor or a list of 2D, batch, n, Tensors.\n    output_size: int, second dimension of weight variable.\n    dtype: data type for variables.\n    build_bias: boolean, whether to build a bias variable.\n    bias_initializer: starting value to initialize the bias\n      (default is all zeros).\n    kernel_initializer: starting value to initialize the weight.\n  Raises:\n    ValueError: if inputs_shape is wrong.\n  \"\"\"\n\n    def __init__(self,\n                 args,\n                 output_size,\n                 build_bias,\n                 bias_initializer=None,\n                 kernel_initializer=None):\n        self._build_bias = build_bias\n\n        if args is None or (nest.is_sequence(args) and not args):\n            raise ValueError(\"`args` must be specified\")\n        if not nest.is_sequence(args):\n            args = [args]\n            self._is_sequence = False\n        else:\n            self._is_sequence = True\n\n        # Calculate the total size of arguments on dimension 1.\n        total_arg_size = 0\n        shapes = [a.get_shape() for a in args]\n        for shape in shapes:\n            if shape.ndims != 2:\n                raise ValueError(\"linear is expecting 2D arguments: %s\" % shapes)\n            if shape.dims[1].value is None:\n                raise ValueError(\"linear expects shape[1] to be provided for shape %s, \"\n                                 \"but saw %s\" % (shape, shape[1]))\n            else:\n                total_arg_size += shape.dims[1].value\n\n        dtype = [a.dtype for a in args][0]\n\n        scope = variable_scope.get_variable_scope()\n        with variable_scope.variable_scope(scope) as outer_scope:\n            self._weights = variable_scope.get_variable(\n                'weights', [total_arg_size, output_size],\n                dtype=dtype,\n                initializer=kernel_initializer)\n            if build_bias:\n                with variable_scope.variable_scope(outer_scope) as inner_scope:\n                    inner_scope.set_partitioner(None)\n                    if bias_initializer is None:\n                        bias_initializer = init_ops.constant_initializer(0.0, dtype=dtype)\n                    self._biases = variable_scope.get_variable(\n                        'bias', [output_size],\n                        dtype=dtype,\n                        initializer=bias_initializer)\n\n    def __call__(self, args):\n        if not self._is_sequence:\n            args = [args]\n\n        if len(args) == 1:\n            res = math_ops.matmul(args[0], self._weights)\n        else:\n            # Explicitly creating a one for a minor performance improvement.\n            one = constant_op.constant(1, dtype=dtypes.int32)\n            res = math_ops.matmul(array_ops.concat(args, one), self._weights)\n        if self._build_bias:\n            res = nn_ops.bias_add(res, self._biases)\n        return res\n\n\ndef attention_decoder(decoder_inputs,\n                      initial_state,\n                      attention_states,\n                      cell,\n                      output_size=None,\n                      num_heads=1,\n                      loop_function=None,\n                      dtype=None,\n                      scope=None,\n                      initial_state_attention=False):\n    \"\"\"RNN decoder with attention for the sequence-to-sequence model.\n  In this context \"attention\" means that, during decoding, the RNN can look up\n  information in the additional tensor attention_states, and it does this by\n  focusing on a few entries from the tensor. This model has proven to yield\n  especially good results in a number of sequence-to-sequence tasks. This\n  implementation is based on http://arxiv.org/abs/1412.7449 (see below for\n  details). It is recommended for complex sequence-to-sequence tasks.\n  Args:\n    decoder_inputs: A list of 2D Tensors [batch_size x input_size].\n    initial_state: 2D Tensor [batch_size x cell.state_size].\n    attention_states: 3D Tensor [batch_size x attn_length x attn_size].\n    cell: tf.compat.v1.nn.rnn_cell.RNNCell defining the cell function and size.\n    output_size: Size of the output vectors; if None, we use cell.output_size.\n    num_heads: Number of attention heads that read from attention_states.\n    loop_function: If not None, this function will be applied to i-th output in\n      order to generate i+1-th input, and decoder_inputs will be ignored, except\n      for the first element (\"GO\" symbol). This can be used for decoding,\n      but also for training to emulate http://arxiv.org/abs/1506.03099.\n        Signature -- loop_function(prev, i) = next * prev is a 2D Tensor of\n        shape [batch_size x output_size], * i is an integer, the step number\n        (when advanced control is needed), * next is a 2D Tensor of shape\n        [batch_size x input_size].\n    dtype: The dtype to use for the RNN initial state (default: tf.float32).\n    scope: VariableScope for the created subgraph; default: \"attention_decoder\".\n    initial_state_attention: If False (default), initial attentions are zero. If\n      True, initialize the attentions from the initial state and attention\n      states -- useful when we wish to resume decoding from a previously stored\n      decoder state and attention states.\n  Returns:\n    A tuple of the form (outputs, state), where:\n      outputs: A list of the same length as decoder_inputs of 2D Tensors of\n        shape [batch_size x output_size]. These represent the generated outputs.\n        Output i is computed from input i (which is either the i-th element\n        of decoder_inputs or loop_function(output {i-1}, i)) as follows.\n        First, we run the cell on a combination of the input and previous\n        attention masks:\n          cell_output, new_state = cell(linear(input, prev_attn), prev_state).\n        Then, we calculate new attention masks:\n          new_attn = softmax(V^T * tanh(W * attention_states + U * new_state))\n        and then we calculate the output:\n          output = linear(cell_output, new_attn).\n      state: The state of each decoder cell the final time-step.\n        It is a 2D Tensor of shape [batch_size x cell.state_size].\n  Raises:\n    ValueError: when num_heads is not positive, there are no inputs, shapes\n      of attention_states are not set, or input size cannot be inferred\n      from the input.\n  \"\"\"\n    if not decoder_inputs:\n        raise ValueError(\"Must provide at least 1 input to attention decoder.\")\n    if num_heads < 1:\n        raise ValueError(\"With less than 1 heads, use a non-attention decoder.\")\n    if attention_states.get_shape()[2] is None:\n        raise ValueError(\"Shape[2] of attention_states must be known: %s\" %\n                         attention_states.get_shape())\n    if output_size is None:\n        output_size = cell.output_size\n\n    with variable_scope.variable_scope(\n            scope or \"attention_decoder\", dtype=dtype) as scope:\n        dtype = scope.dtype\n\n        batch_size = array_ops.shape(decoder_inputs[0])[0]  # Needed for reshaping.\n        attn_length = attention_states.get_shape()[1]\n        if attn_length is None:\n            attn_length = array_ops.shape(attention_states)[1]\n        attn_size = attention_states.get_shape()[2]\n\n        # To calculate W1 * h_t we use a 1-by-1 convolution, need to reshape before.\n        hidden = array_ops.reshape(attention_states,\n                                   [-1, attn_length, 1, attn_size])\n        hidden_features = []\n        v = []\n        attention_vec_size = attn_size  # Size of query vectors for attention.\n        for a in range(num_heads):\n            k = variable_scope.get_variable(\n                \"AttnW_%d\" % a, [1, 1, attn_size, attention_vec_size], dtype=dtype)\n            hidden_features.append(nn_ops.conv2d(hidden, k, [1, 1, 1, 1], \"SAME\"))\n            v.append(\n                variable_scope.get_variable(\n                    \"AttnV_%d\" % a, [attention_vec_size], dtype=dtype))\n\n        state = initial_state\n\n        def attention(query):\n            \"\"\"Put attention masks on hidden using hidden_features and query.\"\"\"\n            ds = []  # Results of attention reads will be stored here.\n            if nest.is_sequence(query):  # If the query is a tuple, flatten it.\n                query_list = nest.flatten(query)\n                for q in query_list:  # Check that ndims == 2 if specified.\n                    ndims = q.get_shape().ndims\n                    if ndims:\n                        assert ndims == 2\n                query = array_ops.concat(query_list, 1)\n            for a in range(num_heads):\n                with variable_scope.variable_scope(\"Attention_%d\" % a):\n                    y = Linear(query, attention_vec_size, True)(query)\n                    y = array_ops.reshape(y, [-1, 1, 1, attention_vec_size])\n                    y = math_ops.cast(y, dtype)\n                    # Attention mask is a softmax of v^T * tanh(...).\n                    s = math_ops.reduce_sum(v[a] * math_ops.tanh(hidden_features[a] + y),\n                                            [2, 3])\n                    a = nn_ops.softmax(math_ops.cast(s, dtype=dtypes.float32))\n                    # Now calculate the attention-weighted vector d.\n                    a = math_ops.cast(a, dtype)\n                    d = math_ops.reduce_sum(\n                        array_ops.reshape(a, [-1, attn_length, 1, 1]) * hidden, [1, 2])\n                    ds.append(array_ops.reshape(d, [-1, attn_size]))\n            return ds\n\n        outputs = []\n        prev = None\n        batch_attn_size = array_ops.stack([batch_size, attn_size])\n        attns = [\n            array_ops.zeros(batch_attn_size, dtype=dtype) for _ in range(num_heads)\n        ]\n        for a in attns:  # Ensure the second shape of attention vectors is set.\n            a.set_shape([None, attn_size])\n        if initial_state_attention:\n            attns = attention(initial_state)\n        for i, inp in enumerate(decoder_inputs):\n            if i > 0:\n                variable_scope.get_variable_scope().reuse_variables()\n            # If loop_function is set, we use it instead of decoder_inputs.\n            if loop_function is not None and prev is not None:\n                with variable_scope.variable_scope(\"loop_function\", reuse=True):\n                    inp = loop_function(prev, i)\n            # Merge input and previous attentions into one vector of the right size.\n            input_size = inp.get_shape().with_rank(2)[1]\n            if input_size is None:\n                raise ValueError(\"Could not infer input size from input: %s\" % inp.name)\n\n            inputs = [inp] + attns\n            inputs = [math_ops.cast(e, dtype) for e in inputs]\n            x = Linear(inputs, input_size, True)(inputs)\n            # Run the RNN.\n            cell_output, state = cell(x, state)\n            # Run the attention mechanism.\n            if i == 0 and initial_state_attention:\n                with variable_scope.variable_scope(\n                        variable_scope.get_variable_scope(), reuse=True):\n                    attns = attention(state)\n            else:\n                attns = attention(state)\n\n            with variable_scope.variable_scope(\"AttnOutputProjection\"):\n                cell_output = math_ops.cast(cell_output, dtype)\n                inputs = [cell_output] + attns\n                output = Linear(inputs, output_size, True)(inputs)\n            if loop_function is not None:\n                prev = output\n            outputs.append(output)\n\n    return outputs, state\n\n\nif __name__ == \"__main__\":\n    _outputs, _state = attention_decoder([tf.ones((1, 1))],\n                                         tf.ones((1, 1)),\n                                         tf.ones((1, 1, 1)),\n                                         tf.compat.v1.nn.rnn_cell.BasicRNNCell(1))\n    print(_outputs, _state)",
            "masked_code": "# https://github.com/tensorflow/tensorflow/blob/v1.15.5/tensorflow/contrib/legacy_seq2seq/python/ops/seq2seq.py#L537\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import variable_scope\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import nn_ops\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.ops import init_ops\nfrom tensorflow.python.framework import constant_op\n\nimport tensorflow as tf\n\n\nclass Linear:\n    \"\"\"Linear map: sum_i(args[i] * W[i]), where W[i] is a variable.\n  Args:\n    args: a 2D Tensor or a list of 2D, batch, n, Tensors.\n    output_size: int, second dimension of weight variable.\n    dtype: data type for variables.\n    build_bias: boolean, whether to build a bias variable.\n    bias_initializer: starting value to initialize the bias\n      (default is all zeros).\n    kernel_initializer: starting value to initialize the weight.\n  Raises:\n    ValueError: if inputs_shape is wrong.\n  \"\"\"\n\n    def __init__(self,\n                 args,\n                 output_size,\n                 build_bias,\n                 bias_initializer=None,\n                 kernel_initializer=None):\n        self._build_bias = build_bias\n\n        if args is None or (nest.is_sequence(args) and not args):\n            raise ValueError(\"`args` must be specified\")\n        if not nest.is_sequence(args):\n            args = [args]\n            self._is_sequence = False\n        else:\n            self._is_sequence = True\n\n        # Calculate the total size of arguments on dimension 1.\n        total_arg_size = 0\n        shapes = [a.get_shape() for a in args]\n        for shape in shapes:\n            if shape.ndims != 2:\n                raise ValueError(\"linear is expecting 2D arguments: %s\" % shapes)\n            if shape.dims[1].value is None:\n                raise ValueError(\"linear expects shape[1] to be provided for shape %s, \"\n                                 \"but saw %s\" % (shape, shape[1]))\n            else:\n                total_arg_size += shape.dims[1].value\n\n        dtype = [a.dtype for a in args][0]\n\n        scope = variable_scope.get_variable_scope()\n        with variable_scope.variable_scope(scope) as outer_scope:\n            self._weights = variable_scope.get_variable(\n                'weights', [total_arg_size, output_size],\n                dtype=dtype,\n                initializer=kernel_initializer)\n            if build_bias:\n                with variable_scope.variable_scope(outer_scope) as inner_scope:\n                    inner_scope.set_partitioner(None)\n                    if bias_initializer is None:\n                        bias_initializer = init_ops.constant_initializer(0.0, dtype=dtype)\n                    self._biases = variable_scope.get_variable(\n                        'bias', [output_size],\n                        dtype=dtype,\n                        initializer=bias_initializer)\n\n    def __call__(self, args):\n        if not self._is_sequence:\n            args = [args]\n\n        if len(args) == 1:\n            res = math_ops.matmul(args[0], self._weights)\n        else:\n            # Explicitly creating a one for a minor performance improvement.\n            one = constant_op.constant(1, dtype=dtypes.int32)\n            res = math_ops.matmul(array_ops.concat(args, one), self._weights)\n        if self._build_bias:\n            res = nn_ops.bias_add(res, self._biases)\n        return res\n\n\ndef attention_decoder(decoder_inputs,\n                      initial_state,\n                      attention_states,\n                      cell,\n                      output_size=None,\n                      num_heads=1,\n                      loop_function=None,\n                      dtype=None,\n                      scope=None,\n                      initial_state_attention=False):\n    \"\"\"RNN decoder with attention for the sequence-to-sequence model.\n  In this context \"attention\" means that, during decoding, the RNN can look up\n  information in the additional tensor attention_states, and it does this by\n  focusing on a few entries from the tensor. This model has proven to yield\n  especially good results in a number of sequence-to-sequence tasks. This\n  implementation is based on http://arxiv.org/abs/1412.7449 (see below for\n  details). It is recommended for complex sequence-to-sequence tasks.\n  Args:\n    decoder_inputs: A list of 2D Tensors [batch_size x input_size].\n    initial_state: 2D Tensor [batch_size x cell.state_size].\n    attention_states: 3D Tensor [batch_size x attn_length x attn_size].\n    cell: tf.compat.v1.nn.rnn_cell.RNNCell defining the cell function and size.\n    output_size: Size of the output vectors; if None, we use cell.output_size.\n    num_heads: Number of attention heads that read from attention_states.\n    loop_function: If not None, this function will be applied to i-th output in\n      order to generate i+1-th input, and decoder_inputs will be ignored, except\n      for the first element (\"GO\" symbol). This can be used for decoding,\n      but also for training to emulate http://arxiv.org/abs/1506.03099.\n        Signature -- loop_function(prev, i) = next * prev is a 2D Tensor of\n        shape [batch_size x output_size], * i is an integer, the step number\n        (when advanced control is needed), * next is a 2D Tensor of shape\n        [batch_size x input_size].\n    dtype: The dtype to use for the RNN initial state (default: tf.float32).\n    scope: VariableScope for the created subgraph; default: \"attention_decoder\".\n    initial_state_attention: If False (default), initial attentions are zero. If\n      True, initialize the attentions from the initial state and attention\n      states -- useful when we wish to resume decoding from a previously stored\n      decoder state and attention states.\n  Returns:\n    A tuple of the form (outputs, state), where:\n      outputs: A list of the same length as decoder_inputs of 2D Tensors of\n        shape [batch_size x output_size]. These represent the generated outputs.\n        Output i is computed from input i (which is either the i-th element\n        of decoder_inputs or loop_function(output {i-1}, i)) as follows.\n        First, we run the cell on a combination of the input and previous\n        attention masks:\n          cell_output, new_state = cell(linear(input, prev_attn), prev_state).\n        Then, we calculate new attention masks:\n          new_attn = softmax(V^T * tanh(W * attention_states + U * new_state))\n        and then we calculate the output:\n          output = linear(cell_output, new_attn).\n      state: The state of each decoder cell the final time-step.\n        It is a 2D Tensor of shape [batch_size x cell.state_size].\n  Raises:\n    ValueError: when num_heads is not positive, there are no inputs, shapes\n      of attention_states are not set, or input size cannot be inferred\n      from the input.\n  \"\"\"\n    if not decoder_inputs:\n        raise ValueError(\"Must provide at least 1 input to attention decoder.\")\n    if num_heads < 1:\n        raise ValueError(\"With less than 1 heads, use a non-attention decoder.\")\n    if attention_states.get_shape()[2] is None:\n        raise ValueError(\"Shape[2] of attention_states must be known: %s\" %\n                         attention_states.get_shape())\n    if output_size is None:\n        output_size = cell.output_size\n\n    with variable_scope.variable_scope(\n            scope or \"attention_decoder\", dtype=dtype) as scope:\n        dtype = scope.dtype\n\n        batch_size = array_ops.shape(decoder_inputs[0])[0]  # Needed for reshaping.\n        attn_length = attention_states.get_shape()[1]\n        if attn_length is None:\n            attn_length = array_ops.shape(attention_states)[1]\n        attn_size = attention_states.get_shape()[2]\n\n        # To calculate W1 * h_t we use a 1-by-1 convolution, need to reshape before.\n        hidden = array_ops.reshape(attention_states,\n                                   [-1, attn_length, 1, attn_size])\n        hidden_features = []\n        v = []\n        attention_vec_size = attn_size  # Size of query vectors for attention.\n        for a in range(num_heads):\n            k = variable_scope.get_variable(\n                \"AttnW_%d\" % a, [1, 1, attn_size, attention_vec_size], dtype=dtype)\n            hidden_features.append(nn_ops.conv2d(hidden, k, [1, 1, 1, 1], \"SAME\"))\n            v.append(\n                variable_scope.get_variable(\n                    \"AttnV_%d\" % a, [attention_vec_size], dtype=dtype))\n\n        state = initial_state\n\n        def attention(query):\n            \"\"\"Put attention masks on hidden using hidden_features and query.\"\"\"\n            ds = []  # Results of attention reads will be stored here.\n            if nest.is_sequence(query):  # If the query is a tuple, flatten it.\n                query_list = nest.flatten(query)\n                for q in query_list:  # Check that ndims == 2 if specified.\n                    ndims = q.get_shape().ndims\n                    if ndims:\n                        assert ndims == 2\n                <line_mask>\n            for a in range(num_heads):\n                with variable_scope.variable_scope(\"Attention_%d\" % a):\n                    y = Linear(query, attention_vec_size, True)(query)\n                    y = array_ops.reshape(y, [-1, 1, 1, attention_vec_size])\n                    y = math_ops.cast(y, dtype)\n                    # Attention mask is a softmax of v^T * tanh(...).\n                    s = math_ops.reduce_sum(v[a] * math_ops.tanh(hidden_features[a] + y),\n                                            [2, 3])\n                    a = nn_ops.softmax(math_ops.cast(s, dtype=dtypes.float32))\n                    # Now calculate the attention-weighted vector d.\n                    a = math_ops.cast(a, dtype)\n                    d = math_ops.reduce_sum(\n                        array_ops.reshape(a, [-1, attn_length, 1, 1]) * hidden, [1, 2])\n                    ds.append(array_ops.reshape(d, [-1, attn_size]))\n            return ds\n\n        outputs = []\n        prev = None\n        batch_attn_size = array_ops.stack([batch_size, attn_size])\n        attns = [\n            array_ops.zeros(batch_attn_size, dtype=dtype) for _ in range(num_heads)\n        ]\n        for a in attns:  # Ensure the second shape of attention vectors is set.\n            a.set_shape([None, attn_size])\n        if initial_state_attention:\n            attns = attention(initial_state)\n        for i, inp in enumerate(decoder_inputs):\n            if i > 0:\n                variable_scope.get_variable_scope().reuse_variables()\n            # If loop_function is set, we use it instead of decoder_inputs.\n            if loop_function is not None and prev is not None:\n                with variable_scope.variable_scope(\"loop_function\", reuse=True):\n                    inp = loop_function(prev, i)\n            # Merge input and previous attentions into one vector of the right size.\n            input_size = inp.get_shape().with_rank(2)[1]\n            if input_size is None:\n                raise ValueError(\"Could not infer input size from input: %s\" % inp.name)\n\n            inputs = [inp] + attns\n            inputs = [math_ops.cast(e, dtype) for e in inputs]\n            x = Linear(inputs, input_size, True)(inputs)\n            # Run the RNN.\n            cell_output, state = cell(x, state)\n            # Run the attention mechanism.\n            if i == 0 and initial_state_attention:\n                with variable_scope.variable_scope(\n                        variable_scope.get_variable_scope(), reuse=True):\n                    attns = attention(state)\n            else:\n                attns = attention(state)\n\n            with variable_scope.variable_scope(\"AttnOutputProjection\"):\n                cell_output = math_ops.cast(cell_output, dtype)\n                inputs = [cell_output] + attns\n                output = Linear(inputs, output_size, True)(inputs)\n            if loop_function is not None:\n                prev = output\n            outputs.append(output)\n\n    return outputs, state\n\n\nif __name__ == \"__main__\":\n    _outputs, _state = attention_decoder([tf.ones((1, 1))],\n                                         tf.ones((1, 1)),\n                                         tf.ones((1, 1, 1)),\n                                         tf.compat.v1.nn.rnn_cell.BasicRNNCell(1))\n    print(_outputs, _state)",
            "masked_line": "query = array_ops.concat(query_list, 1)",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_893"
        },
        {
            "dependency": "geopandas",
            "version": ">=0.11",
            "time": "2022-09-14",
            "description": "The code reads two geospatial datasets from online sources, shards the second dataset into a dictionary based on a specified attribute, and then performs a spatial join operation based on the attribute values between the two datasets to create a new dataset.",
            "code": "import geopandas as gpd\n\n\ndf1 = gpd.read_file(\"https://github.com/gracedoherty/urban_growth/blob/main/df1.zip?raw=true\")\ndf2 = gpd.read_file(\"https://github.com/gracedoherty/urban_growth/blob/main/df2.zip?raw=true\")\n\n# shard the smaller dataframe into a dict\nshards = {k:d for k, d in df2.groupby(\"ADM\")}\n\n# now just group by ADM, sjoin_nearest appropriate shard\ndf_n = df1.groupby(\"ADM\").apply(lambda d: gpd.sjoin_nearest(d, shards[d[\"ADM\"].values[0]]))\n\ndf_n.sample(5, random_state=42)",
            "masked_code": "import geopandas as gpd\n\n\ndf1 = gpd.read_file(\"https://github.com/gracedoherty/urban_growth/blob/main/df1.zip?raw=true\")\ndf2 = gpd.read_file(\"https://github.com/gracedoherty/urban_growth/blob/main/df2.zip?raw=true\")\n\n# shard the smaller dataframe into a dict\n<line_mask>\n\n# now just group by ADM, sjoin_nearest appropriate shard\ndf_n = df1.groupby(\"ADM\").apply(lambda d: gpd.sjoin_nearest(d, shards[d[\"ADM\"].values[0]]))\n\ndf_n.sample(5, random_state=42)",
            "masked_line": "shards = {k:d for k, d in df2.groupby(\"ADM\")}",
            "answer": "groupby",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_894"
        },
        {
            "dependency": "numba",
            "version": "==0.55.1",
            "time": "2022-04-07",
            "description": "The function fills a 2D array with values based on column indices provided.",
            "code": "import numba as nb\n\n@nb.njit(parallel=False) # Try parallel=True for multi-threaded execution, no speed up in my benchmarks \ndef fill(val, ids):\n    res = np.zeros(ids.shape[::-1])\n    for i in nb.prange(len(res)):\n        for j in range(res.shape[1]):\n            res[i, ids[j,i]] += val[j]\n    return res\n\nfill(values, col_ids)",
            "masked_code": "import numba as nb\n\n@nb.njit(parallel=False) # Try parallel=True for multi-threaded execution, no speed up in my benchmarks \ndef fill(val, ids):\n    res = np.zeros(ids.shape[::-1])\n    <line_mask>\n        for j in range(res.shape[1]):\n            res[i, ids[j,i]] += val[j]\n    return res\n\nfill(values, col_ids)",
            "masked_line": "for i in nb.prange(len(res)):",
            "answer": "prange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_895"
        },
        {
            "dependency": "scikit-learn",
            "version": "==1.1.dev0",
            "time": "2022-04-11",
            "description": "The code performs data preprocessing and model training using Elastic Net regression on a dataset containing information about cities, book titles, expert ratings, and user ratings. The data is preprocessed by encoding categorical variables and scaling numerical variables before fitting an Elastic Net regression model with specified parameters.",
            "code": "import pandas as pd\nimport numpy as np\nfrom sklearn.preprocessing import OneHotEncoder, MinMaxScaler\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.compose import make_column_selector, make_column_transformer\nfrom sklearn.linear_model import ElasticNet\n\nX = pd.DataFrame({'city': ['London', 'London', 'Paris', 'Sallisaw', ''],\n              'title': ['His Last Bow', 'How Watson Learned the Trick', 'A Moveable Feast', 'The Grapes of Wrath', 'The Jungle'],\n              'expert_rating': [5, 3, 4, 5, 3],\n              'user_rating': [4, 5, 4, 2, 3]})\n\n# Pipeline 1\ncat_selector = make_column_selector(dtype_include=object)\nnum_selector = make_column_selector(dtype_include=np.number)\n\ncat_linear_processor = OneHotEncoder(handle_unknown=\"ignore\", drop='first', sparse=False)\nnum_linear_processor = make_pipeline(SimpleImputer(strategy=\"median\", add_indicator=True), MinMaxScaler(feature_range=(-1,1)))\n\nlinear_preprocessor = make_column_transformer( (num_linear_processor, num_selector), (cat_linear_processor, cat_selector) )\n\nmodel_params ={\n    'alpha': 0.0013879181970625643,\n    'l1_ratio': 0.9634269882730605,\n    'fit_intercept': True,\n    'normalize': False,\n    'max_iter': 245,\n    'tol': 0.01855761485447601,\n    'positive': False,\n    'selection': 'random'}\nmodel = ElasticNet(**model_params)\n\npipeline = make_pipeline(linear_preprocessor, model)\npipeline.fit(X.iloc[:, :-1], X.iloc[:, -1])\n\npipeline[:-1].get_feature_names_out()",
            "masked_code": "import pandas as pd\nimport numpy as np\nfrom sklearn.preprocessing import OneHotEncoder, MinMaxScaler\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.compose import make_column_selector, make_column_transformer\n<line_mask>\n\nX = pd.DataFrame({'city': ['London', 'London', 'Paris', 'Sallisaw', ''],\n              'title': ['His Last Bow', 'How Watson Learned the Trick', 'A Moveable Feast', 'The Grapes of Wrath', 'The Jungle'],\n              'expert_rating': [5, 3, 4, 5, 3],\n              'user_rating': [4, 5, 4, 2, 3]})\n\n# Pipeline 1\ncat_selector = make_column_selector(dtype_include=object)\nnum_selector = make_column_selector(dtype_include=np.number)\n\ncat_linear_processor = OneHotEncoder(handle_unknown=\"ignore\", drop='first', sparse=False)\nnum_linear_processor = make_pipeline(SimpleImputer(strategy=\"median\", add_indicator=True), MinMaxScaler(feature_range=(-1,1)))\n\nlinear_preprocessor = make_column_transformer( (num_linear_processor, num_selector), (cat_linear_processor, cat_selector) )\n\nmodel_params ={\n    'alpha': 0.0013879181970625643,\n    'l1_ratio': 0.9634269882730605,\n    'fit_intercept': True,\n    'normalize': False,\n    'max_iter': 245,\n    'tol': 0.01855761485447601,\n    'positive': False,\n    'selection': 'random'}\nmodel = ElasticNet(**model_params)\n\npipeline = make_pipeline(linear_preprocessor, model)\npipeline.fit(X.iloc[:, :-1], X.iloc[:, -1])\n\npipeline[:-1].get_feature_names_out()",
            "masked_line": "from sklearn.linear_model import ElasticNet",
            "answer": "ElasticNet",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_896"
        },
        {
            "dependency": "tensorflow-io",
            "version": "==0.24.0",
            "time": "2022-04-21",
            "description": "The code reads TIFF image files from the current directory, decodes them, separates them into RGB channels, stacks the channels, and prints the shapes of the processed images.",
            "code": "import numpy as np\nfrom PIL import Image\nimport tensorflow as tf\nimport tensorflow_io as tfio\nimport os\n\n# Create dummy data\ndata = np.random.randint(0, 255, (10,10)).astype(np.uint8)\nim = Image.fromarray(data)\nim.save('image1.tif')\nim.save('image2.tif')\n\ndef process_image(image):\n\n  image = tf.io.read_file(image)\n  image = tfio.experimental.image.decode_tiff(image)\n  r, g, b = image[:, :, 0], image[:, :, 1], image[:, :, 2]\n  return tf.stack([r, g, b], axis=-1)\n\npath = os.path.join(os.curdir, '*.tif')\nfiles = tf.data.Dataset.list_files(path)\n\nfor file in files.take(5):\n  print(file)\n\ndataset = files.map(process_image, num_parallel_calls=tf.data.experimental.AUTOTUNE)\nfor img in dataset.take(5):\n  print(img.shape)",
            "masked_code": "import numpy as np\nfrom PIL import Image\nimport tensorflow as tf\nimport tensorflow_io as tfio\nimport os\n\n# Create dummy data\ndata = np.random.randint(0, 255, (10,10)).astype(np.uint8)\nim = Image.fromarray(data)\nim.save('image1.tif')\nim.save('image2.tif')\n\ndef process_image(image):\n\n  image = tf.io.read_file(image)\n  image = tfio.experimental.image.decode_tiff(image)\n  <line_mask>\n  return tf.stack([r, g, b], axis=-1)\n\npath = os.path.join(os.curdir, '*.tif')\nfiles = tf.data.Dataset.list_files(path)\n\nfor file in files.take(5):\n  print(file)\n\ndataset = files.map(process_image, num_parallel_calls=tf.data.experimental.AUTOTUNE)\nfor img in dataset.take(5):\n  print(img.shape)",
            "masked_line": "r, g, b = image[:, :, 0], image[:, :, 1], image[:, :, 2]",
            "answer": "image",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_897"
        },
        {
            "dependency": "click",
            "version": "==8.1.x",
            "time": "2022-08-22",
            "description": "This code is testing the functionality of listing all \"foos\" with a specific command by using Click library for command line interfaces in Python.",
            "code": "from click.testing import CliRunner\n# ...\n\n\ndef test_foo_list():\n    runner = CliRunner()\n    result = runner.invoke(commands.get_all_foos, [\"ctm\", \"10\"])\n    response = result.return_value",
            "masked_code": "from click.testing import CliRunner\n# ...\n\n\ndef test_foo_list():\n    runner = CliRunner()\n    <line_mask>\n    response = result.return_value",
            "masked_line": "result = runner.invoke(commands.get_all_foos, [\"ctm\", \"10\"])",
            "answer": "invoke",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_898"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.4",
            "time": "2022-04-03",
            "description": "The code creates a pandas DataFrame from a NumPy array, converts the data type to complex64, and applies a rolling window function with a window size of 3 to print the results.",
            "code": "import pandas as pd\nimport numpy as np\n\na=np.array([[1+0j,2+0j,3+0j],[4j,5j,10+6j]])\npd.DataFrame(a.T).astype(np.complex64).rolling(3).apply(lambda x: print(x) is None)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\na=np.array([[1+0j,2+0j,3+0j],[4j,5j,10+6j]])\n<line_mask>",
            "masked_line": "pd.DataFrame(a.T).astype(np.complex64).rolling(3).apply(lambda x: print(x) is None)",
            "answer": "astype",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_899"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.1",
            "time": "2022-04-12",
            "description": "This code creates two DataFrames, df and df1, where df contains columns 'poi_name', 'column_1', 'column_2', 'column_3', 'column_4' and df1 contains columns 'poi_name', 'column_1', 'column_3', 'column_5'. Both DataFrames are then set_index to 'poi_name' and filled with values from df1 where there are missing values in df. Finally, the filled DataFrame df is printed.",
            "code": "from numpy import nan\ndf = pd.DataFrame({'poi_name': ['block', 'block'],\n                   'column_1': ['uts', 'utr'],\n                   'column_2': [nan, nan],\n                   'column_3': [nan, nan],\n                   'column_4': ['tyi', 'tyi']})\n\ndf1 = pd.DataFrame({'poi_name': ['block'],\n                    'column_1': ['uta'],\n                    'column_3': ['yuw'],\n                    'column_5': ['tyu']})\n\ndf = df.set_index('poi_name')\ndf1 = df1.set_index('poi_name')\ndf = df.fillna(df1)\n\nprint(df)",
            "masked_code": "from numpy import nan\ndf = pd.DataFrame({'poi_name': ['block', 'block'],\n                   'column_1': ['uts', 'utr'],\n                   'column_2': [nan, nan],\n                   'column_3': [nan, nan],\n                   'column_4': ['tyi', 'tyi']})\n\n<line_mask>\n                    'column_1': ['uta'],\n                    'column_3': ['yuw'],\n                    'column_5': ['tyu']})\n\ndf = df.set_index('poi_name')\ndf1 = df1.set_index('poi_name')\ndf = df.fillna(df1)\n\nprint(df)",
            "masked_line": "df1 = pd.DataFrame({'poi_name': ['block'],",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_900"
        },
        {
            "dependency": "cartopy",
            "version": "==0.19",
            "time": "2022-10-09",
            "description": "This code plots a map using Cartopy with a North Polar Stereographic projection. It adds coastlines, grid lines, and a circular boundary to the map. Additionally, it repositions tick labels at the 150th meridian to 180 degrees for better visualization.",
            "code": "import cartopy.crs as ccrs      #cartopy v0.19\nimport matplotlib.pyplot as plt\nimport matplotlib.path as mpath\nimport numpy as np\n\n# Value for r_extent is obtained by trial and error\n# get it with `ax.get_ylim()` after running this code\nr_extent = 4651194.319\nr_extent *= 1.005       #increase a bit for better result\n\n# Projection settings  \nlonlat_proj = ccrs.PlateCarree()\nuse_proj = ccrs.NorthPolarStereo(central_longitude=0)\nfig = plt.figure(figsize=[7, 7])\nax = plt.subplot(1, 1, 1, projection=use_proj)\nax.set_extent([-180, 180, 50, 90], lonlat_proj)\n\n#ax.stock_img() # add bluemarble image\nax.coastlines(lw=0.5, color=\"black\", zorder=20) # add coastlines\n\n# draw graticule (meridian and parallel lines)\ngls = ax.gridlines(draw_labels=True, crs=lonlat_proj, lw=1, color=\"gray\",\n        y_inline=True, xlocs=range(-180,180,30), ylocs=range(0,90,10))\n\n# set the plot limits\nax.set_xlim(-r_extent, r_extent)\nax.set_ylim(-r_extent, r_extent)\n\n# Prep circular boundary\ncircle_path = mpath.Path.unit_circle()\ncircle_path = mpath.Path(circle_path.vertices.copy() * r_extent,\n                           circle_path.codes.copy())\n\n#set circular boundary\n#this method will not interfere with the gridlines' labels \nax.set_boundary(circle_path)\nax.set_frame_on(False)  #hide the boundary frame\n\nplt.draw()  # Enable the use of `gl._labels`\n\n# Reposition the tick labels\n# Labels at 150d meridian will be moved to 180d\nfor ea in gls._labels:\n    # No _labels if not run `plt.draw()`\n    pos = ea[2].get_position()\n    #print(\"Position:\", pos[0], pos[1])\n    if (pos[0]==150):\n        ea[2].set_position([180, pos[1]])\n\nplt.show()",
            "masked_code": "import cartopy.crs as ccrs      #cartopy v0.19\nimport matplotlib.pyplot as plt\nimport matplotlib.path as mpath\nimport numpy as np\n\n# Value for r_extent is obtained by trial and error\n# get it with `ax.get_ylim()` after running this code\nr_extent = 4651194.319\nr_extent *= 1.005       #increase a bit for better result\n\n# Projection settings  \nlonlat_proj = ccrs.PlateCarree()\n<line_mask>\nfig = plt.figure(figsize=[7, 7])\nax = plt.subplot(1, 1, 1, projection=use_proj)\nax.set_extent([-180, 180, 50, 90], lonlat_proj)\n\n#ax.stock_img() # add bluemarble image\nax.coastlines(lw=0.5, color=\"black\", zorder=20) # add coastlines\n\n# draw graticule (meridian and parallel lines)\ngls = ax.gridlines(draw_labels=True, crs=lonlat_proj, lw=1, color=\"gray\",\n        y_inline=True, xlocs=range(-180,180,30), ylocs=range(0,90,10))\n\n# set the plot limits\nax.set_xlim(-r_extent, r_extent)\nax.set_ylim(-r_extent, r_extent)\n\n# Prep circular boundary\ncircle_path = mpath.Path.unit_circle()\ncircle_path = mpath.Path(circle_path.vertices.copy() * r_extent,\n                           circle_path.codes.copy())\n\n#set circular boundary\n#this method will not interfere with the gridlines' labels \nax.set_boundary(circle_path)\nax.set_frame_on(False)  #hide the boundary frame\n\nplt.draw()  # Enable the use of `gl._labels`\n\n# Reposition the tick labels\n# Labels at 150d meridian will be moved to 180d\nfor ea in gls._labels:\n    # No _labels if not run `plt.draw()`\n    pos = ea[2].get_position()\n    #print(\"Position:\", pos[0], pos[1])\n    if (pos[0]==150):\n        ea[2].set_position([180, pos[1]])\n\nplt.show()",
            "masked_line": "use_proj = ccrs.NorthPolarStereo(central_longitude=0)",
            "answer": "NorthPolarStereo",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_901"
        },
        {
            "dependency": "streamlit",
            "version": "==1.14.0",
            "time": "2022-11-01",
            "description": "The code generates a bar chart using the Altair library in Streamlit, where the data is grouped based on date and group, and the counts are displayed on the y-axis for each group.",
            "code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\n<line_mask>",
            "masked_line": "st.altair_chart(c) #, use_container_width=True)",
            "answer": "altair_chart",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_902"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.1",
            "time": "2022-11-01",
            "description": "The code creates a DataFrame with columns 'mydate', 'mygroup' and 'mydate2' by generating dates and groups. It then groups the data by 'mydate2' and 'mygroup', counts the occurrences, and visualizes the data using Altair with a bar chart showing the count of each group per month on the x-axis and the number of occurrences on the y-axis.",
            "code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\n<line_mask>\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_line": "df2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})",
            "answer": "reset_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_903"
        },
        {
            "dependency": "altair",
            "version": "==4.2.0",
            "time": "2022-11-01",
            "description": "The code generates a bar chart using Altair to display the count of occurrences of different groups over time. The chart uses a DataFrame that includes dates, groups, and counts, and it groups the data by a specific date format. The chart is displayed using Streamlit.",
            "code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\n<line_mask>\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_line": "c = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(",
            "answer": "mark_bar",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_904"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.5.2",
            "time": "2022-07-01",
            "description": "The code creates a scatter plot using matplotlib library, where x and y values are plotted with different colors indicated by the z values. The plot has customized features like linewidths, alpha, edgecolor, and size. The plot includes a legend indicating the colors used in the plot.",
            "code": "import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4, 5]\ny = [1, 2, 3, 4, 5]\nz = [3, 8.5, 2.1, 1.8, 9]\n\nfig1, ax1 = plt.subplots()\nscat = ax1.scatter(x, y, linewidths=1, alpha = .7, edgecolor= 'k', s=200, c=z)\nax1.legend(*scat.legend_elements(), title=\"Colors\")\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4, 5]\ny = [1, 2, 3, 4, 5]\nz = [3, 8.5, 2.1, 1.8, 9]\n\nfig1, ax1 = plt.subplots()\nscat = ax1.scatter(x, y, linewidths=1, alpha = .7, edgecolor= 'k', s=200, c=z)\n<line_mask>\n\nplt.show()",
            "masked_line": "ax1.legend(*scat.legend_elements(), title=\"Colors\")",
            "answer": "legend",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_905"
        },
        {
            "dependency": "datasets",
            "version": "==1.1.1",
            "time": "2022-12-13",
            "description": "The code creates a dataset object containing 100 images with each image represented as a 512x512x3 tensor and associated with the caption 'hello'.",
            "code": "img_tensor = np.zeros((100, 512, 512, 3))\ncaptions = []\nfor i in range(100):\n  captions.append('hello')\ncaptioned_imgs = {\n    'images': img_tensor,\n    'text': captions\n}\nfrom datasets import Dataset\nout = Dataset.from_dict(captioned_imgs)\nprint(type(out))",
            "masked_code": "img_tensor = np.zeros((100, 512, 512, 3))\ncaptions = []\nfor i in range(100):\n  captions.append('hello')\ncaptioned_imgs = {\n    'images': img_tensor,\n    'text': captions\n}\nfrom datasets import Dataset\n<line_mask>\nprint(type(out))",
            "masked_line": "out = Dataset.from_dict(captioned_imgs)",
            "answer": "from_dict",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_906"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.6.2",
            "time": "2022-12-30",
            "description": "The function calculates the distance matrix between zip codes based on their geographical coordinates and population density, and visualizes the distances using a heatmap.",
            "code": "from scipy.spatial.distance import pdist, squareform\nfrom uszipcode import SearchEngine\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n\ndef distance_matrix(df: pd.DataFrame, metric=\"euclidean\"):\n    df = df[[\"zipcode\", \"lat\", \"lng\", \"population_density\"]]\n    df = df.sort_values(by=[\"zipcode\"])\n    print(df)\n    dist = pdist(df, metric)\n    dist = squareform(dist)\n    sns.heatmap(dist, cmap=\"mako\")\n    print(dist)\n    plt.show()\n\n\ndef get_df() -> pd.DataFrame:\n    zips = SearchEngine().by_population_density(lower=100, returns=11_000)\n    df = pd.DataFrame(z.to_dict() for z in zips)\n    df[\"zipcode\"] = df.zipcode.astype(int)\n    return df\n\n\ndistance_matrix(get_df())",
            "masked_code": "from scipy.spatial.distance import pdist, squareform\nfrom uszipcode import SearchEngine\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n\ndef distance_matrix(df: pd.DataFrame, metric=\"euclidean\"):\n    df = df[[\"zipcode\", \"lat\", \"lng\", \"population_density\"]]\n    df = df.sort_values(by=[\"zipcode\"])\n    print(df)\n    dist = pdist(df, metric)\n    dist = squareform(dist)\n    sns.heatmap(dist, cmap=\"mako\")\n    print(dist)\n    <line_mask>\n\n\ndef get_df() -> pd.DataFrame:\n    zips = SearchEngine().by_population_density(lower=100, returns=11_000)\n    df = pd.DataFrame(z.to_dict() for z in zips)\n    df[\"zipcode\"] = df.zipcode.astype(int)\n    return df\n\n\ndistance_matrix(get_df())",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_907"
        },
        {
            "dependency": "scipy",
            "version": "==1.9.3",
            "time": "2022-12-30",
            "description": "The function calculates the distance matrix between zip codes based on their latitude, longitude, and population density, and then visualizes the matrix using a heatmap.",
            "code": "from scipy.spatial.distance import pdist, squareform\nfrom uszipcode import SearchEngine\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n\ndef distance_matrix(df: pd.DataFrame, metric=\"euclidean\"):\n    df = df[[\"zipcode\", \"lat\", \"lng\", \"population_density\"]]\n    df = df.sort_values(by=[\"zipcode\"])\n    print(df)\n    dist = pdist(df, metric)\n    dist = squareform(dist)\n    sns.heatmap(dist, cmap=\"mako\")\n    print(dist)\n    plt.show()\n\n\ndef get_df() -> pd.DataFrame:\n    zips = SearchEngine().by_population_density(lower=100, returns=11_000)\n    df = pd.DataFrame(z.to_dict() for z in zips)\n    df[\"zipcode\"] = df.zipcode.astype(int)\n    return df\n\n\ndistance_matrix(get_df())",
            "masked_code": "from scipy.spatial.distance import pdist, squareform\nfrom uszipcode import SearchEngine\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n\ndef distance_matrix(df: pd.DataFrame, metric=\"euclidean\"):\n    df = df[[\"zipcode\", \"lat\", \"lng\", \"population_density\"]]\n    df = df.sort_values(by=[\"zipcode\"])\n    print(df)\n    dist = pdist(df, metric)\n    <line_mask>\n    sns.heatmap(dist, cmap=\"mako\")\n    print(dist)\n    plt.show()\n\n\ndef get_df() -> pd.DataFrame:\n    zips = SearchEngine().by_population_density(lower=100, returns=11_000)\n    df = pd.DataFrame(z.to_dict() for z in zips)\n    df[\"zipcode\"] = df.zipcode.astype(int)\n    return df\n\n\ndistance_matrix(get_df())",
            "masked_line": "dist = squareform(dist)",
            "answer": "squareform",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_908"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.1",
            "time": "2022-12-30",
            "description": "The function calculates the distance matrix between zip codes based on their latitude, longitude, and population density, and visualizes the distances using a heatmap.",
            "code": "from scipy.spatial.distance import pdist, squareform\nfrom uszipcode import SearchEngine\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n\ndef distance_matrix(df: pd.DataFrame, metric=\"euclidean\"):\n    df = df[[\"zipcode\", \"lat\", \"lng\", \"population_density\"]]\n    df = df.sort_values(by=[\"zipcode\"])\n    print(df)\n    dist = pdist(df, metric)\n    dist = squareform(dist)\n    sns.heatmap(dist, cmap=\"mako\")\n    print(dist)\n    plt.show()\n\n\ndef get_df() -> pd.DataFrame:\n    zips = SearchEngine().by_population_density(lower=100, returns=11_000)\n    df = pd.DataFrame(z.to_dict() for z in zips)\n    df[\"zipcode\"] = df.zipcode.astype(int)\n    return df\n\n\ndistance_matrix(get_df())",
            "masked_code": "from scipy.spatial.distance import pdist, squareform\nfrom uszipcode import SearchEngine\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n\ndef distance_matrix(df: pd.DataFrame, metric=\"euclidean\"):\n    df = df[[\"zipcode\", \"lat\", \"lng\", \"population_density\"]]\n    df = df.sort_values(by=[\"zipcode\"])\n    print(df)\n    dist = pdist(df, metric)\n    dist = squareform(dist)\n    <line_mask>\n    print(dist)\n    plt.show()\n\n\ndef get_df() -> pd.DataFrame:\n    zips = SearchEngine().by_population_density(lower=100, returns=11_000)\n    df = pd.DataFrame(z.to_dict() for z in zips)\n    df[\"zipcode\"] = df.zipcode.astype(int)\n    return df\n\n\ndistance_matrix(get_df())",
            "masked_line": "sns.heatmap(dist, cmap=\"mako\")",
            "answer": "heatmap",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_909"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2022-11-29",
            "description": "This code creates a DataFrame with columns \"weight_KG\", \"UpperBoundary\", and \"LowerBoundary\" using lists of values. It then filters the DataFrame to select rows where the \"weight_KG\" value is within the range defined by the \"UpperBoundary\" and \"LowerBoundary\" columns. Finally, it prints the filtered DataFrame and the version of pandas used.",
            "code": "import pandas as pd\n\n# Build DataFrame\nnames = [\"weight_KG\", \"UpperBoundary\", \"LowerBoundary\"]\nweight_KG = [23.2, 55.2, 44.2, 47.8, 38.7, 0]\nUpperBoundary = [30, 40, 50, 50, 30, 20]\nLowerBoundary = [20, 30, 40, 40, 20, 10]\n\ndict = {\n    \"weight_KG\": weight_KG,\n    \"UpperBoundary\": UpperBoundary,\n    \"LowerBoundary\": LowerBoundary,\n}\ndf1 = pd.DataFrame(dict)\n\ndf2 = df1[\n    (df1[\"weight_KG\"] <= df1[\"UpperBoundary\"])\n    & (df1[\"weight_KG\"] >= df1[\"LowerBoundary\"])\n]\nprint(df2)\nprint(pd.__version__)",
            "masked_code": "import pandas as pd\n\n# Build DataFrame\nnames = [\"weight_KG\", \"UpperBoundary\", \"LowerBoundary\"]\nweight_KG = [23.2, 55.2, 44.2, 47.8, 38.7, 0]\nUpperBoundary = [30, 40, 50, 50, 30, 20]\nLowerBoundary = [20, 30, 40, 40, 20, 10]\n\ndict = {\n    \"weight_KG\": weight_KG,\n    \"UpperBoundary\": UpperBoundary,\n    \"LowerBoundary\": LowerBoundary,\n}\n<line_mask>\n\ndf2 = df1[\n    (df1[\"weight_KG\"] <= df1[\"UpperBoundary\"])\n    & (df1[\"weight_KG\"] >= df1[\"LowerBoundary\"])\n]\nprint(df2)\nprint(pd.__version__)",
            "masked_line": "df1 = pd.DataFrame(dict)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_910"
        },
        {
            "dependency": "requests",
            "version": "==2.24.0",
            "time": "2022-03-25",
            "description": "This code is used to check the validity of SSL certificates for specified hostnames and ports. It includes functions to retrieve and check the expiration date of SSL certificates, as well as a main block to print information about Python version, OpenSSL version, and requests version. The code iterates through a list of hostnames, sends HTTPS requests to each, and prints whether the certificate is expired or if there was an error during the request.",
            "code": "import ssl\nimport requests\nimport platform\nfrom datetime import datetime\nfrom cryptography import x509\n\n\ndef get_cert_for_hostname(hostname, port):\n    conn = ssl.create_connection((hostname, port))\n    context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n    sock = context.wrap_socket(conn, server_hostname=hostname)\n    certDER = sock.getpeercert(True)\n    certPEM = ssl.DER_cert_to_PEM_cert(certDER)\n    conn.close()\n    return x509.load_pem_x509_certificate(certPEM.encode('ascii'))\n\n\ndef is_cert_expired(hostname, port):\n    cert = get_cert_for_hostname(hostname, port)\n    return datetime.now() > cert.not_valid_after\n\n\nif __name__ == '__main__':\n    print(f\"Python version: {platform.python_version()}\")\n    print(f\"OpenSSL version: {ssl.OPENSSL_VERSION}\")\n    print(f\"requests version: {requests.__version__}\")  #\n    hosts = ['software7.com', 'expired.badssl.com']\n    for host in hosts:\n        try:\n            requests.get(f\"https://{host}\")\n            print(f\"request for host {host} was successful\")\n        except BaseException as err:\n            if is_cert_expired(host, 443):\n                print(f\"certificate for {host} expired\")\n            else:\n                print(f\"error {err} with {host}\")",
            "masked_code": "import ssl\nimport requests\nimport platform\nfrom datetime import datetime\nfrom cryptography import x509\n\n\ndef get_cert_for_hostname(hostname, port):\n    conn = ssl.create_connection((hostname, port))\n    context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n    sock = context.wrap_socket(conn, server_hostname=hostname)\n    certDER = sock.getpeercert(True)\n    certPEM = ssl.DER_cert_to_PEM_cert(certDER)\n    conn.close()\n    return x509.load_pem_x509_certificate(certPEM.encode('ascii'))\n\n\ndef is_cert_expired(hostname, port):\n    cert = get_cert_for_hostname(hostname, port)\n    return datetime.now() > cert.not_valid_after\n\n\nif __name__ == '__main__':\n    print(f\"Python version: {platform.python_version()}\")\n    print(f\"OpenSSL version: {ssl.OPENSSL_VERSION}\")\n    print(f\"requests version: {requests.__version__}\")  #\n    hosts = ['software7.com', 'expired.badssl.com']\n    for host in hosts:\n        try:\n            <line_mask>\n            print(f\"request for host {host} was successful\")\n        except BaseException as err:\n            if is_cert_expired(host, 443):\n                print(f\"certificate for {host} expired\")\n            else:\n                print(f\"error {err} with {host}\")",
            "masked_line": "requests.get(f\"https://{host}\")",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_911"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.15.2",
            "time": "2022-03-08",
            "description": "The code defines an input layer with a shape of (3, 2, 4) using TensorFlow's Keras API, and then creates a prediction layer by flattening the input layer. Finally, it prints the shapes of the input and prediction layers.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\ninputs = tf.keras.layers.Input(shape=(3,2,4))\nprediction = tf.keras.layers.Flatten()(inputs)\nprint(inputs.shape, prediction.shape)",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\ninputs = tf.keras.layers.Input(shape=(3,2,4))\n<line_mask>\nprint(inputs.shape, prediction.shape)",
            "masked_line": "prediction = tf.keras.layers.Flatten()(inputs)",
            "answer": "Flatten",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_912"
        },
        {
            "dependency": "mss",
            "version": "==7.0.1",
            "time": "2022-12-20",
            "description": "This code creates a Tkinter window and initializes a mss object. It runs the Tkinter main loop indefinitely, and closes the mss object when the window is closed.",
            "code": "import tkinter as tk\nimport mss\n\nmss_obj = mss.mss()\n\nroot = tk.Tk()\n...\ntry:\n    root.mainloop()\nfinally:\n    mss_obj.close()",
            "masked_code": "import tkinter as tk\nimport mss\n\nmss_obj = mss.mss()\n\nroot = tk.Tk()\n...\ntry:\n    root.mainloop()\nfinally:\n    <line_mask>",
            "masked_line": "mss_obj.close()",
            "answer": "close",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_913"
        },
        {
            "dependency": "biopython",
            "version": "==1.80",
            "time": "2022-12-20",
            "description": "This code reads a multiple sequence alignment from a file in Clustal format, converts it into a list of strings, and generates a PDF file displaying the alignment using the FPDF library.",
            "code": "from io import StringIO\n\nfrom Bio import AlignIO  # Biopython 1.80\n\nfrom fpdf import FPDF # pip install fpdf2\n \nalignment = AlignIO.read(\"Multi.txt\", \"clustal\")\n\n\nstri = StringIO()\n    \nAlignIO.write(alignment, stri, 'clustal' )\n\n# print(stri.getvalue())\n\nstri_lines = [ i for i in stri.getvalue().split('\\n')]\n\n# print(stri_lines)\n\npdf = FPDF(orientation=\"P\", unit=\"mm\", format=\"A4\")\n \n# Add a page\npdf.add_page()\n\npdf.add_font('FreeMono', '', 'FreeMono.ttf')\n\npdf.set_font(\"FreeMono\", size = 8)\n\nfor x in stri_lines:\n    pdf.cell(0, 5, txt = x, border = 0,  new_x=\"LMARGIN\" , new_y=\"NEXT\",  align = 'L', fill = False)\n    \n    # print(len(x))\n\npdf.output(\"out.pdf\")",
            "masked_code": "from io import StringIO\n\nfrom Bio import AlignIO  # Biopython 1.80\n\nfrom fpdf import FPDF # pip install fpdf2\n \n<line_mask>\n\n\nstri = StringIO()\n    \nAlignIO.write(alignment, stri, 'clustal' )\n\n# print(stri.getvalue())\n\nstri_lines = [ i for i in stri.getvalue().split('\\n')]\n\n# print(stri_lines)\n\npdf = FPDF(orientation=\"P\", unit=\"mm\", format=\"A4\")\n \n# Add a page\npdf.add_page()\n\npdf.add_font('FreeMono', '', 'FreeMono.ttf')\n\npdf.set_font(\"FreeMono\", size = 8)\n\nfor x in stri_lines:\n    pdf.cell(0, 5, txt = x, border = 0,  new_x=\"LMARGIN\" , new_y=\"NEXT\",  align = 'L', fill = False)\n    \n    # print(len(x))\n\npdf.output(\"out.pdf\")",
            "masked_line": "alignment = AlignIO.read(\"Multi.txt\", \"clustal\")",
            "answer": "read",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_914"
        },
        {
            "dependency": "moto",
            "version": "==4.0.6",
            "time": "2022-10-04",
            "description": "The code sets up a mock for AWS Systems Manager (SSM) service using Moto library. It creates a parameter \"/aws/test\" with some specific values in the mock SSM backend. Then, it uses boto3 to create a client for SSM in the \"us-east-1\" region and retrieves the parameters using the \"get_parameters\" method with the name \"/aws/test\". Finally, it prints the response containing the parameter values.",
            "code": "@mock_ssm\ndef test_default_param():\n    client = boto3.client(\"ssm\", region_name=\"us-east-1\")\n\n    from moto.ssm.models import ssm_backends, Parameter\n    ssm_backends[\"123456789012\"][\"us-east-1\"]._parameters[\"/aws/test\"].append(Parameter(\n        account_id=\"123456789012\",\n        name=\"/aws/test\",\n        value=\"val\",\n        parameter_type=\"String\",\n        description=\"...\",\n        allowed_pattern=None,\n        keyid=None,\n        last_modified_date=1664230158.399,\n        version=None,\n        tags=[],\n        data_type=\"text\",\n    ))\n\n    response = client.get_parameters(Names=[\"/aws/test\"])\n    print(response)",
            "masked_code": "@mock_ssm\ndef test_default_param():\n    client = boto3.client(\"ssm\", region_name=\"us-east-1\")\n\n    from moto.ssm.models import ssm_backends, Parameter\n    <line_mask>\n        account_id=\"123456789012\",\n        name=\"/aws/test\",\n        value=\"val\",\n        parameter_type=\"String\",\n        description=\"...\",\n        allowed_pattern=None,\n        keyid=None,\n        last_modified_date=1664230158.399,\n        version=None,\n        tags=[],\n        data_type=\"text\",\n    ))\n\n    response = client.get_parameters(Names=[\"/aws/test\"])\n    print(response)",
            "masked_line": "ssm_backends[\"123456789012\"][\"us-east-1\"]._parameters[\"/aws/test\"].append(Parameter(",
            "answer": "append",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_915"
        },
        {
            "dependency": "bokeh",
            "version": "==2.4.3",
            "time": "2022-07-28",
            "description": "The code creates a Bokeh plot with red and blue circles representing sine functions. The plot includes both x and y axes with labels, and uses linear axes with specific ranges for both sets of circles. Additionally, the code sets tickers to avoid incorrectly formatted labels when zooming in the plot.",
            "code": "from numpy import arange, linspace, pi, sin\n\nfrom bokeh.models import LinearAxis, Range1d\nfrom bokeh.plotting import figure, show, output_notebook\noutput_notebook()\n\nx = arange(-2*pi, 2*pi, 0.2)\nx2 = arange(-pi, pi, 0.1)\ny = sin(x)\ny2 = sin(x2)\n\np = figure(\n    width=400,\n    height=400,\n    x_range=(-6.5, 6.5),\n    y_range=(-1.1, 1.1),\n    min_border=80,\n    x_axis_type=\"datetime\"\n)\n\np.circle(x, y, color=\"crimson\", size=8)\np.yaxis.axis_label = \"red circles\"\np.yaxis.axis_label_text_color =\"crimson\"\n\np.extra_x_ranges['foo'] = Range1d(-pi, pi)\np.circle(x2, y2, color=\"navy\", size=8, x_range_name=\"foo\")\nax2 = LinearAxis(x_range_name=\"foo\", axis_label=\"blue circles\")\nax2.axis_label_text_color =\"navy\"\np.add_layout(ax2, 'above')\n\n# set ticker to avoid wrong formatted labels while zooming\np.above[0].ticker = list(range(-3,4))\n# overwrite labels\np.above[0].major_label_overrides = {key: item for key, item in zip(range(-3,4), list('ABCDEFG'))}\n\nshow(p)",
            "masked_code": "from numpy import arange, linspace, pi, sin\n\nfrom bokeh.models import LinearAxis, Range1d\nfrom bokeh.plotting import figure, show, output_notebook\noutput_notebook()\n\nx = arange(-2*pi, 2*pi, 0.2)\nx2 = arange(-pi, pi, 0.1)\ny = sin(x)\ny2 = sin(x2)\n\np = figure(\n    width=400,\n    height=400,\n    x_range=(-6.5, 6.5),\n    y_range=(-1.1, 1.1),\n    min_border=80,\n    x_axis_type=\"datetime\"\n)\n\np.circle(x, y, color=\"crimson\", size=8)\np.yaxis.axis_label = \"red circles\"\np.yaxis.axis_label_text_color =\"crimson\"\n\np.extra_x_ranges['foo'] = Range1d(-pi, pi)\np.circle(x2, y2, color=\"navy\", size=8, x_range_name=\"foo\")\nax2 = LinearAxis(x_range_name=\"foo\", axis_label=\"blue circles\")\nax2.axis_label_text_color =\"navy\"\np.add_layout(ax2, 'above')\n\n# set ticker to avoid wrong formatted labels while zooming\np.above[0].ticker = list(range(-3,4))\n# overwrite labels\np.above[0].major_label_overrides = {key: item for key, item in zip(range(-3,4), list('ABCDEFG'))}\n\n<line_mask>",
            "masked_line": "show(p)",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_916"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.8.0",
            "time": "2022-05-17",
            "description": "This code is generating integer embeddings for the tokenized and padded sequences of the given documents using TensorFlow. It is creating integer embeddings based on a random uniform distribution for demonstration purposes.",
            "code": "import tensorflow as tf\nimport numpy as np\n\ndocs = ['Well done!',\n            'Good work',\n            'Great effort',\n            'nice work']\ntokenizer = tf.keras.preprocessing.text.Tokenizer()\ntokenizer.fit_on_texts(docs)\nencoded_docs = tokenizer.texts_to_sequences(docs)\nmax_seq_len = max(len(x) for x in encoded_docs) # max len is 2\npadded_seq = tf.keras.preprocessing.sequence.pad_sequences(sequences=encoded_docs,maxlen=max_seq_len,padding='post')\nembedding_size = 8\n\ntf.random.set_seed(111)\n\n# Create integer embeddings for demonstration purposes.\nembeddings = tf.cast(tf.random.uniform((7, embedding_size), minval=10,  maxval=20, dtype=tf.int32), dtype=tf.float32)\n\nprint(padded_seq)\n\ntf.nn.embedding_lookup(embeddings, padded_seq)",
            "masked_code": "import tensorflow as tf\nimport numpy as np\n\ndocs = ['Well done!',\n            'Good work',\n            'Great effort',\n            'nice work']\n<line_mask>\ntokenizer.fit_on_texts(docs)\nencoded_docs = tokenizer.texts_to_sequences(docs)\nmax_seq_len = max(len(x) for x in encoded_docs) # max len is 2\npadded_seq = tf.keras.preprocessing.sequence.pad_sequences(sequences=encoded_docs,maxlen=max_seq_len,padding='post')\nembedding_size = 8\n\ntf.random.set_seed(111)\n\n# Create integer embeddings for demonstration purposes.\nembeddings = tf.cast(tf.random.uniform((7, embedding_size), minval=10,  maxval=20, dtype=tf.int32), dtype=tf.float32)\n\nprint(padded_seq)\n\ntf.nn.embedding_lookup(embeddings, padded_seq)",
            "masked_line": "tokenizer = tf.keras.preprocessing.text.Tokenizer()",
            "answer": "text",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_917"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2023-05-02",
            "description": "The code generates test data in a DataFrame, writes it to a Parquet file, then writes the same data to a SQL database and reads it back. It checks the column names in the SQL data, attempts to write the SQL data to a Parquet file (which fails due to non-string column names), and finally attempts to read the corrupted Parquet file back into a DataFrame, causing an error.",
            "code": "import tempfile\nimport numpy as np\nimport pandas as pd\nimport fastparquet\nfrom sqlalchemy.sql.expression import quoted_name\n\nwith tempfile.TemporaryDirectory() as tempdir:\n\n    # Test data\n    df = pd.DataFrame({\"col_i\": np.arange(10), \"col_f\": np.random.random(10)})\n\n    outpath = f\"{tempdir}/test_data.parquet\"\n\n    # Base case: fastparquet IO works no problem with the test data\n    fastparquet.write(outpath, df)\n    df_out = fastparquet.ParquetFile(outpath).to_pandas()\n    assert df.equals(df_out)\n\n    # Write the data to SQL, and then load back\n    con, table_name = f\"sqlite:///{tempdir}/test_data.sqlite3\", \"table123\"\n    df.to_sql(table_name, con, index=False)\n    df_sql = pd.read_sql_table(table_name, con)\n    # ...and it still looks to be fine\n    assert df.equals(df_sql)\n\n    # However, column names are not pure `str`.\n    # They are actually instances of :class:`quoted_name`, which is a\n    # subclass of `str`.\n    for column_name in df_sql.columns:\n        assert isinstance(column_name, quoted_name)\n\n    # This will cause failure while writing to the file.\n    # The exception will be caught and output to stderr, but will be ignored.\n    fastparquet.write(outpath, df_sql)\n\n    # This line will raise an error since the Parquet file is broken.\n    df_out = fastparquet.ParquetFile(outpath).to_pandas()",
            "masked_code": "import tempfile\nimport numpy as np\nimport pandas as pd\nimport fastparquet\nfrom sqlalchemy.sql.expression import quoted_name\n\nwith tempfile.TemporaryDirectory() as tempdir:\n\n    # Test data\n    df = pd.DataFrame({\"col_i\": np.arange(10), \"col_f\": np.random.random(10)})\n\n    outpath = f\"{tempdir}/test_data.parquet\"\n\n    # Base case: fastparquet IO works no problem with the test data\n    fastparquet.write(outpath, df)\n    df_out = fastparquet.ParquetFile(outpath).to_pandas()\n    assert df.equals(df_out)\n\n    # Write the data to SQL, and then load back\n    con, table_name = f\"sqlite:///{tempdir}/test_data.sqlite3\", \"table123\"\n    df.to_sql(table_name, con, index=False)\n    <line_mask>\n    # ...and it still looks to be fine\n    assert df.equals(df_sql)\n\n    # However, column names are not pure `str`.\n    # They are actually instances of :class:`quoted_name`, which is a\n    # subclass of `str`.\n    for column_name in df_sql.columns:\n        assert isinstance(column_name, quoted_name)\n\n    # This will cause failure while writing to the file.\n    # The exception will be caught and output to stderr, but will be ignored.\n    fastparquet.write(outpath, df_sql)\n\n    # This line will raise an error since the Parquet file is broken.\n    df_out = fastparquet.ParquetFile(outpath).to_pandas()",
            "masked_line": "df_sql = pd.read_sql_table(table_name, con)",
            "answer": "read_sql_table",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_918"
        },
        {
            "dependency": "fastparquet",
            "version": "==2023.4.0",
            "time": "2023-05-02",
            "description": "The code reads a pandas DataFrame, writes it to a Parquet file, transfers the data to an SQLite database, reads it back from the database, checks the integrity of the data, and then attempts to write the altered DataFrame with column names as instances of the class: quoted_name to the same Parquet file causing a failure due to non-pure strings.",
            "code": "import tempfile\nimport numpy as np\nimport pandas as pd\nimport fastparquet\nfrom sqlalchemy.sql.expression import quoted_name\n\nwith tempfile.TemporaryDirectory() as tempdir:\n\n    # Test data\n    df = pd.DataFrame({\"col_i\": np.arange(10), \"col_f\": np.random.random(10)})\n\n    outpath = f\"{tempdir}/test_data.parquet\"\n\n    # Base case: fastparquet IO works no problem with the test data\n    fastparquet.write(outpath, df)\n    df_out = fastparquet.ParquetFile(outpath).to_pandas()\n    assert df.equals(df_out)\n\n    # Write the data to SQL, and then load back\n    con, table_name = f\"sqlite:///{tempdir}/test_data.sqlite3\", \"table123\"\n    df.to_sql(table_name, con, index=False)\n    df_sql = pd.read_sql_table(table_name, con)\n    # ...and it still looks to be fine\n    assert df.equals(df_sql)\n\n    # However, column names are not pure `str`.\n    # They are actually instances of :class:`quoted_name`, which is a\n    # subclass of `str`.\n    for column_name in df_sql.columns:\n        assert isinstance(column_name, quoted_name)\n\n    # This will cause failure while writing to the file.\n    # The exception will be caught and output to stderr, but will be ignored.\n    fastparquet.write(outpath, df_sql)\n\n    # This line will raise an error since the Parquet file is broken.\n    df_out = fastparquet.ParquetFile(outpath).to_pandas()",
            "masked_code": "import tempfile\nimport numpy as np\nimport pandas as pd\nimport fastparquet\nfrom sqlalchemy.sql.expression import quoted_name\n\nwith tempfile.TemporaryDirectory() as tempdir:\n\n    # Test data\n    df = pd.DataFrame({\"col_i\": np.arange(10), \"col_f\": np.random.random(10)})\n\n    outpath = f\"{tempdir}/test_data.parquet\"\n\n    # Base case: fastparquet IO works no problem with the test data\n    <line_mask>\n    df_out = fastparquet.ParquetFile(outpath).to_pandas()\n    assert df.equals(df_out)\n\n    # Write the data to SQL, and then load back\n    con, table_name = f\"sqlite:///{tempdir}/test_data.sqlite3\", \"table123\"\n    df.to_sql(table_name, con, index=False)\n    df_sql = pd.read_sql_table(table_name, con)\n    # ...and it still looks to be fine\n    assert df.equals(df_sql)\n\n    # However, column names are not pure `str`.\n    # They are actually instances of :class:`quoted_name`, which is a\n    # subclass of `str`.\n    for column_name in df_sql.columns:\n        assert isinstance(column_name, quoted_name)\n\n    # This will cause failure while writing to the file.\n    # The exception will be caught and output to stderr, but will be ignored.\n    fastparquet.write(outpath, df_sql)\n\n    # This line will raise an error since the Parquet file is broken.\n    df_out = fastparquet.ParquetFile(outpath).to_pandas()",
            "masked_line": "fastparquet.write(outpath, df)",
            "answer": "write",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_919"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.8.0",
            "time": "2022-04-26",
            "description": "This code defines a custom decay callback class in TensorFlow that updates the learning rate based on the number of steps taken during training. It also includes a custom L2 regularization function for a neural network model. The code trains a neural network model using an Adam optimizer and mean squared error loss function for 3 epochs with the defined callbacks.",
            "code": "import tensorflow as tf\n\nclass Decay(tf.keras.callbacks.Callback):\n\n  def __init__(self, l2, decay_steps, decay_rate, staircase):\n    super().__init__()\n    self.l2 = l2\n    self.decay_steps = decay_steps\n    self.decay_rate = decay_rate\n    self.staircase = staircase\n\n  def on_epoch_end(self, epoch, logs=None):\n    global_step_recomp = self.params.get('steps')\n    p = global_step_recomp / self.decay_steps\n    if self.staircase:\n      p = tf.floor(p)\n    self.l2.assign(tf.multiply(\n        self.l2, tf.pow(self.decay_rate, p)))\n     \nl2 = tf.Variable(initial_value=0.01, trainable=False)\n\ndef l2_regularizer(weights):\n    tf.print(l2)\n    loss = l2 * tf.reduce_sum(tf.square(weights))\n    return loss\n\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, kernel_regularizer=l2_regularizer))\nmodel.compile(optimizer='adam', loss='mse')\nmodel.fit(tf.random.normal((50,1 )), tf.random.normal((50,1 )), batch_size=4, callbacks=[Decay(l2,\n    decay_steps=100000,\n    decay_rate=0.56,\n    staircase=False)], epochs=3)",
            "masked_code": "import tensorflow as tf\n\nclass Decay(tf.keras.callbacks.Callback):\n\n  def __init__(self, l2, decay_steps, decay_rate, staircase):\n    super().__init__()\n    self.l2 = l2\n    self.decay_steps = decay_steps\n    self.decay_rate = decay_rate\n    self.staircase = staircase\n\n  def on_epoch_end(self, epoch, logs=None):\n    global_step_recomp = self.params.get('steps')\n    p = global_step_recomp / self.decay_steps\n    if self.staircase:\n      p = tf.floor(p)\n    self.l2.assign(tf.multiply(\n        self.l2, tf.pow(self.decay_rate, p)))\n     \nl2 = tf.Variable(initial_value=0.01, trainable=False)\n\ndef l2_regularizer(weights):\n    tf.print(l2)\n    loss = l2 * tf.reduce_sum(tf.square(weights))\n    return loss\n\nmodel = tf.keras.Sequential()\n<line_mask>\nmodel.compile(optimizer='adam', loss='mse')\nmodel.fit(tf.random.normal((50,1 )), tf.random.normal((50,1 )), batch_size=4, callbacks=[Decay(l2,\n    decay_steps=100000,\n    decay_rate=0.56,\n    staircase=False)], epochs=3)",
            "masked_line": "model.add(tf.keras.layers.Dense(1, kernel_regularizer=l2_regularizer))",
            "answer": "layers",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_920"
        },
        {
            "dependency": "pyflann",
            "version": "==1.6.14",
            "time": "2022-07-29",
            "description": "The code creates a FLANN index from random data, saves the index to a file, and then retrieves the 500 nearest neighbors of a specific data point.",
            "code": "from pyflann.index import FLANN, set_distance_type\n \n# creating the data\ndatas = np.random.rand(1000000, 512)\ndatas = np.float32(datas)\n \n# declaring the FLANN\nflann = FLANN()\n# build the index from datas\nflann.build_index(datas, algorithm=\"linear\", checks=10)\n# Saving the index created therebefore\nflann.save_index(b\"my_saved_flann.txt\")\n \n# Searched data\nsearched = datas[i]\nsearched = np.expand_dims(searched, axis=0)\n \n# retrieving the 500 nearest neighbours of searched\nresults, distances = flann.nn_index(searched, 500)",
            "masked_code": "from pyflann.index import FLANN, set_distance_type\n \n# creating the data\ndatas = np.random.rand(1000000, 512)\ndatas = np.float32(datas)\n \n# declaring the FLANN\n<line_mask>\n# build the index from datas\nflann.build_index(datas, algorithm=\"linear\", checks=10)\n# Saving the index created therebefore\nflann.save_index(b\"my_saved_flann.txt\")\n \n# Searched data\nsearched = datas[i]\nsearched = np.expand_dims(searched, axis=0)\n \n# retrieving the 500 nearest neighbours of searched\nresults, distances = flann.nn_index(searched, 500)",
            "masked_line": "flann = FLANN()",
            "answer": "FLANN",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_921"
        },
        {
            "dependency": "joblib",
            "version": ">=0.12",
            "time": "2022-09-26",
            "description": "This code defines a subclass named WeightedBootstrapRandomForestClassifier that extends the functionality of the RandomForestClassifier class from the sklearn library. The new subclass allows for fitting a random forest model with weighted bootstrapping, where the probability of selecting samples during bootstrapping can be defined using the \"bootstrap_weight\" parameter. The fit method of this subclass builds a forest of trees from the training data (X, y) with optional sample weights and bootstrap weights. The random forest model can be used for classification tasks.",
            "code": "from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.tree._tree import DTYPE, DOUBLE\nfrom sklearn.utils import check_random_state\nfrom sklearn.utils.validation import _check_sample_weight\nfrom sklearn.utils.multiclass import check_classification_targets, type_of_target\nfrom sklearn.ensemble._forest import  _get_n_samples_bootstrap\nfrom sklearn.exceptions import DataConversionWarning\nfrom joblib import Parallel, delayed\nfrom warnings import catch_warnings, simplefilter, warn\nfrom scipy.sparse import issparse\nimport numpy as np\ndef _generate_sample_indices_weighted_bootstrap(random_state, n_samples, n_samples_bootstrap, bootstrap_weight):\n    \"\"\"\n    The version of sklearn.ensemble._forest._generate_sample_indices()\n    with an extra parameter `bootstrap_weight`\n    Private function used to _parallel_build_trees_weighted_bootstrap function.\"\"\"\n    \n    if bootstrap_weight is None:\n        p = np.ones(n_samples)\n    else:\n        p = np.array(bootstrap_weight)\n    p /= p.sum()\n\n    random_instance = check_random_state(random_state)\n    # !!! The line below is overriden\n    sample_indices = random_instance.choice(np.arange(n_samples), n_samples_bootstrap, True, p)\n\n    return sample_indices\n\ndef _parallel_build_trees_weighted_bootstrap(\n    tree,\n    bootstrap,\n    X,\n    y,\n    sample_weight,\n    bootstrap_weight,\n    tree_idx,\n    n_trees,\n    verbose=0,\n    class_weight=None,\n    n_samples_bootstrap=None,\n):\n    \"\"\"\n    The version of sklearn.ensemble._forest._parallel_build_trees()\n    with an extra parameter `bootstrap_weight`\n    Private function used to fit a single tree in parallel.\"\"\"\n    if verbose > 1:\n        print(\"building tree %d of %d\" % (tree_idx + 1, n_trees))\n\n    if bootstrap:\n        n_samples = X.shape[0]\n        if sample_weight is None:\n            curr_sample_weight = np.ones((n_samples,), dtype=np.float64)\n        else:\n            curr_sample_weight = sample_weight.copy()\n\n        indices = _generate_sample_indices_weighted_bootstrap( # !!! This line overriden\n            tree.random_state, n_samples, n_samples_bootstrap, bootstrap_weight\n        )\n        sample_counts = np.bincount(indices, minlength=n_samples)\n        curr_sample_weight *= sample_counts\n\n        if class_weight == \"subsample\":\n            with catch_warnings():\n                simplefilter(\"ignore\", DeprecationWarning)\n                curr_sample_weight *= compute_sample_weight(\"auto\", y, indices=indices)\n        elif class_weight == \"balanced_subsample\":\n            curr_sample_weight *= compute_sample_weight(\"balanced\", y, indices=indices)\n\n        tree.fit(X, y, sample_weight=curr_sample_weight, check_input=False)\n    else:\n        tree.fit(X, y, sample_weight=sample_weight, check_input=False)\n\n    return tree\n\nclass WeightedBootstrapRandomForestClassifier(RandomForestClassifier):\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        \n    def fit(self, X, y, sample_weight=None, bootstrap_weight=None):\n        \"\"\"\n        It is a version of sklearn.ensemble.BaseForest.fit() method\n        with extra parameter `bootstrap_weight` which defines the\n        probablity that the sample will be chosen during bootstrapping\n        \n        Build a forest of trees from the training set (X, y).\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The training input samples. Internally, its dtype will be converted\n            to ``dtype=np.float32``. If a sparse matrix is provided, it will be\n            converted into a sparse ``csc_matrix``.\n        y : array-like of shape (n_samples,) or (n_samples, n_outputs)\n            The target values (class labels in classification, real numbers in\n            regression).\n        sample_weight : array-like of shape (n_samples,), default=None\n            Sample weights. If None, then samples are equally weighted. Splits\n            that would create child nodes with net zero or negative weight are\n            ignored while searching for a split in each node. In the case of\n            classification, splits are also ignored if they would result in any\n            single class carrying a negative weight in either child node.\n        bootstrap_weight : array-like of shape (n_samples,), default=None\n            Sample-wise weights. If None, then samples are equally weighted.\n            The weights determine the probability that the sample will be selected\n            while bootstrapping.\n        Returns\n        -------\n        self : object\n            Fitted estimator.\n        \"\"\"\n\n        # Validate or convert input data\n        if issparse(y):\n            raise ValueError(\"sparse multilabel-indicator for y is not supported.\")\n        if sample_weight is not None:\n            sample_weight = _check_sample_weight(sample_weight, X)\n\n        if issparse(X):\n            # Pre-sort indices to avoid that each individual tree of the\n            # ensemble sorts the indices.\n            X.sort_indices()\n\n        y = np.atleast_1d(y)\n        if y.ndim == 2 and y.shape[1] == 1:\n            warn(\n                \"A column-vector y was passed when a 1d array was\"\n                \" expected. Please change the shape of y to \"\n                \"(n_samples,), for example using ravel().\",\n                DataConversionWarning,\n                stacklevel=2,\n            )\n\n        if y.ndim == 1:\n            # reshape is necessary to preserve the data contiguity against vs\n            # [:, np.newaxis] that does not.\n            y = np.reshape(y, (-1, 1))\n\n        if self.criterion == \"poisson\":\n            if np.any(y < 0):\n                raise ValueError(\n                    \"Some value(s) of y are negative which is \"\n                    \"not allowed for Poisson regression.\"\n                )\n            if np.sum(y) <= 0:\n                raise ValueError(\n                    \"Sum of y is not strictly positive which \"\n                    \"is necessary for Poisson regression.\"\n                )\n\n        self.n_outputs_ = y.shape[1]\n\n        y, expanded_class_weight = self._validate_y_class_weight(y)\n\n        if getattr(y, \"dtype\", None) != DOUBLE or not y.flags.contiguous:\n            y = np.ascontiguousarray(y, dtype=DOUBLE)\n\n        if expanded_class_weight is not None:\n            if sample_weight is not None:\n                sample_weight = sample_weight * expanded_class_weight\n            else:\n                sample_weight = expanded_class_weight\n\n        if not self.bootstrap and self.max_samples is not None:\n            raise ValueError(\n                \"`max_sample` cannot be set if `bootstrap=False`. \"\n                \"Either switch to `bootstrap=True` or set \"\n                \"`max_sample=None`.\"\n            )\n        elif self.bootstrap:\n            n_samples_bootstrap = _get_n_samples_bootstrap(\n                n_samples=X.shape[0], max_samples=self.max_samples\n            )\n        else:\n            n_samples_bootstrap = None\n\n        self._validate_estimator()\n        if isinstance(self, (RandomForestRegressor)):\n            # TODO(1.3): Remove \"auto\"\n            if self.max_features == \"auto\":\n                warn(\n                    \"`max_features='auto'` has been deprecated in 1.1 \"\n                    \"and will be removed in 1.3. To keep the past behaviour, \"\n                    \"explicitly set `max_features=1.0` or remove this \"\n                    \"parameter as it is also the default value for \"\n                    \"RandomForestRegressors and ExtraTreesRegressors.\",\n                    FutureWarning,\n                )\n        elif isinstance(self, (RandomForestClassifier)):\n            # TODO(1.3): Remove \"auto\"\n            if self.max_features == \"auto\":\n                warn(\n                    \"`max_features='auto'` has been deprecated in 1.1 \"\n                    \"and will be removed in 1.3. To keep the past behaviour, \"\n                    \"explicitly set `max_features='sqrt'` or remove this \"\n                    \"parameter as it is also the default value for \"\n                    \"RandomForestClassifiers and ExtraTreesClassifiers.\",\n                    FutureWarning,\n                )\n\n        if not self.bootstrap and self.oob_score:\n            raise ValueError(\"Out of bag estimation only available if bootstrap=True\")\n\n        random_state = check_random_state(self.random_state)\n\n        if not self.warm_start or not hasattr(self, \"estimators_\"):\n            # Free allocated memory, if any\n            self.estimators_ = []\n\n        n_more_estimators = self.n_estimators - len(self.estimators_)\n\n        if n_more_estimators < 0:\n            raise ValueError(\n                \"n_estimators=%d must be larger or equal to \"\n                \"len(estimators_)=%d when warm_start==True\"\n                % (self.n_estimators, len(self.estimators_))\n            )\n\n        elif n_more_estimators == 0:\n            warn(\n                \"Warm-start fitting without increasing n_estimators does not \"\n                \"fit new trees.\"\n            )\n        else:\n            if self.warm_start and len(self.estimators_) > 0:\n                # We draw from the random state to get the random state we\n                # would have got if we hadn't used a warm_start.\n                random_state.randint(MAX_INT, size=len(self.estimators_))\n\n            trees = [\n                self._make_estimator(append=False, random_state=random_state)\n                for i in range(n_more_estimators)\n            ]\n\n            # Parallel loop: we prefer the threading backend as the Cython code\n            # for fitting the trees is internally releasing the Python GIL\n            # making threading more efficient than multiprocessing in\n            # that case. However, for joblib 0.12+ we respect any\n            # parallel_backend contexts set at a higher level,\n            # since correctness does not rely on using threads.\n            trees = Parallel(\n                n_jobs=self.n_jobs,\n                verbose=self.verbose,\n                prefer=\"threads\",\n            )(\n                delayed(_parallel_build_trees_weighted_bootstrap)( # !!! This line overriden\n                    t,\n                    self.bootstrap,\n                    X,\n                    y,\n                    sample_weight,\n                    bootstrap_weight,\n                    i,\n                    len(trees),\n                    verbose=self.verbose,\n                    class_weight=self.class_weight,\n                    n_samples_bootstrap=n_samples_bootstrap,\n                )\n                for i, t in enumerate(trees)\n            )\n\n            # Collect newly grown trees\n            self.estimators_.extend(trees)\n\n        if self.oob_score:\n            y_type = type_of_target(y)\n            if y_type in (\"multiclass-multioutput\", \"unknown\"):\n                # FIXME: we could consider to support multiclass-multioutput if\n                # we introduce or reuse a constructor parameter (e.g.\n                # oob_score) allowing our user to pass a callable defining the\n                # scoring strategy on OOB sample.\n                raise ValueError(\n                    \"The type of target cannot be used to compute OOB \"\n                    f\"estimates. Got {y_type} while only the following are \"\n                    \"supported: continuous, continuous-multioutput, binary, \"\n                    \"multiclass, multilabel-indicator.\"\n                )\n            self._set_oob_score_and_attributes(X, y)\n\n        # Decapsulate classes_ attributes\n        if hasattr(self, \"classes_\") and self.n_outputs_ == 1:\n            self.n_classes_ = self.n_classes_[0]\n            self.classes_ = self.classes_[0]\n\n        return self",
            "masked_code": "from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.tree._tree import DTYPE, DOUBLE\nfrom sklearn.utils import check_random_state\nfrom sklearn.utils.validation import _check_sample_weight\nfrom sklearn.utils.multiclass import check_classification_targets, type_of_target\nfrom sklearn.ensemble._forest import  _get_n_samples_bootstrap\nfrom sklearn.exceptions import DataConversionWarning\n<line_mask>\nfrom warnings import catch_warnings, simplefilter, warn\nfrom scipy.sparse import issparse\nimport numpy as np\ndef _generate_sample_indices_weighted_bootstrap(random_state, n_samples, n_samples_bootstrap, bootstrap_weight):\n    \"\"\"\n    The version of sklearn.ensemble._forest._generate_sample_indices()\n    with an extra parameter `bootstrap_weight`\n    Private function used to _parallel_build_trees_weighted_bootstrap function.\"\"\"\n    \n    if bootstrap_weight is None:\n        p = np.ones(n_samples)\n    else:\n        p = np.array(bootstrap_weight)\n    p /= p.sum()\n\n    random_instance = check_random_state(random_state)\n    # !!! The line below is overriden\n    sample_indices = random_instance.choice(np.arange(n_samples), n_samples_bootstrap, True, p)\n\n    return sample_indices\n\ndef _parallel_build_trees_weighted_bootstrap(\n    tree,\n    bootstrap,\n    X,\n    y,\n    sample_weight,\n    bootstrap_weight,\n    tree_idx,\n    n_trees,\n    verbose=0,\n    class_weight=None,\n    n_samples_bootstrap=None,\n):\n    \"\"\"\n    The version of sklearn.ensemble._forest._parallel_build_trees()\n    with an extra parameter `bootstrap_weight`\n    Private function used to fit a single tree in parallel.\"\"\"\n    if verbose > 1:\n        print(\"building tree %d of %d\" % (tree_idx + 1, n_trees))\n\n    if bootstrap:\n        n_samples = X.shape[0]\n        if sample_weight is None:\n            curr_sample_weight = np.ones((n_samples,), dtype=np.float64)\n        else:\n            curr_sample_weight = sample_weight.copy()\n\n        indices = _generate_sample_indices_weighted_bootstrap( # !!! This line overriden\n            tree.random_state, n_samples, n_samples_bootstrap, bootstrap_weight\n        )\n        sample_counts = np.bincount(indices, minlength=n_samples)\n        curr_sample_weight *= sample_counts\n\n        if class_weight == \"subsample\":\n            with catch_warnings():\n                simplefilter(\"ignore\", DeprecationWarning)\n                curr_sample_weight *= compute_sample_weight(\"auto\", y, indices=indices)\n        elif class_weight == \"balanced_subsample\":\n            curr_sample_weight *= compute_sample_weight(\"balanced\", y, indices=indices)\n\n        tree.fit(X, y, sample_weight=curr_sample_weight, check_input=False)\n    else:\n        tree.fit(X, y, sample_weight=sample_weight, check_input=False)\n\n    return tree\n\nclass WeightedBootstrapRandomForestClassifier(RandomForestClassifier):\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        \n    def fit(self, X, y, sample_weight=None, bootstrap_weight=None):\n        \"\"\"\n        It is a version of sklearn.ensemble.BaseForest.fit() method\n        with extra parameter `bootstrap_weight` which defines the\n        probablity that the sample will be chosen during bootstrapping\n        \n        Build a forest of trees from the training set (X, y).\n        Parameters\n        ----------\n        X : {array-like, sparse matrix} of shape (n_samples, n_features)\n            The training input samples. Internally, its dtype will be converted\n            to ``dtype=np.float32``. If a sparse matrix is provided, it will be\n            converted into a sparse ``csc_matrix``.\n        y : array-like of shape (n_samples,) or (n_samples, n_outputs)\n            The target values (class labels in classification, real numbers in\n            regression).\n        sample_weight : array-like of shape (n_samples,), default=None\n            Sample weights. If None, then samples are equally weighted. Splits\n            that would create child nodes with net zero or negative weight are\n            ignored while searching for a split in each node. In the case of\n            classification, splits are also ignored if they would result in any\n            single class carrying a negative weight in either child node.\n        bootstrap_weight : array-like of shape (n_samples,), default=None\n            Sample-wise weights. If None, then samples are equally weighted.\n            The weights determine the probability that the sample will be selected\n            while bootstrapping.\n        Returns\n        -------\n        self : object\n            Fitted estimator.\n        \"\"\"\n\n        # Validate or convert input data\n        if issparse(y):\n            raise ValueError(\"sparse multilabel-indicator for y is not supported.\")\n        if sample_weight is not None:\n            sample_weight = _check_sample_weight(sample_weight, X)\n\n        if issparse(X):\n            # Pre-sort indices to avoid that each individual tree of the\n            # ensemble sorts the indices.\n            X.sort_indices()\n\n        y = np.atleast_1d(y)\n        if y.ndim == 2 and y.shape[1] == 1:\n            warn(\n                \"A column-vector y was passed when a 1d array was\"\n                \" expected. Please change the shape of y to \"\n                \"(n_samples,), for example using ravel().\",\n                DataConversionWarning,\n                stacklevel=2,\n            )\n\n        if y.ndim == 1:\n            # reshape is necessary to preserve the data contiguity against vs\n            # [:, np.newaxis] that does not.\n            y = np.reshape(y, (-1, 1))\n\n        if self.criterion == \"poisson\":\n            if np.any(y < 0):\n                raise ValueError(\n                    \"Some value(s) of y are negative which is \"\n                    \"not allowed for Poisson regression.\"\n                )\n            if np.sum(y) <= 0:\n                raise ValueError(\n                    \"Sum of y is not strictly positive which \"\n                    \"is necessary for Poisson regression.\"\n                )\n\n        self.n_outputs_ = y.shape[1]\n\n        y, expanded_class_weight = self._validate_y_class_weight(y)\n\n        if getattr(y, \"dtype\", None) != DOUBLE or not y.flags.contiguous:\n            y = np.ascontiguousarray(y, dtype=DOUBLE)\n\n        if expanded_class_weight is not None:\n            if sample_weight is not None:\n                sample_weight = sample_weight * expanded_class_weight\n            else:\n                sample_weight = expanded_class_weight\n\n        if not self.bootstrap and self.max_samples is not None:\n            raise ValueError(\n                \"`max_sample` cannot be set if `bootstrap=False`. \"\n                \"Either switch to `bootstrap=True` or set \"\n                \"`max_sample=None`.\"\n            )\n        elif self.bootstrap:\n            n_samples_bootstrap = _get_n_samples_bootstrap(\n                n_samples=X.shape[0], max_samples=self.max_samples\n            )\n        else:\n            n_samples_bootstrap = None\n\n        self._validate_estimator()\n        if isinstance(self, (RandomForestRegressor)):\n            # TODO(1.3): Remove \"auto\"\n            if self.max_features == \"auto\":\n                warn(\n                    \"`max_features='auto'` has been deprecated in 1.1 \"\n                    \"and will be removed in 1.3. To keep the past behaviour, \"\n                    \"explicitly set `max_features=1.0` or remove this \"\n                    \"parameter as it is also the default value for \"\n                    \"RandomForestRegressors and ExtraTreesRegressors.\",\n                    FutureWarning,\n                )\n        elif isinstance(self, (RandomForestClassifier)):\n            # TODO(1.3): Remove \"auto\"\n            if self.max_features == \"auto\":\n                warn(\n                    \"`max_features='auto'` has been deprecated in 1.1 \"\n                    \"and will be removed in 1.3. To keep the past behaviour, \"\n                    \"explicitly set `max_features='sqrt'` or remove this \"\n                    \"parameter as it is also the default value for \"\n                    \"RandomForestClassifiers and ExtraTreesClassifiers.\",\n                    FutureWarning,\n                )\n\n        if not self.bootstrap and self.oob_score:\n            raise ValueError(\"Out of bag estimation only available if bootstrap=True\")\n\n        random_state = check_random_state(self.random_state)\n\n        if not self.warm_start or not hasattr(self, \"estimators_\"):\n            # Free allocated memory, if any\n            self.estimators_ = []\n\n        n_more_estimators = self.n_estimators - len(self.estimators_)\n\n        if n_more_estimators < 0:\n            raise ValueError(\n                \"n_estimators=%d must be larger or equal to \"\n                \"len(estimators_)=%d when warm_start==True\"\n                % (self.n_estimators, len(self.estimators_))\n            )\n\n        elif n_more_estimators == 0:\n            warn(\n                \"Warm-start fitting without increasing n_estimators does not \"\n                \"fit new trees.\"\n            )\n        else:\n            if self.warm_start and len(self.estimators_) > 0:\n                # We draw from the random state to get the random state we\n                # would have got if we hadn't used a warm_start.\n                random_state.randint(MAX_INT, size=len(self.estimators_))\n\n            trees = [\n                self._make_estimator(append=False, random_state=random_state)\n                for i in range(n_more_estimators)\n            ]\n\n            # Parallel loop: we prefer the threading backend as the Cython code\n            # for fitting the trees is internally releasing the Python GIL\n            # making threading more efficient than multiprocessing in\n            # that case. However, for joblib 0.12+ we respect any\n            # parallel_backend contexts set at a higher level,\n            # since correctness does not rely on using threads.\n            trees = Parallel(\n                n_jobs=self.n_jobs,\n                verbose=self.verbose,\n                prefer=\"threads\",\n            )(\n                delayed(_parallel_build_trees_weighted_bootstrap)( # !!! This line overriden\n                    t,\n                    self.bootstrap,\n                    X,\n                    y,\n                    sample_weight,\n                    bootstrap_weight,\n                    i,\n                    len(trees),\n                    verbose=self.verbose,\n                    class_weight=self.class_weight,\n                    n_samples_bootstrap=n_samples_bootstrap,\n                )\n                for i, t in enumerate(trees)\n            )\n\n            # Collect newly grown trees\n            self.estimators_.extend(trees)\n\n        if self.oob_score:\n            y_type = type_of_target(y)\n            if y_type in (\"multiclass-multioutput\", \"unknown\"):\n                # FIXME: we could consider to support multiclass-multioutput if\n                # we introduce or reuse a constructor parameter (e.g.\n                # oob_score) allowing our user to pass a callable defining the\n                # scoring strategy on OOB sample.\n                raise ValueError(\n                    \"The type of target cannot be used to compute OOB \"\n                    f\"estimates. Got {y_type} while only the following are \"\n                    \"supported: continuous, continuous-multioutput, binary, \"\n                    \"multiclass, multilabel-indicator.\"\n                )\n            self._set_oob_score_and_attributes(X, y)\n\n        # Decapsulate classes_ attributes\n        if hasattr(self, \"classes_\") and self.n_outputs_ == 1:\n            self.n_classes_ = self.n_classes_[0]\n            self.classes_ = self.classes_[0]\n\n        return self",
            "masked_line": "from joblib import Parallel, delayed",
            "answer": "delayed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_922"
        },
        {
            "dependency": "numpy",
            "version": "==1.23.2",
            "time": "2022-08-30",
            "description": "func_1() takes a list of strings and concatenates 'x' to each element in the list, while func_2() takes a numpy char array and concatenates 'x' to each element in the array. Both functions are timed with the timeit module running 100 times.",
            "code": "import numpy\nfrom timeit import timeit\n\nlc = list(map(str, range(500_000)))\nla = numpy.char.array(lc)\n\ndef func_1():\n    return [e+'x' for e in lc]\n\ndef func_2():\n    return la+'x'\n\nfor func in func_1, func_2:\n    print(func.__name__, timeit(lambda: func(), number=100))",
            "masked_code": "import numpy\nfrom timeit import timeit\n\nlc = list(map(str, range(500_000)))\n<line_mask>\n\ndef func_1():\n    return [e+'x' for e in lc]\n\ndef func_2():\n    return la+'x'\n\nfor func in func_1, func_2:\n    print(func.__name__, timeit(lambda: func(), number=100))",
            "masked_line": "la = numpy.char.array(lc)",
            "answer": "char",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_923"
        },
        {
            "dependency": "selenium",
            "version": "==4.2.0",
            "time": "2022-10-20",
            "description": "The code opens the Opera browser and visits the website \"https://whatsmyip.com\" to display the user's IP address.",
            "code": "from webdriver_manager.opera import OperaDriverManager\nfrom selenium import webdriver\n\noptions = webdriver.ChromeOptions()\nopera_profile = r\"C:\\\\Users\\\\LEGEND\\\\AppData\\\\Roaming\\\\Opera Software\\\\Opera Stable\"\n\noptions.add_argument('user-data-dir=' + opera_profile)\noptions._binary_location = r'C:\\\\Users\\\\LEGEND\\\\AppData\\\\Local\\\\Programs\\\\Opera\\\\launcher.exe'\noptions = webdriver.ChromeOptions()\noptions.add_argument('allow-elevated-browser')\noptions.add_experimental_option('w3c', True)\ndriver = webdriver.Opera(executable_path=OperaDriverManager().install(), options=options)\ndriver.get('https://whatsmyip.com')\ndriver.quit()",
            "masked_code": "from webdriver_manager.opera import OperaDriverManager\nfrom selenium import webdriver\n\noptions = webdriver.ChromeOptions()\nopera_profile = r\"C:\\\\Users\\\\LEGEND\\\\AppData\\\\Roaming\\\\Opera Software\\\\Opera Stable\"\n\n<line_mask>\noptions._binary_location = r'C:\\\\Users\\\\LEGEND\\\\AppData\\\\Local\\\\Programs\\\\Opera\\\\launcher.exe'\noptions = webdriver.ChromeOptions()\noptions.add_argument('allow-elevated-browser')\noptions.add_experimental_option('w3c', True)\ndriver = webdriver.Opera(executable_path=OperaDriverManager().install(), options=options)\ndriver.get('https://whatsmyip.com')\ndriver.quit()",
            "masked_line": "options.add_argument('user-data-dir=' + opera_profile)",
            "answer": "add_argument",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_924"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.4",
            "time": "2022-07-05",
            "description": "This code snippet uses the Pandas library to create a DataFrame with two columns 'xxx' and 'tmp'. It then modifies the values in the 'xxx' column by taking the first 10 characters of the string, replacing any '-' characters with an empty string, and updating the DataFrame with these modified values.",
            "code": "import pandas as pd\nprint(pd.__version__)\ndf = pd.DataFrame(\n    {'xxx': ['AABBCC-DDEEE', 'DIs-sssssssssssP', 'KKK', 'A', 'A'],\n     'tmp': [1, 2, 3, 4, 5]})\nprint(df)\ndf.loc[df['xxx'].notna(), 'xxx'] = df.loc[df['xxx'].notna(), 'xxx'].astype(str).str[:10].str.replace('-','')\nprint(df)",
            "masked_code": "import pandas as pd\nprint(pd.__version__)\ndf = pd.DataFrame(\n    {'xxx': ['AABBCC-DDEEE', 'DIs-sssssssssssP', 'KKK', 'A', 'A'],\n     'tmp': [1, 2, 3, 4, 5]})\nprint(df)\n<line_mask>\nprint(df)",
            "masked_line": "df.loc[df['xxx'].notna(), 'xxx'] = df.loc[df['xxx'].notna(), 'xxx'].astype(str).str[:10].str.replace('-','')",
            "answer": "replace",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_925"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.5",
            "time": "2022-04-22",
            "description": "This code converts the tuple 'h' into a numpy array and then converts the elements into boolean values.",
            "code": "import numpy as np\n\nh=((), (), (), (), (), (), (), ('USER',), (), (), (), (), (), (), (), (), ('AUTOREJECT',), (), (), (), (), (), ('AUTOREJECT',), ('AUTOREJECT',), (), (), (), (), (), (), (), (), (), (), (), (), ('AUTOREJECT',), ('AUTOREJECT',), (), (), ('AUTOREJECT',), ('AUTOREJECT',), ('AUTOREJECT',), (), ('AUTOREJECT',), ('AUTOREJECT',))\n\nexpected_output=np.array(h).astype(bool)",
            "masked_code": "import numpy as np\n\nh=((), (), (), (), (), (), (), ('USER',), (), (), (), (), (), (), (), (), ('AUTOREJECT',), (), (), (), (), (), ('AUTOREJECT',), ('AUTOREJECT',), (), (), (), (), (), (), (), (), (), (), (), (), ('AUTOREJECT',), ('AUTOREJECT',), (), (), ('AUTOREJECT',), ('AUTOREJECT',), ('AUTOREJECT',), (), ('AUTOREJECT',), ('AUTOREJECT',))\n\n<line_mask>",
            "masked_line": "expected_output=np.array(h).astype(bool)",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_926"
        },
        {
            "dependency": "pandas",
            "version": "==0.15",
            "time": "2022-04-04",
            "description": "The code creates a dataframe containing information about order totals on different weekdays. The dataframe is then sorted by the weekdays in a predefined order (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday) and printed.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame(\n    {\n        'OrderDayName': ['Friday', 'Monday', 'Saturday', 'Sunday', 'Thursday', 'Tuesday', 'Wednesday'],\n        'ItemTotal': [4073, 6787, 2965, 4416, 4260, 4378, 3476],\n    }\n)\nsorted_weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\ndf['OrderDayName'] = pd.Categorical(df['OrderDayName'], sorted_weekdays)\nprint(df.sort_values(\"OrderDayName\"))",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame(\n    {\n        'OrderDayName': ['Friday', 'Monday', 'Saturday', 'Sunday', 'Thursday', 'Tuesday', 'Wednesday'],\n        'ItemTotal': [4073, 6787, 2965, 4416, 4260, 4378, 3476],\n    }\n)\nsorted_weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\ndf['OrderDayName'] = pd.Categorical(df['OrderDayName'], sorted_weekdays)\n<line_mask>",
            "masked_line": "print(df.sort_values(\"OrderDayName\"))",
            "answer": "sort_values",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_927"
        },
        {
            "dependency": "pillow",
            "version": "==10.0.0",
            "time": "2023-07-04",
            "description": "This code generates a gradient image with a sharp color boundary across the diagonal, converts it to a PIL Image object, resizes it to a smaller size using Lanczos resampling, and then displays both the original large image and the resized small image.",
            "code": "import PIL\nimport numpy as np\n\n# Gradient image with a sharp color boundary across the diagonal\nlarge_arr = np.fromfunction(lambda x, y, z: (x+y)//(z+1),\n                            (256, 256, 3)).astype(np.uint8)\nlarge_img = PIL.Image.fromarray(large_arr)\n\n# Resize it: PIL.Image.LANCZOS also works here\nsmall_img = large_img.resize((128, 128), PIL.Image.Resampling.LANCZOS)\nprint(small_img.size)\n\nlarge_img.show()\nsmall_img.show()",
            "masked_code": "import PIL\nimport numpy as np\n\n# Gradient image with a sharp color boundary across the diagonal\nlarge_arr = np.fromfunction(lambda x, y, z: (x+y)//(z+1),\n                            (256, 256, 3)).astype(np.uint8)\nlarge_img = PIL.Image.fromarray(large_arr)\n\n# Resize it: PIL.Image.LANCZOS also works here\nsmall_img = large_img.resize((128, 128), PIL.Image.Resampling.LANCZOS)\nprint(small_img.size)\n\n<line_mask>\nsmall_img.show()",
            "masked_line": "large_img.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_928"
        },
        {
            "dependency": "openai",
            "version": "==1.1.1",
            "time": "2023-11-08",
            "description": "The code uses the OpenAI API to generate a chat completion response based on the given messages. It specifies a role for the system and the user, with the system providing information about answering questions related to Web services. The chat completion response is generated using a specified GPT model with a temperature of 0, and the final response message is then printed.",
            "code": "from openai import OpenAI\n\nclient = OpenAI(api_key='YourKey')\nGPT_MODEL = \"gpt-4-1106-preview\" #\"gpt-3.5-turbo-1106\"\nmessages = [\n        {\"role\": \"system\", \"content\": 'You answer question about Web  services.'\n        },\n        {\"role\": \"user\", \"content\": 'the user message'},\n    ]\nresponse = client.chat.completions.create(\n        model=model,\n        messages=messages,\n        temperature=0\n    )\nresponse_message = response.choices[0].message.content\nprint(response_message )",
            "masked_code": "<line_mask>\n\nclient = OpenAI(api_key='YourKey')\nGPT_MODEL = \"gpt-4-1106-preview\" #\"gpt-3.5-turbo-1106\"\nmessages = [\n        {\"role\": \"system\", \"content\": 'You answer question about Web  services.'\n        },\n        {\"role\": \"user\", \"content\": 'the user message'},\n    ]\nresponse = client.chat.completions.create(\n        model=model,\n        messages=messages,\n        temperature=0\n    )\nresponse_message = response.choices[0].message.content\nprint(response_message )",
            "masked_line": "from openai import OpenAI",
            "answer": "OpenAI",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_929"
        },
        {
            "dependency": "numpy",
            "version": "==1.24.3",
            "time": "2023-06-02",
            "description": "The code performs exponentiation operation on 9 to the power of 19 and returns the result as a long long integer.",
            "code": "import numpy as np\nnp.longlong(9**19)\n\n#output\n1350851717672992089",
            "masked_code": "import numpy as np\n<line_mask>\n\n#output\n1350851717672992089",
            "masked_line": "np.longlong(9**19)",
            "answer": "longlong",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_930"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.2",
            "time": "2023-06-16",
            "description": "The code creates a mixed type DataFrame using the makeMixedDataFrame() function from the pandas library.",
            "code": "import pandas as pd\n#pd.__version__ #2.0.2\n\ndf = pd._testing.makeMixedDataFrame()",
            "masked_code": "import pandas as pd\n#pd.__version__ #2.0.2\n\n<line_mask>",
            "masked_line": "df = pd._testing.makeMixedDataFrame()",
            "answer": "makeMixedDataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_931"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==2.x",
            "time": "2023-05-03",
            "description": "The code converts the string \"english\" to a tsvector data type using the REGCONFIG dialect in PostgreSQL.",
            "code": "from sqlalchemy import cast, literal\nfrom sqlalchemy.dialects.postgresql import REGCONFIG\nfunc.to_tsvector(cast(literal(\"english\"), type_=REGCONFIG), ...)",
            "masked_code": "<line_mask>\nfrom sqlalchemy.dialects.postgresql import REGCONFIG\nfunc.to_tsvector(cast(literal(\"english\"), type_=REGCONFIG), ...)",
            "masked_line": "from sqlalchemy import cast, literal",
            "answer": "literal",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_932"
        },
        {
            "dependency": "fastapi",
            "version": "==0.104",
            "time": "2023-12-20",
            "description": "This code defines a FastAPI application with a single route (\"/\") that returns a plain text response of \"Hello \"World\"!\". The application is then run using uvicorn.",
            "code": "import uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.responses import PlainTextResponse\n\napp = FastAPI()\n\n\n@app.get(\n    \"/\",\n    response_class=PlainTextResponse,\n)\ndef read_root():\n    return 'Hello \"World\"!'\n\n\nuvicorn.run(app)",
            "masked_code": "import uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.responses import PlainTextResponse\n\n<line_mask>\n\n\n@app.get(\n    \"/\",\n    response_class=PlainTextResponse,\n)\ndef read_root():\n    return 'Hello \"World\"!'\n\n\nuvicorn.run(app)",
            "masked_line": "app = FastAPI()",
            "answer": "FastAPI",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_933"
        },
        {
            "dependency": "selenium",
            "version": ">=4.6",
            "time": "2023-07-29",
            "description": "The code opens a Chrome browser using Selenium and navigates to the Google homepage.",
            "code": "from selenium import webdriver\n\ndriver = webdriver.Chrome()\ndriver.get(\"https://www.google.com/\")",
            "masked_code": "from selenium import webdriver\n\n<line_mask>\ndriver.get(\"https://www.google.com/\")",
            "masked_line": "driver = webdriver.Chrome()",
            "answer": "Chrome",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_934"
        },
        {
            "dependency": "selenium",
            "version": ">=4.6",
            "time": "2023-07-18",
            "description": "The code opens a Chrome browser window with maximized window size and navigates to the Google homepage.",
            "code": "from selenium import webdriver\n\noption = webdriver.ChromeOptions()\noption.add_argument(\"--start-maximized\")\ndriver = webdriver.Chrome(options=option)\ndriver.get(\"https://google.com/\")",
            "masked_code": "from selenium import webdriver\n\n<line_mask>\noption.add_argument(\"--start-maximized\")\ndriver = webdriver.Chrome(options=option)\ndriver.get(\"https://google.com/\")",
            "masked_line": "option = webdriver.ChromeOptions()",
            "answer": "ChromeOptions",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_935"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.0",
            "time": "2023-03-04",
            "description": "The code generates a polar plot with scatter points representing random data points with a phase and amplitude. It also overlays a kernel density estimation plot on top of the scatter plot for visualization.",
            "code": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\nn_data = 1000\ndata_phase = np.random.rand(n_data) * 1.2 * np.pi\ndata_amp = np.random.randn(n_data)\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='polar')\n\nax.scatter(data_phase, data_amp, vmin=0, vmax=2 * np.pi, s=10, alpha=0.3)\nax.set_thetagrids(angles=np.linspace(0, 360, 5));\nsns.kdeplot(x=data_phase, y=data_amp, n_levels=5, c='k', ax=ax)",
            "masked_code": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\nn_data = 1000\ndata_phase = np.random.rand(n_data) * 1.2 * np.pi\ndata_amp = np.random.randn(n_data)\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='polar')\n\nax.scatter(data_phase, data_amp, vmin=0, vmax=2 * np.pi, s=10, alpha=0.3)\nax.set_thetagrids(angles=np.linspace(0, 360, 5));\n<line_mask>",
            "masked_line": "sns.kdeplot(x=data_phase, y=data_amp, n_levels=5, c='k', ax=ax)",
            "answer": "kdeplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_936"
        },
        {
            "dependency": "kivy",
            "version": "==2.1.0",
            "time": "2023-05-07",
            "description": "This code defines a mobile application using KivyMD framework. The application has a top app bar with a title \"My First App\" and a left menu icon that triggers a navigation menu. The main screen of the app contains a label with text \"hello App\" centered horizontally. The app is built using the MDApp class and is run when an instance of the MobileApp class is created and executed.",
            "code": "from kivymd.app import  MDApp\nfrom kivy.lang import Builder\nfrom kivy.core.window import Window\nWindow.size=(700,700)\nscreen_helper =\"\"\"\nScreen:\n     BoxLayout:\n          orientation:'vertical'\n          MDTopAppBar:\n               title:'My First App'\n               left_action_items:[[\"menu\",lambda x: app.navigation_draw()]]\n          MDLabel:\n               text:'hello App'\n               halign:'center'\n\"\"\"\nclass MobileApp(MDApp):\n    def build(self):\n        screen =Builder.load_string(screen_helper)\n        return screen\n\n    def navigation_draw(self):\n        print(\"Navigation\")\n\nMobileApp().run()",
            "masked_code": "from kivymd.app import  MDApp\nfrom kivy.lang import Builder\nfrom kivy.core.window import Window\nWindow.size=(700,700)\nscreen_helper =\"\"\"\nScreen:\n     BoxLayout:\n          orientation:'vertical'\n          MDTopAppBar:\n               title:'My First App'\n               left_action_items:[[\"menu\",lambda x: app.navigation_draw()]]\n          MDLabel:\n               text:'hello App'\n               halign:'center'\n\"\"\"\nclass MobileApp(MDApp):\n    def build(self):\n        <line_mask>\n        return screen\n\n    def navigation_draw(self):\n        print(\"Navigation\")\n\nMobileApp().run()",
            "masked_line": "screen =Builder.load_string(screen_helper)",
            "answer": "load_string",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_937"
        },
        {
            "dependency": "gradio",
            "version": "==4.4.0",
            "time": "2023-11-20",
            "description": "This code creates a user interface using the Gradio library where there are two dropdown menus. The first dropdown menu allows users to select a city from the options \"Paris\" and \"Berlin\". The second dropdown menu dynamically changes its options based on the selection made in the first dropdown menu. Once selections are made in both dropdown menus, a text output is generated displaying the choices made in the dropdown menus.",
            "code": "import gradio as gr\n\noptions_1 = ['Paris', 'Berlin' ]\noptions_2 = {\n    'Paris': ['Saint Denis', 'Eiffel Tower', 'Le Louvre'],\n    'Berlin': ['Reichstag', 'Alexanderplatz', 'Kreuzberg'],\n    }\n\nwith gr.Blocks() as demo:\n    d1 = gr.Dropdown(choices=options_1, label=\"City dropdown\")\n    d2 = gr.Dropdown([])\n    \n    def update_second(first_val):\n        d2 = gr.Dropdown(options_2[first_val])\n        return d2 \n    \n    d1.input(update_second, d1, d2)\n\n    outputs = gr.Textbox()\n\n    def print_results(option_1, option_2):\n        return f\"You selected '{option_1}' in the first dropdown and '{option_2}' in the second dropdown.\"\n        \n    d2.input(print_results, [d1, d2], outputs) \n\ndemo.launch()",
            "masked_code": "import gradio as gr\n\noptions_1 = ['Paris', 'Berlin' ]\noptions_2 = {\n    'Paris': ['Saint Denis', 'Eiffel Tower', 'Le Louvre'],\n    'Berlin': ['Reichstag', 'Alexanderplatz', 'Kreuzberg'],\n    }\n\nwith gr.Blocks() as demo:\n    d1 = gr.Dropdown(choices=options_1, label=\"City dropdown\")\n    <line_mask>\n    \n    def update_second(first_val):\n        d2 = gr.Dropdown(options_2[first_val])\n        return d2 \n    \n    d1.input(update_second, d1, d2)\n\n    outputs = gr.Textbox()\n\n    def print_results(option_1, option_2):\n        return f\"You selected '{option_1}' in the first dropdown and '{option_2}' in the second dropdown.\"\n        \n    d2.input(print_results, [d1, d2], outputs) \n\ndemo.launch()",
            "masked_line": "d2 = gr.Dropdown([])",
            "answer": "Dropdown",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_938"
        },
        {
            "dependency": "requests",
            "version": "==2.31.0",
            "time": "2023-10-11",
            "description": "The code creates a custom HTTP adapter in Python using custom cipher suites for HTTPS connections. It then creates a session with the adapter mounted and makes a GET request to a specific URL using the custom cipher suites.",
            "code": "import requests\nfrom requests.adapters import HTTPAdapter\nfrom requests.packages.urllib3.util.ssl_ import create_urllib3_context\nimport urllib3\n\ncustom_ciphers = [\n    \"ECDHE-RSA-AES256-GCM-SHA384\",\n#    \"DHE-RSA-AES256-GCM-SHA384\",\n#    \"ECDHE-RSA-AES128-GCM-SHA256\",\n#    \"TLS_AES_256_GCM_SHA384\",\n]\n\nclass CustomCipherAdapter(HTTPAdapter):\n    def init_poolmanager(self, *args, **kwargs):\n        context = create_urllib3_context(ciphers=\":\".join(custom_ciphers))\n        kwargs['ssl_context'] = context\n        return super(CustomCipherAdapter, self).init_poolmanager(*args, **kwargs)\n\n# Create a session and mount the adapter\nsession = requests.Session()\nsession.mount(\"https://\", CustomCipherAdapter())\n\n# Now you can use the session to make requests with the custom cipher suites\nresponse = session.get(\"https://api-mte.itespp.org/markets/VirtualService/v2/?WSDL\")\nprint(response)",
            "masked_code": "import requests\nfrom requests.adapters import HTTPAdapter\n<line_mask>\nimport urllib3\n\ncustom_ciphers = [\n    \"ECDHE-RSA-AES256-GCM-SHA384\",\n#    \"DHE-RSA-AES256-GCM-SHA384\",\n#    \"ECDHE-RSA-AES128-GCM-SHA256\",\n#    \"TLS_AES_256_GCM_SHA384\",\n]\n\nclass CustomCipherAdapter(HTTPAdapter):\n    def init_poolmanager(self, *args, **kwargs):\n        context = create_urllib3_context(ciphers=\":\".join(custom_ciphers))\n        kwargs['ssl_context'] = context\n        return super(CustomCipherAdapter, self).init_poolmanager(*args, **kwargs)\n\n# Create a session and mount the adapter\nsession = requests.Session()\nsession.mount(\"https://\", CustomCipherAdapter())\n\n# Now you can use the session to make requests with the custom cipher suites\nresponse = session.get(\"https://api-mte.itespp.org/markets/VirtualService/v2/?WSDL\")\nprint(response)",
            "masked_line": "from requests.packages.urllib3.util.ssl_ import create_urllib3_context",
            "answer": "create_urllib3_context",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_939"
        },
        {
            "dependency": "selenium",
            "version": "==4.10",
            "time": "2023-07-15",
            "description": "The code sets up Chrome browser options, configures logging preferences for performance logging, and initializes a Chrome driver with the specified service and options.",
            "code": "from selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.set_capability('goog:loggingPrefs', {'performance': 'ALL'})\n# other configurations\ndriver = Chrome(service=service, options=options)",
            "masked_code": "from selenium.webdriver.chrome.options import Options\n\n<line_mask>\noptions.set_capability('goog:loggingPrefs', {'performance': 'ALL'})\n# other configurations\ndriver = Chrome(service=service, options=options)",
            "masked_line": "options = Options()",
            "answer": "Options",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_940"
        },
        {
            "dependency": "selenium",
            "version": "==4.8.0",
            "time": "2023-06-13",
            "description": "This code opens a Chrome browser using Selenium WebDriver, with specific options configured to maximize the window, and navigates to the URL 'https://pypi.org/'.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.chrome.service import Service\nfrom webdriver_manager.chrome import ChromeDriverManager\nimport sys\n\nprint (\"Python Version: \" +sys.version)\nimport webdriver_manager\nprint(\"WebDriverManager version: \" +webdriver_manager.__version__)\nimport selenium\nprint(\"Selenium version: \" +selenium.__version__)\noptions = Options()\noptions.add_argument(\"start-maximized\")\ndriver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)\ndriver.get('https://pypi.org/')",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n<line_mask>\nfrom webdriver_manager.chrome import ChromeDriverManager\nimport sys\n\nprint (\"Python Version: \" +sys.version)\nimport webdriver_manager\nprint(\"WebDriverManager version: \" +webdriver_manager.__version__)\nimport selenium\nprint(\"Selenium version: \" +selenium.__version__)\noptions = Options()\noptions.add_argument(\"start-maximized\")\ndriver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)\ndriver.get('https://pypi.org/')",
            "masked_line": "from selenium.webdriver.chrome.service import Service",
            "answer": "Service",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_941"
        },
        {
            "dependency": "bokeh",
            "version": "==2.4.3",
            "time": "2023-01-23",
            "description": "The code generates a Bokeh plot with multiple lines representing stock closing prices for Apple (AAPL), Google (GOOG), IBM, and Microsoft (MSFT). The legend allows users to click and hide/show specific stock lines on the plot.",
            "code": "import pandas as pd\n\nfrom bokeh.plotting import figure, show, output_notebook\nfrom bokeh.sampledata.stocks import AAPL, GOOG, IBM, MSFT\noutput_notebook()\n\np = figure(width=800, height=250, x_axis_type=\"datetime\")\np.title.text = 'Click on legend entries to hide the corresponding lines'\n\ndataset = [AAPL, GOOG, IBM, MSFT, AAPL]\nnameset = [\"AAPL\", \"GOOG\", \"IBM\", \"MSFT\", \"AAP\"]\ncolorset = ['blue', 'red', 'green', 'magenta', 'black']\n\nfor data, name, color in zip(dataset, nameset, colorset):\n    df = pd.DataFrame(data)\n    df['date'] = pd.to_datetime(df['date'])\n    p.line(df['date'], df['close'], line_width=2, color=color, alpha=0.8, legend_label=name)\n\np.legend.location = \"top_left\"\np.legend.click_policy=\"hide\"\nshow(p)",
            "masked_code": "import pandas as pd\n\n<line_mask>\nfrom bokeh.sampledata.stocks import AAPL, GOOG, IBM, MSFT\noutput_notebook()\n\np = figure(width=800, height=250, x_axis_type=\"datetime\")\np.title.text = 'Click on legend entries to hide the corresponding lines'\n\ndataset = [AAPL, GOOG, IBM, MSFT, AAPL]\nnameset = [\"AAPL\", \"GOOG\", \"IBM\", \"MSFT\", \"AAP\"]\ncolorset = ['blue', 'red', 'green', 'magenta', 'black']\n\nfor data, name, color in zip(dataset, nameset, colorset):\n    df = pd.DataFrame(data)\n    df['date'] = pd.to_datetime(df['date'])\n    p.line(df['date'], df['close'], line_width=2, color=color, alpha=0.8, legend_label=name)\n\np.legend.location = \"top_left\"\np.legend.click_policy=\"hide\"\nshow(p)",
            "masked_line": "from bokeh.plotting import figure, show, output_notebook",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_942"
        },
        {
            "dependency": "connexion",
            "version": "==3.0.2",
            "time": "2023-11-28",
            "description": "The code creates a Flask web application using the Connexion library and initializes it with an OpenAPI specification file named \"openapi.yaml\" to validate responses.",
            "code": "from connexion import FlaskApp\n\ndef create_app():\n    app = FlaskApp(__name__)\n    app.add_api(\"openapi.yaml\", validate_responses=True)\n    return app\n\napp = create_app()",
            "masked_code": "from connexion import FlaskApp\n\ndef create_app():\n    app = FlaskApp(__name__)\n    <line_mask>\n    return app\n\napp = create_app()",
            "masked_line": "app.add_api(\"openapi.yaml\", validate_responses=True)",
            "answer": "add_api",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_943"
        },
        {
            "dependency": "spacy",
            "version": "==3.0.9",
            "time": "2023-09-25",
            "description": "The code loads the spaCy model \"en_ner_bc5cdr_md\" for named entity recognition.",
            "code": "import spacy\nnlp = spacy.load(\"en_ner_bc5cdr_md\")",
            "masked_code": "import spacy\n<line_mask>",
            "masked_line": "nlp = spacy.load(\"en_ner_bc5cdr_md\")",
            "answer": "load",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_944"
        },
        {
            "dependency": "plotly",
            "version": ">=5.15",
            "time": "2023-08-20",
            "description": "This code generates a multi-plot figure using Plotly library to show the life expectancy data for different countries in the Americas over time. Each subplot corresponds to a different country, with the x-axis representing the year and the y-axis representing the life expectancy. The figure includes plots for Canada, United States, Mexico, Colombia, Brazil, Argentina, and Chile, each with their respective legend and legend group. The layout includes titles for the overall plot and each subplot, as well as customized y-axis ranges for each subplot.",
            "code": "import pandas as pd\nimport plotly.express as px\n\ndf = px.data.gapminder().query(\"continent=='Americas'\")\n\n\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\n\nfig = make_subplots(rows=3, cols=1, row_heights=[2,1,0.75]) \n\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Canada'\")['year'],\n    y=df.query(\"country == 'Canada'\")['lifeExp'],\n    name = 'Canada',\n    legend='legend',\n    legendgroup = '1'\n), row=1, col=1)\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'United States'\")['year'],\n    y=df.query(\"country == 'United States'\")['lifeExp'],\n    name = 'United States',\n    legend='legend',\n    legendgroup = '1'\n), row=1, col=1)\n\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Mexico'\")['year'],\n    y=df.query(\"country == 'Mexico'\")['lifeExp'],\n    name = 'Mexico',\n    legend='legend2',\n    legendgroup = '2'\n), row=2, col=1)\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Colombia'\")['year'],\n    y=df.query(\"country == 'Colombia'\")['lifeExp'],\n    name = 'Colombia',\n    legend='legend2',\n    legendgroup = '2'\n), row=2, col=1)\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Brazil'\")['year'],\n    y=df.query(\"country == 'Brazil'\")['lifeExp'],\n    name = 'Brazil',\n    legend='legend2',\n    legendgroup = '2'\n), row=2, col=1)\n\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Argentina'\")['year'],\n    y=df.query(\"country == 'Argentina'\")['lifeExp'],\n    name = 'Argentina',\n    legend='legend3',\n    legendgroup = '3'\n), row=3, col=1)\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Chile'\")['year'],\n    y=df.query(\"country == 'Chile'\")['lifeExp'],\n    name = 'Chile',\n    legend='legend3',\n    legendgroup = '3',\n), row=3, col=1)\n\nfig.update_layout(\n    height=800,\n    width=800,\n    title_text=\"Life Expectancy in the Americas\",\n    xaxis3_title = 'Year',\n    yaxis1_title = 'Age',\n    yaxis2_title = 'Age',\n    yaxis3_title = 'Age',\n    legend = {\"y\": 1.0},\n    legend2 = {\"y\": 0.42},\n    legend3 = {\"y\": 0.08},\n    yaxis1_range=[50, 90],\n    yaxis2_range=[50, 90],\n    yaxis3_range=[50, 90]\n)\nfig.show()",
            "masked_code": "import pandas as pd\nimport plotly.express as px\n\ndf = px.data.gapminder().query(\"continent=='Americas'\")\n\n\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\n\nfig = make_subplots(rows=3, cols=1, row_heights=[2,1,0.75]) \n\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Canada'\")['year'],\n    y=df.query(\"country == 'Canada'\")['lifeExp'],\n    name = 'Canada',\n    legend='legend',\n    legendgroup = '1'\n), row=1, col=1)\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'United States'\")['year'],\n    y=df.query(\"country == 'United States'\")['lifeExp'],\n    name = 'United States',\n    legend='legend',\n    legendgroup = '1'\n), row=1, col=1)\n\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Mexico'\")['year'],\n    y=df.query(\"country == 'Mexico'\")['lifeExp'],\n    name = 'Mexico',\n    legend='legend2',\n    legendgroup = '2'\n), row=2, col=1)\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Colombia'\")['year'],\n    y=df.query(\"country == 'Colombia'\")['lifeExp'],\n    name = 'Colombia',\n    legend='legend2',\n    legendgroup = '2'\n), row=2, col=1)\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Brazil'\")['year'],\n    y=df.query(\"country == 'Brazil'\")['lifeExp'],\n    name = 'Brazil',\n    legend='legend2',\n    legendgroup = '2'\n), row=2, col=1)\n\nfig.append_trace(go.Scatter(\n    x=df.query(\"country == 'Argentina'\")['year'],\n    y=df.query(\"country == 'Argentina'\")['lifeExp'],\n    name = 'Argentina',\n    legend='legend3',\n    legendgroup = '3'\n), row=3, col=1)\n<line_mask>\n    x=df.query(\"country == 'Chile'\")['year'],\n    y=df.query(\"country == 'Chile'\")['lifeExp'],\n    name = 'Chile',\n    legend='legend3',\n    legendgroup = '3',\n), row=3, col=1)\n\nfig.update_layout(\n    height=800,\n    width=800,\n    title_text=\"Life Expectancy in the Americas\",\n    xaxis3_title = 'Year',\n    yaxis1_title = 'Age',\n    yaxis2_title = 'Age',\n    yaxis3_title = 'Age',\n    legend = {\"y\": 1.0},\n    legend2 = {\"y\": 0.42},\n    legend3 = {\"y\": 0.08},\n    yaxis1_range=[50, 90],\n    yaxis2_range=[50, 90],\n    yaxis3_range=[50, 90]\n)\nfig.show()",
            "masked_line": "fig.append_trace(go.Scatter(",
            "answer": "append_trace",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_945"
        },
        {
            "dependency": "selenium",
            "version": "==4.10",
            "time": "2023-07-13",
            "description": "This code initializes Chrome options, sets a logging preference for performance data, and creates a Chrome web driver instance with the specified options.",
            "code": "from selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.set_capability('goog:loggingPrefs', {'performance': 'ALL'})\ndriver = Chrome(options=options)",
            "masked_code": "<line_mask>\n\noptions = Options()\noptions.set_capability('goog:loggingPrefs', {'performance': 'ALL'})\ndriver = Chrome(options=options)",
            "masked_line": "from selenium.webdriver.chrome.options import Options",
            "answer": "Options",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_946"
        },
        {
            "dependency": "selenium",
            "version": "==4.10.0",
            "time": "2023-06-20",
            "description": "The code initiates a headless Chrome browser using Selenium, with the Chrome browser options set to run in headless mode. It then prints \"done\" to the console.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = webdriver.ChromeOptions()\noptions.add_argument('\"--headless=new\"')\ndriver = webdriver.Chrome(options=options)\nprint(\"done\")",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = webdriver.ChromeOptions()\n<line_mask>\ndriver = webdriver.Chrome(options=options)\nprint(\"done\")",
            "masked_line": "options.add_argument('\"--headless=new\"')",
            "answer": "add_argument",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_947"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2024-01-10",
            "description": "This code snippet defines a function called \"predict_package_mix_p\" that takes a Pandas DataFrame as input and applies various transformations (including loading pre-trained machine learning models) to generate predictions for a specific business case related to airline package mix.",
            "code": "import cachetools\n\n@cachetools.cached(cache={})\ndef read_file(filename):\n    import sys\n    import os\n    import joblib\n    # Get the \"path\" of where files added through iport are avalible\n    import_dir = sys._xoptions.get(\"snowflake_import_directory\")\n    if import_dir:\n        with open(os.path.join(import_dir, filename), 'rb') as file:\n            m = joblib.load(file)\n            return m\n\nsession.add_import(\"@AM_TEST_MODELS/xgb_model.pkl.gz\")\nsession.add_import(\"@AM_TEST_MODELS/one_hot_encode.pkl\")\nsession.add_import(\"@AM_TEST_MODELS/ordinal_encode.pkl\")\nsession.add_import(\"@AM_TEST_MODELS/target_encoding.csv.gz\")\nsession.add_packages(\"pandas==1.5.3\",\"joblib==1.2.0\",\"xgboost==1.7.3\",\"scikit-learn==1.2.2\",\"cloudpickle==2.2.1\",\"cachetools\",\"snowflake-ml-python\")\n\nfrom snowflake.snowpark.types import PandasDataFrameType,PandasSeriesType,IntegerType,StringType,FloatType,PandasDataFrame,PandasSeries\nimport pandas as pd\n\n\n@F.udf(\n        name='predict_package_mix_p',session=session,replace=True,\n        is_permanent=True,stage_location='@AM_TEST_UDFS',\n)\ndef predict_package_mix_p(\n    df:PandasDataFrame[int,str,str,str,str,str,int]\n) -> PandasSeries[float]:\n    import sys\n    import pandas as pd\n    from joblib import load\n    import sklearn\n    import xgboost as xgb\n    import json\n    import snowflake.ml.modeling\n\n    def transform_simple_target_encode_manual(\n            df,transform_col,transform_df\n        ):\n        df = df.merge(transform_df, on=transform_col)\n        return df\n    \n    def remove_space(df):\n        cols = df.columns\n        space_cols = [x for x in cols if ' ' in x]\n        for c in space_cols:\n            new_col = c.replace(\" \",\"_\")\n            df = df.rename(columns={c:new_col})\n        return df\n\n    IMPORT_DIRECTORY_NAME = \"snowflake_import_directory\"\n    import_dir = sys._xoptions[IMPORT_DIRECTORY_NAME]\n\n    ohe = read_file('one_hot_encode.pkl')\n    oe = read_file('ordinal_encode.pkl')\n    te = pd.read_csv(import_dir + 'target_encoding.csv.gz')\n    model = read_file('xgb_model.pkl.gz')\n    print('loaded models')\n    \n    features = [\n        \"LS1_FLIGHT_ID\",\"DEPARTURE_AIRPORT_CODE\",\"ARRIVAL_AIRPORT_CODE\",\n        \"ROUTE_CATEGORY_NAME\",\"DEPARTURE_DATETIME_LOCAL\",\n        \"ARRIVAL_DATETIME_LOCAL\",\"CAPACITY\"\n    ]\n\n    df.columns = features\n    print('loaded dataframe')\n\n    # transform data for one hot and ordinal encodings\n    df_ohe = ohe.transform(df[['ROUTE_CATEGORY_NAME']])\n    encoded_df = pd.DataFrame(df_ohe, columns=ohe.categories_)\n    encoded_df.columns = encoded_df.columns.get_level_values(0)\n    encoded_df = encoded_df.add_prefix('ROUTE_NAME_OHE_')\n    df = pd.concat([df, encoded_df], axis=1)\n    df['DEPART_CODE_ENCODE'] = oe.transform(df[['DEPARTURE_AIRPORT_CODE']])\n\n    print('transformed via one hot and ordinal')\n    # transform using pre-set target encoding\n    df_te = transform_simple_target_encode_manual(df,'ARRIVAL_AIRPORT_CODE',te)\n    df_final = remove_space(df_te)\n    print('transformed via target encode')\n\n    # change date cols to datetime\n    df_final.loc[:,'DEPARTURE_DATETIME_LOCAL'] = pd.to_datetime(\n        df_final.loc[:,'DEPARTURE_DATETIME_LOCAL'],format='%Y-%m-%d %H:%M:%S',yearfirst=True\n    )\n    df_final['ARRIVAL_DATETIME_LOCAL'] = pd.to_datetime(\n        df_final['ARRIVAL_DATETIME_LOCAL'],format='%Y-%m-%d %H:%M:%S',yearfirst=True\n    )\n    print('transformed dates')\n\n    df_final['DEPART_HOUR'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.hour\n    # snowpark function goes from 1-7 whereas pandas goes from 0-6\n    df_final['DEPART_WEEKDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day_of_week + 1\n    df_final['DEPART_MONTHDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day\n    df_final['DEPART_YEARDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day_of_year\n    df_final['DEPART_MONTH'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.month\n    df_final['DEPART_YEAR'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.year\n    df_final['ARRIVE_HOUR'] = df_final['ARRIVAL_DATETIME_LOCAL'].dt.hour\n    print('created features')\n\n    pm = pd.Series(model.predict(df_final[\n            [\"DEPART_CODE_ENCODE\",\"ROUTE_NAME_OHE_CITY\",\"ROUTE_NAME_OHE_FAR_SUN\",\n            \"ROUTE_NAME_OHE_SKI\",\"ROUTE_NAME_OHE_SUN\",\"CAPACITY\",\n            \"ARRIVAL_AIRPORT_CODE_ENCODED\",\"DEPART_HOUR\",\n            \"DEPART_WEEKDAY\",\"DEPART_MONTHDAY\",\"DEPART_YEARDAY\",\n            \"DEPART_MONTH\",\"DEPART_YEAR\",\"ARRIVE_HOUR\"]\n        ]))\n    return pm\n\nfrom snowflake.snowpark.session import Session\nfrom snowflake.snowpark.functions import col,array_construct,call_udf\nimport json\nimport pandas as pd\n\n# Create Snowflake Session object\nconnection_parameters = json.load(open('connection.json'))\nsession = Session.builder.configs(connection_parameters).create()\nsession.sql_simplifier_enabled = True\n\ntest_df = session.create_dataframe(\n    [[979152,\"LBA\",\"ALC\",\"SUN\",\"2023-11-24 08:30:00\",\"2023-11-24 12:25:00\",189],\n     [987073,\"LBA\",\"FAO\",\"SUN\",\"2023-12-13 16:15:00\",\"2023-12-13 11:25:00\",189],\n     [951384,\"STN\",\"FNC\",\"FAR SUN\",\"2023-12-05 09:40:00\",\"2023-12-05 13:35:00\",189],\n     [952380,\"MAN\",\"LPA\",\"FAR SUN\",\"2023-12-22 19:45:00\",\"2023-12-22 14:30:00\",235],\n     [963602,\"MAN\",\"FUE\",\"FAR SUN\",\"2023-12-29 10:30:00\",\"2023-12-29 15:05:00\",235]],\n    schema=[\n        \"LS1_FLIGHT_ID\",\"DEPARTURE_AIRPORT_CODE\",\"ARRIVAL_AIRPORT_CODE\",\n        \"ROUTE_CATEGORY_NAME\",\"DEPARTURE_DATETIME_LOCAL\",\"ARRIVAL_DATETIME_LOCAL\",\"CAPACITY\"\n    ]\n)\n\ntest_df.withColumn(\n    'PREDICTED_PACKAGE_MIX', \n    predict_package_mix_p([*test_df])).show()",
            "masked_code": "import cachetools\n\n@cachetools.cached(cache={})\ndef read_file(filename):\n    import sys\n    import os\n    import joblib\n    # Get the \"path\" of where files added through iport are avalible\n    import_dir = sys._xoptions.get(\"snowflake_import_directory\")\n    if import_dir:\n        with open(os.path.join(import_dir, filename), 'rb') as file:\n            m = joblib.load(file)\n            return m\n\nsession.add_import(\"@AM_TEST_MODELS/xgb_model.pkl.gz\")\nsession.add_import(\"@AM_TEST_MODELS/one_hot_encode.pkl\")\nsession.add_import(\"@AM_TEST_MODELS/ordinal_encode.pkl\")\nsession.add_import(\"@AM_TEST_MODELS/target_encoding.csv.gz\")\nsession.add_packages(\"pandas==1.5.3\",\"joblib==1.2.0\",\"xgboost==1.7.3\",\"scikit-learn==1.2.2\",\"cloudpickle==2.2.1\",\"cachetools\",\"snowflake-ml-python\")\n\nfrom snowflake.snowpark.types import PandasDataFrameType,PandasSeriesType,IntegerType,StringType,FloatType,PandasDataFrame,PandasSeries\nimport pandas as pd\n\n\n@F.udf(\n        name='predict_package_mix_p',session=session,replace=True,\n        is_permanent=True,stage_location='@AM_TEST_UDFS',\n)\ndef predict_package_mix_p(\n    df:PandasDataFrame[int,str,str,str,str,str,int]\n) -> PandasSeries[float]:\n    import sys\n    import pandas as pd\n    from joblib import load\n    import sklearn\n    import xgboost as xgb\n    import json\n    import snowflake.ml.modeling\n\n    def transform_simple_target_encode_manual(\n            df,transform_col,transform_df\n        ):\n        df = df.merge(transform_df, on=transform_col)\n        return df\n    \n    def remove_space(df):\n        cols = df.columns\n        space_cols = [x for x in cols if ' ' in x]\n        for c in space_cols:\n            new_col = c.replace(\" \",\"_\")\n            <line_mask>\n        return df\n\n    IMPORT_DIRECTORY_NAME = \"snowflake_import_directory\"\n    import_dir = sys._xoptions[IMPORT_DIRECTORY_NAME]\n\n    ohe = read_file('one_hot_encode.pkl')\n    oe = read_file('ordinal_encode.pkl')\n    te = pd.read_csv(import_dir + 'target_encoding.csv.gz')\n    model = read_file('xgb_model.pkl.gz')\n    print('loaded models')\n    \n    features = [\n        \"LS1_FLIGHT_ID\",\"DEPARTURE_AIRPORT_CODE\",\"ARRIVAL_AIRPORT_CODE\",\n        \"ROUTE_CATEGORY_NAME\",\"DEPARTURE_DATETIME_LOCAL\",\n        \"ARRIVAL_DATETIME_LOCAL\",\"CAPACITY\"\n    ]\n\n    df.columns = features\n    print('loaded dataframe')\n\n    # transform data for one hot and ordinal encodings\n    df_ohe = ohe.transform(df[['ROUTE_CATEGORY_NAME']])\n    encoded_df = pd.DataFrame(df_ohe, columns=ohe.categories_)\n    encoded_df.columns = encoded_df.columns.get_level_values(0)\n    encoded_df = encoded_df.add_prefix('ROUTE_NAME_OHE_')\n    df = pd.concat([df, encoded_df], axis=1)\n    df['DEPART_CODE_ENCODE'] = oe.transform(df[['DEPARTURE_AIRPORT_CODE']])\n\n    print('transformed via one hot and ordinal')\n    # transform using pre-set target encoding\n    df_te = transform_simple_target_encode_manual(df,'ARRIVAL_AIRPORT_CODE',te)\n    df_final = remove_space(df_te)\n    print('transformed via target encode')\n\n    # change date cols to datetime\n    df_final.loc[:,'DEPARTURE_DATETIME_LOCAL'] = pd.to_datetime(\n        df_final.loc[:,'DEPARTURE_DATETIME_LOCAL'],format='%Y-%m-%d %H:%M:%S',yearfirst=True\n    )\n    df_final['ARRIVAL_DATETIME_LOCAL'] = pd.to_datetime(\n        df_final['ARRIVAL_DATETIME_LOCAL'],format='%Y-%m-%d %H:%M:%S',yearfirst=True\n    )\n    print('transformed dates')\n\n    df_final['DEPART_HOUR'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.hour\n    # snowpark function goes from 1-7 whereas pandas goes from 0-6\n    df_final['DEPART_WEEKDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day_of_week + 1\n    df_final['DEPART_MONTHDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day\n    df_final['DEPART_YEARDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day_of_year\n    df_final['DEPART_MONTH'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.month\n    df_final['DEPART_YEAR'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.year\n    df_final['ARRIVE_HOUR'] = df_final['ARRIVAL_DATETIME_LOCAL'].dt.hour\n    print('created features')\n\n    pm = pd.Series(model.predict(df_final[\n            [\"DEPART_CODE_ENCODE\",\"ROUTE_NAME_OHE_CITY\",\"ROUTE_NAME_OHE_FAR_SUN\",\n            \"ROUTE_NAME_OHE_SKI\",\"ROUTE_NAME_OHE_SUN\",\"CAPACITY\",\n            \"ARRIVAL_AIRPORT_CODE_ENCODED\",\"DEPART_HOUR\",\n            \"DEPART_WEEKDAY\",\"DEPART_MONTHDAY\",\"DEPART_YEARDAY\",\n            \"DEPART_MONTH\",\"DEPART_YEAR\",\"ARRIVE_HOUR\"]\n        ]))\n    return pm\n\nfrom snowflake.snowpark.session import Session\nfrom snowflake.snowpark.functions import col,array_construct,call_udf\nimport json\nimport pandas as pd\n\n# Create Snowflake Session object\nconnection_parameters = json.load(open('connection.json'))\nsession = Session.builder.configs(connection_parameters).create()\nsession.sql_simplifier_enabled = True\n\ntest_df = session.create_dataframe(\n    [[979152,\"LBA\",\"ALC\",\"SUN\",\"2023-11-24 08:30:00\",\"2023-11-24 12:25:00\",189],\n     [987073,\"LBA\",\"FAO\",\"SUN\",\"2023-12-13 16:15:00\",\"2023-12-13 11:25:00\",189],\n     [951384,\"STN\",\"FNC\",\"FAR SUN\",\"2023-12-05 09:40:00\",\"2023-12-05 13:35:00\",189],\n     [952380,\"MAN\",\"LPA\",\"FAR SUN\",\"2023-12-22 19:45:00\",\"2023-12-22 14:30:00\",235],\n     [963602,\"MAN\",\"FUE\",\"FAR SUN\",\"2023-12-29 10:30:00\",\"2023-12-29 15:05:00\",235]],\n    schema=[\n        \"LS1_FLIGHT_ID\",\"DEPARTURE_AIRPORT_CODE\",\"ARRIVAL_AIRPORT_CODE\",\n        \"ROUTE_CATEGORY_NAME\",\"DEPARTURE_DATETIME_LOCAL\",\"ARRIVAL_DATETIME_LOCAL\",\"CAPACITY\"\n    ]\n)\n\ntest_df.withColumn(\n    'PREDICTED_PACKAGE_MIX', \n    predict_package_mix_p([*test_df])).show()",
            "masked_line": "df = df.rename(columns={c:new_col})",
            "answer": "rename",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_948"
        },
        {
            "dependency": "joblib",
            "version": "==1.2.0",
            "time": "2024-01-10",
            "description": "The code reads pre-trained machine learning models and applies them to a given dataset to predict a specific output value based on the input features. It transforms the input data using one-hot encoding, ordinal encoding, and target encoding techniques before making predictions using an XGBoost model. Finally, it creates new features based on the input data and outputs the predicted package mix for each input row.",
            "code": "import cachetools\n\n@cachetools.cached(cache={})\ndef read_file(filename):\n    import sys\n    import os\n    import joblib\n    # Get the \"path\" of where files added through iport are avalible\n    import_dir = sys._xoptions.get(\"snowflake_import_directory\")\n    if import_dir:\n        with open(os.path.join(import_dir, filename), 'rb') as file:\n            m = joblib.load(file)\n            return m\n\nsession.add_import(\"@AM_TEST_MODELS/xgb_model.pkl.gz\")\nsession.add_import(\"@AM_TEST_MODELS/one_hot_encode.pkl\")\nsession.add_import(\"@AM_TEST_MODELS/ordinal_encode.pkl\")\nsession.add_import(\"@AM_TEST_MODELS/target_encoding.csv.gz\")\nsession.add_packages(\"pandas==1.5.3\",\"joblib==1.2.0\",\"xgboost==1.7.3\",\"scikit-learn==1.2.2\",\"cloudpickle==2.2.1\",\"cachetools\",\"snowflake-ml-python\")\n\nfrom snowflake.snowpark.types import PandasDataFrameType,PandasSeriesType,IntegerType,StringType,FloatType,PandasDataFrame,PandasSeries\nimport pandas as pd\n\n\n@F.udf(\n        name='predict_package_mix_p',session=session,replace=True,\n        is_permanent=True,stage_location='@AM_TEST_UDFS',\n)\ndef predict_package_mix_p(\n    df:PandasDataFrame[int,str,str,str,str,str,int]\n) -> PandasSeries[float]:\n    import sys\n    import pandas as pd\n    from joblib import load\n    import sklearn\n    import xgboost as xgb\n    import json\n    import snowflake.ml.modeling\n\n    def transform_simple_target_encode_manual(\n            df,transform_col,transform_df\n        ):\n        df = df.merge(transform_df, on=transform_col)\n        return df\n    \n    def remove_space(df):\n        cols = df.columns\n        space_cols = [x for x in cols if ' ' in x]\n        for c in space_cols:\n            new_col = c.replace(\" \",\"_\")\n            df = df.rename(columns={c:new_col})\n        return df\n\n    IMPORT_DIRECTORY_NAME = \"snowflake_import_directory\"\n    import_dir = sys._xoptions[IMPORT_DIRECTORY_NAME]\n\n    ohe = read_file('one_hot_encode.pkl')\n    oe = read_file('ordinal_encode.pkl')\n    te = pd.read_csv(import_dir + 'target_encoding.csv.gz')\n    model = read_file('xgb_model.pkl.gz')\n    print('loaded models')\n    \n    features = [\n        \"LS1_FLIGHT_ID\",\"DEPARTURE_AIRPORT_CODE\",\"ARRIVAL_AIRPORT_CODE\",\n        \"ROUTE_CATEGORY_NAME\",\"DEPARTURE_DATETIME_LOCAL\",\n        \"ARRIVAL_DATETIME_LOCAL\",\"CAPACITY\"\n    ]\n\n    df.columns = features\n    print('loaded dataframe')\n\n    # transform data for one hot and ordinal encodings\n    df_ohe = ohe.transform(df[['ROUTE_CATEGORY_NAME']])\n    encoded_df = pd.DataFrame(df_ohe, columns=ohe.categories_)\n    encoded_df.columns = encoded_df.columns.get_level_values(0)\n    encoded_df = encoded_df.add_prefix('ROUTE_NAME_OHE_')\n    df = pd.concat([df, encoded_df], axis=1)\n    df['DEPART_CODE_ENCODE'] = oe.transform(df[['DEPARTURE_AIRPORT_CODE']])\n\n    print('transformed via one hot and ordinal')\n    # transform using pre-set target encoding\n    df_te = transform_simple_target_encode_manual(df,'ARRIVAL_AIRPORT_CODE',te)\n    df_final = remove_space(df_te)\n    print('transformed via target encode')\n\n    # change date cols to datetime\n    df_final.loc[:,'DEPARTURE_DATETIME_LOCAL'] = pd.to_datetime(\n        df_final.loc[:,'DEPARTURE_DATETIME_LOCAL'],format='%Y-%m-%d %H:%M:%S',yearfirst=True\n    )\n    df_final['ARRIVAL_DATETIME_LOCAL'] = pd.to_datetime(\n        df_final['ARRIVAL_DATETIME_LOCAL'],format='%Y-%m-%d %H:%M:%S',yearfirst=True\n    )\n    print('transformed dates')\n\n    df_final['DEPART_HOUR'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.hour\n    # snowpark function goes from 1-7 whereas pandas goes from 0-6\n    df_final['DEPART_WEEKDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day_of_week + 1\n    df_final['DEPART_MONTHDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day\n    df_final['DEPART_YEARDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day_of_year\n    df_final['DEPART_MONTH'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.month\n    df_final['DEPART_YEAR'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.year\n    df_final['ARRIVE_HOUR'] = df_final['ARRIVAL_DATETIME_LOCAL'].dt.hour\n    print('created features')\n\n    pm = pd.Series(model.predict(df_final[\n            [\"DEPART_CODE_ENCODE\",\"ROUTE_NAME_OHE_CITY\",\"ROUTE_NAME_OHE_FAR_SUN\",\n            \"ROUTE_NAME_OHE_SKI\",\"ROUTE_NAME_OHE_SUN\",\"CAPACITY\",\n            \"ARRIVAL_AIRPORT_CODE_ENCODED\",\"DEPART_HOUR\",\n            \"DEPART_WEEKDAY\",\"DEPART_MONTHDAY\",\"DEPART_YEARDAY\",\n            \"DEPART_MONTH\",\"DEPART_YEAR\",\"ARRIVE_HOUR\"]\n        ]))\n    return pm\n\nfrom snowflake.snowpark.session import Session\nfrom snowflake.snowpark.functions import col,array_construct,call_udf\nimport json\nimport pandas as pd\n\n# Create Snowflake Session object\nconnection_parameters = json.load(open('connection.json'))\nsession = Session.builder.configs(connection_parameters).create()\nsession.sql_simplifier_enabled = True\n\ntest_df = session.create_dataframe(\n    [[979152,\"LBA\",\"ALC\",\"SUN\",\"2023-11-24 08:30:00\",\"2023-11-24 12:25:00\",189],\n     [987073,\"LBA\",\"FAO\",\"SUN\",\"2023-12-13 16:15:00\",\"2023-12-13 11:25:00\",189],\n     [951384,\"STN\",\"FNC\",\"FAR SUN\",\"2023-12-05 09:40:00\",\"2023-12-05 13:35:00\",189],\n     [952380,\"MAN\",\"LPA\",\"FAR SUN\",\"2023-12-22 19:45:00\",\"2023-12-22 14:30:00\",235],\n     [963602,\"MAN\",\"FUE\",\"FAR SUN\",\"2023-12-29 10:30:00\",\"2023-12-29 15:05:00\",235]],\n    schema=[\n        \"LS1_FLIGHT_ID\",\"DEPARTURE_AIRPORT_CODE\",\"ARRIVAL_AIRPORT_CODE\",\n        \"ROUTE_CATEGORY_NAME\",\"DEPARTURE_DATETIME_LOCAL\",\"ARRIVAL_DATETIME_LOCAL\",\"CAPACITY\"\n    ]\n)\n\ntest_df.withColumn(\n    'PREDICTED_PACKAGE_MIX', \n    predict_package_mix_p([*test_df])).show()",
            "masked_code": "import cachetools\n\n@cachetools.cached(cache={})\ndef read_file(filename):\n    import sys\n    import os\n    import joblib\n    # Get the \"path\" of where files added through iport are avalible\n    import_dir = sys._xoptions.get(\"snowflake_import_directory\")\n    if import_dir:\n        with open(os.path.join(import_dir, filename), 'rb') as file:\n            m = joblib.load(file)\n            return m\n\nsession.add_import(\"@AM_TEST_MODELS/xgb_model.pkl.gz\")\nsession.add_import(\"@AM_TEST_MODELS/one_hot_encode.pkl\")\nsession.add_import(\"@AM_TEST_MODELS/ordinal_encode.pkl\")\nsession.add_import(\"@AM_TEST_MODELS/target_encoding.csv.gz\")\nsession.add_packages(\"pandas==1.5.3\",\"joblib==1.2.0\",\"xgboost==1.7.3\",\"scikit-learn==1.2.2\",\"cloudpickle==2.2.1\",\"cachetools\",\"snowflake-ml-python\")\n\nfrom snowflake.snowpark.types import PandasDataFrameType,PandasSeriesType,IntegerType,StringType,FloatType,PandasDataFrame,PandasSeries\nimport pandas as pd\n\n\n@F.udf(\n        name='predict_package_mix_p',session=session,replace=True,\n        is_permanent=True,stage_location='@AM_TEST_UDFS',\n)\ndef predict_package_mix_p(\n    df:PandasDataFrame[int,str,str,str,str,str,int]\n) -> PandasSeries[float]:\n    import sys\n    import pandas as pd\n    <line_mask>\n    import sklearn\n    import xgboost as xgb\n    import json\n    import snowflake.ml.modeling\n\n    def transform_simple_target_encode_manual(\n            df,transform_col,transform_df\n        ):\n        df = df.merge(transform_df, on=transform_col)\n        return df\n    \n    def remove_space(df):\n        cols = df.columns\n        space_cols = [x for x in cols if ' ' in x]\n        for c in space_cols:\n            new_col = c.replace(\" \",\"_\")\n            df = df.rename(columns={c:new_col})\n        return df\n\n    IMPORT_DIRECTORY_NAME = \"snowflake_import_directory\"\n    import_dir = sys._xoptions[IMPORT_DIRECTORY_NAME]\n\n    ohe = read_file('one_hot_encode.pkl')\n    oe = read_file('ordinal_encode.pkl')\n    te = pd.read_csv(import_dir + 'target_encoding.csv.gz')\n    model = read_file('xgb_model.pkl.gz')\n    print('loaded models')\n    \n    features = [\n        \"LS1_FLIGHT_ID\",\"DEPARTURE_AIRPORT_CODE\",\"ARRIVAL_AIRPORT_CODE\",\n        \"ROUTE_CATEGORY_NAME\",\"DEPARTURE_DATETIME_LOCAL\",\n        \"ARRIVAL_DATETIME_LOCAL\",\"CAPACITY\"\n    ]\n\n    df.columns = features\n    print('loaded dataframe')\n\n    # transform data for one hot and ordinal encodings\n    df_ohe = ohe.transform(df[['ROUTE_CATEGORY_NAME']])\n    encoded_df = pd.DataFrame(df_ohe, columns=ohe.categories_)\n    encoded_df.columns = encoded_df.columns.get_level_values(0)\n    encoded_df = encoded_df.add_prefix('ROUTE_NAME_OHE_')\n    df = pd.concat([df, encoded_df], axis=1)\n    df['DEPART_CODE_ENCODE'] = oe.transform(df[['DEPARTURE_AIRPORT_CODE']])\n\n    print('transformed via one hot and ordinal')\n    # transform using pre-set target encoding\n    df_te = transform_simple_target_encode_manual(df,'ARRIVAL_AIRPORT_CODE',te)\n    df_final = remove_space(df_te)\n    print('transformed via target encode')\n\n    # change date cols to datetime\n    df_final.loc[:,'DEPARTURE_DATETIME_LOCAL'] = pd.to_datetime(\n        df_final.loc[:,'DEPARTURE_DATETIME_LOCAL'],format='%Y-%m-%d %H:%M:%S',yearfirst=True\n    )\n    df_final['ARRIVAL_DATETIME_LOCAL'] = pd.to_datetime(\n        df_final['ARRIVAL_DATETIME_LOCAL'],format='%Y-%m-%d %H:%M:%S',yearfirst=True\n    )\n    print('transformed dates')\n\n    df_final['DEPART_HOUR'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.hour\n    # snowpark function goes from 1-7 whereas pandas goes from 0-6\n    df_final['DEPART_WEEKDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day_of_week + 1\n    df_final['DEPART_MONTHDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day\n    df_final['DEPART_YEARDAY'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.day_of_year\n    df_final['DEPART_MONTH'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.month\n    df_final['DEPART_YEAR'] = df_final['DEPARTURE_DATETIME_LOCAL'].dt.year\n    df_final['ARRIVE_HOUR'] = df_final['ARRIVAL_DATETIME_LOCAL'].dt.hour\n    print('created features')\n\n    pm = pd.Series(model.predict(df_final[\n            [\"DEPART_CODE_ENCODE\",\"ROUTE_NAME_OHE_CITY\",\"ROUTE_NAME_OHE_FAR_SUN\",\n            \"ROUTE_NAME_OHE_SKI\",\"ROUTE_NAME_OHE_SUN\",\"CAPACITY\",\n            \"ARRIVAL_AIRPORT_CODE_ENCODED\",\"DEPART_HOUR\",\n            \"DEPART_WEEKDAY\",\"DEPART_MONTHDAY\",\"DEPART_YEARDAY\",\n            \"DEPART_MONTH\",\"DEPART_YEAR\",\"ARRIVE_HOUR\"]\n        ]))\n    return pm\n\nfrom snowflake.snowpark.session import Session\nfrom snowflake.snowpark.functions import col,array_construct,call_udf\nimport json\nimport pandas as pd\n\n# Create Snowflake Session object\nconnection_parameters = json.load(open('connection.json'))\nsession = Session.builder.configs(connection_parameters).create()\nsession.sql_simplifier_enabled = True\n\ntest_df = session.create_dataframe(\n    [[979152,\"LBA\",\"ALC\",\"SUN\",\"2023-11-24 08:30:00\",\"2023-11-24 12:25:00\",189],\n     [987073,\"LBA\",\"FAO\",\"SUN\",\"2023-12-13 16:15:00\",\"2023-12-13 11:25:00\",189],\n     [951384,\"STN\",\"FNC\",\"FAR SUN\",\"2023-12-05 09:40:00\",\"2023-12-05 13:35:00\",189],\n     [952380,\"MAN\",\"LPA\",\"FAR SUN\",\"2023-12-22 19:45:00\",\"2023-12-22 14:30:00\",235],\n     [963602,\"MAN\",\"FUE\",\"FAR SUN\",\"2023-12-29 10:30:00\",\"2023-12-29 15:05:00\",235]],\n    schema=[\n        \"LS1_FLIGHT_ID\",\"DEPARTURE_AIRPORT_CODE\",\"ARRIVAL_AIRPORT_CODE\",\n        \"ROUTE_CATEGORY_NAME\",\"DEPARTURE_DATETIME_LOCAL\",\"ARRIVAL_DATETIME_LOCAL\",\"CAPACITY\"\n    ]\n)\n\ntest_df.withColumn(\n    'PREDICTED_PACKAGE_MIX', \n    predict_package_mix_p([*test_df])).show()",
            "masked_line": "from joblib import load",
            "answer": "load",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_949"
        },
        {
            "dependency": "pytest",
            "version": "==7.3.0",
            "time": "2023-05-02",
            "description": "The code defines a list of instance sizes with CPU and memory specifications. It also includes a function `get_instance_size` that returns the instance size that meets the specified CPU and memory requirements. Additionally, there is a test function `test_get_instance_size` that tests the `get_instance_size` function for specific CPU and memory inputs.",
            "code": "import pytest\n\ninstance_sizes = [\n    {\"name\": \"t3a.nano\", \"cpu\": 2, \"mem\": 0.5},\n    {\"name\": \"t3a.micro\", \"cpu\": 2, \"mem\": 1},\n    {\"name\": \"t3a.small\", \"cpu\": 2, \"mem\": 2},\n    {\"name\": \"t3a.medium/c5a.large\", \"cpu\": 2, \"mem\": 4},\n    {\"name\": \"t3a/m5a.large\", \"cpu\": 2, \"mem\": 8},\n    {\"name\": \"c5a.xlarge\", \"cpu\": 4, \"mem\": 8},\n    {\"name\": \"t3a/m5a.xlarge\", \"cpu\": 4, \"mem\": 16},\n    {\"name\": \"c5a.2xlarge\", \"cpu\": 8, \"mem\": 16},\n    {\"name\": \"t3a/m5a.2xlarge\", \"cpu\": 8, \"mem\": 32},\n]\n\n\ndef get_instance_size(cpu, mem):\n    return next(\n        x\n        for x in sorted(instance_sizes, key=lambda size: size[\"cpu\"])\n        if x[\"cpu\"] >= cpu and x[\"mem\"] >= mem\n    )\n\n\n@pytest.mark.parametrize(\n    \"cpu,mem,expected\",\n    (\n        (1.8, 6, \"t3a/m5a.large\"),\n        (0.1, 6, \"t3a/m5a.large\"),\n        (2.1, 6, \"c5a.xlarge\"),\n        (6, 16, \"c5a.2xlarge\"),\n    ),\n)\ndef test_get_instance_size(cpu, mem, expected):\n    res = get_instance_size(cpu, mem)\n\n    assert res is not None\n    assert res[\"name\"] == expected",
            "masked_code": "import pytest\n\ninstance_sizes = [\n    {\"name\": \"t3a.nano\", \"cpu\": 2, \"mem\": 0.5},\n    {\"name\": \"t3a.micro\", \"cpu\": 2, \"mem\": 1},\n    {\"name\": \"t3a.small\", \"cpu\": 2, \"mem\": 2},\n    {\"name\": \"t3a.medium/c5a.large\", \"cpu\": 2, \"mem\": 4},\n    {\"name\": \"t3a/m5a.large\", \"cpu\": 2, \"mem\": 8},\n    {\"name\": \"c5a.xlarge\", \"cpu\": 4, \"mem\": 8},\n    {\"name\": \"t3a/m5a.xlarge\", \"cpu\": 4, \"mem\": 16},\n    {\"name\": \"c5a.2xlarge\", \"cpu\": 8, \"mem\": 16},\n    {\"name\": \"t3a/m5a.2xlarge\", \"cpu\": 8, \"mem\": 32},\n]\n\n\ndef get_instance_size(cpu, mem):\n    return next(\n        x\n        for x in sorted(instance_sizes, key=lambda size: size[\"cpu\"])\n        if x[\"cpu\"] >= cpu and x[\"mem\"] >= mem\n    )\n\n\n<line_mask>\n    \"cpu,mem,expected\",\n    (\n        (1.8, 6, \"t3a/m5a.large\"),\n        (0.1, 6, \"t3a/m5a.large\"),\n        (2.1, 6, \"c5a.xlarge\"),\n        (6, 16, \"c5a.2xlarge\"),\n    ),\n)\ndef test_get_instance_size(cpu, mem, expected):\n    res = get_instance_size(cpu, mem)\n\n    assert res is not None\n    assert res[\"name\"] == expected",
            "masked_line": "@pytest.mark.parametrize(",
            "answer": "mark",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_950"
        },
        {
            "dependency": "SQLAlchemy",
            "version": ">=1.4",
            "time": "2023-12-08",
            "description": "The code selects rows from a table where the 'attributes' column contains the keys 'b1' or 'b3'.",
            "code": "from sqlalchemy import select, func\nfrom sqlalchemy.dialects.postgresql import JSONB\n\n# Assuming test_table is your Table object and 'attributes' is the column\nstmt = select(test_table).where(\n    func.jsonb_exists_any(\n        cast(test_table.c.attributes['b'], JSONB),\n        array(['b1', 'b3'])\n    )\n)",
            "masked_code": "from sqlalchemy import select, func\nfrom sqlalchemy.dialects.postgresql import JSONB\n\n# Assuming test_table is your Table object and 'attributes' is the column\nstmt = select(test_table).where(\n    <line_mask>\n        cast(test_table.c.attributes['b'], JSONB),\n        array(['b1', 'b3'])\n    )\n)",
            "masked_line": "func.jsonb_exists_any(",
            "answer": "jsonb_exists_any",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_951"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.5",
            "time": "2023-03-29",
            "description": "The code divides the values in series1 by the values in series2, replaces any resulting NaN values with 0, and returns the resulting Series.",
            "code": "import pandas as pd\nimport numpy as np\n\nseries1 = pd.Series([0.1, 0.2, 0.3])\nseries2 = pd.Series([np.nan, 0.2, 0.3])\n\nseries1.divide(series2).replace(np.nan, 0)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\nseries1 = pd.Series([0.1, 0.2, 0.3])\n<line_mask>\n\nseries1.divide(series2).replace(np.nan, 0)",
            "masked_line": "series2 = pd.Series([np.nan, 0.2, 0.3])",
            "answer": "Series",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_952"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.6",
            "time": "2023-12-29",
            "description": "This code generates a plot with a line graph in matplotlib and adds an image of a plane next to it as an annotation. The resulting plot is saved as an image file named \"example.png\".",
            "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n\nim = plt.imread('plane.jpg')\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_xlabel(\"my label\")\n\nimagebox = OffsetImage(im, zoom = 0.05)\n\nab = AnnotationBbox(imagebox, (1, 0), xycoords='axes fraction', box_alignment=(1.1, 1), frameon = False)\nax.add_artist(ab)\n\nfig.savefig(\"example.png\", bbox_inches=\"tight\")",
            "masked_code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n\nim = plt.imread('plane.jpg')\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_xlabel(\"my label\")\n\nimagebox = OffsetImage(im, zoom = 0.05)\n\nab = AnnotationBbox(imagebox, (1, 0), xycoords='axes fraction', box_alignment=(1.1, 1), frameon = False)\n<line_mask>\n\nfig.savefig(\"example.png\", bbox_inches=\"tight\")",
            "masked_line": "ax.add_artist(ab)",
            "answer": "add_artist",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_953"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.8",
            "time": "2023-12-29",
            "description": "This code saves a plot as an image file with an airplane image embedded in the plot.",
            "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n\nim = plt.imread('plane.jpg')\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_xlabel(\"my label\")\n\nimagebox = OffsetImage(im, zoom = 0.05)\n\nab = AnnotationBbox(imagebox, (1, 0), xycoords='axes fraction', box_alignment=(1.1, 1), frameon = False)\nax.add_artist(ab)\n\nfig.savefig(\"example.png\", bbox_inches=\"tight\")",
            "masked_code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n\nim = plt.imread('plane.jpg')\n\nfig, ax = plt.subplots()\nax.plot(range(10))\n<line_mask>\n\nimagebox = OffsetImage(im, zoom = 0.05)\n\nab = AnnotationBbox(imagebox, (1, 0), xycoords='axes fraction', box_alignment=(1.1, 1), frameon = False)\nax.add_artist(ab)\n\nfig.savefig(\"example.png\", bbox_inches=\"tight\")",
            "masked_line": "ax.set_xlabel(\"my label\")",
            "answer": "set_xlabel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_954"
        },
        {
            "dependency": "smartsheet-python-sdk",
            "version": "==3.0.2",
            "time": "2023-12-19",
            "description": "The code establishes a connection to the Smartsheet API using an access token, retrieves a list of all sheets within the account, and prints out the list of sheets.",
            "code": "import smartsheet\n\napi_key = \"MY_ACCESS_TOKEN_HERE\"\n\nsmartsheet_client = smartsheet.Smartsheet(api_key)\nsmartsheet_client.errors_as_exceptions(True)\nprint(\"Hello World\\n\")\n\nsheets = smartsheet_client.Sheets.list_sheets(include_all=True).data\nprint(sheets)",
            "masked_code": "import smartsheet\n\napi_key = \"MY_ACCESS_TOKEN_HERE\"\n\nsmartsheet_client = smartsheet.Smartsheet(api_key)\n<line_mask>\nprint(\"Hello World\\n\")\n\nsheets = smartsheet_client.Sheets.list_sheets(include_all=True).data\nprint(sheets)",
            "masked_line": "smartsheet_client.errors_as_exceptions(True)",
            "answer": "errors_as_exceptions",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_955"
        },
        {
            "dependency": "openai",
            "version": "==0.28.1",
            "time": "2023-12-26",
            "description": "The code sets up a function to send a chat completion request to a specified Azure OpenAI deployment using a given deployment ID. It specifies the user's question, data sources, and necessary parameters for the completion request. Finally, it prints the question, text part of the response, and context part of the response.",
            "code": "# Via https://learn.microsoft.com/en-us/azure/ai-services/openai/use-your-data-quickstart?tabs=command-line%2Cpython&pivots=programming-language-python\n# Using openai ver 0.28.1 (older version, not new 1.6+)\n# Also for Search API, need to use Primary Admin key (not my own query key), otherwise can't authenticate to send a search call\n\nimport os\nimport openai\nimport requests\n\nopenai.api_base = \"https://my_openai_service.openai.azure.com/\" \n\n# Azure OpenAI on your own data is only supported by the 2023-08-01-preview API version ? No, 2023-06-01 works too\nopenai.api_version = \"2023-06-01-preview\"\nopenai.api_type = 'azure'\nopenai.api_key = 'aaaaaaaaaa' \n\ndef setup_byod(deployment_id: str) -> None:\n\n    class BringYourOwnDataAdapter(requests.adapters.HTTPAdapter):\n\n     def send(self, request, **kwargs):\n         request.url = f\"{openai.api_base}/openai/deployments/{deployment_id}/extensions/chat/completions?api-version={openai.api_version}\"\n         return super().send(request, **kwargs)\n\n    session = requests.Session()\n\n    # Mount a custom adapter which will use the extensions endpoint for any call using the given `deployment_id`\n    session.mount(\n        prefix=f\"{openai.api_base}/openai/deployments/{deployment_id}\",\n        adapter=BringYourOwnDataAdapter()\n    )\n\n    openai.requestssession = session\n\naoai_deployment_id = \"gpt-35-turbo\" \nsetup_byod(aoai_deployment_id)\n\nmy_question= \"What is the goal of Contoso?\" #\"When Contoso corp was created?\" #\"When Contoso was created?\" # \"What is Contoso corporation?\",\ncompletion = openai.ChatCompletion.create(\n    messages=[\n                {\n                \"role\": \"user\", \n                \"content\": my_question,\n                }\n            ],\n    deployment_id=\"gpt-35-turbo\", \n    dataSources=[  # camelCase is intentional, as this is the format the API expects\n        {\n            \"type\": \"AzureCognitiveSearch\",\n            \"parameters\": {\n                \"endpoint\": \"https://my_search_service.search.windows.net\",\n                \"key\": \"Need_search_admin_key_here\",\n                \"indexName\": \"my-precreated-index\",\n            }\n        }\n    ]\n)\n\nprint(f\"Question: {my_question}\")\nprint(f\"Text part of the response:\\n{completion.choices[0].messages[1].content}\\n\")\nprint(\"-\"*50)\nprint(f\"Context part of the response:\\n{completion.choices[0].messages[0].content}\\n\")\nprint(\"-\"*50)\nprint(completion)",
            "masked_code": "# Via https://learn.microsoft.com/en-us/azure/ai-services/openai/use-your-data-quickstart?tabs=command-line%2Cpython&pivots=programming-language-python\n# Using openai ver 0.28.1 (older version, not new 1.6+)\n# Also for Search API, need to use Primary Admin key (not my own query key), otherwise can't authenticate to send a search call\n\nimport os\nimport openai\nimport requests\n\nopenai.api_base = \"https://my_openai_service.openai.azure.com/\" \n\n# Azure OpenAI on your own data is only supported by the 2023-08-01-preview API version ? No, 2023-06-01 works too\nopenai.api_version = \"2023-06-01-preview\"\nopenai.api_type = 'azure'\nopenai.api_key = 'aaaaaaaaaa' \n\ndef setup_byod(deployment_id: str) -> None:\n\n    class BringYourOwnDataAdapter(requests.adapters.HTTPAdapter):\n\n     def send(self, request, **kwargs):\n         request.url = f\"{openai.api_base}/openai/deployments/{deployment_id}/extensions/chat/completions?api-version={openai.api_version}\"\n         return super().send(request, **kwargs)\n\n    session = requests.Session()\n\n    # Mount a custom adapter which will use the extensions endpoint for any call using the given `deployment_id`\n    session.mount(\n        prefix=f\"{openai.api_base}/openai/deployments/{deployment_id}\",\n        adapter=BringYourOwnDataAdapter()\n    )\n\n    openai.requestssession = session\n\naoai_deployment_id = \"gpt-35-turbo\" \nsetup_byod(aoai_deployment_id)\n\nmy_question= \"What is the goal of Contoso?\" #\"When Contoso corp was created?\" #\"When Contoso was created?\" # \"What is Contoso corporation?\",\n<line_mask>\n    messages=[\n                {\n                \"role\": \"user\", \n                \"content\": my_question,\n                }\n            ],\n    deployment_id=\"gpt-35-turbo\", \n    dataSources=[  # camelCase is intentional, as this is the format the API expects\n        {\n            \"type\": \"AzureCognitiveSearch\",\n            \"parameters\": {\n                \"endpoint\": \"https://my_search_service.search.windows.net\",\n                \"key\": \"Need_search_admin_key_here\",\n                \"indexName\": \"my-precreated-index\",\n            }\n        }\n    ]\n)\n\nprint(f\"Question: {my_question}\")\nprint(f\"Text part of the response:\\n{completion.choices[0].messages[1].content}\\n\")\nprint(\"-\"*50)\nprint(f\"Context part of the response:\\n{completion.choices[0].messages[0].content}\\n\")\nprint(\"-\"*50)\nprint(completion)",
            "masked_line": "completion = openai.ChatCompletion.create(",
            "answer": "create",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_956"
        },
        {
            "dependency": "requests-html",
            "version": "==0.10.0",
            "time": "2023-11-17",
            "description": "The code retrieves football match information including teams, results, and odds from a specific website and displays the match details if the result is not 'POSTP.'.",
            "code": "from requests_html import HTMLSession\n \nmatchlink = 'https://www.betexplorer.com/football/england/league-one/results/'\n \nsession = HTMLSession()\n \nr = session.get(matchlink)\n\nallmatch = r.html.find('.in-match')\nresults = r.html.find('.h-text-center a')\n# search for elements containing \"data-odd\" attribute\nmatchodds = r.html.find('[data-odd]')\n\nodds = [matchodd.attrs[\"data-odd\"] for matchodd in matchodds]\n\nidx = 0\nfor match, res in zip(allmatch, results):\n    if res.text == 'POSTP.':\n        continue\n\n    print(f\"{match.text} {res.text} {', '.join(odds[idx:idx+3])}\")\n    idx += 3",
            "masked_code": "<line_mask>\n \nmatchlink = 'https://www.betexplorer.com/football/england/league-one/results/'\n \nsession = HTMLSession()\n \nr = session.get(matchlink)\n\nallmatch = r.html.find('.in-match')\nresults = r.html.find('.h-text-center a')\n# search for elements containing \"data-odd\" attribute\nmatchodds = r.html.find('[data-odd]')\n\nodds = [matchodd.attrs[\"data-odd\"] for matchodd in matchodds]\n\nidx = 0\nfor match, res in zip(allmatch, results):\n    if res.text == 'POSTP.':\n        continue\n\n    print(f\"{match.text} {res.text} {', '.join(odds[idx:idx+3])}\")\n    idx += 3",
            "masked_line": "from requests_html import HTMLSession",
            "answer": "HTMLSession",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_957"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.3",
            "time": "2023-07-03",
            "description": "This code generates a DataFrame with a column named 'Runtime' filled with random integer values between 0 and 50. It then calculates the frequency of each unique value in the 'Runtime' column, sorts the values in descending order, and returns the top 10 most frequent values along with their counts.",
            "code": "import numpy as np\nimport pandas as pd\nnp.random.seed(5678)\nvals = np.random.randint(0, 50, size=1000).astype(float)\ndf = pd.DataFrame(vals, columns=['Runtime'])\n\ns = df['Runtime'].value_counts().sort_values(ascending = False)\ns[:10]   # produces 32 rows, the last one with index 10.0\ns.iloc[:10]  # the first 10 rows\ns.head(10)   # also the first 10 rows",
            "masked_code": "import numpy as np\nimport pandas as pd\nnp.random.seed(5678)\nvals = np.random.randint(0, 50, size=1000).astype(float)\ndf = pd.DataFrame(vals, columns=['Runtime'])\n\n<line_mask>\ns[:10]   # produces 32 rows, the last one with index 10.0\ns.iloc[:10]  # the first 10 rows\ns.head(10)   # also the first 10 rows",
            "masked_line": "s = df['Runtime'].value_counts().sort_values(ascending = False)",
            "answer": "value_counts",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_958"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.1",
            "time": "2023-06-13",
            "description": "This code snippet formats the float values in the 'margins' column of a Pandas DataFrame as percentages. It first prints the original formatting of the 'margins' column, then changes the display format to show percentages with two decimal places, and prints the 'margins' column again with the new formatting. Next, it confirms the values of the first row in the 'margins' column. Finally, it creates a new DataFrame with an additional column 'more data', applies string formatting to the 'margins' column in this new DataFrame, and prints the updated DataFrame.",
            "code": "import pandas as pd\n# pd version == 2.0.1\n\nmargin_data = {\"margins\":[0.3646, 0.2584, 0.8954]}\nmy_df = pd.DataFrame(margin_data)\n\n# What you were printing before\nprint(\"Old formatting\")\ngross_margins = my_df['margins']\nprint(gross_margins)\n\n# Apply new formatting to all floats\nprint(\"\\nNew formatting\")\npd.options.display.float_format = '{:.2%}'.format\ngross_margins = my_df['margins']\nprint(gross_margins)\n\n# Confirm values are still what you expect\nprint(\"\\nValues\")\nprint(my_df['margins'].iloc[0])\n\n# Apply formatting to only one column, but makes \n# values a string instead of float\nprint(\"\\nString formatting single column\")\nmargin_data[\"more data\"] = [1,2,3]\nmy_df2 = pd.DataFrame(margin_data)\nmy_df2['margins'].map('{:.2%}'.format)\nprint(my_df2)",
            "masked_code": "import pandas as pd\n# pd version == 2.0.1\n\nmargin_data = {\"margins\":[0.3646, 0.2584, 0.8954]}\n<line_mask>\n\n# What you were printing before\nprint(\"Old formatting\")\ngross_margins = my_df['margins']\nprint(gross_margins)\n\n# Apply new formatting to all floats\nprint(\"\\nNew formatting\")\npd.options.display.float_format = '{:.2%}'.format\ngross_margins = my_df['margins']\nprint(gross_margins)\n\n# Confirm values are still what you expect\nprint(\"\\nValues\")\nprint(my_df['margins'].iloc[0])\n\n# Apply formatting to only one column, but makes \n# values a string instead of float\nprint(\"\\nString formatting single column\")\nmargin_data[\"more data\"] = [1,2,3]\nmy_df2 = pd.DataFrame(margin_data)\nmy_df2['margins'].map('{:.2%}'.format)\nprint(my_df2)",
            "masked_line": "my_df = pd.DataFrame(margin_data)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_959"
        },
        {
            "dependency": "redis",
            "version": "==4.5.5",
            "time": "2023-05-22",
            "description": "The code connects to a Redis database, creates a pipeline for multiple commands to be executed atomically, increments the value of a key called \"somekey\" by 1, sets a key \"hello\" to have the value \"world\", retrieves the value of the key \"hello\", executes the pipeline, and prints the responses returned from the pipeline execution.",
            "code": "from redis import Redis\n\nredis_client = Redis(decode_responses=True)\n\npipeline = redis_client.pipeline(transaction=False)\n\npipeline.incr(\"somekey\", 1)\npipeline.set(\"hello\", \"world\")\npipeline.get(\"hello\")\nresponses = pipeline.execute()\n\nprint(responses)",
            "masked_code": "from redis import Redis\n\nredis_client = Redis(decode_responses=True)\n\npipeline = redis_client.pipeline(transaction=False)\n\n<line_mask>\npipeline.set(\"hello\", \"world\")\npipeline.get(\"hello\")\nresponses = pipeline.execute()\n\nprint(responses)",
            "masked_line": "pipeline.incr(\"somekey\", 1)",
            "answer": "pipeline",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_960"
        },
        {
            "dependency": "bokeh",
            "version": "==2.4.3",
            "time": "2023-02-08",
            "description": "This code generates a scatter plot showing the distribution of commits by time of day on different days of the week from the provided data set. The x-axis represents the time of the commits, displayed in hours, while the y-axis represents the days of the week. Each point on the scatter plot represents a commit, with color indicating the day of the week. The plot also includes a title and certain styling options such as range padding and grid line colors.",
            "code": "from bokeh.models import ColumnDataSource\nfrom bokeh.plotting import figure, show, output_notebook\nfrom bokeh.sampledata.commits import data\nfrom bokeh.transform import jitter, factor_cmap\noutput_notebook()\n\nDAYS = ['Sun', 'Sat', 'Fri', 'Thu', 'Wed', 'Tue', 'Mon']\n\nsource = ColumnDataSource(data)\n\np = figure(\n    width=800,\n    height=300,\n    y_range=DAYS,\n    x_axis_type='datetime',\n    title=\"Commits by Time of Day (US/Central) 2012-2016\"\n)\n\np.scatter(\n    x='time',\n    y=jitter('day', width=0.6, range=p.y_range),\n    source=source,\n    alpha=0.3,\n    fill_color=factor_cmap('day', palette='Spectral7', factors=DAYS)\n)\n\np.xaxis.formatter.days = '%Hh'\np.x_range.range_padding = 0\np.ygrid.grid_line_color = None\n\nshow(p)",
            "masked_code": "from bokeh.models import ColumnDataSource\nfrom bokeh.plotting import figure, show, output_notebook\nfrom bokeh.sampledata.commits import data\n<line_mask>\noutput_notebook()\n\nDAYS = ['Sun', 'Sat', 'Fri', 'Thu', 'Wed', 'Tue', 'Mon']\n\nsource = ColumnDataSource(data)\n\np = figure(\n    width=800,\n    height=300,\n    y_range=DAYS,\n    x_axis_type='datetime',\n    title=\"Commits by Time of Day (US/Central) 2012-2016\"\n)\n\np.scatter(\n    x='time',\n    y=jitter('day', width=0.6, range=p.y_range),\n    source=source,\n    alpha=0.3,\n    fill_color=factor_cmap('day', palette='Spectral7', factors=DAYS)\n)\n\np.xaxis.formatter.days = '%Hh'\np.x_range.range_padding = 0\np.ygrid.grid_line_color = None\n\nshow(p)",
            "masked_line": "from bokeh.transform import jitter, factor_cmap",
            "answer": "jitter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_961"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.7.0.68",
            "time": "2023-01-12",
            "description": "This code reads an image from a specified file path, displays the original image as well as each individual color channel of the image, and then saves the image with the updated file name.",
            "code": "import cv2 as cv\nimport numpy as np\n\nimg_path = \"C:\\\\Users\\\\me\\\\Downloads\\\\snail4.bmp\"\nim = cv.imread(img_path, flags=cv.IMREAD_UNCHANGED)\nprint(im.shape)\n(height, width, channels) = im.shape\ncv.imshow('original', im)\nfor i in range(channels):\n  s = im[:, :, i]\n  cv.imshow(f'channel {i}',s)\n\ncv.waitKey(0)\ncv.destroyAllWindows()\n\ncv.imwrite(img_path[:-4] + '_imwritten.bmp', im)",
            "masked_code": "import cv2 as cv\nimport numpy as np\n\nimg_path = \"C:\\\\Users\\\\me\\\\Downloads\\\\snail4.bmp\"\nim = cv.imread(img_path, flags=cv.IMREAD_UNCHANGED)\nprint(im.shape)\n(height, width, channels) = im.shape\ncv.imshow('original', im)\nfor i in range(channels):\n  s = im[:, :, i]\n  cv.imshow(f'channel {i}',s)\n\ncv.waitKey(0)\ncv.destroyAllWindows()\n\n<line_mask>",
            "masked_line": "cv.imwrite(img_path[:-4] + '_imwritten.bmp', im)",
            "answer": "imwrite",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_962"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.3",
            "time": "2023-12-09",
            "description": "The code calculates the rolling mean of the 'a' column in a pandas DataFrame with a window size of 3, where NaN values are skipped in the first calculation and considered in the second calculation.",
            "code": "import pandas as pd\nimport numpy as np\n\n\ndf = pd.DataFrame({'a': [1, 2, 3, np.nan, 5, 6, 7]})\nprint(df['a'].rolling(3).mean(skipna=True))\nprint(df['a'].rolling(3).mean(skipna=False))",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n\n<line_mask>\nprint(df['a'].rolling(3).mean(skipna=True))\nprint(df['a'].rolling(3).mean(skipna=False))",
            "masked_line": "df = pd.DataFrame({'a': [1, 2, 3, np.nan, 5, 6, 7]})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_963"
        },
        {
            "dependency": "django",
            "version": "==4.1",
            "time": "2023-08-18",
            "description": "This code defines three models: Client, Order, and Service. \n\nThe Client model has attributes \"name\" and \"email\", and a method \"__str__\" that returns the client's name.\n\nThe Order model has an attribute \"created\" of type DateTimeField with automatic creation, and a ForeignKey relationship with the Client model.\n\nThe Service model has attributes \"client\" and \"name\", both with a max length of 50 characters, and a ForeignKey relationship with the Client model.",
            "code": "from django.db import models\nfrom django.utils import timezone\n\nclass Client(models.Model):\n    name = models.CharField(max_length=50)\n    email = models.EmailField(blank=True, null=True)\n\n    def __str__(self):\n        return self.name\n\n\nclass Order(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    client = models.ForeignKey(\"Client\", on_delete=models.SET_NULL, null=True)\n\n\nclass Service(models.Model):\n    client = models.ForeignKey(\"Client\", on_delete=models.SET_NULL, null=True)\n    name = models.CharField(max_length=50)",
            "masked_code": "from django.db import models\nfrom django.utils import timezone\n\nclass Client(models.Model):\n    <line_mask>\n    email = models.EmailField(blank=True, null=True)\n\n    def __str__(self):\n        return self.name\n\n\nclass Order(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    client = models.ForeignKey(\"Client\", on_delete=models.SET_NULL, null=True)\n\n\nclass Service(models.Model):\n    client = models.ForeignKey(\"Client\", on_delete=models.SET_NULL, null=True)\n    name = models.CharField(max_length=50)",
            "masked_line": "name = models.CharField(max_length=50)",
            "answer": "CharField",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_964"
        },
        {
            "dependency": "bokeh",
            "version": "==3.x",
            "time": "2023-06-30",
            "description": "The code creates a Bokeh plot with a line chart and adds a text label to the plot with specified position and styling. The plot is then displayed in the notebook.",
            "code": "from bokeh.models import Label\nfrom bokeh.plotting import figure, show, output_notebook\noutput_notebook()\n\np = figure(width=300, height=250)\np.line([1,2,3],[0,1,2])\ncitation = Label(\n    x=1, y=1, x_units='screen', y_units='screen',\n    text='Text',\n    border_line_color='wheat',\n    background_fill_color='wheat'\n)\np.add_layout(citation)\nshow(p)",
            "masked_code": "from bokeh.models import Label\n<line_mask>\noutput_notebook()\n\np = figure(width=300, height=250)\np.line([1,2,3],[0,1,2])\ncitation = Label(\n    x=1, y=1, x_units='screen', y_units='screen',\n    text='Text',\n    border_line_color='wheat',\n    background_fill_color='wheat'\n)\np.add_layout(citation)\nshow(p)",
            "masked_line": "from bokeh.plotting import figure, show, output_notebook",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_965"
        },
        {
            "dependency": "gspread",
            "version": "==5.9.0",
            "time": "2023-06-25",
            "description": "This code is used to authorize access to a Google Sheets API using OAuth2 credentials.",
            "code": "from gspread import authorize\nfrom oauth2client.service_account import ServiceAccountCredentials\n\nscopes = [\"https://spreadsheets.google.com/feeds\",\n                  \"https://www.googleapis.com/auth/spreadsheets\",\n                  \"https://www.googleapis.com/auth/drive\",\n                  \"https://www.googleapis.com/auth/drive\"]\ncred = ServiceAccountCredentials.from_json_keyfile_name(\"link_to_the_credentials\", scopes)\ngclient = authorize(cred)",
            "masked_code": "from gspread import authorize\nfrom oauth2client.service_account import ServiceAccountCredentials\n\nscopes = [\"https://spreadsheets.google.com/feeds\",\n                  \"https://www.googleapis.com/auth/spreadsheets\",\n                  \"https://www.googleapis.com/auth/drive\",\n                  \"https://www.googleapis.com/auth/drive\"]\ncred = ServiceAccountCredentials.from_json_keyfile_name(\"link_to_the_credentials\", scopes)\n<line_mask>",
            "masked_line": "gclient = authorize(cred)",
            "answer": "authorize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_966"
        },
        {
            "dependency": "selenium",
            "version": "==4.9.1",
            "time": "2023-05-10",
            "description": "This code opens a Chrome browser, maximizes the window, navigates to the URL \"https://www.asurascans.com/?s=Beast+Burn\", finds an element with class name \"surprise\", clicks on that element using ActionChains, closes the browser, and prints \"successful run!\".",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.common.action_chains import ActionChains\nfrom selenium.webdriver.common.by import By\n\nbrowser = webdriver.Chrome()\nbrowser.maximize_window()\nbrowser.get(\"https://www.asurascans.com/?s=Beast+Burn\")\nelement = browser.find_element(By.CLASS_NAME, \"surprise\")\naction = ActionChains(browser)\naction.click(on_element=element)\naction.perform()\nbrowser.quit()\nprint(\"succesfull run!\")",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.common.action_chains import ActionChains\nfrom selenium.webdriver.common.by import By\n\nbrowser = webdriver.Chrome()\nbrowser.maximize_window()\nbrowser.get(\"https://www.asurascans.com/?s=Beast+Burn\")\nelement = browser.find_element(By.CLASS_NAME, \"surprise\")\naction = ActionChains(browser)\n<line_mask>\naction.perform()\nbrowser.quit()\nprint(\"succesfull run!\")",
            "masked_line": "action.click(on_element=element)",
            "answer": "click",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_967"
        },
        {
            "dependency": "bokeh",
            "version": "==2.4.3",
            "time": "2023-04-14",
            "description": "The code generates a Bokeh plot with tile-based map background using CARTODBPOSITRON tile provider. The plot has specified range bounds in web mercator coordinates and the x and y axes are in mercator type.",
            "code": "from bokeh.tile_providers import CARTODBPOSITRON, get_provider\n\noutput_file(\"tile.html\")\n\ntile_provider = get_provider(CARTODBPOSITRON)\n\n# range bounds supplied in web mercator coordinates\np = figure(x_range=(-2000000, 6000000), y_range=(-1000000, 7000000),\n           x_axis_type=\"mercator\", y_axis_type=\"mercator\")\np.add_tile(tile_provider)\n\nshow(p)",
            "masked_code": "from bokeh.tile_providers import CARTODBPOSITRON, get_provider\n\noutput_file(\"tile.html\")\n\n<line_mask>\n\n# range bounds supplied in web mercator coordinates\np = figure(x_range=(-2000000, 6000000), y_range=(-1000000, 7000000),\n           x_axis_type=\"mercator\", y_axis_type=\"mercator\")\np.add_tile(tile_provider)\n\nshow(p)",
            "masked_line": "tile_provider = get_provider(CARTODBPOSITRON)",
            "answer": "get_provider",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_968"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-05-26",
            "description": "The given Python code defines three functions (f1, f2, f3) that use the TensorFlow library to unstack a tensor along different axes. These functions take in a tensor as input and return the unstacked tensor. The code then creates a tensor x of shape (4, 2) and applies the unstack operation using the functions f1, f2, and f3, and directly using the tf.unstack function along different axes. The output of the applied functions and direct unstacking operations are then printed. The code demonstrates how to unstack a tensor along different axes using TensorFlow.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\n\n@tf.function\ndef f1(x):\n    y = tf.unstack(x)\n    return y \n\n@tf.function\ndef f2(x):\n    y = tf.unstack(x, axis=0)\n    return y\n\n@tf.function\ndef f3(x):\n    y = tf.unstack(x, axis=1)\n    return y\n\nx = tf.random.uniform((4,2))\ny1 = tf.unstack(x, axis=0) #f2\ny2 = tf.unstack(x, axis=1) #f3\ny = f1(x) # No problem! (output equal to y1)\nz = f2(x) \nzz = f3(x)\nprint(y)\nprint(z)\nprint(zz)",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\n\n@tf.function\ndef f1(x):\n    y = tf.unstack(x)\n    return y \n\n@tf.function\ndef f2(x):\n    y = tf.unstack(x, axis=0)\n    return y\n\n<line_mask>\ndef f3(x):\n    y = tf.unstack(x, axis=1)\n    return y\n\nx = tf.random.uniform((4,2))\ny1 = tf.unstack(x, axis=0) #f2\ny2 = tf.unstack(x, axis=1) #f3\ny = f1(x) # No problem! (output equal to y1)\nz = f2(x) \nzz = f3(x)\nprint(y)\nprint(z)\nprint(zz)",
            "masked_line": "@tf.function",
            "answer": "function",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_969"
        },
        {
            "dependency": "statsmodels",
            "version": "==0.14.0",
            "time": "2022-08-26",
            "description": "The code plots the observed values of a time series data starting from index 354 and also overlays the predictions made by the model from time periods 354 to 365 using statsmodels library.",
            "code": "from statsmodels.graphics.tsaplots import plot_predict\n\nfig, ax = plt.subplots(figsize=(10,8))\n\nax.plot(pd.DataFrame(train).loc[354:].reset_index(drop=True), '-g', label='observed')\n\nplot_predict(model_fit, start=354, end=365, ax=ax);",
            "masked_code": "from statsmodels.graphics.tsaplots import plot_predict\n\nfig, ax = plt.subplots(figsize=(10,8))\n\nax.plot(pd.DataFrame(train).loc[354:].reset_index(drop=True), '-g', label='observed')\n\n<line_mask>",
            "masked_line": "plot_predict(model_fit, start=354, end=365, ax=ax);",
            "answer": "plot_predict",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_970"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-09-07",
            "description": "Calculate the gradient of the loss with respect to the trainable weights of the model.",
            "code": "with tf.GradientTape() as tape:\n    loss = model(model.trainable_weights)\n\ntape.gradient(loss, model.trainable_weights)",
            "masked_code": "<line_mask>\n    loss = model(model.trainable_weights)\n\ntape.gradient(loss, model.trainable_weights)",
            "masked_line": "with tf.GradientTape() as tape:",
            "answer": "GradientTape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_971"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-09-07",
            "description": "This function calculates the gradient of the model's output with respect to the input data x.",
            "code": "def gradient(model, x):\n    x_tensor = tf.convert_to_tensor(x, dtype=tf.float32)\n    with tf.GradientTape() as t:\n        t.watch(x_tensor)\n        loss = model(x_tensor)\n    return t.gradient(loss, x_tensor).numpy()",
            "masked_code": "def gradient(model, x):\n    x_tensor = tf.convert_to_tensor(x, dtype=tf.float32)\n    <line_mask>\n        t.watch(x_tensor)\n        loss = model(x_tensor)\n    return t.gradient(loss, x_tensor).numpy()",
            "masked_line": "with tf.GradientTape() as t:",
            "answer": "GradientTape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_972"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-06-11",
            "description": "This code calculates the categorical crossentropy loss between the target values and the predicted values.",
            "code": "cce = tf.keras.metrics.CategoricalCrossentropy()\n# cce.update_state(target, prediction)\ncce.update_state([[0, 1, 0], [0, 0, 1]], [[0.05, 0.95, 0], [0.1, 0.8, 0.1]])\n\ncce.result().numpy()\n# 1.1769392",
            "masked_code": "cce = tf.keras.metrics.CategoricalCrossentropy()\n# cce.update_state(target, prediction)\ncce.update_state([[0, 1, 0], [0, 0, 1]], [[0.05, 0.95, 0], [0.1, 0.8, 0.1]])\n\n<line_mask>\n# 1.1769392",
            "masked_line": "cce.result().numpy()",
            "answer": "result",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_973"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-06-11",
            "description": "Calculate the categorical crossentropy loss between two sets of categorical labels and predicted logits.",
            "code": "cce = tf.keras.metrics.CategoricalCrossentropy()\ncce([[0, 1, 0], [0, 0, 1]], [[0.05, 0.95, 0], [0.1, 0.8, 0.1]]).numpy()\n# 1.1769392",
            "masked_code": "cce = tf.keras.metrics.CategoricalCrossentropy()\n<line_mask>\n# 1.1769392",
            "masked_line": "cce([[0, 1, 0], [0, 0, 1]], [[0.05, 0.95, 0], [0.1, 0.8, 0.1]]).numpy()",
            "answer": "numpy",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_974"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0.0",
            "time": "2019-12-16",
            "description": "This code saves the model to the file \"h5_emb.hp5\" in the H5 format.",
            "code": "tf.keras.models.save_model(model, \"h5_emb.hp5\", save_format=\"h5\")",
            "masked_code": "<line_mask>",
            "masked_line": "tf.keras.models.save_model(model, \"h5_emb.hp5\", save_format=\"h5\")",
            "answer": "save_model",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_975"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0.0",
            "time": "2019-12-16",
            "description": "The code loads a pre-trained deep learning model from a saved file named 'h5_emb.hp5'.",
            "code": "model = tf.keras.models.load_model('h5_emb.hp5')",
            "masked_code": "<line_mask>",
            "masked_line": "model = tf.keras.models.load_model('h5_emb.hp5')",
            "answer": "models",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_976"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.5.0",
            "time": "2022-05-11",
            "description": "This code generates a DataFrame using pandas and then applies a centered gradient styling to the DataFrame using a specific colormap. The centered gradient is based on the median value of each column in the DataFrame. Values above the center are given a gradient color based on the colormap, while values below the center remain unchanged.",
            "code": "from typing import List\n\nimport pandas as pd\nfrom matplotlib.cm import get_cmap\nfrom matplotlib.colors import Colormap, CenteredNorm, rgb2hex\n\ndf = pd.DataFrame({\n    'A': [1, -2, 0, -1, 17],\n    'B': [11, -23, 1, -3, 132],\n    'C': [121, 2029, -243, 17, -45]\n})\n\n\ndef centered_gradient(\n        s: pd.Series, cmap: Colormap, false_css: str = ''\n) -> List[str]:\n    # Find center point\n    center = 1.5 * s.median()\n    # Create normaliser centered on median\n    norm = CenteredNorm(vcenter=center)\n    # s = s.where(s > center, center)\n    return [\n        # Conditionally apply gradient to values above center only\n        f'background-color: {rgb2hex(rgba)}' if row > center else false_css\n        for row, rgba in zip(s, cmap(norm(s)))\n    ]\n\n\ndf.style.apply(centered_gradient, cmap=get_cmap('Greens'))",
            "masked_code": "from typing import List\n\nimport pandas as pd\nfrom matplotlib.cm import get_cmap\nfrom matplotlib.colors import Colormap, CenteredNorm, rgb2hex\n\ndf = pd.DataFrame({\n    'A': [1, -2, 0, -1, 17],\n    'B': [11, -23, 1, -3, 132],\n    'C': [121, 2029, -243, 17, -45]\n})\n\n\ndef centered_gradient(\n        s: pd.Series, cmap: Colormap, false_css: str = ''\n) -> List[str]:\n    # Find center point\n    center = 1.5 * s.median()\n    # Create normaliser centered on median\n    norm = CenteredNorm(vcenter=center)\n    # s = s.where(s > center, center)\n    return [\n        # Conditionally apply gradient to values above center only\n        f'background-color: {rgb2hex(rgba)}' if row > center else false_css\n        for row, rgba in zip(s, cmap(norm(s)))\n    ]\n\n\n<line_mask>",
            "masked_line": "df.style.apply(centered_gradient, cmap=get_cmap('Greens'))",
            "answer": "get_cmap",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_977"
        },
        {
            "dependency": "rpy2",
            "version": "==3.2.x",
            "time": "2019-12-17",
            "description": "The code creates a list in R with a panel named \"Base\" and a selection type of \"Equal\".",
            "code": "dsgn = robjects.r.list(**{'None': robjects.r.listlist(panel=c(Base=50),\n                                                      seltype=\"Equal\")})",
            "masked_code": "<line_mask>\n                                                      seltype=\"Equal\")})",
            "masked_line": "dsgn = robjects.r.list(**{'None': robjects.r.listlist(panel=c(Base=50),",
            "answer": "list",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_978"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-10",
            "description": "The code broadcasts array 'a' to shape (10,) plus the original shape of 'a' and then creates a copy of the broadcasted array.",
            "code": "np.broadcast_to(a,(10,)+a.shape).copy() # a is input array",
            "masked_code": "<line_mask>",
            "masked_line": "np.broadcast_to(a,(10,)+a.shape).copy() # a is input array",
            "answer": "copy",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_979"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24.0",
            "time": "2019-01-14",
            "description": "The code restricts a dataframe based on specified price intervals by creating an IntervalArray from the 'price_low' and 'price_high' columns of the dataframe and then using the 'overlaps' method to filter out rows that do not overlap with the desired price interval defined by the 'my_price' interval.",
            "code": "# construct the IntervalArray\nprice_ivs = pd.arrays.IntervalArray.from_arrays(df['price_low'], df['price_high'], closed='both')\n\n# define desired price Interval and use the overlaps method to restrict df\nmy_price = pd.Interval(8, 16, closed='both')\ndf = df[price_ivs.overlaps(my_price)]",
            "masked_code": "# construct the IntervalArray\nprice_ivs = pd.arrays.IntervalArray.from_arrays(df['price_low'], df['price_high'], closed='both')\n\n# define desired price Interval and use the overlaps method to restrict df\nmy_price = pd.Interval(8, 16, closed='both')\n<line_mask>",
            "masked_line": "df = df[price_ivs.overlaps(my_price)]",
            "answer": "overlaps",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_980"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-09",
            "description": "This code calculates the Kuwahara filter of an image by taking the mean of the minimum values in a neighborhood around each pixel.",
            "code": "j, i = np.meshgrid(range(columns), range(rows))\nimg_kuwahara = mean[index_min[i, j], i, j]",
            "masked_code": "<line_mask>\nimg_kuwahara = mean[index_min[i, j], i, j]",
            "masked_line": "j, i = np.meshgrid(range(columns), range(rows))",
            "answer": "meshgrid",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_981"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-25",
            "description": "The code compares two arrays (df1 and df2) and returns the unique values in df1 that are not present in df2.",
            "code": "np.setdiff1d(df1, df2)",
            "masked_code": "<line_mask>",
            "masked_line": "np.setdiff1d(df1, df2)",
            "answer": "setdiff1d",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_982"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-25",
            "description": "The code creates a DataFrame containing the elements that are present in the first array (df1) but not in the second array (df2).",
            "code": "pd.DataFrame([np.setdiff1d(df1, df2)])",
            "masked_code": "<line_mask>",
            "masked_line": "pd.DataFrame([np.setdiff1d(df1, df2)])",
            "answer": "setdiff1d",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_983"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.4",
            "time": "2019-02-07",
            "description": "The code computes the outer product of arrays A and B, resulting in a new array C. It then prints the shape of the new array C, which is (3, 5, 4).",
            "code": "C = np.multiply.outer(A,B)\nprint(C.shape)\n# (3, 5, 4)",
            "masked_code": "<line_mask>\nprint(C.shape)\n# (3, 5, 4)",
            "masked_line": "C = np.multiply.outer(A,B)",
            "answer": "outer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_984"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-19",
            "description": "This code snippet assigns the index of the rightmost occurrence of each element in the 'fecha' column of the dataframe 'df' to a new column called 'result'.",
            "code": "df['result'] = np.searchsorted(dates, df['fecha'].values, side='right')",
            "masked_code": "<line_mask>",
            "masked_line": "df['result'] = np.searchsorted(dates, df['fecha'].values, side='right')",
            "answer": "searchsorted",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_985"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-10-16",
            "description": "Create a 10x10 NumPy array filled with integer zeros.",
            "code": "np.full((10, 10), 0, dtype=int)",
            "masked_code": "<line_mask>",
            "masked_line": "np.full((10, 10), 0, dtype=int)",
            "answer": "full",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_986"
        },
        {
            "dependency": "pandas",
            "version": ">=1.1.0",
            "time": "2020-09-21",
            "description": "The code creates a pandas DataFrame with columns 'a' and 'b', then groups the DataFrame by column 'b' and selects a random sample of size 4 from each group in column 'a'.",
            "code": "df = pd.DataFrame({'a': [10,20,30,40,50,60,70],\n                   'b': [1,1,1,0,0,0,0]})\n\nn = 4\ndf.groupby('b', as_index=False)['a'].apply(lambda x: x.sample(n=min(10, len(x))))",
            "masked_code": "df = pd.DataFrame({'a': [10,20,30,40,50,60,70],\n                   'b': [1,1,1,0,0,0,0]})\n\nn = 4\n<line_mask>",
            "masked_line": "df.groupby('b', as_index=False)['a'].apply(lambda x: x.sample(n=min(10, len(x))))",
            "answer": "groupby",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_987"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3",
            "time": "2021-03-25",
            "description": "The code generates a set of scatter plots with linear regression lines, where each plot represents a different day of the week. Additionally, it adds a line with equation y = 0.18*x - 0.3 to each plot.",
            "code": "# store underlying facet grid\ng = sns.lmplot(x='total_bill', y='tip', col='day', hue='day', col_wrap=2, data=df)\n\n# apply axline to each facet (y = 0.18*x - 0.3)\ng.map_dataframe(lambda data, **kws: plt.axline((0, -0.3), slope=0.18))",
            "masked_code": "# store underlying facet grid\ng = sns.lmplot(x='total_bill', y='tip', col='day', hue='day', col_wrap=2, data=df)\n\n# apply axline to each facet (y = 0.18*x - 0.3)\n<line_mask>",
            "masked_line": "g.map_dataframe(lambda data, **kws: plt.axline((0, -0.3), slope=0.18))",
            "answer": "axline",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_988"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.2.4",
            "time": "2020-01-23",
            "description": "Set the title of the legend on a matplotlib plot to 'title' with a larger font size.",
            "code": "plt.legend.set_title('title',prop={'size':'large'})",
            "masked_code": "<line_mask>",
            "masked_line": "plt.legend.set_title('title',prop={'size':'large'})",
            "answer": "legend",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_989"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.x.x",
            "time": "2020-01-23",
            "description": "This code sets the title of the legend in a matplotlib plot to 'title' with a larger font size.",
            "code": "plt.legend.set_title('title',prop={'size':'large'})",
            "masked_code": "<line_mask>",
            "masked_line": "plt.legend.set_title('title',prop={'size':'large'})",
            "answer": "set_title",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_990"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-07-10",
            "description": "The code generates a random selection of 'animal' values from the 'category' list for each row in the DataFrame 'df'.",
            "code": "df['animal'] = np.random.choice(catergory, size=len(df))",
            "masked_code": "<line_mask>",
            "masked_line": "df['animal'] = np.random.choice(catergory, size=len(df))",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_991"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-07-10",
            "description": "The code generates a pandas DataFrame with a column 'ColA' containing 10 random integers between 1 and 10, and adds another column 'animal' with random choices of 'dog', 'cat', or 'monkey' for each row. Finally, it counts the occurrences of each unique value in the 'animal' column.",
            "code": "np.random.seed(12345)\n\ndf = pd.DataFrame({'ColA': np.random.randint(1, 10, 10)})\ncatergory = ['dog', 'cat', 'monkey']\n\ndf['animal'] = np.random.choice(catergory, size=len(df))\ndf['animal'].value_counts()",
            "masked_code": "np.random.seed(12345)\n\n<line_mask>\ncatergory = ['dog', 'cat', 'monkey']\n\ndf['animal'] = np.random.choice(catergory, size=len(df))\ndf['animal'].value_counts()",
            "masked_line": "df = pd.DataFrame({'ColA': np.random.randint(1, 10, 10)})",
            "answer": "randint",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_992"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2020-04-23",
            "description": "The code transforms a pandas Series of lists into a pandas Series with individual elements, effectively \"exploding\" the lists into separate rows.",
            "code": "pd.Series(states).explode()",
            "masked_code": "<line_mask>",
            "masked_line": "pd.Series(states).explode()",
            "answer": "Series",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_993"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2020-06-05",
            "description": "This code reads an image file \"sample.jpg\", decodes it as a JPEG image with 3 channels, then uses TensorFlow session to evaluate the image array to obtain its height and width, and finally prints out the height and width of the image.",
            "code": "img = tf.io.read_file(\"sample.jpg\")\nimg = tf.image.decode_jpeg(img, channels=3)\n\nwith tf.Session() as sess:\n  array = img.eval(session=sess)\n  height = array.shape[0]\n  width = array.shape[1]\n  print(\"Height:\",height)\n  print(\"Width:\",width)",
            "masked_code": "img = tf.io.read_file(\"sample.jpg\")\n<line_mask>\n\nwith tf.Session() as sess:\n  array = img.eval(session=sess)\n  height = array.shape[0]\n  width = array.shape[1]\n  print(\"Height:\",height)\n  print(\"Width:\",width)",
            "masked_line": "img = tf.image.decode_jpeg(img, channels=3)",
            "answer": "decode_jpeg",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_994"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2021-08-05",
            "description": "The code converts a Keras model into a concrete function, freezes the function to get a frozen ConcreteFunction, and then saves the frozen graph to the hard drive as a .pb file.",
            "code": "# Convert Keras model to ConcreteFunction\nfull_model = tf.function(lambda x: model(x))\nfull_model = full_model.get_concrete_function(\n    tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))\n\n# Get frozen ConcreteFunction\nfrozen_func = convert_variables_to_constants_v2(full_model)\nfrozen_func.graph.as_graph_def()\n\n\n# Save frozen graph from frozen ConcreteFunction to hard drive\ntf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n                  logdir=\"./frozen_models\",\n                  name=\"frozen_graph.pb\",\n                  as_text=False)",
            "masked_code": "# Convert Keras model to ConcreteFunction\nfull_model = tf.function(lambda x: model(x))\nfull_model = full_model.get_concrete_function(\n    <line_mask>\n\n# Get frozen ConcreteFunction\nfrozen_func = convert_variables_to_constants_v2(full_model)\nfrozen_func.graph.as_graph_def()\n\n\n# Save frozen graph from frozen ConcreteFunction to hard drive\ntf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n                  logdir=\"./frozen_models\",\n                  name=\"frozen_graph.pb\",\n                  as_text=False)",
            "masked_line": "tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))",
            "answer": "TensorSpec",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_995"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-07-22",
            "description": "The code creates a violin plot showing the distribution of 'value' within each 'Group' category, with the distribution colored by 'Class'. It also adds a legend titled 'Class' outside the plot on the upper left corner.",
            "code": "p = sns.violinplot(data=dfm, x='Group', y='value', hue='Class')\np.legend(title='Class', bbox_to_anchor=(1, 1), loc='upper left')",
            "masked_code": "p = sns.violinplot(data=dfm, x='Group', y='value', hue='Class')\n<line_mask>",
            "masked_line": "p.legend(title='Class', bbox_to_anchor=(1, 1), loc='upper left')",
            "answer": "legend",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_996"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-07-22",
            "description": "The code creates a categorical plot with violin plots to visualize the distribution of 'value' across different 'Class' values for each 'Group', with 2 plots per row.",
            "code": "sns.catplot(kind='violin', data=dfm, x='Class', y='value', col='Group', col_wrap=2)",
            "masked_code": "<line_mask>",
            "masked_line": "sns.catplot(kind='violin', data=dfm, x='Class', y='value', col='Group', col_wrap=2)",
            "answer": "catplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_997"
        },
        {
            "dependency": "gspread",
            "version": "==5.0.0",
            "time": "2021-12-19",
            "description": "This code snippet reads all values from a worksheet, organizes them into a dictionary where the first value of each column becomes the key and the remaining values in the column become a list associated with that key, and finally prints out the resulting dictionary.",
            "code": "values = worksheet.get_all_values()\nobj = {}\nfor e in zip(*values):\n    obj[e[0]] = list(e[1:])\n\nprint(obj)",
            "masked_code": "<line_mask>\nobj = {}\nfor e in zip(*values):\n    obj[e[0]] = list(e[1:])\n\nprint(obj)",
            "masked_line": "values = worksheet.get_all_values()",
            "answer": "get_all_values",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_998"
        },
        {
            "dependency": "polars",
            "version": "==0.17.10",
            "time": "2022-04-05",
            "description": "This code snippet converts the 'event_date' column in a DataFrame from string format to datetime format.",
            "code": "df = pl.from_repr(\"\"\"\n\n id   event_date       \n ---  ---              \n i64  str              \n\n 1    27 July 2020     \n 2    31 December 2020 \n\n\"\"\")\n\ndf.with_columns(\n   pl.col(\"event_date\").str.to_datetime(\"%d %B %Y\")\n)",
            "masked_code": "df = pl.from_repr(\"\"\"\n\n id   event_date       \n ---  ---              \n i64  str              \n\n 1    27 July 2020     \n 2    31 December 2020 \n\n\"\"\")\n\ndf.with_columns(\n   <line_mask>\n)",
            "masked_line": "pl.col(\"event_date\").str.to_datetime(\"%d %B %Y\")",
            "answer": "col",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_999"
        },
        {
            "dependency": "pandas",
            "version": ">=1.1",
            "time": "2022-07-28",
            "description": "The code divides a DataFrame 'df' into two parts based on the unique values in the 'Type' column. It then samples 'N2' rows from each unique 'Type' group and concatenates them with a sample of 'R' rows from the remaining DataFrame.",
            "code": "N = 5\nN2, R = divmod(N, df['Type'].nunique())\n\nout = df.groupby('Type').sample(n=N2)\n\nout = pd.concat([out, df.drop(out.index).sample(n=R)])",
            "masked_code": "N = 5\nN2, R = divmod(N, df['Type'].nunique())\n\nout = df.groupby('Type').sample(n=N2)\n\n<line_mask>",
            "masked_line": "out = pd.concat([out, df.drop(out.index).sample(n=R)])",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1000"
        },
        {
            "dependency": "pydantic",
            "version": "==1.10.2",
            "time": "2022-10-27",
            "description": "This code defines a class A that inherits from BaseModel and has two attributes: _value and id. The _value attribute is set to \"Initial value\" by default and is a private attribute. The class also has a property method value that returns the value of _value. Additionally, the class has a method clone that creates a deep copy of the instance with an updated id and _value set to \"Updated value\". The code then creates an instance of class A with id=1, clones it to create another instance, and prints both instances along with their values.",
            "code": "from pydantic import BaseModel, PrivateAttr\n\nclass A(BaseModel):\n    _value: str = PrivateAttr(default=\"Initial value\")\n    id: int\n\n    @property\n    def value(self):\n        return self._value\n\n    def clone(self):\n        obj = self.copy(update={\"id\": self.id + 1})\n        obj._value = \"Updated value\"\n        return obj\n\nif __name__ == '__main__':\n    a1 = A(id=1)\n    a2 = a1.clone()\n    print([a1, a2])\n    print(a1.value)\n    print(a2.value)",
            "masked_code": "<line_mask>\n\nclass A(BaseModel):\n    _value: str = PrivateAttr(default=\"Initial value\")\n    id: int\n\n    @property\n    def value(self):\n        return self._value\n\n    def clone(self):\n        obj = self.copy(update={\"id\": self.id + 1})\n        obj._value = \"Updated value\"\n        return obj\n\nif __name__ == '__main__':\n    a1 = A(id=1)\n    a2 = a1.clone()\n    print([a1, a2])\n    print(a1.value)\n    print(a2.value)",
            "masked_line": "from pydantic import BaseModel, PrivateAttr",
            "answer": "PrivateAttr",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1001"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.5",
            "time": "2023-09-20",
            "description": "This code calculates the gradients of two losses with respect to the model weights using TensorFlow's GradientTape, and then applies the gradients to the model using an optimizer.",
            "code": "with tf.GradientTape(persistent=True) as tp:\n    logits_1,logits_2=model(X_train)\n    loss1= loss_fn_1(y_train_1, logits_1)\n    loss2= loss_fn_2(y_train_2, logits_2)\ngrads = tp.gradient([loss1,loss2], model.weights)\nopt.apply_gradients(zip(grads, model.weights))",
            "masked_code": "<line_mask>\n    logits_1,logits_2=model(X_train)\n    loss1= loss_fn_1(y_train_1, logits_1)\n    loss2= loss_fn_2(y_train_2, logits_2)\ngrads = tp.gradient([loss1,loss2], model.weights)\nopt.apply_gradients(zip(grads, model.weights))",
            "masked_line": "with tf.GradientTape(persistent=True) as tp:",
            "answer": "GradientTape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1002"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.5",
            "time": "2023-09-20",
            "description": "This code calculates the gradients of two different loss functions with respect to the model weights using Tensorflow's GradientTape. The gradients are then combined and applied to the model using an optimizer.",
            "code": "with tf.GradientTape(persistent=True) as tp:\n    logits_1,logits_2=model(X_train)\n    loss1= loss_fn_1(y_train_1, logits_1)\n    loss2= loss_fn_2(y_train_2, logits_2)\ngrads_1 = tp.gradient(loss1, model.weights)\ngrads_2 = tp.gradient(loss2, model.weights)\ngrads_final = grads_1 + grads_2\nopt.apply_gradients(zip(grads_final, model.weights))",
            "masked_code": "<line_mask>\n    logits_1,logits_2=model(X_train)\n    loss1= loss_fn_1(y_train_1, logits_1)\n    loss2= loss_fn_2(y_train_2, logits_2)\ngrads_1 = tp.gradient(loss1, model.weights)\ngrads_2 = tp.gradient(loss2, model.weights)\ngrads_final = grads_1 + grads_2\nopt.apply_gradients(zip(grads_final, model.weights))",
            "masked_line": "with tf.GradientTape(persistent=True) as tp:",
            "answer": "GradientTape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1003"
        },
        {
            "dependency": "discord.py",
            "version": "==2.0",
            "time": "2022-04-08",
            "description": "The given Python code defines a custom button class `MyButton` that inherits from `discord.ui.View`. The class initializes with the author of the interaction and includes a button labeled \"Back\" that, when pressed, prints \"button pressed\" and can perform additional actions. Additionally, the code includes an `interaction_check` method that checks if the user interacting with the button is the same as the author. Finally, a command `button_test` creates an instance of `MyButton` with the context author and sends it in a message.",
            "code": "class MyButton(discord.ui.View):\n    def __init__(self, author):\n        self.author = author\n        super().__init__()\n\n    @discord.ui.button(label=\"Back\", style=discord.ButtonStyle.blurple)\n    async def back(self, interaction: discord.Interaction, button: discord.ui.Button):\n        print(\"button pressed\")\n        # do whatever here\n\n    async def interaction_check(self, interaction: discord.Interaction):\n        return interaction.user.id == self.author.id\n\n\n[...]\n\n@bot.command()\nasync def button_test(ctx):\n    view = MyButton(ctx.author)\n    await ctx.send(view=view)",
            "masked_code": "class MyButton(discord.ui.View):\n    def __init__(self, author):\n        self.author = author\n        super().__init__()\n\n    @discord.ui.button(label=\"Back\", style=discord.ButtonStyle.blurple)\n    <line_mask>\n        print(\"button pressed\")\n        # do whatever here\n\n    async def interaction_check(self, interaction: discord.Interaction):\n        return interaction.user.id == self.author.id\n\n\n[...]\n\n@bot.command()\nasync def button_test(ctx):\n    view = MyButton(ctx.author)\n    await ctx.send(view=view)",
            "masked_line": "async def back(self, interaction: discord.Interaction, button: discord.ui.Button):",
            "answer": "button",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1004"
        },
        {
            "dependency": "aiohttp-retry",
            "version": "==2.x",
            "time": "2022-03-13",
            "description": "The code defines a class MyLogger with a debug method to print debug messages. It also includes an async function async_retry_fetch to perform HTTP GET requests with retry options using aiohttp library. The main function initiates multiple async HTTP GET requests to various URLs with retry logic using RetryClient and ExponentialRetry. It then gathers the results and prints them.",
            "code": "import asyncio\nfrom aiohttp_retry import RetryClient, ExponentialRetry\n\nclass MyLogger():\n    def debug(self, *args, **kwargs):\n        print('[debug]:', *args, **kwargs)\n    \nasync def async_retry_fetch(url, retry_client):\n\n    retry_options = ExponentialRetry(attempts=3)\n\n    #async with retry_client.get(url) as response:\n    # OR\n    async with retry_client.get(url, retry_options=ExponentialRetry(attempts=3), raise_for_status=[500, 501]) as response:\n        try:\n            data = await response.json()\n        except Exception as e:\n            raise Exception(\"Could not convert json\")\n\n    return data\n\nasync def main():\n    urls = [\n        \"https://httpstat.us/200\",\n        \"https://httpstat.us/500\",\n        \"https://httpstat.us/501\",\n        \"https://httpbin.org/status/500\",\n        \"https://httpbin.org/status/501\",\n        \"https://httpbin.org/json\"\n    ]\n\n    #async with RetryClient(logger=MyLogger(), retry_options=ExponentialRetry(attempts=3), raise_for_status=[500, 501]) as retry_client:\n    # OR\n    async with RetryClient(logger=MyLogger()) as retry_client:\n        api_calls = []\n        \n        for url in urls:\n            api_calls.append(async_retry_fetch(url, retry_client))\n            \n        res = await asyncio.gather(*api_calls, return_exceptions=True)\n \n        for item in res:\n            print(item)\n            print('---')\n\n# --- start ---\n\nasyncio.run(main())",
            "masked_code": "import asyncio\nfrom aiohttp_retry import RetryClient, ExponentialRetry\n\nclass MyLogger():\n    def debug(self, *args, **kwargs):\n        print('[debug]:', *args, **kwargs)\n    \nasync def async_retry_fetch(url, retry_client):\n\n    <line_mask>\n\n    #async with retry_client.get(url) as response:\n    # OR\n    async with retry_client.get(url, retry_options=ExponentialRetry(attempts=3), raise_for_status=[500, 501]) as response:\n        try:\n            data = await response.json()\n        except Exception as e:\n            raise Exception(\"Could not convert json\")\n\n    return data\n\nasync def main():\n    urls = [\n        \"https://httpstat.us/200\",\n        \"https://httpstat.us/500\",\n        \"https://httpstat.us/501\",\n        \"https://httpbin.org/status/500\",\n        \"https://httpbin.org/status/501\",\n        \"https://httpbin.org/json\"\n    ]\n\n    #async with RetryClient(logger=MyLogger(), retry_options=ExponentialRetry(attempts=3), raise_for_status=[500, 501]) as retry_client:\n    # OR\n    async with RetryClient(logger=MyLogger()) as retry_client:\n        api_calls = []\n        \n        for url in urls:\n            api_calls.append(async_retry_fetch(url, retry_client))\n            \n        res = await asyncio.gather(*api_calls, return_exceptions=True)\n \n        for item in res:\n            print(item)\n            print('---')\n\n# --- start ---\n\nasyncio.run(main())",
            "masked_line": "retry_options = ExponentialRetry(attempts=3)",
            "answer": "ExponentialRetry",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1005"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.0",
            "time": "2022-12-01",
            "description": "The code combines a pandas DataFrame with a Series or DataFrame created from a dictionary, excluding the first row, and then resets the index of the resulting DataFrame.",
            "code": "dct = {\"a\": 300, \"b\": 88}\ndf_new = pd.concat([df, pd.Series(dct).to_frame().T]\n                  ).iloc[1:, :].reset_index(drop=True)\nprint(df_new)\n\n# If maybe the values of 'dict' have multiple items.\n# dct = {\"a\": [300, 400], \"b\": [88, 98]}\n# df_new = pd.concat([df, pd.DataFrame(dct)]\n#                   ).iloc[1:, :].reset_index(drop=True)",
            "masked_code": "dct = {\"a\": 300, \"b\": 88}\n<line_mask>\n                  ).iloc[1:, :].reset_index(drop=True)\nprint(df_new)\n\n# If maybe the values of 'dict' have multiple items.\n# dct = {\"a\": [300, 400], \"b\": [88, 98]}\n# df_new = pd.concat([df, pd.DataFrame(dct)]\n#                   ).iloc[1:, :].reset_index(drop=True)",
            "masked_line": "df_new = pd.concat([df, pd.Series(dct).to_frame().T]",
            "answer": "to_frame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1006"
        },
        {
            "dependency": "pandas",
            "version": ">=1.4.0",
            "time": "2022-10-10",
            "description": "The code concatenates a row from DataFrame DF2 to the DataFrame OutputDf and ignores the original index.",
            "code": "OutputDf = pd.concat([OutputDf, DF2.loc[[i]]], ignore_index=True)",
            "masked_code": "<line_mask>",
            "masked_line": "OutputDf = pd.concat([OutputDf, DF2.loc[[i]]], ignore_index=True)",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1007"
        },
        {
            "dependency": "pandas",
            "version": ">=1.4.0",
            "time": "2022-10-10",
            "description": "The code concatenates rows from DF1 where the value in the column 'TheName' matches the value in the corresponding position in DF2['TheName'] and where the value in the column 'WGT' is greater than 0 to the dataframe OutputDf.",
            "code": "OutputDf = pd.concat([OutputDf, DF1.loc[(DF1['TheName'] == DF2['TheName'][i]) & (DF1['WGT'].apply(lambda x: float(x)) > 0) ]], ignore_index=True)",
            "masked_code": "<line_mask>",
            "masked_line": "OutputDf = pd.concat([OutputDf, DF1.loc[(DF1['TheName'] == DF2['TheName'][i]) & (DF1['WGT'].apply(lambda x: float(x)) > 0) ]], ignore_index=True)",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1008"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.1",
            "time": "2022-11-17",
            "description": "The code melts the dataframe by transforming it into a long format where one or more columns are identifier variables (id_vars) and the rest of the columns are converted into two columns (variable and value). It then creates a stacked histogram plot using seaborn library to visualize the distribution of 'value' across different 'variable' values, grouped by 'name'.",
            "code": "# melt the dataframe\ndfm = df.melt(id_vars='name')\n\n# plot\nax = sns.histplot(data=dfm, x='variable', weights='value', hue='name', discrete=True, multiple='stack')",
            "masked_code": "# melt the dataframe\ndfm = df.melt(id_vars='name')\n\n# plot\n<line_mask>",
            "masked_line": "ax = sns.histplot(data=dfm, x='variable', weights='value', hue='name', discrete=True, multiple='stack')",
            "answer": "histplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1009"
        },
        {
            "dependency": "polars",
            "version": "==0.16.15",
            "time": "2023-03-22",
            "description": "The code concatenates quantile cuts of the column \"col\" for each group in the dataframe (\"df\"), maintaining order and selecting the \"category\" column converted to a physical column.",
            "code": "pl.concat(\n    frame.get_column(\"col\")\n         .qcut([.5], maintain_order=True)\n         .select(pl.col(\"category\").to_physical())\n    for frame in df.partition_by(\"group\")\n)",
            "masked_code": "pl.concat(\n    frame.get_column(\"col\")\n         .qcut([.5], maintain_order=True)\n         <line_mask>\n    for frame in df.partition_by(\"group\")\n)",
            "masked_line": ".select(pl.col(\"category\").to_physical())",
            "answer": "col",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1010"
        },
        {
            "dependency": "polars",
            "version": "==0.16.15",
            "time": "2023-03-22",
            "description": "This code creates a new column in the dataframe 'df' where the values in the column 'col' are divided into two categories based on a quantile cut-off point (.5), maintaining the original order of the values. The categories are then converted to physical values before being grouped together.",
            "code": "df.with_columns(\n   pl.col(\"col\")\n     .apply(\n        lambda x: x.qcut([.5], maintain_order=True)[\"category\"].to_physical())\n     .over(\"group\")\n)",
            "masked_code": "df.with_columns(\n   <line_mask>\n     .apply(\n        lambda x: x.qcut([.5], maintain_order=True)[\"category\"].to_physical())\n     .over(\"group\")\n)",
            "masked_line": "pl.col(\"col\")",
            "answer": "col",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1011"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.0",
            "time": "2023-05-24",
            "description": "The code converts the \"date\" column in the DataFrame \"df\" to datetime format, with the date format being in a mixed format and with the day appearing first.",
            "code": "df[\"date\"] = pd.to_datetime(df[\"date\"], format=\"mixed\", dayfirst=True)",
            "masked_code": "<line_mask>",
            "masked_line": "df[\"date\"] = pd.to_datetime(df[\"date\"], format=\"mixed\", dayfirst=True)",
            "answer": "to_datetime",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1012"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==2.0",
            "time": "2023-04-08",
            "description": "This code defines a base class `Base` and a mixin class `SoftDeleteMixin` that adds soft delete functionality to an entity class `Entity`. The `Entity` class represents an entity with attributes like `id`, `field_a`, `field_b`, and `created_at`, along with methods to delete and undelete the entity. Additionally, there is an event listener that logs whether an entity is being deleted or undeleted before an update operation.",
            "code": "from datetime import datetime\nfrom logging import getLogger\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, Session\nfrom sqlalchemy.orm import InstrumentedAttribute, Relationship\nfrom sqlalchemy.orm import mapped_column, relationship\n\nlogger = getLogger(__name__)\n\nclass Base(DeclarativeBase):\n    def __repr__(self):\n        return '<%s id=%r>' % (type(self).__name__, self.id)\n\nclass SoftDeleteMixin:\n    deleted_at: Mapped[datetime] = mapped_column(nullable=True)\n\n    def delete(self):\n        self.deleted_at = datetime.now()\n\n    def undelete(self):\n        self.deleted_at = None\n\nclass Entity(Base, SoftDeleteMixin):\n    __tablename__ = 'entity'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    field_a: Mapped[str]\n    field_b: Mapped[str]\n    created_at: Mapped[datetime] = mapped_column(default=datetime.now)\n\n@event.listens_for(Entity, \"before_update\")\ndef before_update(mapper, connection, target):\n    # ensure the target inherits from `SoftDeleteMixin`\n    if isinstance(target, SoftDeleteMixin):\n        if target.deleted_at:\n            logger.info('%r is deleted', target)\n        else:\n            logger.info('%r is undeleted', target)",
            "masked_code": "from datetime import datetime\nfrom logging import getLogger\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, Session\nfrom sqlalchemy.orm import InstrumentedAttribute, Relationship\nfrom sqlalchemy.orm import mapped_column, relationship\n\nlogger = getLogger(__name__)\n\nclass Base(DeclarativeBase):\n    def __repr__(self):\n        return '<%s id=%r>' % (type(self).__name__, self.id)\n\nclass SoftDeleteMixin:\n    deleted_at: Mapped[datetime] = mapped_column(nullable=True)\n\n    def delete(self):\n        self.deleted_at = datetime.now()\n\n    def undelete(self):\n        self.deleted_at = None\n\nclass Entity(Base, SoftDeleteMixin):\n    __tablename__ = 'entity'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    field_a: Mapped[str]\n    field_b: Mapped[str]\n    created_at: Mapped[datetime] = mapped_column(default=datetime.now)\n\n<line_mask>\ndef before_update(mapper, connection, target):\n    # ensure the target inherits from `SoftDeleteMixin`\n    if isinstance(target, SoftDeleteMixin):\n        if target.deleted_at:\n            logger.info('%r is deleted', target)\n        else:\n            logger.info('%r is undeleted', target)",
            "masked_line": "@event.listens_for(Entity, \"before_update\")",
            "answer": "listens_for",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1013"
        },
        {
            "dependency": "hdf5storage",
            "version": "==0.1.10",
            "time": "2023-04-11",
            "description": "The code writes the data stored in variable 'a' to a file named 'data.h5' at the specified path '/a' in HDF5 format.",
            "code": "hdf5storage.write(a, path='/a', filename='data.h5')",
            "masked_code": "<line_mask>",
            "masked_line": "hdf5storage.write(a, path='/a', filename='data.h5')",
            "answer": "write",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1014"
        },
        {
            "dependency": "hdf5storage",
            "version": "==0.1.10",
            "time": "2023-04-11",
            "description": "This code writes the contents of the dictionary `mdict` to a file named `data.h5` in the HDF5 file format.",
            "code": "hdf5storage.writes(mdict, filename='data.h5')",
            "masked_code": "<line_mask>",
            "masked_line": "hdf5storage.writes(mdict, filename='data.h5')",
            "answer": "writes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1015"
        },
        {
            "dependency": "hdf5storage",
            "version": "==0.1.10",
            "time": "2023-04-11",
            "description": "The code generates three NumPy arrays, writes them to an HDF5 file with individual paths, and then writes all three arrays to the HDF5 file with a dictionary of paths.",
            "code": "arr1 = np.arange(10)\narr2 = np.arange(10,20).reshape(5,2)\narr3 = np.arange(20,30).reshape(2,5)\nhdf5storage.write(arr1, path='/arr1', filename='write_data.h5')\nhdf5storage.write(arr2, path='/arr2', filename='write_data.h5')\nhdf5storage.write(arr3, path='/arr3', filename='write_data.h5')\n\nmdict = {'/arr1':arr1, '/arr2':arr2, '/arr3':arr3}\nhdf5storage.writes(mdict, filename='writes_data.h5')",
            "masked_code": "arr1 = np.arange(10)\narr2 = np.arange(10,20).reshape(5,2)\narr3 = np.arange(20,30).reshape(2,5)\nhdf5storage.write(arr1, path='/arr1', filename='write_data.h5')\nhdf5storage.write(arr2, path='/arr2', filename='write_data.h5')\nhdf5storage.write(arr3, path='/arr3', filename='write_data.h5')\n\nmdict = {'/arr1':arr1, '/arr2':arr2, '/arr3':arr3}\n<line_mask>",
            "masked_line": "hdf5storage.writes(mdict, filename='writes_data.h5')",
            "answer": "writes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1016"
        },
        {
            "dependency": "click",
            "version": "==7.0",
            "time": "2019-10-30",
            "description": "This code is a test script for automatic completion of CLI arguments using Click, a Python package for creating command line interfaces. The script defines a CLI command with options and arguments, and then tests the auto-completion mechanism for various command input scenarios. The script uses mock environment variables and functions to simulate user input and compare the actual auto-completed options with expected results. If the actual completions do not match the expected completions, the script logs the failures. Finally, the script outputs the Click version and Python version used, as well as a message indicating whether all tests passed.",
            "code": "import click\n\n@click.command()\n@click.option('--opt', type=(str, str), autocompletion=get_opts)\n@click.argument('arg')\ndef cli(opt, arg):\n    \"\"\"My Great Cli\"\"\"\n\nif __name__ == \"__main__\":\n    commands = (\n        ('--opt', 2, 'foo1 foo2 fox3'),\n        ('--opt f', 2, 'foo1 foo2 fox3'),\n        ('--opt fo', 2, 'foo1 foo2 fox3'),\n        ('--opt foo', 2, 'foo1 foo2'),\n        ('--opt fox', 2, 'fox3'),\n        ('--opt foz', 2, ''),\n        ('--opt foo2 b', 3, 'bar12 bar22 bar32'),\n        ('--opt foo2 bar1', 3, 'bar12'),\n        ('--opt foo2 baz', 3, ''),\n    )\n\n    import os\n    import sys\n    from unittest import mock\n    from click._bashcomplete import do_complete\n\n    failed = []\n    for cmd_args in commands:\n        cmd_args_with_arg = (\n            'arg ' + cmd_args[0], cmd_args[1] + 1, cmd_args[2])\n        for cmd in (cmd_args, cmd_args_with_arg):\n            with mock.patch('click._bashcomplete.echo') as echo:\n                os.environ['COMP_WORDS'] = 'x ' + cmd[0]\n                os.environ['COMP_CWORD'] = str(cmd[1])\n                do_complete(cli, 'x', False)\n                completions = [c[0][0] for c in echo.call_args_list]\n                if completions != cmd[2].split():\n                    failed.append(completions, cmd[2].split())\n\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    if failed:\n        for fail in failed:\n            print('Got {}, expected {}'.format(completions, cmd[2].split()))\n    else:\n        print('All tests passed')",
            "masked_code": "import click\n\n@click.command()\n@click.option('--opt', type=(str, str), autocompletion=get_opts)\n@click.argument('arg')\ndef cli(opt, arg):\n    \"\"\"My Great Cli\"\"\"\n\nif __name__ == \"__main__\":\n    commands = (\n        ('--opt', 2, 'foo1 foo2 fox3'),\n        ('--opt f', 2, 'foo1 foo2 fox3'),\n        ('--opt fo', 2, 'foo1 foo2 fox3'),\n        ('--opt foo', 2, 'foo1 foo2'),\n        ('--opt fox', 2, 'fox3'),\n        ('--opt foz', 2, ''),\n        ('--opt foo2 b', 3, 'bar12 bar22 bar32'),\n        ('--opt foo2 bar1', 3, 'bar12'),\n        ('--opt foo2 baz', 3, ''),\n    )\n\n    import os\n    import sys\n    from unittest import mock\n    from click._bashcomplete import do_complete\n\n    failed = []\n    for cmd_args in commands:\n        cmd_args_with_arg = (\n            'arg ' + cmd_args[0], cmd_args[1] + 1, cmd_args[2])\n        for cmd in (cmd_args, cmd_args_with_arg):\n            with mock.patch('click._bashcomplete.echo') as echo:\n                os.environ['COMP_WORDS'] = 'x ' + cmd[0]\n                os.environ['COMP_CWORD'] = str(cmd[1])\n                <line_mask>\n                completions = [c[0][0] for c in echo.call_args_list]\n                if completions != cmd[2].split():\n                    failed.append(completions, cmd[2].split())\n\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    if failed:\n        for fail in failed:\n            print('Got {}, expected {}'.format(completions, cmd[2].split()))\n    else:\n        print('All tests passed')",
            "masked_line": "do_complete(cli, 'x', False)",
            "answer": "do_complete",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1017"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-05-08",
            "description": "The code defines a Command Line Interface (CLI) using the Click library in Python. It creates a CLI group and adds a command to show the environment, with an option to specify the environment. The default environment is set to \"dev\". When executed, it displays the environment specified or the default environment. Additionally, it prints the Click version and Python version, and then runs commands provided in the 'commands' list.",
            "code": "import click\n\n@click.group()\n@click.pass_context\ndef cli(ctx):\n    \"\"\"\n    CLI\n    \"\"\"\n    ctx.ensure_object(dict)\n    ctx.obj['DEFAULT_ENVIRONMENT'] = \"dev\"\n\n\n@cli.command()\n@click.option('-e', '--environment', required=True,\n              cls=default_from_context('DEFAULT_ENVIRONMENT'))\ndef show_env(environment):\n    click.echo(environment)\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'show_env',\n        '--help',\n    )\n\n    import sys, time\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\n<line_mask>\n@click.pass_context\ndef cli(ctx):\n    \"\"\"\n    CLI\n    \"\"\"\n    ctx.ensure_object(dict)\n    ctx.obj['DEFAULT_ENVIRONMENT'] = \"dev\"\n\n\n@cli.command()\n@click.option('-e', '--environment', required=True,\n              cls=default_from_context('DEFAULT_ENVIRONMENT'))\ndef show_env(environment):\n    click.echo(environment)\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'show_env',\n        '--help',\n    )\n\n    import sys, time\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.group()",
            "answer": "group",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1018"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-02",
            "description": "This code randomly selects 1000 samples from the list \"emo_list\" with probabilities defined by the array \"p\" and stores the result in the variable \"emo_sample\".",
            "code": "emo_sample = np.random.choice(emo_list, 1000, p=p)",
            "masked_code": "<line_mask>",
            "masked_line": "emo_sample = np.random.choice(emo_list, 1000, p=p)",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1019"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2019-03-18",
            "description": "The code sets the order of the column in the dataframe, pivots the dataframe based on certain columns, plots an area chart showing the number of launches by country over the years, and adjusts the legend position on the plot.",
            "code": "# set the order of the column in df\ndf.state_code = pd.Categorical(df.state_code, sorted(df.state_code.unique())[::-1], ordered=True)\n\n# now pivot df\nyear_countries = df.pivot(index='launch_year', columns='state_code', values='value')\n\n# plot\nax = year_countries.plot(kind='area', figsize=(9, 6), xticks=range(1957, 1962))\nax.set_xlabel('Launch Year', fontsize=15)\nax.set_ylabel('Number of Launches', fontsize=15)\nax.set_title('Space Launches By Country', fontsize=17)\n\n# move the legend\nax.legend(title='Countries', bbox_to_anchor=(1, 1.02), loc='upper left', frameon=False)",
            "masked_code": "# set the order of the column in df\ndf.state_code = pd.Categorical(df.state_code, sorted(df.state_code.unique())[::-1], ordered=True)\n\n# now pivot df\nyear_countries = df.pivot(index='launch_year', columns='state_code', values='value')\n\n# plot\nax = year_countries.plot(kind='area', figsize=(9, 6), xticks=range(1957, 1962))\n<line_mask>\nax.set_ylabel('Number of Launches', fontsize=15)\nax.set_title('Space Launches By Country', fontsize=17)\n\n# move the legend\nax.legend(title='Countries', bbox_to_anchor=(1, 1.02), loc='upper left', frameon=False)",
            "masked_line": "ax.set_xlabel('Launch Year', fontsize=15)",
            "answer": "set_xlabel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1020"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-28",
            "description": "The code stacks the transpose of the array 'gmm' with the array 'gauss' and then transposes the result. It prints the resulting array and its shape. The shape of the resulting array is (3, 2, 2).",
            "code": "gmm = np.array([[[4.64, -1.93],\n                [-1.93, 6.5 ]],\n                [[3.65, 2.89],\n                 [2.89, -1.26]]])\n\ngauss = np.array([[ -1.24, 2.34],\n                  [2.34, 4.76]])\n\n\nresult = np.dstack((gmm.T, gauss)).T\nprint (result)\nprint (result.shape)\n# (3, 2, 2)",
            "masked_code": "gmm = np.array([[[4.64, -1.93],\n                [-1.93, 6.5 ]],\n                [[3.65, 2.89],\n                 [2.89, -1.26]]])\n\ngauss = np.array([[ -1.24, 2.34],\n                  [2.34, 4.76]])\n\n\n<line_mask>\nprint (result)\nprint (result.shape)\n# (3, 2, 2)",
            "masked_line": "result = np.dstack((gmm.T, gauss)).T",
            "answer": "dstack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1021"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.0.0.21",
            "time": "2019-05-23",
            "description": "The code reads an image file named 'e.png', converts the image to a float data type using NumPy, and stores it in the variable 'img'.",
            "code": "img = cv2.imread('e.png')\nimg = img.astype(np.float)",
            "masked_code": "<line_mask>\nimg = img.astype(np.float)",
            "masked_line": "img = cv2.imread('e.png')",
            "answer": "imread",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1022"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-06-12",
            "description": "This code retrieves specific elements from the tensor tf_a1 along the axis specified by tf_a2.",
            "code": "tf.gather(tf_a1, tf_a2, axis=0)                                                                                        \n#",
            "masked_code": "<line_mask>\n#",
            "masked_line": "tf.gather(tf_a1, tf_a2, axis=0)",
            "answer": "gather",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1023"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-02-15",
            "description": "The code calculates a weighted average (wa) of columns A, B, and C in a DataFrame. Then, it adds a new column 'new_col' to the DataFrame, where if there are any missing values in the DataFrame, it fills them with the mean value of each row; otherwise, it fills them with the calculated weighted average (wa).",
            "code": "wa = 0.2*df.A + 0.4*df.B + 0.2*df.C\ndf['new_col'] = np.where(df.isna().any(axis=1), df.mean(axis=1), wa)",
            "masked_code": "wa = 0.2*df.A + 0.4*df.B + 0.2*df.C\n<line_mask>",
            "masked_line": "df['new_col'] = np.where(df.isna().any(axis=1), df.mean(axis=1), wa)",
            "answer": "mean",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1024"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-13",
            "description": "The code creates a transposed array from a given 2x3 numpy array \"a\", and then generates two flattened arrays \"c\" and \"d\" from the transposed array \"a\". The code then prints whether the array \"d\" is a view of array \"a\".",
            "code": "a = np.array([[1,2,3], [4,5,6]])\nc = a.T.ravel()\nd = a.T.ravel(order='F')\n\nprint('d is a view of a\\n%s\\n' % (d.base is a))",
            "masked_code": "<line_mask>\nc = a.T.ravel()\nd = a.T.ravel(order='F')\n\nprint('d is a view of a\\n%s\\n' % (d.base is a))",
            "masked_line": "a = np.array([[1,2,3], [4,5,6]])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1025"
        },
        {
            "dependency": "pyglet",
            "version": "==1.3",
            "time": "2019-01-14",
            "description": "This code sets up a pyglet window and implements 3D rendering using OpenGL. The window displays a colored polygon that can be moved forward and backward (W and S keys) and rotated (A and D keys) by the user.",
            "code": "import pyglet\nfrom pyglet.gl import *\n\npos = [0, 0, -20]\nrot_y = 0\n\nconfig = Config(sample_buffers=1, samples=8)\ntela = pyglet.window.Window(height=500, width=500, config=config)\n\n@tela.event\ndef on_draw():\n\n    global pos_z, rot_y\n\n    tela.clear()\n\n    glMatrixMode(GL_PROJECTION)\n    glLoadIdentity()\n    gluPerspective(90, 1, 0.1, 100)\n\n    glMatrixMode(GL_MODELVIEW)\n    glLoadIdentity()\n\n    glTranslatef(*pos)\n    glRotatef(rot_y, 0, 1, 0)\n\n    glBegin(GL_POLYGON)\n    glVertex3f(-5,-5,0)\n    glVertex3f(5,-5,0)\n    glVertex3f(0,5,0)\n    glEnd()\n\n    glFlush()\n\n@tela.event\ndef on_key_press(s,m):\n\n    global pos_z, rot_y\n\n    if s == pyglet.window.key.W:\n        pos[2] -= 1\n    if s == pyglet.window.key.S:\n        pos[2] += 1\n    if s == pyglet.window.key.A:\n        rot_y += 5\n    if s == pyglet.window.key.D:\n        rot_y -= 5\n\npyglet.app.run()",
            "masked_code": "import pyglet\nfrom pyglet.gl import *\n\npos = [0, 0, -20]\nrot_y = 0\n\nconfig = Config(sample_buffers=1, samples=8)\ntela = pyglet.window.Window(height=500, width=500, config=config)\n\n@tela.event\ndef on_draw():\n\n    global pos_z, rot_y\n\n    tela.clear()\n\n    glMatrixMode(GL_PROJECTION)\n    glLoadIdentity()\n    gluPerspective(90, 1, 0.1, 100)\n\n    glMatrixMode(GL_MODELVIEW)\n    glLoadIdentity()\n\n    glTranslatef(*pos)\n    glRotatef(rot_y, 0, 1, 0)\n\n    glBegin(GL_POLYGON)\n    glVertex3f(-5,-5,0)\n    glVertex3f(5,-5,0)\n    glVertex3f(0,5,0)\n    glEnd()\n\n    glFlush()\n\n@tela.event\ndef on_key_press(s,m):\n\n    global pos_z, rot_y\n\n    if s == pyglet.window.key.W:\n        pos[2] -= 1\n    <line_mask>\n        pos[2] += 1\n    if s == pyglet.window.key.A:\n        rot_y += 5\n    if s == pyglet.window.key.D:\n        rot_y -= 5\n\npyglet.app.run()",
            "masked_line": "if s == pyglet.window.key.S:",
            "answer": "window",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1026"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-10-16",
            "description": "This code defines a custom layer called PrunableDense, which is a subclass of the Dense layer in Keras. The purpose of this custom layer is to allow for pruning of weights in a neural network by setting certain weights to zero based on provided conditions or thresholds. The layer contains methods to prune the kernel and bias weights based on specific conditions, as well as properties to provide access to the pruned weights.",
            "code": "class PrunableDense(keras.layers.Dense):\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.deleted_channels = None\n        self.deleted_bias = None\n        self._kernel=None\n        self._bias=None\n\n\n    def build(self, input_shape):\n        last_dim = input_shape[-1]\n        self._kernel = self.add_weight(\n            'kernel',\n            shape=[last_dim, self.units],\n            initializer=self.kernel_initializer,\n            regularizer=self.kernel_regularizer,\n            constraint=self.kernel_constraint,\n            dtype=self.dtype,\n            trainable=True)\n        self.deleted_channels = tf.ones([last_dim, self.units]) # we'll use this to prune the network\n        if self.use_bias:\n            self._bias = self.add_weight(\n                'bias',\n                shape=[self.units,],\n                initializer=self.bias_initializer,\n                regularizer=self.bias_regularizer,\n                constraint=self.bias_constraint,\n                dtype=self.dtype,\n                trainable=True)\n            self.deleted_bias = tf.ones([self.units,])\n\n    @property\n    def kernel(self):\n        \"\"\"gets called whenever self.kernel is used\"\"\"\n        # only the weights that haven't been deleted should be non-zero\n        # deleted weights are 0.'s in self.deleted_channels\n        return self.deleted_channels * self._kernel  \n\n    @property\n    def bias(self):\n        #similar to kernel\n        if not self.use_bias:\n            return None\n        else:\n            return self.deleted_bias * self._bias\n\n    def prune_kernel(self, to_be_deleted):\n        \"\"\"\n        Delete some channels\n        to_be_deleted should be a tensor or numpy array of shape kernel.shape\n        containing 1's at the locations where weights should be kept, and 0's \n        at the locations where weights should be deleted.\n        \"\"\"\n        self.deleted_channels *= to_be_deleted\n\n    def prune_bias(self, to_be_deleted):\n        assert(self.use_bias)\n        self.deleted_bias *= to_be_deleted\n\n    def prune_kernel_below_threshold(self, threshold=0.01):\n        to_be_deleted = tf.cast(tf.greater(self.kernel, threshold), tf.float32)\n        self.deleted_channels *= to_be_deleted\n\n    def prune_bias_below_threshold(self, threshold=0.01):\n        assert(self.use_bias)\n        to_be_deleted = tf.cast(tf.greater(self.bias, threshold), tf.float32)\n        self.deleted_bias *= to_be_deleted",
            "masked_code": "class PrunableDense(keras.layers.Dense):\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.deleted_channels = None\n        self.deleted_bias = None\n        self._kernel=None\n        self._bias=None\n\n\n    def build(self, input_shape):\n        last_dim = input_shape[-1]\n        <line_mask>\n            'kernel',\n            shape=[last_dim, self.units],\n            initializer=self.kernel_initializer,\n            regularizer=self.kernel_regularizer,\n            constraint=self.kernel_constraint,\n            dtype=self.dtype,\n            trainable=True)\n        self.deleted_channels = tf.ones([last_dim, self.units]) # we'll use this to prune the network\n        if self.use_bias:\n            self._bias = self.add_weight(\n                'bias',\n                shape=[self.units,],\n                initializer=self.bias_initializer,\n                regularizer=self.bias_regularizer,\n                constraint=self.bias_constraint,\n                dtype=self.dtype,\n                trainable=True)\n            self.deleted_bias = tf.ones([self.units,])\n\n    @property\n    def kernel(self):\n        \"\"\"gets called whenever self.kernel is used\"\"\"\n        # only the weights that haven't been deleted should be non-zero\n        # deleted weights are 0.'s in self.deleted_channels\n        return self.deleted_channels * self._kernel  \n\n    @property\n    def bias(self):\n        #similar to kernel\n        if not self.use_bias:\n            return None\n        else:\n            return self.deleted_bias * self._bias\n\n    def prune_kernel(self, to_be_deleted):\n        \"\"\"\n        Delete some channels\n        to_be_deleted should be a tensor or numpy array of shape kernel.shape\n        containing 1's at the locations where weights should be kept, and 0's \n        at the locations where weights should be deleted.\n        \"\"\"\n        self.deleted_channels *= to_be_deleted\n\n    def prune_bias(self, to_be_deleted):\n        assert(self.use_bias)\n        self.deleted_bias *= to_be_deleted\n\n    def prune_kernel_below_threshold(self, threshold=0.01):\n        to_be_deleted = tf.cast(tf.greater(self.kernel, threshold), tf.float32)\n        self.deleted_channels *= to_be_deleted\n\n    def prune_bias_below_threshold(self, threshold=0.01):\n        assert(self.use_bias)\n        to_be_deleted = tf.cast(tf.greater(self.bias, threshold), tf.float32)\n        self.deleted_bias *= to_be_deleted",
            "masked_line": "self._kernel = self.add_weight(",
            "answer": "add_weight",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1027"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-10-16",
            "description": "This code defines a custom layer \"FreezableDense\" that extends the functionality of a standard Dense layer in a neural network. It allows for freezing and pruning of weights and biases by using trainable and non-trainable masks to selectively control which parts of the network should be updated during training. The \"FreezableDense\" layer provides methods to freeze specific weights in the kernel and bias based on provided masks and track the frozen parts of the network using trainable flags.",
            "code": "class FreezableDense(keras.layers.Dense):\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.trainable_channels = None\n        self.trainable_bias = None\n        self._kernel1 = None\n        self._bias1 = None\n        self._kernel2 = None\n        self._bias2 = None\n\n\n    def build(self, input_shape):\n        last_dim = input_shape[-1]\n        self._kernel1 = self.add_weight(\n            'kernel1',\n            shape=[last_dim, self.units],\n            initializer=self.kernel_initializer,\n            regularizer=self.kernel_regularizer,\n            constraint=self.kernel_constraint,\n            dtype=self.dtype,\n            trainable=True)\n        self._kernel2 = tf.zeros([last_dim, self.units])\n        self.trainable_channels = tf.ones([last_dim, self.units]) # we'll use this to freeze parts of the network\n        if self.use_bias:\n            self._bias1 = self.add_weight(\n                'bias',\n                shape=[self.units,],\n                initializer=self.bias_initializer,\n                regularizer=self.bias_regularizer,\n                constraint=self.bias_constraint,\n                dtype=self.dtype,\n                trainable=True)\n            self._bias2 = tf.zeros([self.units,])\n            self.trainable_bias = tf.ones([self.units,])\n\n    @property\n    def kernel(self):\n        \"\"\"gets called whenever self.kernel is used\"\"\"\n        # frozen \n        return self.trainable_channels * self._kernel1 + (1 - self.trainable_channels) * self._kernel2\n\n    @property\n    def bias(self):\n        #similar to kernel\n        if not self.use_bias:\n            return None\n        else:\n            return self.trainable_bias * self._bias1 + (1 - self.trainable_bias) * self._bias2\n\n    def freeze_kernel(self, to_be_frozen):\n        \"\"\"\n        freeze some channels\n        to_be_frozen should be a tensor or numpy array of shape kernel.shape\n        containing 1's at the locations where weights should be kept trainable, and 0's \n        at the locations where weights should be frozen.\n        \"\"\"\n        # we want to do two things: update the weights in self._kernel2 \n        # and update self.trainable_channels\n        # first we update self._kernel2 with all newly frozen weights\n        newly_frozen = 1 - tf.maximum((1 - to_be_frozen) - (1 - self.trainable_channels), 0)\n        # the above should have 0 only where to_be_frozen is 0 and self.trainable_channels is 1\n        # if I'm not mistaken that is\n        newly_frozen_weights = (1-newly_frozen)*self._kernel1\n        self._kernel2 += newly_frozen_weights\n\n        # now we update self.trainable_channels:\n        self.trainable_channels *= to_be_frozen\n\n    def prune_bias(self, to_be_deleted):\n        assert(self.use_bias)\n        newly_frozen = 1 - tf.maximum((1 - to_be_frozen) - (1 - self.trainable_bias), 0)\n        newly_frozen_bias = (1-newly_frozen)*self._bias1\n        self._bias2 += newly_frozen_bias\n        self.trainable_bias *= to_be_frozen",
            "masked_code": "class FreezableDense(keras.layers.Dense):\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.trainable_channels = None\n        self.trainable_bias = None\n        self._kernel1 = None\n        self._bias1 = None\n        self._kernel2 = None\n        self._bias2 = None\n\n\n    def build(self, input_shape):\n        last_dim = input_shape[-1]\n        self._kernel1 = self.add_weight(\n            'kernel1',\n            shape=[last_dim, self.units],\n            initializer=self.kernel_initializer,\n            regularizer=self.kernel_regularizer,\n            constraint=self.kernel_constraint,\n            dtype=self.dtype,\n            trainable=True)\n        self._kernel2 = tf.zeros([last_dim, self.units])\n        self.trainable_channels = tf.ones([last_dim, self.units]) # we'll use this to freeze parts of the network\n        if self.use_bias:\n            self._bias1 = self.add_weight(\n                'bias',\n                shape=[self.units,],\n                initializer=self.bias_initializer,\n                regularizer=self.bias_regularizer,\n                constraint=self.bias_constraint,\n                dtype=self.dtype,\n                trainable=True)\n            self._bias2 = tf.zeros([self.units,])\n            self.trainable_bias = tf.ones([self.units,])\n\n    @property\n    def kernel(self):\n        \"\"\"gets called whenever self.kernel is used\"\"\"\n        # frozen \n        return self.trainable_channels * self._kernel1 + (1 - self.trainable_channels) * self._kernel2\n\n    @property\n    def bias(self):\n        #similar to kernel\n        if not self.use_bias:\n            return None\n        else:\n            return self.trainable_bias * self._bias1 + (1 - self.trainable_bias) * self._bias2\n\n    def freeze_kernel(self, to_be_frozen):\n        \"\"\"\n        freeze some channels\n        to_be_frozen should be a tensor or numpy array of shape kernel.shape\n        containing 1's at the locations where weights should be kept trainable, and 0's \n        at the locations where weights should be frozen.\n        \"\"\"\n        # we want to do two things: update the weights in self._kernel2 \n        # and update self.trainable_channels\n        # first we update self._kernel2 with all newly frozen weights\n        <line_mask>\n        # the above should have 0 only where to_be_frozen is 0 and self.trainable_channels is 1\n        # if I'm not mistaken that is\n        newly_frozen_weights = (1-newly_frozen)*self._kernel1\n        self._kernel2 += newly_frozen_weights\n\n        # now we update self.trainable_channels:\n        self.trainable_channels *= to_be_frozen\n\n    def prune_bias(self, to_be_deleted):\n        assert(self.use_bias)\n        newly_frozen = 1 - tf.maximum((1 - to_be_frozen) - (1 - self.trainable_bias), 0)\n        newly_frozen_bias = (1-newly_frozen)*self._bias1\n        self._bias2 += newly_frozen_bias\n        self.trainable_bias *= to_be_frozen",
            "masked_line": "newly_frozen = 1 - tf.maximum((1 - to_be_frozen) - (1 - self.trainable_channels), 0)",
            "answer": "maximum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1028"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-03-02",
            "description": "Count the elements in the array U that fall into each bin defined by the array P.",
            "code": "np.bincount(np.digitize(U,P))[1:]\n# array([1, 0, 2, 4, 3])",
            "masked_code": "<line_mask>\n# array([1, 0, 2, 4, 3])",
            "masked_line": "np.bincount(np.digitize(U,P))[1:]",
            "answer": "bincount",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1029"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.4",
            "time": "2019-01-10",
            "description": "This code generates a cross-tabulation of the 'Bin' column in a DataFrame 'df' against the 'CPB%' column after binning the 'CPB%' values into specified bins.",
            "code": "pd.crosstab(pd.cut(df['CPB%'], bins=bins), df.Bin)",
            "masked_code": "<line_mask>",
            "masked_line": "pd.crosstab(pd.cut(df['CPB%'], bins=bins), df.Bin)",
            "answer": "crosstab",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1030"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-04-24",
            "description": "This code defines a command-line tool using Click library in Python that has two commands: add and remove. The add command optionally accepts an overwrite flag and the remove command does not accept any options. The tool also has a main function that prints the Click and Python versions and processes a list of commands.",
            "code": "import click\n\n@click.group(cls=IgnoreRequiredWithHelp)\n@click.option('--directory', required=True)\ndef cli(directory):\n    \"\"\"\n    this is a tool that has an add and remove command\n    \"\"\"\n    click.echo(directory)\n\n@cli.command()\n@click.option('--overwrite', is_flag=True)\ndef add(overwrite):\n    \"\"\"\n    this is the add command\n    \"\"\"\n    click.echo(\"add overwrite={}\".format(overwrite))\n\n\n@cli.command()\ndef remove():\n    \"\"\"\n    this is the remove command\n    \"\"\"\n    click.echo('remove')\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'add --help',\n        '--help',\n        '--directory a_dir add'\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\n<line_mask>\n@click.option('--directory', required=True)\ndef cli(directory):\n    \"\"\"\n    this is a tool that has an add and remove command\n    \"\"\"\n    click.echo(directory)\n\n@cli.command()\n@click.option('--overwrite', is_flag=True)\ndef add(overwrite):\n    \"\"\"\n    this is the add command\n    \"\"\"\n    click.echo(\"add overwrite={}\".format(overwrite))\n\n\n@cli.command()\ndef remove():\n    \"\"\"\n    this is the remove command\n    \"\"\"\n    click.echo('remove')\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'add --help',\n        '--help',\n        '--directory a_dir add'\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.group(cls=IgnoreRequiredWithHelp)",
            "answer": "group",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1031"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-03-10",
            "description": "The code checks for a condition in the 'col' column of the DataFrame 'df' where the value is equal to 0. If the condition is met, it shifts the values in the 't' column by 1 and adds 1, otherwise it sets the value to 0.",
            "code": "np.where(df.col.eq(0), df.t.shift() + 1, 0)",
            "masked_code": "<line_mask>",
            "masked_line": "np.where(df.col.eq(0), df.t.shift() + 1, 0)",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1032"
        },
        {
            "dependency": "seaborn",
            "version": "==0.9.0",
            "time": "2019-07-31",
            "description": "This code creates a categorical plot to display the relationship between sales and month, categorized by store type, with different plots for different promo statuses.",
            "code": "sns.catplot(x=\"Month\", y=\"Sales\", hue=\"StoreType\",col=\"Promo\", kind=\"point\", data=train_store)",
            "masked_code": "<line_mask>",
            "masked_line": "sns.catplot(x=\"Month\", y=\"Sales\", hue=\"StoreType\",col=\"Promo\", kind=\"point\", data=train_store)",
            "answer": "catplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1033"
        },
        {
            "dependency": "seaborn",
            "version": "==0.9.0",
            "time": "2019-07-31",
            "description": "The code generates a factor plot to show the relationship between sales and month, with separate plots for different promo levels and store types.",
            "code": "sns.factorplot(data = train_store, x = 'Month', y = \"Sales\",col = 'Promo',hue = 'StoreType')",
            "masked_code": "<line_mask>",
            "masked_line": "sns.factorplot(data = train_store, x = 'Month', y = \"Sales\",col = 'Promo',hue = 'StoreType')",
            "answer": "factorplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1034"
        },
        {
            "dependency": "rpy2",
            "version": "==3.0.x",
            "time": "2019-02-24",
            "description": "The code defines a function myfunc that takes a model as an input and uses the predict.merMod function to make predictions, with the re.form parameter set to NA.",
            "code": "myfunc = robjects.r('function (x) predict.merMod(x, re.form=NA)')\nmyfunc(mymodel)",
            "masked_code": "myfunc = robjects.r('function (x) predict.merMod(x, re.form=NA)')\n<line_mask>",
            "masked_line": "myfunc(mymodel)",
            "answer": "myfunc",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1035"
        },
        {
            "dependency": "pandas",
            "version": "==0.25",
            "time": "2019-11-22",
            "description": "The code takes a JSON dictionary, extracts the 'date' and 'values' key-value pairs from each element, evaluates the 'values' string as a list, then creates a DataFrame from the resulting data and explodes the 'values' column.",
            "code": "data = [{'date': x['date'], 'values': eval(x['values'])} for x in your_json_dict]\npd.DataFrame(data).explode('values')",
            "masked_code": "data = [{'date': x['date'], 'values': eval(x['values'])} for x in your_json_dict]\n<line_mask>",
            "masked_line": "pd.DataFrame(data).explode('values')",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1036"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-06-21",
            "description": "The code constructs a model-view matrix by applying translations and rotations to an initial matrix.",
            "code": "T  = np.matrix(translate(0.0, 0.0, -4.0)).reshape(4,4)\nRX = np.matrix(rotation_matrix( [1.0, 0.0, 0.0], currentTime * m3dDegToRad(17.0)))\nRY = np.matrix(rotation_matrix( [0.0, 1.0, 0.0], currentTime * m3dDegToRad(13.0)))\n\nmv_matrix = RX * RY * T",
            "masked_code": "<line_mask>\nRX = np.matrix(rotation_matrix( [1.0, 0.0, 0.0], currentTime * m3dDegToRad(17.0)))\nRY = np.matrix(rotation_matrix( [0.0, 1.0, 0.0], currentTime * m3dDegToRad(13.0)))\n\nmv_matrix = RX * RY * T",
            "masked_line": "T  = np.matrix(translate(0.0, 0.0, -4.0)).reshape(4,4)",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1037"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-06-16",
            "description": "This code defines a CLI (Command Line Interface) application using the Click library in Python. It includes a main CLI function with subcommands and options, and allows for chaining commands. The code also includes error handling and displays version information for Click and Python.",
            "code": "import click\nimport copy\nimport sys\n\n@click.group()\ndef cli():\n    \"\"\"This is cli helptext\"\"\"\n    click.echo('cli called')\n\n\n@cli.group(chain=True, no_args_is_help=False, cls=RepeatMultiCommand)\n@click.option('-r', '--repeat', default=1, type=click.INT,\n              help='repeat helptext')\ndef chainedgroup(repeat):\n    \"\"\"This is chainedgroup helptext\"\"\"\n    click.echo('chainedgroup code called')\n\n\n@chainedgroup.command()\ndef command1():\n    \"\"\"This is command1 helptext\"\"\"\n    click.echo('command1 called')\n\n\n@chainedgroup.command()\n@click.option('-o', '--option')\ndef command2(option):\n    \"\"\"This is command2 helptext\"\"\"\n    click.echo('command2 called with {0}'.format(option))\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'chainedgroup --repeat 2 command1',\n        'chainedgroup -r 3 command1 command2 -o test',\n        'chainedgroup command1',\n        'chainedgroup --help',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\nimport copy\nimport sys\n\n<line_mask>\ndef cli():\n    \"\"\"This is cli helptext\"\"\"\n    click.echo('cli called')\n\n\n@cli.group(chain=True, no_args_is_help=False, cls=RepeatMultiCommand)\n@click.option('-r', '--repeat', default=1, type=click.INT,\n              help='repeat helptext')\ndef chainedgroup(repeat):\n    \"\"\"This is chainedgroup helptext\"\"\"\n    click.echo('chainedgroup code called')\n\n\n@chainedgroup.command()\ndef command1():\n    \"\"\"This is command1 helptext\"\"\"\n    click.echo('command1 called')\n\n\n@chainedgroup.command()\n@click.option('-o', '--option')\ndef command2(option):\n    \"\"\"This is command2 helptext\"\"\"\n    click.echo('command2 called with {0}'.format(option))\n\n\nif __name__ == \"__main__\":\n    commands = (\n        'chainedgroup --repeat 2 command1',\n        'chainedgroup -r 3 command1 command2 -o test',\n        'chainedgroup command1',\n        'chainedgroup --help',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            cli(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.group()",
            "answer": "group",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1038"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-03-12",
            "description": "The code generates a numpy array containing unique values that are the result of multiplying logarithmic values from 0 to 1000 by integers from 0 to 20.",
            "code": "n = 20\nbins = np.unique(np.outer(np.logspace(0, 3, 4), np.arange(0, n+1)))\n# array([0.0e+00, 1.0e+00, 2.0e+00, 3.0e+00, 4.0e+00, 5.0e+00, 6.0e+00, 7.0e+00, 8.0e+00, 9.0e+00, 1.0e+01, 1.1e+01, 1.2e+01, 1.3e+01, 1.4e+01, 1.5e+01, 1.6e+01, 1.7e+01, 1.8e+01, 1.9e+01, 2.0e+01, 3.0e+01, 4.0e+01, 5.0e+01, 6.0e+01, 7.0e+01, 8.0e+01, 9.0e+01, 1.0e+02, 1.1e+02, 1.2e+02, 1.3e+02, 1.4e+02, 1.5e+02, 1.6e+02, 1.7e+02, 1.8e+02, 1.9e+02, 2.0e+02, 3.0e+02, 4.0e+02, 5.0e+02, 6.0e+02, 7.0e+02, 8.0e+02, 9.0e+02, 1.0e+03, 1.1e+03, 1.2e+03, 1.3e+03, 1.4e+03, 1.5e+03, 1.6e+03, 1.7e+03, 1.8e+03, 1.9e+03, 2.0e+03, 3.0e+03, 4.0e+03, 5.0e+03, 6.0e+03, 7.0e+03, 8.0e+03, 9.0e+03, 1.0e+04, 1.1e+04, 1.2e+04, 1.3e+04, 1.4e+04, 1.5e+04, 1.6e+04, 1.7e+04, 1.8e+04, 1.9e+04, 2.0e+04])",
            "masked_code": "n = 20\n<line_mask>\n# array([0.0e+00, 1.0e+00, 2.0e+00, 3.0e+00, 4.0e+00, 5.0e+00, 6.0e+00, 7.0e+00, 8.0e+00, 9.0e+00, 1.0e+01, 1.1e+01, 1.2e+01, 1.3e+01, 1.4e+01, 1.5e+01, 1.6e+01, 1.7e+01, 1.8e+01, 1.9e+01, 2.0e+01, 3.0e+01, 4.0e+01, 5.0e+01, 6.0e+01, 7.0e+01, 8.0e+01, 9.0e+01, 1.0e+02, 1.1e+02, 1.2e+02, 1.3e+02, 1.4e+02, 1.5e+02, 1.6e+02, 1.7e+02, 1.8e+02, 1.9e+02, 2.0e+02, 3.0e+02, 4.0e+02, 5.0e+02, 6.0e+02, 7.0e+02, 8.0e+02, 9.0e+02, 1.0e+03, 1.1e+03, 1.2e+03, 1.3e+03, 1.4e+03, 1.5e+03, 1.6e+03, 1.7e+03, 1.8e+03, 1.9e+03, 2.0e+03, 3.0e+03, 4.0e+03, 5.0e+03, 6.0e+03, 7.0e+03, 8.0e+03, 9.0e+03, 1.0e+04, 1.1e+04, 1.2e+04, 1.3e+04, 1.4e+04, 1.5e+04, 1.6e+04, 1.7e+04, 1.8e+04, 1.9e+04, 2.0e+04])",
            "masked_line": "bins = np.unique(np.outer(np.logspace(0, 3, 4), np.arange(0, n+1)))",
            "answer": "logspace",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1039"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-03-12",
            "description": "This code generates an array of bin values that are spaced exponentially between 10^1 to 10^3, with a total of n+1 bins.",
            "code": "n = 10\nbins = np.unique(np.outer(np.logspace(1, 3, 3), np.arange(0, n+1)))\n# array([    0.,    10.,    20.,    30.,    40.,    50.,    60.,    70.,\n#           80.,    90.,   100.,   200.,   300.,   400.,   500.,   600.,\n#          700.,   800.,   900.,  1000.,  2000.,  3000.,  4000.,  5000.,\n#         6000.,  7000.,  8000.,  9000., 10000.])",
            "masked_code": "n = 10\n<line_mask>\n# array([    0.,    10.,    20.,    30.,    40.,    50.,    60.,    70.,\n#           80.,    90.,   100.,   200.,   300.,   400.,   500.,   600.,\n#          700.,   800.,   900.,  1000.,  2000.,  3000.,  4000.,  5000.,\n#         6000.,  7000.,  8000.,  9000., 10000.])",
            "masked_line": "bins = np.unique(np.outer(np.logspace(1, 3, 3), np.arange(0, n+1)))",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1040"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.10",
            "time": "2019-02-25",
            "description": "The code reads a CSV file and creates a dataset using TensorFlow's Dataset API.",
            "code": "dataset = tf.contrib.data.make_csv_dataset(filenames)",
            "masked_code": "<line_mask>",
            "masked_line": "dataset = tf.contrib.data.make_csv_dataset(filenames)",
            "answer": "make_csv_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1041"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24.1",
            "time": "2019-02-14",
            "description": "The code groups the data in dataframe df by day and transforms each group by selecting the value at 12:00 PM.",
            "code": "df.groupby(pd.Grouper(freq='D'))[0]\\\n  .transform(lambda x: x.loc[(x.index.hour == 12) & \n                             (x.index.minute==0)].to_numpy()[0])",
            "masked_code": "<line_mask>\n  .transform(lambda x: x.loc[(x.index.hour == 12) & \n                             (x.index.minute==0)].to_numpy()[0])",
            "masked_line": "df.groupby(pd.Grouper(freq='D'))[0]\\",
            "answer": "Grouper",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1042"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.0",
            "time": "2019-10-30",
            "description": "This code filters the values in the array thetas based on whether they are not close to any values in the array known_thetas.",
            "code": "thetas[~np.isclose(thetas[:,None],known_thetas).any(1)]",
            "masked_code": "<line_mask>",
            "masked_line": "thetas[~np.isclose(thetas[:,None],known_thetas).any(1)]",
            "answer": "any",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1043"
        },
        {
            "dependency": "networkx",
            "version": "==2.2",
            "time": "2019-02-27",
            "description": "The code creates a multi graph and adds nodes from a dictionary called auth_dict.",
            "code": "G = nx.MultiGraph()\nG.add_nodes_from(auth_dict)",
            "masked_code": "G = nx.MultiGraph()\n<line_mask>",
            "masked_line": "G.add_nodes_from(auth_dict)",
            "answer": "add_nodes_from",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1044"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1",
            "time": "2020-06-04",
            "description": "The code adds a binary mask to the input data, activating only even indices in the input.",
            "code": "\"\"\"Solution based on binary mask.\n- We just add this mask to inputs, instead of multiplying.\"\"\"\nclass AddToEven(tf.keras.Model):\n    def __init__(self):\n        super(AddToEven, self).__init__()        \n\n    def build(self, inputshape):\n        self.built = True # Actually nothing to build with, becuase we don't have any variables or weights here.\n\n    @tf.function\n    def call(self, inputs):\n        w = inputs.get_shape()[-1]\n\n        # 1-d mask generation for w-axis (activate even indices only)        \n        m_w = tf.range(w)  # [0, 1, 2,... w-1]\n        m_w = ((m_w%2)==0) # [True, False, True ,...] with dtype=tf.bool\n\n        # Apply 1-d mask to 2-d input\n        m_w = tf.expand_dims(m_w, axis=0) # just extend dimension as to be (1, W)\n        m_w = tf.cast(m_w, dtype=inputs.dtype) # in advance, we need to convert dtype\n\n        # Here, we just add this (1, W) mask to (H,W) input magically.\n        outputs = inputs + m_w # This add operation is allowed in both TF and numpy!\n        return tf.reshape(outputs, inputs.get_shape())",
            "masked_code": "\"\"\"Solution based on binary mask.\n- We just add this mask to inputs, instead of multiplying.\"\"\"\nclass AddToEven(tf.keras.Model):\n    def __init__(self):\n        super(AddToEven, self).__init__()        \n\n    def build(self, inputshape):\n        self.built = True # Actually nothing to build with, becuase we don't have any variables or weights here.\n\n    @tf.function\n    def call(self, inputs):\n        w = inputs.get_shape()[-1]\n\n        # 1-d mask generation for w-axis (activate even indices only)        \n        m_w = tf.range(w)  # [0, 1, 2,... w-1]\n        m_w = ((m_w%2)==0) # [True, False, True ,...] with dtype=tf.bool\n\n        # Apply 1-d mask to 2-d input\n        <line_mask>\n        m_w = tf.cast(m_w, dtype=inputs.dtype) # in advance, we need to convert dtype\n\n        # Here, we just add this (1, W) mask to (H,W) input magically.\n        outputs = inputs + m_w # This add operation is allowed in both TF and numpy!\n        return tf.reshape(outputs, inputs.get_shape())",
            "masked_line": "m_w = tf.expand_dims(m_w, axis=0) # just extend dimension as to be (1, W)",
            "answer": "expand_dims",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1045"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1",
            "time": "2020-06-04",
            "description": "The code defines a model called \"AddToEven\" and initializes it. The model is then built with a tensor shape of [None, None]. Lastly, the model is used to calculate the result of adding 0 to a tensor of shape [2,4] and the result is printed.",
            "code": "# sanity-check as model\nmodel = AddToEven()\nmodel.build(tf.TensorShape([None, None]))\nz = model(tf.zeros([2,4]))\nprint(z)",
            "masked_code": "# sanity-check as model\nmodel = AddToEven()\n<line_mask>\nz = model(tf.zeros([2,4]))\nprint(z)",
            "masked_line": "model.build(tf.TensorShape([None, None]))",
            "answer": "TensorShape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1046"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.2",
            "time": "2020-09-15",
            "description": "This code loads the penguins dataset using seaborn, and then creates a joint plot showing the relationship between bill length and bill depth of penguins, with purple colors.",
            "code": "import seaborn as sns\n\n# load data\ndf = sns.load_dataset(\"penguins\", cache=False)\n\n# plot\ng = sns.jointplot(data=df, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n                  ec=\"purple\", fc=\"none\", color='purple')",
            "masked_code": "import seaborn as sns\n\n# load data\n<line_mask>\n\n# plot\ng = sns.jointplot(data=df, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n                  ec=\"purple\", fc=\"none\", color='purple')",
            "masked_line": "df = sns.load_dataset(\"penguins\", cache=False)",
            "answer": "load_dataset",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1047"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.2",
            "time": "2020-09-15",
            "description": "The code creates a joint plot using seaborn library to visualize the relationship between bill length and bill depth of penguins from the loaded dataset. It customizes the plot by assigning different colors to different species of penguins and setting the facecolor of some plot elements to 'none'. Finally, it adds a legend to the plot with the corresponding colors for each penguin species.",
            "code": "import seaborn as sns\nimport matplotlib as mpl\n\n# load data\ndf = sns.load_dataset(\"penguins\")\n\n# create a palette dict with a known color_palette\nspecies = df.species.unique()\npalette = dict(zip(species, sns.color_palette(palette='crest', n_colors=len(species))))\n\n# ec requires a single value or a list of values\nec = df.species.map(palette)\n\n# plot\ng = sns.jointplot(data=df, x=\"bill_length_mm\", y=\"bill_depth_mm\", ec=ec, hue='species', palette=palette, linewidth=1)\n\n# get the join axes; not the margins\nax_joint = g.ax_joint\n\n# iterate throught axes children\nfor c in ax_joint.get_children():\n    # set the facecolor to none\n    if type(c) == mpl.collections.PathCollection:    \n        c.set_facecolor('none')\n\n# also change the legend\nkws = {\"s\": 70, \"facecolor\": \"none\", \"linewidth\": 1.5}\nhandles, labels = zip(*[\n    (plt.scatter([], [], ec=color, **kws), key) for key, color in palette.items()\n])\nax_joint.legend(handles, labels, title=\"cat\")",
            "masked_code": "import seaborn as sns\nimport matplotlib as mpl\n\n# load data\ndf = sns.load_dataset(\"penguins\")\n\n# create a palette dict with a known color_palette\nspecies = df.species.unique()\n<line_mask>\n\n# ec requires a single value or a list of values\nec = df.species.map(palette)\n\n# plot\ng = sns.jointplot(data=df, x=\"bill_length_mm\", y=\"bill_depth_mm\", ec=ec, hue='species', palette=palette, linewidth=1)\n\n# get the join axes; not the margins\nax_joint = g.ax_joint\n\n# iterate throught axes children\nfor c in ax_joint.get_children():\n    # set the facecolor to none\n    if type(c) == mpl.collections.PathCollection:    \n        c.set_facecolor('none')\n\n# also change the legend\nkws = {\"s\": 70, \"facecolor\": \"none\", \"linewidth\": 1.5}\nhandles, labels = zip(*[\n    (plt.scatter([], [], ec=color, **kws), key) for key, color in palette.items()\n])\nax_joint.legend(handles, labels, title=\"cat\")",
            "masked_line": "palette = dict(zip(species, sns.color_palette(palette='crest', n_colors=len(species))))",
            "answer": "color_palette",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1048"
        },
        {
            "dependency": "opencv-python",
            "version": "==3.4",
            "time": "2020-01-16",
            "description": "This function rotates a rectangle around its top left corner by a given angle. It generates the homogenous coordinates of the rectangle's corners, creates a rotation matrix to transform the coordinates, and then applies the transformation to rotate the rectangle.",
            "code": "# Rotate rectangle defined by (x,y,w,h) around its top left corner (x,y) by given angle\ndef rotate_rectangle(x, y, w, h, angle):\n    # Generate homogenous coordinates of the corners\n    # Start top left, go clockwise\n    corners = np.array([\n        (x, y, 1)\n        , (x + w, y, 1)\n        , (x + w, y + h, 1)\n        , (x, y + h, 1)\n    ], np.int32)\n    # Create rotation matrix to transform the coordinates\n    m_rot = cv2.getRotationMatrix2D((x, y), angle, 1.0)\n    # Apply transformation\n    rotated_points = np.dot(m_rot, corners.T).T\n    return rotated_points",
            "masked_code": "# Rotate rectangle defined by (x,y,w,h) around its top left corner (x,y) by given angle\ndef rotate_rectangle(x, y, w, h, angle):\n    # Generate homogenous coordinates of the corners\n    # Start top left, go clockwise\n    corners = np.array([\n        (x, y, 1)\n        , (x + w, y, 1)\n        , (x + w, y + h, 1)\n        , (x, y + h, 1)\n    ], np.int32)\n    # Create rotation matrix to transform the coordinates\n    <line_mask>\n    # Apply transformation\n    rotated_points = np.dot(m_rot, corners.T).T\n    return rotated_points",
            "masked_line": "m_rot = cv2.getRotationMatrix2D((x, y), angle, 1.0)",
            "answer": "getRotationMatrix2D",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1049"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.4.0",
            "time": "2020-08-05",
            "description": "This code adds a search path for sample data in OpenCV library.",
            "code": "cv2.samples.addSamplesDataSearchPath('.../Desktop/opencv-4.4.0/samples/data')",
            "masked_code": "<line_mask>",
            "masked_line": "cv2.samples.addSamplesDataSearchPath('.../Desktop/opencv-4.4.0/samples/data')",
            "answer": "samples",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1050"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-05-13",
            "description": "This function initializes weights for a neural network layer based on the input shape provided. If the condition `self.cause_error` is True, the function reshapes the weights.",
            "code": "def build(self,input_shape): \n    self.input_size = input_shape[1]        \n    self.w = self.add_weight(shape=(self.input_size,\n                                          self.output_size),\n                                   initializer='random_normal',\n                                   trainable=True)\n\n    if self.cause_error:\n        self.w.assign(tf.reshape(self.w,\n                                   shape = (self.input_size,\n                                            self.output_size)))",
            "masked_code": "def build(self,input_shape): \n    self.input_size = input_shape[1]        \n    self.w = self.add_weight(shape=(self.input_size,\n                                          self.output_size),\n                                   initializer='random_normal',\n                                   trainable=True)\n\n    if self.cause_error:\n        <line_mask>\n                                   shape = (self.input_size,\n                                            self.output_size)))",
            "masked_line": "self.w.assign(tf.reshape(self.w,",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1051"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-04-27",
            "description": "The code generates a visualization of the intersection between graph1 and graph2, where isolated nodes are removed and the layout is determined using a spring layout algorithm. The resulting graph is then drawn with labeled nodes colored in light green.",
            "code": "g_int = nx.intersection(graph1, graph2)\ng_int.remove_nodes_from(list(nx.isolates(g_int)))\n\npos = nx.spring_layout(g_int, scale=20, k=3/np.sqrt(g_int.order()))\nnx.draw(g_int, pos=pos, with_labels=True, k=13.8, node_color='lightgreen', node_size=800)",
            "masked_code": "<line_mask>\ng_int.remove_nodes_from(list(nx.isolates(g_int)))\n\npos = nx.spring_layout(g_int, scale=20, k=3/np.sqrt(g_int.order()))\nnx.draw(g_int, pos=pos, with_labels=True, k=13.8, node_color='lightgreen', node_size=800)",
            "masked_line": "g_int = nx.intersection(graph1, graph2)",
            "answer": "intersection",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1052"
        },
        {
            "dependency": "networkx",
            "version": "==2.5",
            "time": "2020-11-03",
            "description": "The code separates the connected components of a graph and filters out components that have less than 20 nodes or less than 20 edges.",
            "code": "components = [panama.subgraph(p).copy() for p in nx.connected_components(panama)]\n\n# probably you want a list/set instead of a NodeView\ncomponents = [list(p.nodes()) for p in components\n              if p.number_of_nodes(p) >= 20\n              or p.number_of_edges(p) >= 20]",
            "masked_code": "<line_mask>\n\n# probably you want a list/set instead of a NodeView\ncomponents = [list(p.nodes()) for p in components\n              if p.number_of_nodes(p) >= 20\n              or p.number_of_edges(p) >= 20]",
            "masked_line": "components = [panama.subgraph(p).copy() for p in nx.connected_components(panama)]",
            "answer": "connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1053"
        },
        {
            "dependency": "networkx",
            "version": "==2.5",
            "time": "2020-11-03",
            "description": "The code selects connected components from a graph named \"panama\" that have a size of at least 20 nodes or contain at least 20 edges.",
            "code": "components = [p for p in nx.connected_components(panama)\n              if len(p) >= 20\n              or panama.subgraph(p).number_of_edges() >= 20]",
            "masked_code": "<line_mask>\n              if len(p) >= 20\n              or panama.subgraph(p).number_of_edges() >= 20]",
            "masked_line": "components = [p for p in nx.connected_components(panama)",
            "answer": "connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1054"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.1",
            "time": "2020-11-19",
            "description": "This code defines a custom Keras metric named CERMetric that computes the Character Error Rate (CER) between predicted and true values. It calculates the CER by decoding the predicted values, converting them into sparse format, calculating the edit distance between predicted and true values, and then updating and resetting the CER accumulator and counter. The result method returns the CER value.",
            "code": "class CERMetric(tf.keras.metrics.Metric):\n    \"\"\"\n    A custom Keras metric to compute the Character Error Rate\n    \"\"\"\n    def __init__(self, name='CER_metric', **kwargs):\n        super(CERMetric, self).__init__(name=name, **kwargs)\n        self.cer_accumulator = self.add_weight(name=\"total_cer\", initializer=\"zeros\")\n        self.counter = self.add_weight(name=\"cer_count\", initializer=\"zeros\")\n\n    def update_state(self, y_true, y_pred, sample_weight=None):\n        input_shape = K.shape(y_pred)\n        input_length = tf.ones(shape=input_shape[0]) * K.cast(input_shape[1], 'float32')\n\n        decode, log = K.ctc_decode(y_pred,\n                                    input_length,\n                                    greedy=True)\n\n        decode = K.ctc_label_dense_to_sparse(decode[0], K.cast(input_length, 'int32'))\n        y_true_sparse = K.ctc_label_dense_to_sparse(y_true, K.cast(input_length, 'int32'))\n\n        decode = tf.sparse.retain(decode, tf.not_equal(decode.values, -1))\n        distance = tf.edit_distance(decode, y_true_sparse, normalize=True)\n\n        self.cer_accumulator.assign_add(tf.reduce_sum(distance))\n        self.counter.assign_add(len(y_true))\n\n    def result(self):\n        return tf.math.divide_no_nan(self.cer_accumulator, self.counter)\n\n    def reset_states(self):\n        self.cer_accumulator.assign(0.0)\n        self.counter.assign(0.0)",
            "masked_code": "class CERMetric(tf.keras.metrics.Metric):\n    \"\"\"\n    A custom Keras metric to compute the Character Error Rate\n    \"\"\"\n    def __init__(self, name='CER_metric', **kwargs):\n        super(CERMetric, self).__init__(name=name, **kwargs)\n        self.cer_accumulator = self.add_weight(name=\"total_cer\", initializer=\"zeros\")\n        self.counter = self.add_weight(name=\"cer_count\", initializer=\"zeros\")\n\n    def update_state(self, y_true, y_pred, sample_weight=None):\n        input_shape = K.shape(y_pred)\n        input_length = tf.ones(shape=input_shape[0]) * K.cast(input_shape[1], 'float32')\n\n        decode, log = K.ctc_decode(y_pred,\n                                    input_length,\n                                    greedy=True)\n\n        decode = K.ctc_label_dense_to_sparse(decode[0], K.cast(input_length, 'int32'))\n        y_true_sparse = K.ctc_label_dense_to_sparse(y_true, K.cast(input_length, 'int32'))\n\n        <line_mask>\n        distance = tf.edit_distance(decode, y_true_sparse, normalize=True)\n\n        self.cer_accumulator.assign_add(tf.reduce_sum(distance))\n        self.counter.assign_add(len(y_true))\n\n    def result(self):\n        return tf.math.divide_no_nan(self.cer_accumulator, self.counter)\n\n    def reset_states(self):\n        self.cer_accumulator.assign(0.0)\n        self.counter.assign(0.0)",
            "masked_line": "decode = tf.sparse.retain(decode, tf.not_equal(decode.values, -1))",
            "answer": "sparse",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1055"
        },
        {
            "dependency": "networkx",
            "version": "==1.11",
            "time": "2020-06-03",
            "description": "The code generates a Fruchterman-Reingold layout for a given graph G with specific parameters, then visualizes the graph with nodes positioned according to the layout using matplotlib.",
            "code": "pos_spaced=nx.fruchterman_reingold_layout(G, k=0.5, iterations=100)\n\nplt.figure(figsize=(10,6))\nnx.draw(G,\n        pos=pos_spaced,\n        with_labels=True, \n        nodesize=1000, \n        node_color='lightgreen')",
            "masked_code": "<line_mask>\n\nplt.figure(figsize=(10,6))\nnx.draw(G,\n        pos=pos_spaced,\n        with_labels=True, \n        nodesize=1000, \n        node_color='lightgreen')",
            "masked_line": "pos_spaced=nx.fruchterman_reingold_layout(G, k=0.5, iterations=100)",
            "answer": "fruchterman_reingold_layout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1056"
        },
        {
            "dependency": "networkx",
            "version": "==1.11",
            "time": "2020-06-03",
            "description": "The code generates a graph visualization where nodes are labeled with the values in the show_labels list and positioned using the Fruchterman-Reingold layout algorithm.",
            "code": "show_labels = ['plant', 'tree', 'oak', 'eucaliptus']\n\npos_spaced=nx.fruchterman_reingold_layout(G, k=0.54, iterations=100)\n\nplt.figure(figsize=(10,6))\nnx.draw(G,\n        pos=pos_spaced,\n        with_labels=True, \n        nodesize=1000, \n        labels=dict(zip(show_labels,show_labels)),\n        node_color='lightgreen')",
            "masked_code": "show_labels = ['plant', 'tree', 'oak', 'eucaliptus']\n\n<line_mask>\n\nplt.figure(figsize=(10,6))\nnx.draw(G,\n        pos=pos_spaced,\n        with_labels=True, \n        nodesize=1000, \n        labels=dict(zip(show_labels,show_labels)),\n        node_color='lightgreen')",
            "masked_line": "pos_spaced=nx.fruchterman_reingold_layout(G, k=0.54, iterations=100)",
            "answer": "fruchterman_reingold_layout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1057"
        },
        {
            "dependency": "torch",
            "version": ">=0.4..0",
            "time": "2020-05-19",
            "description": "The code defines a function called myfunc that takes an index and a tensor as input. It then performs a multiplication operation on the tensor based on whether the index is even or odd. The function prints the index and whether the resulting tensor requires gradient computation.\n\nIn the main block of the code, a random tensor with requires_grad set to True is created. It then creates 10 threads, each calling the myfunc function with a different index and the same tensor as input.",
            "code": "import threading\n\nimport torch\n\n\ndef myfunc(i, tensor):\n    if i % 2 == 0:\n        with torch.no_grad():\n            z = tensor * 2\n    else:\n        z = tensor * 2\n    print(i, z.requires_grad)\n\n\nif __name__ == \"__main__\":\n    tensor = torch.randn(5, requires_grad=True)\n    with torch.no_grad():\n        for i in range(10):\n            t = threading.Thread(target=myfunc, args=(i, tensor))\n            t.start()",
            "masked_code": "import threading\n\nimport torch\n\n\ndef myfunc(i, tensor):\n    if i % 2 == 0:\n        with torch.no_grad():\n            z = tensor * 2\n    else:\n        z = tensor * 2\n    print(i, z.requires_grad)\n\n\nif __name__ == \"__main__\":\n    <line_mask>\n    with torch.no_grad():\n        for i in range(10):\n            t = threading.Thread(target=myfunc, args=(i, tensor))\n            t.start()",
            "masked_line": "tensor = torch.randn(5, requires_grad=True)",
            "answer": "randn",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1058"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-08-16",
            "description": "This code finds the maximum value in tensor A, identifies the elements in A that are equal to the maximum value, and returns the indices of those elements.",
            "code": "max_val = tf.reduce_max(A, keepdims=True)\ncond = tf.equal(A, max_val)\nres = tf.where(cond)\nres\n#",
            "masked_code": "<line_mask>\ncond = tf.equal(A, max_val)\nres = tf.where(cond)\nres\n#",
            "masked_line": "max_val = tf.reduce_max(A, keepdims=True)",
            "answer": "reduce_max",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1059"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24",
            "time": "2020-02-04",
            "description": "This code creates a new column in a pandas DataFrame called 'start', where each value is the previous row's value from the 'end' column, with the first row filled in with the timestamp '2020-01-01'.",
            "code": "df['start']= df['end'].shift(fill_value=pd.Timestamp('2020-01-01'))",
            "masked_code": "<line_mask>",
            "masked_line": "df['start']= df['end'].shift(fill_value=pd.Timestamp('2020-01-01'))",
            "answer": "Timestamp",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1060"
        },
        {
            "dependency": "pandas",
            "version": ">=1.1",
            "time": "2020-10-31",
            "description": "This code calculates the rolling sum of the 'daychange' column in the DataFrame 'df' for a window size of 5 when the value in the 'SS' column is equal to 100.",
            "code": "indexer = pd.api.indexers.FixedForwardWindowIndexer(window_size=5)\ndf['total'] = df.daychange.rolling(indexer, min_periods=1).sum()[df.SS == 100]\ndf",
            "masked_code": "<line_mask>\ndf['total'] = df.daychange.rolling(indexer, min_periods=1).sum()[df.SS == 100]\ndf",
            "masked_line": "indexer = pd.api.indexers.FixedForwardWindowIndexer(window_size=5)",
            "answer": "FixedForwardWindowIndexer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1061"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.0",
            "time": "2020-04-11",
            "description": "The code generates a heatmap plot by multiplying the outer product of two arrays C_1 and C_2. It also sets the x and y tick labels to be shown at intervals of 0.5.",
            "code": "g = sns.heatmap(np.multiply.outer(C_1, C_2), \n                xticklabels=True, yticklabels=True)\n_ = g.set(xticklabels = show_at_intervals(C_1, 0.5),\n          yticklabels = show_at_intervals(C_1, 0.5))",
            "masked_code": "<line_mask>\n                xticklabels=True, yticklabels=True)\n_ = g.set(xticklabels = show_at_intervals(C_1, 0.5),\n          yticklabels = show_at_intervals(C_1, 0.5))",
            "masked_line": "g = sns.heatmap(np.multiply.outer(C_1, C_2),",
            "answer": "outer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1062"
        },
        {
            "dependency": "networkx",
            "version": ">=2.4",
            "time": "2020-12-07",
            "description": "This code creates a subgraph consisting of the largest connected component in the given graph g.",
            "code": "giantC = g.subgraph(max(nx.connected_components(g), key=len))",
            "masked_code": "<line_mask>",
            "masked_line": "giantC = g.subgraph(max(nx.connected_components(g), key=len))",
            "answer": "connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1063"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.4.0",
            "time": "2021-01-05",
            "description": "The code initializes a video capture object using the cv2 library to read frames from a video file named \"vtest.avi\" using the FFMPEG backend.",
            "code": "video = cv2.VideoCapture(\"vtest.avi\", cv.CAP_FFMPEG)",
            "masked_code": "<line_mask>",
            "masked_line": "video = cv2.VideoCapture(\"vtest.avi\", cv.CAP_FFMPEG)",
            "answer": "VideoCapture",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1064"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-04-16",
            "description": "This function generates random binary matrices with unique rows selected from a range specified by input parameters. Each output row is a randomly selected unique row from the specified range. The function also shuffles the columns of each row independently.",
            "code": "def randbin(m, n, p, q):\n    # make the unique rows\n    options = np.arange(n) < np.arange(p, q + 1).reshape(-1, 1)\n    # select random unique row to go into each output row\n    selection = np.random.choice(options.shape[0], size=m, replace=True)\n    # perform the selection\n    result = options[selection]\n    # create indices to shuffle each row independently\n    col_ind = np.argsort(np.random.random(result.shape), axis=1)\n    row_ind = np.arange(m).reshape(-1, 1)\n    # perform the shuffle\n    result = result[row_ind, col_ind]\n    return result",
            "masked_code": "def randbin(m, n, p, q):\n    # make the unique rows\n    options = np.arange(n) < np.arange(p, q + 1).reshape(-1, 1)\n    # select random unique row to go into each output row\n    selection = np.random.choice(options.shape[0], size=m, replace=True)\n    # perform the selection\n    result = options[selection]\n    # create indices to shuffle each row independently\n    col_ind = np.argsort(np.random.random(result.shape), axis=1)\n    <line_mask>\n    # perform the shuffle\n    result = result[row_ind, col_ind]\n    return result",
            "masked_line": "row_ind = np.arange(m).reshape(-1, 1)",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1065"
        },
        {
            "dependency": "pygame",
            "version": "==2.0.1",
            "time": "2021-02-24",
            "description": "This code creates an OpenGL display window using the Pygame library for graphics rendering. The code does not include the \"DOUBLEBUF\" flag for the display mode.",
            "code": "pygame.display.set_mode(display, OPENGL)   # <--- Note \"DOUBLEBUF|\" was removed\n\n# [... GL drawing commands ...]",
            "masked_code": "<line_mask>\n\n# [... GL drawing commands ...]",
            "masked_line": "pygame.display.set_mode(display, OPENGL)   # <--- Note \"DOUBLEBUF|\" was removed",
            "answer": "set_mode",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1066"
        },
        {
            "dependency": "pygame",
            "version": "==2.0.1",
            "time": "2021-02-24",
            "description": "The code forces the execution of OpenGL commands and updates the display in Pygame.",
            "code": "glFlush()               # <--- Force the execution of GL commands\npygame.display.flip()   #      before pygame.display.flip()\n\n# [...  rest of the code   ...]",
            "masked_code": "glFlush()               # <--- Force the execution of GL commands\n<line_mask>\n\n# [...  rest of the code   ...]",
            "masked_line": "pygame.display.flip()   #      before pygame.display.flip()",
            "answer": "flip",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1067"
        },
        {
            "dependency": "numpy",
            "version": "==1.7",
            "time": "2020-09-24",
            "description": "The code uses the NumPy logical_not function to compute the truth value of the input array 'arr' element-wise, where the flip_mask condition is met. The results are stored in the 'arr' output array.",
            "code": "np.logical_not(arr, where=flip_mask, out=arr)",
            "masked_code": "<line_mask>",
            "masked_line": "np.logical_not(arr, where=flip_mask, out=arr)",
            "answer": "logical_not",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1068"
        },
        {
            "dependency": "praw",
            "version": ">=6.1.0",
            "time": "2020-01-19",
            "description": "The code submits an image to a specific subreddit on Reddit with a title and then adds a comment to the post.",
            "code": "my_post = reddit.subreddit(subreddit).submit_image(title, image_path)\nmy_post.reply(\"This is a comment.\")",
            "masked_code": "<line_mask>\nmy_post.reply(\"This is a comment.\")",
            "masked_line": "my_post = reddit.subreddit(subreddit).submit_image(title, image_path)",
            "answer": "subreddit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1069"
        },
        {
            "dependency": "torch",
            "version": "==1.7.1",
            "time": "2021-02-01",
            "description": "This code generates samples by first computing z based on a given hidden state using a prior distribution, then sampling z from a normal distribution, generating x based on the concatenated h and z values, and finally updating the hidden state using the output x and z concatenation.",
            "code": "def generate(self, hidden=None, temperature=None):\n        if hidden is None:\n            hidden=Variable(torch.zeros(1,64))\n        if temperature is None:\n            temperature = 0.8\n        # 1. h => z\n        z_prior = self.prior(hidden)\n        # sampling\n        z = Variable(torch.randn(z_prior.size(0),64))*z_prior[:,64:].exp()+z_prior[:,:64]\n        z = self.phi_z(z)\n        # 2. h + z => x\n        x_out = self.decoder(torch.cat([hidden, z], dim=1))\n        # sampling\n        x_sample = x = x_out.div(temperature).exp().multinomial(1).squeeze()\n        x = self.phi_x(x)\n        # 3. x + z => h\n        x = x[None, ...]   # changed here\n        xz = torch.cat([x,z], dim=1)  # changed here\n        hidden_next = self.rnn(xz,hidden) # changed here\n        return x_sample, hidden_next",
            "masked_code": "def generate(self, hidden=None, temperature=None):\n        if hidden is None:\n            hidden=Variable(torch.zeros(1,64))\n        if temperature is None:\n            temperature = 0.8\n        # 1. h => z\n        z_prior = self.prior(hidden)\n        # sampling\n        <line_mask>\n        z = self.phi_z(z)\n        # 2. h + z => x\n        x_out = self.decoder(torch.cat([hidden, z], dim=1))\n        # sampling\n        x_sample = x = x_out.div(temperature).exp().multinomial(1).squeeze()\n        x = self.phi_x(x)\n        # 3. x + z => h\n        x = x[None, ...]   # changed here\n        xz = torch.cat([x,z], dim=1)  # changed here\n        hidden_next = self.rnn(xz,hidden) # changed here\n        return x_sample, hidden_next",
            "masked_line": "z = Variable(torch.randn(z_prior.size(0),64))*z_prior[:,64:].exp()+z_prior[:,:64]",
            "answer": "randn",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1070"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.3",
            "time": "2021-03-04",
            "description": "This code reads an Excel file located at a specified path and stores the data into a pandas DataFrame. The 'Time' column in the Excel file is read as a string data type.",
            "code": "df = pd.read_excel(path_to_your_excelfile, dtype={'Time': str})",
            "masked_code": "<line_mask>",
            "masked_line": "df = pd.read_excel(path_to_your_excelfile, dtype={'Time': str})",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1071"
        },
        {
            "dependency": "pandas",
            "version": ">=2.0.0",
            "time": "2023-08-18",
            "description": "The code creates a pandas DataFrame with columns 'A' and 'B', where column 'A' contains values 1, 2, and 3, and column 'B' contains values 4, 5, and NaN. It then prints the DataFrame and displays information about it using the info() method. Finally, it converts the DataFrame to a nullable dtype using the numpy backend and prints the updated DataFrame and its information.",
            "code": "df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, None]})\n\nprint(df)\ndf.info()\n\ndf = df.convert_dtypes(dtype_backend='numpy_nullable')\nprint(df)\ndf.info()",
            "masked_code": "df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, None]})\n\nprint(df)\ndf.info()\n\n<line_mask>\nprint(df)\ndf.info()",
            "masked_line": "df = df.convert_dtypes(dtype_backend='numpy_nullable')",
            "answer": "convert_dtypes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1072"
        },
        {
            "dependency": "tensorflow",
            "version": ">=2.0",
            "time": "2021-06-13",
            "description": "This code defines a custom attention layer called RochtaschelAttention in TensorFlow/Keras. The layer calculates attention weights based on the input data and applies them to compute the output. The layer also includes trainable parameters (weights) for the attention mechanism.",
            "code": "class RochtaschelAttention(tf.keras.layers.Layer):\n\n    def __init__(self, regularize):\n        self.kernel_regularizer = regularize\n        super(RochtaschelAttention, self).__init__()\n\n    def build(self, input_shape):\n\n        self.W_y = self.add_weight(name=\"att_weight_y\", shape=(input_shape[-1], input_shape[-1]),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n        self.W_h = self.add_weight(name=\"att_weight_h\", shape=(input_shape[-1], input_shape[-1]),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n        self.W_p = self.add_weight(name=\"att_weight_p\", shape=(input_shape[-1], input_shape[-1]),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n        self.W_x = self.add_weight(name=\"att_weight_x\", shape=(input_shape[-1], input_shape[-1]),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n        self.w = self.add_weight(name=\"att_weight\", shape=(input_shape[-1], 1),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n\n        return super(RochtaschelAttention, self).build(input_shape)\n\n\n    def call(self, inputs):\n\n        y = inputs[:, :inputs.shape[1]//2, :]\n        h_n = inputs[:, -1, :]\n        first_term =  tf.einsum('ijk,kk->ijk', y, self.W_y)\n        second_term = tf.keras.layers.RepeatVector(inputs.shape[1]//2)(tf.einsum('ik,kk->ik', h_n, self.W_h))\n        M = tf.keras.activations.tanh(first_term + second_term)\n        alpha = tf.keras.activations.softmax(tf.einsum('ij,lkj->lik', tf.transpose(self.w), M))\n        r = tf.einsum('ijk,ilj->ik', y, alpha)\n        output = tf.keras.activations.tanh(tf.einsum('jj,ij->ij', self.W_p, r) + tf.einsum('jj,ij->ij', self.W_x, h_n))\n        return output\n\n    def get_config(self):\n        config = super().get_config().copy()\n        config.update({\n            'regularizer': self.kernel_regularizer \n        })\n        return config",
            "masked_code": "class RochtaschelAttention(tf.keras.layers.Layer):\n\n    def __init__(self, regularize):\n        self.kernel_regularizer = regularize\n        super(RochtaschelAttention, self).__init__()\n\n    def build(self, input_shape):\n\n        self.W_y = self.add_weight(name=\"att_weight_y\", shape=(input_shape[-1], input_shape[-1]),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n        self.W_h = self.add_weight(name=\"att_weight_h\", shape=(input_shape[-1], input_shape[-1]),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n        self.W_p = self.add_weight(name=\"att_weight_p\", shape=(input_shape[-1], input_shape[-1]),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n        self.W_x = self.add_weight(name=\"att_weight_x\", shape=(input_shape[-1], input_shape[-1]),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n        self.w = self.add_weight(name=\"att_weight\", shape=(input_shape[-1], 1),\n                           initializer=\"glorot_uniform\", regularizer=self.kernel_regularizer, trainable=True)\n\n        return super(RochtaschelAttention, self).build(input_shape)\n\n\n    def call(self, inputs):\n\n        y = inputs[:, :inputs.shape[1]//2, :]\n        h_n = inputs[:, -1, :]\n        first_term =  tf.einsum('ijk,kk->ijk', y, self.W_y)\n        <line_mask>\n        M = tf.keras.activations.tanh(first_term + second_term)\n        alpha = tf.keras.activations.softmax(tf.einsum('ij,lkj->lik', tf.transpose(self.w), M))\n        r = tf.einsum('ijk,ilj->ik', y, alpha)\n        output = tf.keras.activations.tanh(tf.einsum('jj,ij->ij', self.W_p, r) + tf.einsum('jj,ij->ij', self.W_x, h_n))\n        return output\n\n    def get_config(self):\n        config = super().get_config().copy()\n        config.update({\n            'regularizer': self.kernel_regularizer \n        })\n        return config",
            "masked_line": "second_term = tf.keras.layers.RepeatVector(inputs.shape[1]//2)(tf.einsum('ik,kk->ik', h_n, self.W_h))",
            "answer": "RepeatVector",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1073"
        },
        {
            "dependency": "tensorflow",
            "version": ">=2.0",
            "time": "2021-06-13",
            "description": "The code defines two LSTM layers with regularization, return sequences, and optional initial states. It then applies the LSTM layers to input data (premise and hypothesis) and uses an attention mechanism to combine the outputs of the LSTM layers.",
            "code": "lstm_layer_1 = tf.keras.layers.LSTM(100, \n                            kernel_regularizer=lam, \n                            recurrent_regularizer=lam, \n                            return_sequences=True,\n                            return_state=True,\n                            time_major=False)\n\nlstm_layer_2 = tf.keras.layers.LSTM(100, \n                            kernel_regularizer=lam, \n                            recurrent_regularizer=lam, \n                            return_sequences=True,\n                            time_major=False)\n\nl2 = 0.0001\nlam = tf.keras.regularizers.l2(l2=l2)\npremise, forward_h, forward_c, = lstm_layer_1(premise)\ninit_states = [forward_h, forward_c]\nhypothesis = lstm_layer_2(hypothesis, initial_state=init_states)\ntrain_input = RochtaschelAttention(regularizer=lam)(tf.keras.layers.concatenate([premise, hypothesis], axis=1))",
            "masked_code": "lstm_layer_1 = tf.keras.layers.LSTM(100, \n                            kernel_regularizer=lam, \n                            recurrent_regularizer=lam, \n                            return_sequences=True,\n                            return_state=True,\n                            time_major=False)\n\nlstm_layer_2 = tf.keras.layers.LSTM(100, \n                            kernel_regularizer=lam, \n                            recurrent_regularizer=lam, \n                            return_sequences=True,\n                            time_major=False)\n\nl2 = 0.0001\nlam = tf.keras.regularizers.l2(l2=l2)\npremise, forward_h, forward_c, = lstm_layer_1(premise)\ninit_states = [forward_h, forward_c]\n<line_mask>\ntrain_input = RochtaschelAttention(regularizer=lam)(tf.keras.layers.concatenate([premise, hypothesis], axis=1))",
            "masked_line": "hypothesis = lstm_layer_2(hypothesis, initial_state=init_states)",
            "answer": "lstm_layer_2",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1074"
        },
        {
            "dependency": "matplotlib",
            "version": "<3.7",
            "time": "2022-02-07",
            "description": "This code creates labels for a bar chart by formatting the data values in a specific way.",
            "code": "# < 3.7\nplt.bar_label(bars, labels=[f'{x:,.2f}' for x in bars.datavalues])",
            "masked_code": "# < 3.7\n<line_mask>",
            "masked_line": "plt.bar_label(bars, labels=[f'{x:,.2f}' for x in bars.datavalues])",
            "answer": "bar_label",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1075"
        },
        {
            "dependency": "pandas",
            "version": ">=1.5.1",
            "time": "2022-10-27",
            "description": "The code creates a PeriodIndex with yearly frequency for the years 2000 and 2001.",
            "code": "idx = pd.PeriodIndex(year=[2000, 2001], month=[1, 1], freq='Y')",
            "masked_code": "<line_mask>",
            "masked_line": "idx = pd.PeriodIndex(year=[2000, 2001], month=[1, 1], freq='Y')",
            "answer": "PeriodIndex",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1076"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2022-04-20",
            "description": "This function is a generator in a Generative Adversarial Network (GAN) that takes a input tensor 'z', applies two convolutional layers with leaky ReLU activation function, and then applies a dense layer to generate an output tensor 'out'. The function also creates and reuses variables within the \"GAN/Generator\" variable scope.",
            "code": "def generator(z, hsize=[1024, 1024], reuse=False):\n     with tf.variable_scope(\"GAN/Generator\", reuse=reuse):\n         h1 = tf.layers.conv2d(z, 64, [3, 3], activation=tf.nn.leaky_relu)\n         h2 = tf.layers.conv2d(h1, 64, [3, 3], activation=tf.nn.leaky_relu)\n         out = tf.layers.dense(h3, z.shape[-1])\n     return out",
            "masked_code": "def generator(z, hsize=[1024, 1024], reuse=False):\n     with tf.variable_scope(\"GAN/Generator\", reuse=reuse):\n         <line_mask>\n         h2 = tf.layers.conv2d(h1, 64, [3, 3], activation=tf.nn.leaky_relu)\n         out = tf.layers.dense(h3, z.shape[-1])\n     return out",
            "masked_line": "h1 = tf.layers.conv2d(z, 64, [3, 3], activation=tf.nn.leaky_relu)",
            "answer": "conv2d",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1077"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2022-04-20",
            "description": "This function defines a discriminator neural network in a Generative Adversarial Network (GAN) model. It takes an input tensor 'z', applies two convolutional layers with leaky ReLU activation function, reduces the dimensionality of the output tensor, and finally passes it through a dense layer to produce a single scalar output. The 'reuse' parameter controls whether the variables in the scope should be reused or not.",
            "code": "def discriminator(z, hsize=[1024, 1024], reuse=False):\n     with tf.variable_scope(\"GAN/Discriminator\", reuse=reuse):\n         h1 = tf.layers.conv2d(z, 64, [3, 3], activation=tf.nn.leaky_relu)\n         h2 = tf.layers.conv2d(h1, 64, [3, 3], activation=tf.nn.leaky_relu)\n         h3 = tf.math.reduce_mean(h2, 1)\n         h3 = tf.math.reduce_mean(h3, 1)\n         out = tf.layers.dense(h3, 1)\n     return out",
            "masked_code": "def discriminator(z, hsize=[1024, 1024], reuse=False):\n     with tf.variable_scope(\"GAN/Discriminator\", reuse=reuse):\n         h1 = tf.layers.conv2d(z, 64, [3, 3], activation=tf.nn.leaky_relu)\n         h2 = tf.layers.conv2d(h1, 64, [3, 3], activation=tf.nn.leaky_relu)\n         <line_mask>\n         h3 = tf.math.reduce_mean(h3, 1)\n         out = tf.layers.dense(h3, 1)\n     return out",
            "masked_line": "h3 = tf.math.reduce_mean(h2, 1)",
            "answer": "reduce_mean",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1078"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.1",
            "time": "2022-11-30",
            "description": "The code defines a Grouper object with the key as 'datetime' and the frequency as daily.",
            "code": "g = pd.Grouper(key='datetime', freq='D')",
            "masked_code": "<line_mask>",
            "masked_line": "g = pd.Grouper(key='datetime', freq='D')",
            "answer": "Grouper",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1079"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.0",
            "time": "2022-01-20",
            "description": "This code defines a neural network model with input layer, data scaling, data augmentation, base model, global average pooling, dropout, dense output layer, and creates a model using the specified inputs and outputs.",
            "code": "inputs = tf.keras.Input(shape=(TARGET_SIZE, TARGET_SIZE, 3))\nx0 = rescale(inputs)\nx0 = data_augmentation(x0)\nx0 = base_model(x0, training=False)\nx0 = tf.keras.layers.GlobalAveragePooling2D()(x0)\nx0 = tf.keras.layers.Dropout(DROPOUT_VAL)(x0)\noutputs = tf.keras.layers.Dense(NUM_CLASSES)(x0)\nembedding_network = tf.keras.Model(inputs, outputs)",
            "masked_code": "inputs = tf.keras.Input(shape=(TARGET_SIZE, TARGET_SIZE, 3))\nx0 = rescale(inputs)\nx0 = data_augmentation(x0)\nx0 = base_model(x0, training=False)\nx0 = tf.keras.layers.GlobalAveragePooling2D()(x0)\n<line_mask>\noutputs = tf.keras.layers.Dense(NUM_CLASSES)(x0)\nembedding_network = tf.keras.Model(inputs, outputs)",
            "masked_line": "x0 = tf.keras.layers.Dropout(DROPOUT_VAL)(x0)",
            "answer": "Dropout",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1080"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2022-10-30",
            "description": "This code defines a function called get_data, which takes a directory path and a set_option as input. If the set_option is 'train', it reads images from subfolders in the specified directory and appends them to a list called train_ds. If the set_option is 'test', it reads images from subfolders in the specified directory and appends them to a list called test_ds. Finally, it returns the train_ds list for the train set and test_ds list for the test set.",
            "code": "def get_data(dir, set_option):\n    if set_option == 'train':\n        train_ds = []\n        subfolders = sorted([file.path for file in os.scandir(dir) if file.is_dir()])\n        for folder in subfolders:\n            for file in sorted(os.listdir(folder)):\n                img = tf.keras.preprocessing.image.load_img(folder+\"/\"+file, color_mode='grayscale')\n                train_ds.append(img)\n        return train_ds\n    elif set_option == 'test':  \n        test_ds = []\n        subfolders = sorted([file.path for file in os.scandir(dir) if file.is_dir()])\n        for folder in subfolders:\n            for file in sorted(os.listdir(folder)):\n                img = tf.keras.preprocessing.image.load_img(folder+\"/\"+file, color_mode='grayscale')\n                test_ds.append(img)\n        return test_ds\n    \ntrain_ds = get_data(path_training, 'train')\ntest_ds = get_data(path_validation, 'test')",
            "masked_code": "def get_data(dir, set_option):\n    if set_option == 'train':\n        train_ds = []\n        subfolders = sorted([file.path for file in os.scandir(dir) if file.is_dir()])\n        for folder in subfolders:\n            for file in sorted(os.listdir(folder)):\n                img = tf.keras.preprocessing.image.load_img(folder+\"/\"+file, color_mode='grayscale')\n                train_ds.append(img)\n        return train_ds\n    elif set_option == 'test':  \n        test_ds = []\n        subfolders = sorted([file.path for file in os.scandir(dir) if file.is_dir()])\n        for folder in subfolders:\n            for file in sorted(os.listdir(folder)):\n                <line_mask>\n                test_ds.append(img)\n        return test_ds\n    \ntrain_ds = get_data(path_training, 'train')\ntest_ds = get_data(path_validation, 'test')",
            "masked_line": "img = tf.keras.preprocessing.image.load_img(folder+\"/\"+file, color_mode='grayscale')",
            "answer": "image",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1081"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.8.1",
            "time": "2022-07-12",
            "description": "The code initializes a global step variable by retrieving or creating a global step counter using TensorFlow's training utility.",
            "code": "global_step = tf.training_util.get_or_create_global_step()",
            "masked_code": "<line_mask>",
            "masked_line": "global_step = tf.training_util.get_or_create_global_step()",
            "answer": "get_or_create_global_step",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1082"
        },
        {
            "dependency": "pandas",
            "version": "==0.25",
            "time": "2022-03-23",
            "description": "The code groups the dataframe by the columns 'Target_sequence' and 'processed_SMILES', and calculates the minimum and maximum values of the 'Label' column within each group.",
            "code": "df.groupby(['Target_sequence','processed_SMILES']).agg(Minimum = pd.NamedAgg(column='Label',aggfunc='min'),\n                                                   Maximum = pd.NamedAgg(column='Label',aggfunc='max'))",
            "masked_code": "<line_mask>\n                                                   Maximum = pd.NamedAgg(column='Label',aggfunc='max'))",
            "masked_line": "df.groupby(['Target_sequence','processed_SMILES']).agg(Minimum = pd.NamedAgg(column='Label',aggfunc='min'),",
            "answer": "NamedAgg",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1083"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.2",
            "time": "2023-01-14",
            "description": "The code reads data from a CSV file named 'input.txt', then displays the data in a table format. It then creates a kernel density plot using seaborn library, with x-axis representing the data in the first column and y-axis representing the data in the second column, using orange color for the plot.",
            "code": "df = pd.read_csv('input.txt', sep=\"\\s\\s+\", engine='python', header=None)\nprint(df)\nsns.kdeplot(data=df, x=0, y=1, color = \"orange\")",
            "masked_code": "df = pd.read_csv('input.txt', sep=\"\\s\\s+\", engine='python', header=None)\nprint(df)\n<line_mask>",
            "masked_line": "sns.kdeplot(data=df, x=0, y=1, color = \"orange\")",
            "answer": "kdeplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1084"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.2",
            "time": "2023-01-14",
            "description": "The code reads a CSV file named 'input.txt' and creates a kernel density estimate plot using Seaborn, with the data from the CSV file, labeling it as \"s1\" and coloring it orange.",
            "code": "df = pd.read_csv('input.txt', sep=\"\\s\\s+\", engine='python',)\nsns.kdeplot(data=df, label = \"s1\", color=\"orange\")",
            "masked_code": "df = pd.read_csv('input.txt', sep=\"\\s\\s+\", engine='python',)\n<line_mask>",
            "masked_line": "sns.kdeplot(data=df, label = \"s1\", color=\"orange\")",
            "answer": "kdeplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1085"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-03-27",
            "description": "The code defines a TensorFlow variable \"v\" with value [0] of type float32, within the nested name scopes \"foo\" and \"bar\". An assertion checks if the variable name is correctly set to \"foo/bar/v:0\".",
            "code": "with tf.name_scope(\"foo\"):\n    with tf.name_scope(\"bar\"):\n        v = tf.Variable([0], dtype=tf.float32, name=\"v\")\n        assert v.name == \"foo/bar/v:0\"",
            "masked_code": "with tf.name_scope(\"foo\"):\n    with tf.name_scope(\"bar\"):\n        <line_mask>\n        assert v.name == \"foo/bar/v:0\"",
            "masked_line": "v = tf.Variable([0], dtype=tf.float32, name=\"v\")",
            "answer": "Variable",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1086"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-03-24",
            "description": "The code initializes a variable 'var' with Glorot uniform initialization for a 3x3 tensor shape.",
            "code": "shape = (3,3)\ninitializer = tf.initializers.GlorotUniform()\nvar = tf.Variable(initializer(shape=shape))",
            "masked_code": "shape = (3,3)\ninitializer = tf.initializers.GlorotUniform()\n<line_mask>",
            "masked_line": "var = tf.Variable(initializer(shape=shape))",
            "answer": "initializer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1087"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-04-22",
            "description": "This code defines a custom gradient function that squares the input and returns the gradient as a constant of 0.0. It then creates a TensorFlow graph with a variable x initialized to 5.0, calculates the square of x using the custom gradient function, and prints the gradient of the resulting value with respect to x.",
            "code": "@tf.custom_gradient\ndef custom_square(x):\n  def grad(dy):\n    return tf.constant(0.0)\n  return tf.square(x), grad\n\nwith tf.Graph().as_default() as g:\n  x = tf.Variable(5.0)\n  with tf.GradientTape() as tape:\n    s_2 = custom_square(x)\n\n  with tf.compat.v1.Session() as sess:\n    sess.run(tf.compat.v1.global_variables_initializer())            \n    print(sess.run(tape.gradient(s_2, x)))",
            "masked_code": "@tf.custom_gradient\ndef custom_square(x):\n  def grad(dy):\n    <line_mask>\n  return tf.square(x), grad\n\nwith tf.Graph().as_default() as g:\n  x = tf.Variable(5.0)\n  with tf.GradientTape() as tape:\n    s_2 = custom_square(x)\n\n  with tf.compat.v1.Session() as sess:\n    sess.run(tf.compat.v1.global_variables_initializer())            \n    print(sess.run(tape.gradient(s_2, x)))",
            "masked_line": "return tf.constant(0.0)",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1088"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-04-23",
            "description": "This code clips the values of the variable \"image\" to be within the range of 0 and 1.",
            "code": "image = tf.clip_by_value(image, clip_value_min=0., clip_value_max=1.)",
            "masked_code": "<line_mask>",
            "masked_line": "image = tf.clip_by_value(image, clip_value_min=0., clip_value_max=1.)",
            "answer": "clip_by_value",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1089"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-03-31",
            "description": "The code defines a function that takes an input x, processes it through convolutional layers, flattens it, applies dense layers, and returns the final processed output. Additionally, it includes functions for testing and validation during training.",
            "code": "def call(self, x):\n    x = self.conv1(x)\n    x = self.flatten(x)\n    self.intermediate=x #assign it as an object attribute for accessing later\n    x = self.d1(x)\nreturn self.d2(x)\n\n#Remove @tf.function decorator from test_step for prediction\ndef test_step(images, labels):\n    predictions = model(images, training=False)\n    t_loss = loss_object(labels, predictions)\n    test_loss(t_loss)\n    test_accuracy(labels, predictions)\n    return\n\n#Create a decorated val_step for object's internal use during training\n@tf.function\ndef val_step(images, labels):\n    return test_step(images, labels)",
            "masked_code": "def call(self, x):\n    x = self.conv1(x)\n    x = self.flatten(x)\n    self.intermediate=x #assign it as an object attribute for accessing later\n    x = self.d1(x)\nreturn self.d2(x)\n\n#Remove @tf.function decorator from test_step for prediction\ndef test_step(images, labels):\n    predictions = model(images, training=False)\n    t_loss = loss_object(labels, predictions)\n    test_loss(t_loss)\n    test_accuracy(labels, predictions)\n    return\n\n#Create a decorated val_step for object's internal use during training\n<line_mask>\ndef val_step(images, labels):\n    return test_step(images, labels)",
            "masked_line": "@tf.function",
            "answer": "function",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1090"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-04-09",
            "description": "The code creates a DataFrame with a column named 'Created' containing a single datetime string. It then converts this datetime string to a datetime object, localizes it to the 'Europe/London' timezone, handles nonexistent timestamps by shifting them forward, and finally converts the timestamp to the 'Europe/Paris' timezone.",
            "code": "df = pd.DataFrame()\ndf['Created'] = [\"2019-03-31 01:50:24.455000\"]\ndf[\"Created\"] = pd.to_datetime(df[\"Created\"],errors='coerce').dt.tz_localize('Europe/London', nonexistent='shift_forward').dt.tz_convert('Europe/Paris')",
            "masked_code": "df = pd.DataFrame()\ndf['Created'] = [\"2019-03-31 01:50:24.455000\"]\n<line_mask>",
            "masked_line": "df[\"Created\"] = pd.to_datetime(df[\"Created\"],errors='coerce').dt.tz_localize('Europe/London', nonexistent='shift_forward').dt.tz_convert('Europe/Paris')",
            "answer": "tz_localize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1091"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-03-13",
            "description": "This code defines functions for performing dropout, layer normalization, and a combination of layer normalization followed by dropout on a given input tensor.",
            "code": "def dropout(input_tensor, dropout_prob):\n    \"\"\"Perform dropout.\n\n    Args:\n      input_tensor: float Tensor.\n      dropout_prob: Python float. The probability of dropping out a value (NOT of\n        *keeping* a dimension as in `tf.nn.dropout`).\n\n    Returns:\n      A version of `input_tensor` with dropout applied.\n    \"\"\"\n    if dropout_prob is None or dropout_prob == 0.0:\n        return input_tensor\n\n    output = tf.nn.dropout(input_tensor, dropout_prob) # tf 2.10\n    return output\n\n\ndef layer_norm(input_tensor, name=None):\n    \"\"\"Run layer normalization on the last dimension of the tensor.\"\"\"\n    input_layer_norm = tf.keras.layers.LayerNormalization(\n        axis=-1, name=name, epsilon=1e-12, dtype=tf.float32)\n    return input_layer_norm(input_tensor)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n    \"\"\"Runs layer normalization followed by dropout.\"\"\"\n    output_tensor = layer_norm(input_tensor, name)\n    # output_tensor = tf.keras.layers.Dropout(rate=dropout_prob)(output_tensor)\n    output_tensor = dropout(output_tensor, dropout_prob)\n    return output_tensor",
            "masked_code": "def dropout(input_tensor, dropout_prob):\n    \"\"\"Perform dropout.\n\n    Args:\n      input_tensor: float Tensor.\n      dropout_prob: Python float. The probability of dropping out a value (NOT of\n        *keeping* a dimension as in `tf.nn.dropout`).\n\n    Returns:\n      A version of `input_tensor` with dropout applied.\n    \"\"\"\n    if dropout_prob is None or dropout_prob == 0.0:\n        return input_tensor\n\n    output = tf.nn.dropout(input_tensor, dropout_prob) # tf 2.10\n    return output\n\n\ndef layer_norm(input_tensor, name=None):\n    \"\"\"Run layer normalization on the last dimension of the tensor.\"\"\"\n    <line_mask>\n        axis=-1, name=name, epsilon=1e-12, dtype=tf.float32)\n    return input_layer_norm(input_tensor)\n\n\ndef layer_norm_and_dropout(input_tensor, dropout_prob, name=None):\n    \"\"\"Runs layer normalization followed by dropout.\"\"\"\n    output_tensor = layer_norm(input_tensor, name)\n    # output_tensor = tf.keras.layers.Dropout(rate=dropout_prob)(output_tensor)\n    output_tensor = dropout(output_tensor, dropout_prob)\n    return output_tensor",
            "masked_line": "input_layer_norm = tf.keras.layers.LayerNormalization(",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1092"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-07-17",
            "description": "This code calculates the gradient of a multi-layer perceptron (MLP) model with respect to the loss function, updates the weights of the model using the Adam optimizer, and trains the model for a specified number of epochs by iterating over batches of data.",
            "code": "def grad(x, y):\n  with tf.GradientTape() as tape:\n    y_pred = mlp(x)\n    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=tf.cast(y, dtype=tf.int32), logits=y_pred)\n    loss = tf.reduce_mean(loss)\n    return loss, tape.gradient(loss, [f1, b1, f2, b2, out, b_out])\n\noptimizer = tf.keras.optimizers.Adam(lr_rate)\n\nfor epoch in range(epochs):\n  no_steps = n_shape//batch_size\n  for (batch_xs, batch_ys) in data_gen.take(no_steps):\n    cost, grads = grad(batch_xs, batch_ys)\n    optimizer.apply_gradients(zip(grads, [f1, b1, f2, b2, out, b_out]))\n  print('epoch: {} loss: {}'.format(epoch, cost))",
            "masked_code": "def grad(x, y):\n  with tf.GradientTape() as tape:\n    y_pred = mlp(x)\n    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=tf.cast(y, dtype=tf.int32), logits=y_pred)\n    loss = tf.reduce_mean(loss)\n    return loss, tape.gradient(loss, [f1, b1, f2, b2, out, b_out])\n\noptimizer = tf.keras.optimizers.Adam(lr_rate)\n\nfor epoch in range(epochs):\n  no_steps = n_shape//batch_size\n  for (batch_xs, batch_ys) in data_gen.take(no_steps):\n    cost, grads = grad(batch_xs, batch_ys)\n    <line_mask>\n  print('epoch: {} loss: {}'.format(epoch, cost))",
            "masked_line": "optimizer.apply_gradients(zip(grads, [f1, b1, f2, b2, out, b_out]))",
            "answer": "apply_gradients",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1093"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-07-09",
            "description": "The code replaces missing values in a pandas Series with None.",
            "code": "def replaceMissing(ser):\n    return ser.replace({pd.NaT: None}).where(pd.notna(ser), None)\n\nprint(pd.__version__)\nprint(80*\"-\")\nprint(replaceMissing(dates))\nprint(80*\"-\")\nprint(replaceMissing(dates).apply(type))\nprint(80*\"-\")\nprint(replaceMissing(floats1))\nprint(80*\"-\")\nprint(replaceMissing(floats1).apply(type))\nprint(80*\"-\")\nprint(replaceMissing(floats2))",
            "masked_code": "def replaceMissing(ser):\n    <line_mask>\n\nprint(pd.__version__)\nprint(80*\"-\")\nprint(replaceMissing(dates))\nprint(80*\"-\")\nprint(replaceMissing(dates).apply(type))\nprint(80*\"-\")\nprint(replaceMissing(floats1))\nprint(80*\"-\")\nprint(replaceMissing(floats1).apply(type))\nprint(80*\"-\")\nprint(replaceMissing(floats2))",
            "masked_line": "return ser.replace({pd.NaT: None}).where(pd.notna(ser), None)",
            "answer": "notna",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1094"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.4.0",
            "time": "2020-10-14",
            "description": "The code finds and retrieves contours from a binary image using the RETR_LIST retrieval mode and CHAIN_APPROX_SIMPLE approximation method.",
            "code": "contours = cv2.findContours(binary, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\ncontours = contours[0] if len(contours) == 2 else contours[1]",
            "masked_code": "<line_mask>\ncontours = contours[0] if len(contours) == 2 else contours[1]",
            "masked_line": "contours = cv2.findContours(binary, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)",
            "answer": "findContours",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1095"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-03-10",
            "description": "The code compiles a neural network model using the Adam optimizer, binary crossentropy loss function, and evaluates the model using accuracy, precision, and recall metrics.",
            "code": "model.compile(optimizer='adam',\n              loss='binary_crossentropy',\n              metrics=['accuracy',tf.keras.metrics.Precision(),tf.keras.metrics.Recall()])",
            "masked_code": "model.compile(optimizer='adam',\n              loss='binary_crossentropy',\n              <line_mask>",
            "masked_line": "metrics=['accuracy',tf.keras.metrics.Precision(),tf.keras.metrics.Recall()])",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1096"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-06-16",
            "description": "The code disables eager execution in TensorFlow v1.",
            "code": "tf.compat.v1.disable_eager_execution()",
            "masked_code": "<line_mask>",
            "masked_line": "tf.compat.v1.disable_eager_execution()",
            "answer": "v1",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1097"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.13.2",
            "time": "2020-05-06",
            "description": "The code defines a neural network model with a single dense layer and a binary cross-entropy loss function for binary classification. The model is compiled with the RMSprop optimizer, the binary cross-entropy loss function, and the accuracy metric.",
            "code": "self.fc3 = Dense(1) #, activation='sigmoid'\n\nloss = tf.keras.losses.BinaryCrossentropy(from_logits=True)\nmodel.compile(optimizer='rmsprop',\n                  loss=loss, #'binary_crossentropy'\n                  metrics=['accuracy'])",
            "masked_code": "self.fc3 = Dense(1) #, activation='sigmoid'\n\n<line_mask>\nmodel.compile(optimizer='rmsprop',\n                  loss=loss, #'binary_crossentropy'\n                  metrics=['accuracy'])",
            "masked_line": "loss = tf.keras.losses.BinaryCrossentropy(from_logits=True)",
            "answer": "losses",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1098"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-01-15",
            "description": "The code converts a frozen graph into a quantized TFLite model and saves it as a .tflite file named \"uno_mobilenetV2.tflite\".",
            "code": "converter = tf.compat.v1.lite.TFLiteConverter.from_frozen_graph(\"/content/tflite_graph.pb\",input_shapes = {'normalized_input_image_tensor':[1,300,300,3]},\n    input_arrays = ['normalized_input_image_tensor'],output_arrays = ['TFLite_Detection_PostProcess','TFLite_Detection_PostProcess:1',\n    'TFLite_Detection_PostProcess:2','TFLite_Detection_PostProcess:3'])\n\nconverter.allow_custom_ops=True\n\n# Convert the model to quantized TFLite model.\nconverter.optimizations =  [tf.lite.Optimize.DEFAULT]\ntflite_model = converter.convert()\n\n\n# Write a model using the following line\nopen(\"/content/uno_mobilenetV2.tflite\", \"wb\").write(tflite_model)",
            "masked_code": "<line_mask>\n    input_arrays = ['normalized_input_image_tensor'],output_arrays = ['TFLite_Detection_PostProcess','TFLite_Detection_PostProcess:1',\n    'TFLite_Detection_PostProcess:2','TFLite_Detection_PostProcess:3'])\n\nconverter.allow_custom_ops=True\n\n# Convert the model to quantized TFLite model.\nconverter.optimizations =  [tf.lite.Optimize.DEFAULT]\ntflite_model = converter.convert()\n\n\n# Write a model using the following line\nopen(\"/content/uno_mobilenetV2.tflite\", \"wb\").write(tflite_model)",
            "masked_line": "converter = tf.compat.v1.lite.TFLiteConverter.from_frozen_graph(\"/content/tflite_graph.pb\",input_shapes = {'normalized_input_image_tensor':[1,300,300,3]},",
            "answer": "v1",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1099"
        },
        {
            "dependency": "abjad",
            "version": "==3.2",
            "time": "2021-03-12",
            "description": "The code creates a musical staff with notes, attaches a BPM (beats per minute) to the staff, creates a LilyPond file object, adds a title to the LilyPond file, and saves the file as a PDF at a custom location.",
            "code": "staff = abjad.Staff(abjad_notes)\n\n# attach BPM to notes file\nmetronome_mark = abjad.MetronomeMark((1, 4), bpm)\nabjad.attach(metronome_mark, staff[0])\n\n# creates lilypond file object\nlilypond_file = abjad.LilyPondFile.new(staff)\n\n# notes title\nlilypond_file.header_block.title = abjad.Markup(title)\n\n# save pdf file at a custom location\nabjad.persist.as_pdf(lilypond_file, '/path/to/file.pdf')",
            "masked_code": "staff = abjad.Staff(abjad_notes)\n\n# attach BPM to notes file\nmetronome_mark = abjad.MetronomeMark((1, 4), bpm)\nabjad.attach(metronome_mark, staff[0])\n\n# creates lilypond file object\nlilypond_file = abjad.LilyPondFile.new(staff)\n\n# notes title\nlilypond_file.header_block.title = abjad.Markup(title)\n\n# save pdf file at a custom location\n<line_mask>",
            "masked_line": "abjad.persist.as_pdf(lilypond_file, '/path/to/file.pdf')",
            "answer": "as_pdf",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1100"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2021-09-14",
            "description": "The code creates a model that takes an input tensor of shape (32,) and computes the square of each element in the input tensor.",
            "code": "x = Input(shape=(32,))\ny = tf.square(x)  # This op will be treated like a layer\nmodel = Model(x, y)",
            "masked_code": "x = Input(shape=(32,))\n<line_mask>\nmodel = Model(x, y)",
            "masked_line": "y = tf.square(x)  # This op will be treated like a layer",
            "answer": "square",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1101"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2022-06-16",
            "description": "This code initializes the weights of a neural network using the Glorot normal initialization method.",
            "code": "tf.keras.initializers.GlorotNormal(\n    seed=None\n)",
            "masked_code": "<line_mask>\n    seed=None\n)",
            "masked_line": "tf.keras.initializers.GlorotNormal(",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1102"
        },
        {
            "dependency": "PyJWT",
            "version": "<2.0",
            "time": "2019-12-20",
            "description": "The code decodes a token using JSON Web Token library, with verification disabled, and works in PyJWT versions before v2.0.",
            "code": "decoded = jwt.decode(token, verify=False)  # works in PyJWT < v2.0",
            "masked_code": "<line_mask>",
            "masked_line": "decoded = jwt.decode(token, verify=False)  # works in PyJWT < v2.0",
            "answer": "decode",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1103"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-02",
            "description": "The code assigns values to columns 'HS_FIRST_NAME', 'HS_LAST_NAME', and 'HS_SSN' in DataFrame df1 based on the condition of the variable devprod. If devprod is 'prod', it assigns values directly from columns 4, 6, and 8 of DataFrame df. If devprod is not 'prod', it shuffles the values in columns 4, 6, and 8 of DataFrame df using np.random.permutation and assigns them to corresponding columns in DataFrame df1.",
            "code": "if devprod == 'prod':\n    #do not shuffle data\n    df1['HS_FIRST_NAME'] = df[4]\n    df1['HS_LAST_NAME'] = df[6]\n    df1['HS_SSN'] = df[8]\nelse:\n    df1['HS_FIRST_NAME'] = np.random.permutation(df[4].values)\n    df1['HS_LAST_NAME'] = np.random.permutation(df[6].values)\n    df1['HS_SSN'] = np.random.permutation(df[8].values)",
            "masked_code": "if devprod == 'prod':\n    #do not shuffle data\n    df1['HS_FIRST_NAME'] = df[4]\n    df1['HS_LAST_NAME'] = df[6]\n    df1['HS_SSN'] = df[8]\nelse:\n    df1['HS_FIRST_NAME'] = np.random.permutation(df[4].values)\n    df1['HS_LAST_NAME'] = np.random.permutation(df[6].values)\n    <line_mask>",
            "masked_line": "df1['HS_SSN'] = np.random.permutation(df[8].values)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1104"
        },
        {
            "dependency": "pytest",
            "version": "==3.10.0",
            "time": "2019-10-21",
            "description": "This code defines a pytest hook that runs before each test execution, where it catches different types of exceptions including xfail, skip, exit, ValueError, fail and general exceptions, and handles them accordingly by either raising them or turning them into a skip with a specified message.",
            "code": "import pytest\n\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item):\n    outcome = yield\n    try:\n        outcome.get_result()\n    except (pytest.xfail.Exception, pytest.skip.Exception, pytest.exit.Exception):\n        raise  # already xfailed,  skipped or explicit exit\n    except ValueError:\n        raise  # not ignoring\n    except (pytest.fail.Exception, Exception):\n        # turn everything else into a skip\n        pytest.skip(\"[NOTRUN] ignoring everything but ValueError\")",
            "masked_code": "import pytest\n\n<line_mask>\ndef pytest_runtest_call(item):\n    outcome = yield\n    try:\n        outcome.get_result()\n    except (pytest.xfail.Exception, pytest.skip.Exception, pytest.exit.Exception):\n        raise  # already xfailed,  skipped or explicit exit\n    except ValueError:\n        raise  # not ignoring\n    except (pytest.fail.Exception, Exception):\n        # turn everything else into a skip\n        pytest.skip(\"[NOTRUN] ignoring everything but ValueError\")",
            "masked_line": "@pytest.hookimpl(hookwrapper=True)",
            "answer": "hookimpl",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1105"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-11-21",
            "description": "This code sorts a list of sets based on the first element of each set and then returns a list of unique elements from the sorted list.",
            "code": "np.unique(sorted(sets, key=lambda x: next(iter(x))))",
            "masked_code": "<line_mask>",
            "masked_line": "np.unique(sorted(sets, key=lambda x: next(iter(x))))",
            "answer": "unique",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1106"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.0",
            "time": "2019-01-27",
            "description": "The code takes a DataFrame and applies a natural logarithm base 10 function to all numeric columns in the DataFrame, leaving non-numeric columns unchanged.",
            "code": "numeric_df = df.apply(lambda x: np.log10(x) if np.issubdtype(x.dtype, np.number) else x)",
            "masked_code": "<line_mask>",
            "masked_line": "numeric_df = df.apply(lambda x: np.log10(x) if np.issubdtype(x.dtype, np.number) else x)",
            "answer": "log10",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1107"
        },
        {
            "dependency": "requests",
            "version": "==2.4.2",
            "time": "2019-08-13",
            "description": "The code sends a POST request to the specified URL with the JSON data {'some': 'data'}.",
            "code": "r = requests.post(url, json={'some': 'data'})",
            "masked_code": "<line_mask>",
            "masked_line": "r = requests.post(url, json={'some': 'data'})",
            "answer": "post",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1108"
        },
        {
            "dependency": "pandas",
            "version": "==0.25",
            "time": "2019-08-16",
            "description": "The code is assigning hourly time intervals between 'date_start' and 'date_end' for each row in the dataframe, then expanding the dataframe to have one row per hour, and finally renaming the 'hour' column to 'date_start' for each row.",
            "code": "df['hour'] = df.apply(lambda row: pd.date_range(row.name, row['date_end'], freq='H'), axis=1)\ndf = df.explode('hour').reset_index() \\\n        .drop(columns=['date_start', 'date_end']) \\\n        .rename(columns={'hour': 'date_start'}) \\\n        .set_index('date_start')",
            "masked_code": "<line_mask>\ndf = df.explode('hour').reset_index() \\\n        .drop(columns=['date_start', 'date_end']) \\\n        .rename(columns={'hour': 'date_start'}) \\\n        .set_index('date_start')",
            "masked_line": "df['hour'] = df.apply(lambda row: pd.date_range(row.name, row['date_end'], freq='H'), axis=1)",
            "answer": "date_range",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1109"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24",
            "time": "2019-04-13",
            "description": "This code converts the 'Value' column of a DataFrame into a NumPy array.",
            "code": "# pd.DataFrame(df['Value'].tolist()).values   #  < v0.24\npd.DataFrame(df['Value'].tolist()).to_numpy() #  v0.24+\n\narray([[ 1.,  2., nan],\n       [ 3., nan, nan],\n       [ 4.,  5.,  6.]])",
            "masked_code": "# pd.DataFrame(df['Value'].tolist()).values   #  < v0.24\n<line_mask>\n\narray([[ 1.,  2., nan],\n       [ 3., nan, nan],\n       [ 4.,  5.,  6.]])",
            "masked_line": "pd.DataFrame(df['Value'].tolist()).to_numpy() #  v0.24+",
            "answer": "to_numpy",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1110"
        },
        {
            "dependency": "pandas",
            "version": "==0.25",
            "time": "2019-08-27",
            "description": "Generate a list of days with events, mark those days with at least one event as 1 and fill in the missing days with 0 to cover every day of the year.",
            "code": "# Generate the list of days that has an event\ns = df.apply(lambda row: pd.date_range(row['Date'], periods=row['Duration']), axis=1) \\\n        .explode() \\\n        .drop_duplicates()\n\n# First line: we know those days have at least one event so mark them with 1\n# Second line: expand it to cover every day of the year and fill the missing days with 0\nresult = pd.DataFrame({'Event': 1}, index=s) \\\n            .reindex(pd.date_range('2010-01-01', '2010-12-31'), fill_value=0)",
            "masked_code": "# Generate the list of days that has an event\ns = df.apply(lambda row: pd.date_range(row['Date'], periods=row['Duration']), axis=1) \\\n        .explode() \\\n        .drop_duplicates()\n\n# First line: we know those days have at least one event so mark them with 1\n# Second line: expand it to cover every day of the year and fill the missing days with 0\n<line_mask>\n            .reindex(pd.date_range('2010-01-01', '2010-12-31'), fill_value=0)",
            "masked_line": "result = pd.DataFrame({'Event': 1}, index=s) \\",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1111"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-10-11",
            "description": "This code generates a Vandermonde matrix of size 6 using the input array s.",
            "code": "np.vander(s, 6)",
            "masked_code": "<line_mask>",
            "masked_line": "np.vander(s, 6)",
            "answer": "vander",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1112"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-02-28",
            "description": "The main function defines a command line interface with a default command that prints \"Does A\" if no subcommand is invoked. The default_cmd_with_args function defines a subcommand that takes arguments and prints \"Does B: \" followed by the supplied arguments.",
            "code": "@click.group(cls=DefaultCommandGroup, invoke_without_command=True)\n@click.pass_context\ndef main(ctx):\n    if not ctx.invoked_subcommand:\n        click.echo(\"Does A\")\n\n@main.command(default_command=True)\n@click.argument('args', nargs=-1)\ndef default_cmd_with_args(args):\n    click.echo(\"Does B: {}\".format(args))",
            "masked_code": "@click.group(cls=DefaultCommandGroup, invoke_without_command=True)\n<line_mask>\ndef main(ctx):\n    if not ctx.invoked_subcommand:\n        click.echo(\"Does A\")\n\n@main.command(default_command=True)\n@click.argument('args', nargs=-1)\ndef default_cmd_with_args(args):\n    click.echo(\"Does B: {}\".format(args))",
            "masked_line": "@click.pass_context",
            "answer": "pass_context",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1113"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-26",
            "description": "The code calculates the average of points based on their labels. It first sorts the points by the label indices, then calculates the cumulative sum of points for each label, and finally computes the average value for each label.",
            "code": "sidx = labels.argsort()\nsorted_points = points[sidx]\nsums = np.add.reduceat(sorted_points,np.r_[0,np.bincount(labels)[:-1].cumsum()])\nout = sums/np.bincount(labels).astype(float)[:,None]",
            "masked_code": "sidx = labels.argsort()\nsorted_points = points[sidx]\n<line_mask>\nout = sums/np.bincount(labels).astype(float)[:,None]",
            "masked_line": "sums = np.add.reduceat(sorted_points,np.r_[0,np.bincount(labels)[:-1].cumsum()])",
            "answer": "reduceat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1114"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-09",
            "description": "The code calculates the cumulative sum of the elements in the array 'a'.",
            "code": "a=np.array([3,5,7])\n\nIn [1]: np.cumsum(a)\nOut[1]: array([ 3,  8, 15], dtype=int32)",
            "masked_code": "<line_mask>\n\nIn [1]: np.cumsum(a)\nOut[1]: array([ 3,  8, 15], dtype=int32)",
            "masked_line": "a=np.array([3,5,7])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1115"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-29",
            "description": "This code creates a new column called 'adult_indicator' in the dataframe 'df'. The values in the 'adult_indicator' column are determined based on the condition that if the value in the 'age' column is greater than or equal to 18, the corresponding value in the 'adult_indicator' column is set to 1, otherwise it is set to 0.",
            "code": "df['adult_indicator'] = np.where(df.age >= 18, 1, 0)",
            "masked_code": "<line_mask>",
            "masked_line": "df['adult_indicator'] = np.where(df.age >= 18, 1, 0)",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1116"
        },
        {
            "dependency": "tweepy",
            "version": "==3.5.0",
            "time": "2019-01-30",
            "description": "The code retrieves the last tweet ID from a list called previous_tweets, or sets it to None if the list is empty. It then iterates over a list of Twitter handles, retrieves the latest tweets for each handle since the last tweet ID, and persists the IDs of the latest tweets in memory.",
            "code": "try:\n    since_id = previous_tweets[-1]\nexcept IndexError:\n    since_id = None\n\nfor handle in handles:\n    last_tweet = None\n    for status in tweepy.Cursor(\n      api.user_timeline, screen_name=handle, \n      tweet_mode=\"extended\", since_id=since_id\n    ).items():\n     # ... persist tweets to flat file or database  \n     last_tweet_id = status.id\n\n    # this persists the last_tweet_id in memory.\n    # you may find that persisting this to a database a better way to go.\n    previous_tweets.append(last_tweet_id)",
            "masked_code": "try:\n    since_id = previous_tweets[-1]\nexcept IndexError:\n    since_id = None\n\nfor handle in handles:\n    last_tweet = None\n    <line_mask>\n      api.user_timeline, screen_name=handle, \n      tweet_mode=\"extended\", since_id=since_id\n    ).items():\n     # ... persist tweets to flat file or database  \n     last_tweet_id = status.id\n\n    # this persists the last_tweet_id in memory.\n    # you may find that persisting this to a database a better way to go.\n    previous_tweets.append(last_tweet_id)",
            "masked_line": "for status in tweepy.Cursor(",
            "answer": "Cursor",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1117"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-16",
            "description": "The code compares each element in the input matrix \"mat\" with the corresponding element in matrix \"mat2\". If all elements in a row are the same, it replaces that row in \"mat2\" with [0, 0].",
            "code": "np.where((mat == mat2).all(axis=2,  keepdims=True), [0,0], mat2)\n\narray([[[0, 1],\n        [0, 0],\n        [0, 0]],\n\n       [[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[0, 0],\n        [2, 2],\n        [0, 0]]])",
            "masked_code": "<line_mask>\n\narray([[[0, 1],\n        [0, 0],\n        [0, 0]],\n\n       [[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[0, 0],\n        [2, 2],\n        [0, 0]]])",
            "masked_line": "np.where((mat == mat2).all(axis=2,  keepdims=True), [0,0], mat2)",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1118"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.3",
            "time": "2019-12-01",
            "description": "The code creates a new IntervalIndex based on the 'START DATE' and 'END DATE' columns in the dataframe 'df'. It then calculates the number of overlapping intervals for each interval in the Index and adds the result as a new column 'Num of Colleagues' in the dataframe. Finally, it prints the updated dataframe.",
            "code": "df.index = pd.IntervalIndex.from_arrays(df['START DATE'], df['END DATE'])\n\ndf['Num of Colleagues'] = [sum(df.index.overlaps(i))-1 for i in df.index]\nprint(df)",
            "masked_code": "<line_mask>\n\ndf['Num of Colleagues'] = [sum(df.index.overlaps(i))-1 for i in df.index]\nprint(df)",
            "masked_line": "df.index = pd.IntervalIndex.from_arrays(df['START DATE'], df['END DATE'])",
            "answer": "IntervalIndex",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1119"
        },
        {
            "dependency": "discord.py",
            "version": "==1.0",
            "time": "2019-11-18",
            "description": "The function `redeemkey` checks if the `key` passed as a parameter is in the list of keys. If the key is found, it fetches the `authenticated` role from the server, and assigns it to the author of the command in the discord server.",
            "code": "@client.command()\nasync def redeemkey(ctx, key):\n    if key in keys:\n        role = discord.utils.get(ctx.guild.roles, name='authenticated')\n        await client.add_roles(ctx.author, role)",
            "masked_code": "@client.command()\nasync def redeemkey(ctx, key):\n    if key in keys:\n        <line_mask>\n        await client.add_roles(ctx.author, role)",
            "masked_line": "role = discord.utils.get(ctx.guild.roles, name='authenticated')",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1120"
        },
        {
            "dependency": "numpy",
            "version": ">=1.17.0",
            "time": "2019-10-29",
            "description": "Calculate the sum of elements in the array dat_ara based on the mask values along the last axis, and then divide the result by the value of breaks.",
            "code": "out_ara = np.sum(dat_ara, where=mask, axis=-1) / breaks",
            "masked_code": "<line_mask>",
            "masked_line": "out_ara = np.sum(dat_ara, where=mask, axis=-1) / breaks",
            "answer": "sum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1121"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2019-10-12",
            "description": "This code calculates the average of the first and last element in each file in the specified directory, and writes the results to a file named \"average.txt\".",
            "code": "import numpy as np\nimport os\ndata_path = os.path.abspath(\"/media/linux/DATADISK\")\n\nwith open(\"average.txt\", \"a\") as output:\n    for f in os.listdir(data_path):\n        f_path = os.path.join(data_path, f)\n        data = np.loadtxt(f_path, delimiter=' ', usecols=0)\n        average = (data[0] + data[-1]) / 2\n        output.write(str(average) + \"\\n\")",
            "masked_code": "import numpy as np\nimport os\ndata_path = os.path.abspath(\"/media/linux/DATADISK\")\n\nwith open(\"average.txt\", \"a\") as output:\n    for f in os.listdir(data_path):\n        f_path = os.path.join(data_path, f)\n        <line_mask>\n        average = (data[0] + data[-1]) / 2\n        output.write(str(average) + \"\\n\")",
            "masked_line": "data = np.loadtxt(f_path, delimiter=' ', usecols=0)",
            "answer": "loadtxt",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1122"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-11-06",
            "description": "The code tests whether the TensorFlow 2.0 implementation of bilinear interpolation for image resizing aligns with the pixel-area-based approach used in OpenCV. The function resizes an input array with equivalent column indices to produce an expected output array with specific values at each position. The test asserts that the TensorFlow output matches the expected output within a specified tolerance level.",
            "code": "def test_tf2_resample_upsample_matches_opencv_methodology():\n    \"\"\"\n    According to the article below, the Tensorflow 1.x implementation of bilinear interpolation for resizing images did\n    not reproduce the pixel-area-based approach adopted by OpenCV. The `align_corners` option was set to False by\n    default due to some questionable legacy reasons but users were advised to set it to True in order to get a\n    'reasonable' output: https://jricheimer.github.io/tensorflow/2019/02/11/resize-confusion/\n    This appears to have been fixed in TF 2.0 and this test confirms that we get the results one would expect from a\n    pixel-area-based technique.\n\n    We start with an input array whose values are equivalent to their column indices:\n    input_arr = np.array([\n        [[0], [1], [2], [3], [4], [5]],\n        [[0], [1], [2], [3], [4], [5]],\n    ])\n\n    And then resize this (holding the rows dimension constant in size, but increasing the column dimnesion to 12) to\n    reproduce the OpenCV example from the article. We expect this to produce the following output:\n    expected_output = np.array([\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n    ])\n\n    \"\"\"\n    input_tensor = tf.convert_to_tensor(\n        np.array([\n            [[0], [1], [2], [3], [4], [5]],\n            [[0], [1], [2], [3], [4], [5]],\n        ]),\n        dtype=tf.float32,\n    )\n    output_arr = tf.image.resize(\n        images=input_tensor,\n        size=(2,12),\n        method=tf.image.ResizeMethod.BILINEAR).numpy()\n    expected_output = np.array([\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n    ])\n    np.testing.assert_almost_equal(output_arr, expected_output, decimal=2)",
            "masked_code": "def test_tf2_resample_upsample_matches_opencv_methodology():\n    \"\"\"\n    According to the article below, the Tensorflow 1.x implementation of bilinear interpolation for resizing images did\n    not reproduce the pixel-area-based approach adopted by OpenCV. The `align_corners` option was set to False by\n    default due to some questionable legacy reasons but users were advised to set it to True in order to get a\n    'reasonable' output: https://jricheimer.github.io/tensorflow/2019/02/11/resize-confusion/\n    This appears to have been fixed in TF 2.0 and this test confirms that we get the results one would expect from a\n    pixel-area-based technique.\n\n    We start with an input array whose values are equivalent to their column indices:\n    input_arr = np.array([\n        [[0], [1], [2], [3], [4], [5]],\n        [[0], [1], [2], [3], [4], [5]],\n    ])\n\n    And then resize this (holding the rows dimension constant in size, but increasing the column dimnesion to 12) to\n    reproduce the OpenCV example from the article. We expect this to produce the following output:\n    expected_output = np.array([\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n    ])\n\n    \"\"\"\n    input_tensor = tf.convert_to_tensor(\n        np.array([\n            [[0], [1], [2], [3], [4], [5]],\n            [[0], [1], [2], [3], [4], [5]],\n        ]),\n        dtype=tf.float32,\n    )\n    <line_mask>\n        images=input_tensor,\n        size=(2,12),\n        method=tf.image.ResizeMethod.BILINEAR).numpy()\n    expected_output = np.array([\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n    ])\n    np.testing.assert_almost_equal(output_arr, expected_output, decimal=2)",
            "masked_line": "output_arr = tf.image.resize(",
            "answer": "image",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1123"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-14",
            "description": "This code checks if there is at least one True value in each column of the \"all_masks\" numpy array.",
            "code": "all_masks = np.array([[False, False, False, False, False, False],\n                      [False, False, False, False, False, False],\n                      [False, False, False, False, False, False],\n                      [False,  True, False, False,  True, False],\n                      [False, False, False, False, False, False],\n                      [False,  True, False, False,  True, False]])\n\nall_masks.any(axis=0)",
            "masked_code": "all_masks = np.array([[False, False, False, False, False, False],\n                      [False, False, False, False, False, False],\n                      [False, False, False, False, False, False],\n                      [False,  True, False, False,  True, False],\n                      [False, False, False, False, False, False],\n                      [False,  True, False, False,  True, False]])\n\n<line_mask>",
            "masked_line": "all_masks.any(axis=0)",
            "answer": "any",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1124"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-04-09",
            "description": "The code calculates the cumulative sum of differences between adjacent elements in a boolean array, with some manipulation done to the array based on the differences between specific elements.",
            "code": "bnd = np.diff(bool_arr, axis=0, prepend=0, append=0)\nx, y = np.where(bnd.T)\nbnd.T[x, y] *= (y[1::2]-y[::2]).repeat(2)\nbnd[:-1].cumsum(axis=0)\n# array([[3, 6, 1, 6, 0, 1],\n#        [3, 6, 0, 6, 5, 0],\n#        [3, 6, 3, 6, 5, 2],\n#        [0, 6, 3, 6, 5, 2],\n#        [2, 6, 3, 6, 5, 0],\n#        [2, 6, 0, 6, 5, 1]])",
            "masked_code": "bnd = np.diff(bool_arr, axis=0, prepend=0, append=0)\nx, y = np.where(bnd.T)\nbnd.T[x, y] *= (y[1::2]-y[::2]).repeat(2)\n<line_mask>\n# array([[3, 6, 1, 6, 0, 1],\n#        [3, 6, 0, 6, 5, 0],\n#        [3, 6, 3, 6, 5, 2],\n#        [0, 6, 3, 6, 5, 2],\n#        [2, 6, 3, 6, 5, 0],\n#        [2, 6, 0, 6, 5, 1]])",
            "masked_line": "bnd[:-1].cumsum(axis=0)",
            "answer": "cumsum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1125"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-08",
            "description": "This function pads the input array 'x' with zeros to make its second dimension to be equal to the specified length 'm'.",
            "code": "def pad_to_length(x, m):\n    return np.pad(x,((0, 0), (0, m - x.shape[1])), mode = 'constant')",
            "masked_code": "def pad_to_length(x, m):\n    <line_mask>",
            "masked_line": "return np.pad(x,((0, 0), (0, m - x.shape[1])), mode = 'constant')",
            "answer": "pad",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1126"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-17",
            "description": "The code calculates the rank of each value in the 'Volume' column of the dataframe 'df' based on their ordering, where a lower rank indicates a higher value. The result is stored in a new column 'Rank' in the dataframe.",
            "code": "df['Rank'] = np.array([i - np.searchsorted(sorted(df.Volume[:i]), v) for i, v in enumerate(df.Volume)]) + 1\nprint(df)",
            "masked_code": "<line_mask>\nprint(df)",
            "masked_line": "df['Rank'] = np.array([i - np.searchsorted(sorted(df.Volume[:i]), v) for i, v in enumerate(df.Volume)]) + 1",
            "answer": "searchsorted",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1127"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.2",
            "time": "2019-05-21",
            "description": "This code moves the axis at index 2 to index 0 in the array 'a'.",
            "code": "np.moveaxis(a,2,0)",
            "masked_code": "<line_mask>",
            "masked_line": "np.moveaxis(a,2,0)",
            "answer": "moveaxis",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1128"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-10",
            "description": "The code identifies the indices where the person_id column in a dataframe df1 is different from the previous row.",
            "code": "ix = np.flatnonzero(df1.person_id != df1.person_id.shift(1))\n#array([0, 2, 5])",
            "masked_code": "<line_mask>\n#array([0, 2, 5])",
            "masked_line": "ix = np.flatnonzero(df1.person_id != df1.person_id.shift(1))",
            "answer": "flatnonzero",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1129"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.5",
            "time": "2019-02-12",
            "description": "The code assigns the value 'Okanagan_and_Kootenays' to the '_area_large' column in the 'main_file' dataframe based on whether the 'long_name' column in 'main_file' contains values from the list 'Okanagan_and_Kootenays'.",
            "code": "Okanagan_and_Kootenays = ['Columbia-Shuswap','Central Okanagan', 'North Okanagan',\n                          'Okanagan-Similkameen', 'East Kootenay', 'Kootenay Boundary',\n                          'Central Kootenay' ]\n\nconditions = [(main_file['long_name'].isin(Okanagan_and_Kootenays))]\nchoices = ['Okanagan_and_Kootenays']\n\nmain_file['_area_large'] = np.select(conditions, choices)",
            "masked_code": "Okanagan_and_Kootenays = ['Columbia-Shuswap','Central Okanagan', 'North Okanagan',\n                          'Okanagan-Similkameen', 'East Kootenay', 'Kootenay Boundary',\n                          'Central Kootenay' ]\n\n<line_mask>\nchoices = ['Okanagan_and_Kootenays']\n\nmain_file['_area_large'] = np.select(conditions, choices)",
            "masked_line": "conditions = [(main_file['long_name'].isin(Okanagan_and_Kootenays))]",
            "answer": "isin",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1130"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24",
            "time": "2019-06-19",
            "description": "The code converts the 'word_id' column in the 'data' dataframe to numeric type, with the option to coerce errors, and then converts it to nullable integer type (Int64).",
            "code": "data.word_id = pd.to_numeric(data.word_id, errors='coerce').astype('Int64')",
            "masked_code": "<line_mask>",
            "masked_line": "data.word_id = pd.to_numeric(data.word_id, errors='coerce').astype('Int64')",
            "answer": "to_numeric",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1131"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-02",
            "description": "This code compares two numpy arrays element-wise and returns the indices where the values are not equal.",
            "code": "array1 = np.array([1,2,3])\narray2 = np.array([1,2,4])\n\nres = np.flatnonzero(array1 != array2)\n\nprint(res)\n# array([2], dtype=int64)",
            "masked_code": "array1 = np.array([1,2,3])\narray2 = np.array([1,2,4])\n\n<line_mask>\n\nprint(res)\n# array([2], dtype=int64)",
            "masked_line": "res = np.flatnonzero(array1 != array2)",
            "answer": "flatnonzero",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1132"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-05",
            "description": "Broadcast array 'a' to have a shape of (n, *a.shape) and then reshape it into a 2D array with the same number of columns as the original array 'a'.",
            "code": "np.broadcast_to(a, (n, *a.shape)).reshape(-1, a.shape[1])\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])",
            "masked_code": "<line_mask>\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])",
            "masked_line": "np.broadcast_to(a, (n, *a.shape)).reshape(-1, a.shape[1])",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1133"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-10",
            "description": "The code assigns 'ball' to column2_type if 'baseball' or 'basketball' is in column1_sport, 'box' if 'boxing' is in column1_sport, and 'other' for all other values in column1_sport.",
            "code": "values = ['ball', 'box']\nconditions = list(map(df['column1_sport'].str.contains, values))\n\ndf['column2_type'] = np.select(conditions, values, 'other')\n\nprint(df)\n\n#   column1_sport column2_type\n# 0      baseball         ball\n# 1    basketball         ball\n# 2        tennis        other\n# 3        boxing          box\n# 4          golf        other",
            "masked_code": "values = ['ball', 'box']\nconditions = list(map(df['column1_sport'].str.contains, values))\n\n<line_mask>\n\nprint(df)\n\n#   column1_sport column2_type\n# 0      baseball         ball\n# 1    basketball         ball\n# 2        tennis        other\n# 3        boxing          box\n# 4          golf        other",
            "masked_line": "df['column2_type'] = np.select(conditions, values, 'other')",
            "answer": "select",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1134"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-10",
            "description": "This code adds a new column 'value2' to a DataFrame. If the last character of the 'value1' column is 'L', it negates the values in the 'value2' column; otherwise, it keeps the values in the 'value2' column unchanged.",
            "code": "df['value2'] = np.where(df['value1'].str[-1] == 'L', -df['value2'], df['value2'])",
            "masked_code": "<line_mask>",
            "masked_line": "df['value2'] = np.where(df['value1'].str[-1] == 'L', -df['value2'], df['value2'])",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1135"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-06",
            "description": "This code performs a least squares regression to solve the equation Ax = b, where A is a matrix, b is a vector, and x is the solution vector.",
            "code": "x, _, _, _ = np.linalg.lsq(A, b)",
            "masked_code": "<line_mask>",
            "masked_line": "x, _, _, _ = np.linalg.lsq(A, b)",
            "answer": "lsq",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1136"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-12-01",
            "description": "The code inserts a column of ones at the beginning of the array 'x' along axis 1 and assigns the resulting array to 'new_x'.",
            "code": "new_x = np.insert(x, 0, 1, axis=1)",
            "masked_code": "<line_mask>",
            "masked_line": "new_x = np.insert(x, 0, 1, axis=1)",
            "answer": "insert",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1137"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-10",
            "description": "The code finds the indices of elements in `arr1` that are closest to the values in `arr2`, then creates a mask to check for matching elements between the two arrays. Finally, it generates a count of the occurrences of each index value in the masked array.",
            "code": "idx = np.searchsorted(arr1,arr2)\nidx[idx==len(arr1)] = 0\nmask = arr1[idx]==arr2\nout = np.bincount(idx[mask])",
            "masked_code": "<line_mask>\nidx[idx==len(arr1)] = 0\nmask = arr1[idx]==arr2\nout = np.bincount(idx[mask])",
            "masked_line": "idx = np.searchsorted(arr1,arr2)",
            "answer": "searchsorted",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1138"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-10-17",
            "description": "Return the rows in the DataFrame where the 'tag' column contains a dictionary with the key 'id' and value of 12.",
            "code": "# toy data\ndf = pd.DataFrame({'type':['df','fg','ff'],\n                   'tag': [[{\"id\" : 12} ,{\"id\" : 13}], \n                           [{\"id\" : 12}],\n                           [{'id':10}]]\n                  })\n\n# make each row contains exactly one dict: {id: val}\ns = df['tag'].explode()\n\n# the indexes of interested rows\nidx = s.index[pd.DataFrame(s.to_list())['id'].values==12]\n\n# output\ndf.loc[idx]",
            "masked_code": "# toy data\ndf = pd.DataFrame({'type':['df','fg','ff'],\n                   'tag': [[{\"id\" : 12} ,{\"id\" : 13}], \n                           [{\"id\" : 12}],\n                           [{'id':10}]]\n                  })\n\n# make each row contains exactly one dict: {id: val}\n<line_mask>\n\n# the indexes of interested rows\nidx = s.index[pd.DataFrame(s.to_list())['id'].values==12]\n\n# output\ndf.loc[idx]",
            "masked_line": "s = df['tag'].explode()",
            "answer": "explode",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1139"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-16",
            "description": "The function of the code is to reshape the input array \"arr_old\" into a new array \"arr_new\" with a shape of (2, 2, 3).",
            "code": "arr_old = np.array([\n               [1, 2, 3],\n               [1, 2, 3],\n               [1, 2, 3],\n               [1, 2, 3],\n               ])\n\nx, y = arr_old.shape # The shape of this input array is (4, 3)\n\narr_new = arr_old.reshape(int(x/2), 2, y) # Reshape the old array\n\nprint (arr_new.shape)  \n# (2, 2, 3)\n\nprint (arr_new)\n\n# [[[1 2 3]\n#  [1 2 3]]\n\n# [[1 2 3]\n#  [1 2 3]]]",
            "masked_code": "arr_old = np.array([\n               [1, 2, 3],\n               [1, 2, 3],\n               [1, 2, 3],\n               [1, 2, 3],\n               ])\n\nx, y = arr_old.shape # The shape of this input array is (4, 3)\n\n<line_mask>\n\nprint (arr_new.shape)  \n# (2, 2, 3)\n\nprint (arr_new)\n\n# [[[1 2 3]\n#  [1 2 3]]\n\n# [[1 2 3]\n#  [1 2 3]]]",
            "masked_line": "arr_new = arr_old.reshape(int(x/2), 2, y) # Reshape the old array",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1140"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-15",
            "description": "The code generates a 2-dimensional array filled with ones, and then calculates the cumulative sum of each row along the second axis.",
            "code": "np.ones(array_2d.shape).cumsum(axis=1)\n\narray([[1., 2., 3., 4., 5., 6.],\n       [1., 2., 3., 4., 5., 6.],\n       [1., 2., 3., 4., 5., 6.]])",
            "masked_code": "<line_mask>\n\narray([[1., 2., 3., 4., 5., 6.],\n       [1., 2., 3., 4., 5., 6.],\n       [1., 2., 3., 4., 5., 6.]])",
            "masked_line": "np.ones(array_2d.shape).cumsum(axis=1)",
            "answer": "ones",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1141"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-10-25",
            "description": "This function sums blocks of elements in a 2D array 'a' based on specified row_sizes and col_sizes. It first sums the rows based on row_sizes and then sums the columns based on col_sizes.",
            "code": "def sum_blocks(a, row_sizes, col_sizes):\n    # Sum rows based on row-sizes\n    s1 = np.add.reduceat(a,np.r_[0,row_sizes[:-1].cumsum()],axis=0)\n\n    # Sum cols from row-summed output based on col-sizes\n    return np.add.reduceat(s1,np.r_[0,col_sizes[:-1].cumsum()],axis=1)",
            "masked_code": "def sum_blocks(a, row_sizes, col_sizes):\n    # Sum rows based on row-sizes\n    s1 = np.add.reduceat(a,np.r_[0,row_sizes[:-1].cumsum()],axis=0)\n\n    # Sum cols from row-summed output based on col-sizes\n    <line_mask>",
            "masked_line": "return np.add.reduceat(s1,np.r_[0,col_sizes[:-1].cumsum()],axis=1)",
            "answer": "add",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1142"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-04-24",
            "description": "The code generates a list of all the cliques (fully connected subgraphs) in the given graph G.",
            "code": "list(nx.enumerate_all_cliques(G))\n\n[[0],\n [1],\n [2],\n [3],\n [4],\n [5],\n [6],\n [7],\n [8],\n [9],\n [10],\n [0, 1],\n [0, 5],\n [1, 2],\n [1, 6],\n [1, 7],\n [2, 3],\n [2, 7],\n [2, 8],\n [3, 4],\n [3, 8],\n [4, 8],\n [5, 6],\n [5, 9],\n [6, 7],\n [6, 9],\n [6, 10],\n [7, 8],\n [7, 10],\n [9, 10],\n [1, 2, 7],\n [1, 6, 7],\n [2, 3, 8],\n [2, 7, 8],\n [3, 4, 8],\n [5, 6, 9],\n [6, 7, 10],\n [6, 9, 10]]",
            "masked_code": "<line_mask>\n\n[[0],\n [1],\n [2],\n [3],\n [4],\n [5],\n [6],\n [7],\n [8],\n [9],\n [10],\n [0, 1],\n [0, 5],\n [1, 2],\n [1, 6],\n [1, 7],\n [2, 3],\n [2, 7],\n [2, 8],\n [3, 4],\n [3, 8],\n [4, 8],\n [5, 6],\n [5, 9],\n [6, 7],\n [6, 9],\n [6, 10],\n [7, 8],\n [7, 10],\n [9, 10],\n [1, 2, 7],\n [1, 6, 7],\n [2, 3, 8],\n [2, 7, 8],\n [3, 4, 8],\n [5, 6, 9],\n [6, 7, 10],\n [6, 9, 10]]",
            "masked_line": "list(nx.enumerate_all_cliques(G))",
            "answer": "enumerate_all_cliques",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1143"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-04-24",
            "description": "Filter out all cliques in the graph G where the length of each clique is greater than 2.",
            "code": "list(filter(lambda x: len(x) > 2, nx.enumerate_all_cliques(G)))\n\n[[1, 2, 7],\n [1, 6, 7],\n [2, 3, 8],\n [2, 7, 8],\n [3, 4, 8],\n [5, 6, 9],\n [6, 7, 10],\n [6, 9, 10]]",
            "masked_code": "<line_mask>\n\n[[1, 2, 7],\n [1, 6, 7],\n [2, 3, 8],\n [2, 7, 8],\n [3, 4, 8],\n [5, 6, 9],\n [6, 7, 10],\n [6, 9, 10]]",
            "masked_line": "list(filter(lambda x: len(x) > 2, nx.enumerate_all_cliques(G)))",
            "answer": "enumerate_all_cliques",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1144"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-04-16",
            "description": "Calculate the median of the values from three arrays A, B, and C, where each array represents a different dimension, and return a 2D array with the median values.",
            "code": "np.median(np.dstack([A,B,C]), -1)\n\narray([[2., 2.],\n       [3., 3.]])",
            "masked_code": "<line_mask>\n\narray([[2., 2.],\n       [3., 3.]])",
            "masked_line": "np.median(np.dstack([A,B,C]), -1)",
            "answer": "median",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1145"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-02-04",
            "description": "This code calculates the near minimum and near maximum values of the input data using quantiles and then sets the y-axis limits of a plot to be between these values.",
            "code": "near_min = np.quantile(in_data, 0.0001)\nnear_max = np.quantile(in_data, 0.9999)\nax.set_ylim(near_min, near_max)",
            "masked_code": "<line_mask>\nnear_max = np.quantile(in_data, 0.9999)\nax.set_ylim(near_min, near_max)",
            "masked_line": "near_min = np.quantile(in_data, 0.0001)",
            "answer": "quantile",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1146"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.0",
            "time": "2019-10-15",
            "description": "The code calculates the indices of the upper triangular part of a 3x3 matrix, excluding the main diagonal.",
            "code": "upper_index = np.triu_indices(n=3, k=1)",
            "masked_code": "<line_mask>",
            "masked_line": "upper_index = np.triu_indices(n=3, k=1)",
            "answer": "triu_indices",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1147"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-03-26",
            "description": "The code splits array b using the unique indices of array a.",
            "code": "a = np.array([1, 1, 2, 2, 3, 3])\nb = np.array([10, 11, 12, 13, 14, 15])\n\nu, s = np.unique(a, return_index=True)\nnp.split(b,s[1:])",
            "masked_code": "a = np.array([1, 1, 2, 2, 3, 3])\nb = np.array([10, 11, 12, 13, 14, 15])\n\nu, s = np.unique(a, return_index=True)\n<line_mask>",
            "masked_line": "np.split(b,s[1:])",
            "answer": "split",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1148"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-02-20",
            "description": "The code generates a 2D array where each element is the sum of the corresponding indices in the two dimensions starting from 0 and incrementing by 10 in the first dimension and by 1 in the second dimension.",
            "code": "np.add(*np.ogrid[:60:10, :6]) \n\n# array([[ 0,  1,  2,  3,  4,  5],\n#        [10, 11, 12, 13, 14, 15],\n#        [20, 21, 22, 23, 24, 25],\n#        [30, 31, 32, 33, 34, 35],\n#        [40, 41, 42, 43, 44, 45],\n#        [50, 51, 52, 53, 54, 55]])",
            "masked_code": "<line_mask>\n\n# array([[ 0,  1,  2,  3,  4,  5],\n#        [10, 11, 12, 13, 14, 15],\n#        [20, 21, 22, 23, 24, 25],\n#        [30, 31, 32, 33, 34, 35],\n#        [40, 41, 42, 43, 44, 45],\n#        [50, 51, 52, 53, 54, 55]])",
            "masked_line": "np.add(*np.ogrid[:60:10, :6])",
            "answer": "add",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1149"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24.0",
            "time": "2019-04-15",
            "description": "This code constructs intervals from endpoints and computes the intersections between these intervals and a set of original intervals.",
            "code": "endpoints = df.stack().sort_values().reset_index(drop=True)\nintervals = pd.DataFrame({'start':endpoints.shift().fillna(0), \n                          'end':endpoints}).astype(int)\n# construct the list of intervals from the endpoints\nintervals['intv'] = [pd.Interval(a,b) for a,b in zip(intervals.start, intervals.end)]\n\n# these are the original intervals\norig_invt = pd.arrays.IntervalArray([pd.Interval(a,b) for a,b in zip(df.start, df.end)])\n\n# walk through the intervals and compute the intersections\nintervals['total'] = intervals.intv.apply(lambda x: org_intv.overlaps(x).sum())",
            "masked_code": "endpoints = df.stack().sort_values().reset_index(drop=True)\nintervals = pd.DataFrame({'start':endpoints.shift().fillna(0), \n                          'end':endpoints}).astype(int)\n# construct the list of intervals from the endpoints\nintervals['intv'] = [pd.Interval(a,b) for a,b in zip(intervals.start, intervals.end)]\n\n# these are the original intervals\norig_invt = pd.arrays.IntervalArray([pd.Interval(a,b) for a,b in zip(df.start, df.end)])\n\n# walk through the intervals and compute the intersections\n<line_mask>",
            "masked_line": "intervals['total'] = intervals.intv.apply(lambda x: org_intv.overlaps(x).sum())",
            "answer": "intv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1150"
        },
        {
            "dependency": "pandas",
            "version": ">=0.19",
            "time": "2019-09-09",
            "description": "The code reads a JSON file into a pandas DataFrame where each line represents a separate JSON object.",
            "code": "pd.read_json(jsonfile, lines=True)",
            "masked_code": "<line_mask>",
            "masked_line": "pd.read_json(jsonfile, lines=True)",
            "answer": "read_json",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1151"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-06",
            "description": "This code finds the indices of elements in final_vals where the absolute value of each element is less than or equal to 1 for each row.",
            "code": "np.flatnonzero((np.abs(final_vals) <= 1).all(axis=1))",
            "masked_code": "<line_mask>",
            "masked_line": "np.flatnonzero((np.abs(final_vals) <= 1).all(axis=1))",
            "answer": "flatnonzero",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1152"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.1",
            "time": "2019-09-10",
            "description": "The code creates an empty DataFrame with columns in the order specified by the keys in the combo_dict dictionary, and appends the data from the combo_dict dictionary to the DataFrame while ignoring the index and not sorting the data.",
            "code": "combo_cols = list(combo_dict) # get the current order of the columns\ndf = pd.DataFrame(columns=combo_cols) # set empty df columns to match \ndf.append(combo_dict, ignore_index = True, sort = False) # append the dataframes",
            "masked_code": "combo_cols = list(combo_dict) # get the current order of the columns\ndf = pd.DataFrame(columns=combo_cols) # set empty df columns to match \n<line_mask>",
            "masked_line": "df.append(combo_dict, ignore_index = True, sort = False) # append the dataframes",
            "answer": "append",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1153"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-03-21",
            "description": "The code converts the column values in a pandas DataFrame to datetime values with a day precision.",
            "code": "df.columns = pd.to_datetime(df.columns).values.astype('datetime64[D]')",
            "masked_code": "<line_mask>",
            "masked_line": "df.columns = pd.to_datetime(df.columns).values.astype('datetime64[D]')",
            "answer": "to_datetime",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1154"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-25",
            "description": "The code concatenates arrays along axis 1 and then flattens the resulting array in column-major (Fortran) order.",
            "code": "np.concatenate(o, axis=1).flatten(order='f')",
            "masked_code": "<line_mask>",
            "masked_line": "np.concatenate(o, axis=1).flatten(order='f')",
            "answer": "flatten",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1155"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-01",
            "description": "The code appends the value 0 to the end of the numpy array 'data'.",
            "code": "data = np.append(data, 0)",
            "masked_code": "<line_mask>",
            "masked_line": "data = np.append(data, 0)",
            "answer": "append",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1156"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-03",
            "description": "This code creates a 2D numpy array and fills the diagonal elements with 0.",
            "code": "x = np.array([[1, 2, 3], [4, 5, 6],[4, 1, 6],[1, 5, 11],[4,3, 4]], np.int32)\nnp.fill_diagonal(x,0)\n\nprint(x)\narray([[ 0,  2,  3],\n       [ 4,  0,  6],\n       [ 4,  1,  0],\n       [ 1,  5, 11],\n       [ 4,  3,  4]], dtype=int32)",
            "masked_code": "x = np.array([[1, 2, 3], [4, 5, 6],[4, 1, 6],[1, 5, 11],[4,3, 4]], np.int32)\n<line_mask>\n\nprint(x)\narray([[ 0,  2,  3],\n       [ 4,  0,  6],\n       [ 4,  1,  0],\n       [ 1,  5, 11],\n       [ 4,  3,  4]], dtype=int32)",
            "masked_line": "np.fill_diagonal(x,0)",
            "answer": "fill_diagonal",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1157"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-10-27",
            "description": "The code repeates the rows in a dataframe based on the value in the 's_count' column, then resets the index. It then generates random integers between 1 and 100 and assigns them to a new column 'num' in the dataframe.",
            "code": "df = df.loc[df.index.repeat(df['s_count'])].reset_index(drop=True)\ndf['num'] = np.random.randint(1, 100, size=len(df))",
            "masked_code": "<line_mask>\ndf['num'] = np.random.randint(1, 100, size=len(df))",
            "masked_line": "df = df.loc[df.index.repeat(df['s_count'])].reset_index(drop=True)",
            "answer": "index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1158"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-04-23",
            "description": "The code defines a command-line interface using the Click library in Python. The `my_command` function takes in command line arguments such as verbosity flag, target, and commands, and prints them out. It then runs a series of command strings, splitting them and calling the `my_command` function with the parsed arguments. If any exceptions occur during execution, it handles them accordingly.",
            "code": "import click\n\n@click.command(cls=RealNargsMinusOne)\n@click.option('-v', '--verbose', is_flag=True)\n@click.argument('target')\n@click.argument('command', nargs=-1)\ndef my_command(verbose, target, command):\n    print('verbose:', verbose)\n    print('target:', target)\n    print('command:', command)\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '-v hostname echo -e foo',\n        '-v hostname -x echo -e foo',\n        '-x hostname -x echo -e foo',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            my_command(cmd.split(), allow_extra_args=True)\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\n@click.command(cls=RealNargsMinusOne)\n@click.option('-v', '--verbose', is_flag=True)\n<line_mask>\n@click.argument('command', nargs=-1)\ndef my_command(verbose, target, command):\n    print('verbose:', verbose)\n    print('target:', target)\n    print('command:', command)\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '-v hostname echo -e foo',\n        '-v hostname -x echo -e foo',\n        '-x hostname -x echo -e foo',\n        '--help',\n        '',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            my_command(cmd.split(), allow_extra_args=True)\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.argument('target')",
            "answer": "argument",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1159"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-31",
            "description": "The code sorts the columns of a numpy array 'arr' based on the values in the last row of the array in ascending order.",
            "code": "arr = np.array([[0, 1, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 1],\n                [1, 0, 3, 4, 4]])\narr[:, np.argsort(arr[-1, :])]\n# array([[1, 0, 0, 0, 0],\n#        [0, 1, 0, 0, 0],\n#        [0, 0, 0, 1, 0],\n#        [0, 0, 0, 0, 1],\n#        [0, 1, 3, 4, 4]])",
            "masked_code": "arr = np.array([[0, 1, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 1],\n                [1, 0, 3, 4, 4]])\n<line_mask>\n# array([[1, 0, 0, 0, 0],\n#        [0, 1, 0, 0, 0],\n#        [0, 0, 0, 1, 0],\n#        [0, 0, 0, 0, 1],\n#        [0, 1, 3, 4, 4]])",
            "masked_line": "arr[:, np.argsort(arr[-1, :])]",
            "answer": "argsort",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1160"
        },
        {
            "dependency": "click",
            "version": "==7.1.2",
            "time": "2022-04-14",
            "description": "This Python code is creating a decorator that adds a prefix \"pre\" to the value of the \"--testy\" option passed to the decorated function. It then invokes the decorated function with the updated \"testy\" value and allows Click to be aware of the options defined on the wrapper. Finally, it uses functools to update the wrapper function as required.",
            "code": "def decorator_example(f):\n\n    @pass_context\n    @click.option(\"--testy\")\n    def wrapper(ctx, *args, testy, **kwargs):\n        # Do stuff with testy here\n        testy = f\"pre{testy}\"\n    \n    # Think this is the bit that allows click to be aware of options defined on the wrapper\n    return ctx.invoke(wrapped_function, *args, testy=testy, **kwargs)\n\n# Using functools to update the wrapper as required - think this is the same as @wraps(f)?\nreturn update_wrapper(wrapper, wrapped_function)",
            "masked_code": "def decorator_example(f):\n\n    @pass_context\n    <line_mask>\n    def wrapper(ctx, *args, testy, **kwargs):\n        # Do stuff with testy here\n        testy = f\"pre{testy}\"\n    \n    # Think this is the bit that allows click to be aware of options defined on the wrapper\n    return ctx.invoke(wrapped_function, *args, testy=testy, **kwargs)\n\n# Using functools to update the wrapper as required - think this is the same as @wraps(f)?\nreturn update_wrapper(wrapper, wrapped_function)",
            "masked_line": "@click.option(\"--testy\")",
            "answer": "option",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1161"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-05-03",
            "description": "Assigns a boolean array to the specified rows and columns in the input array, where the value is True if the index is less than or equal to the specified column index.",
            "code": "arr[row_indices] = np.arange(arr.shape[0]) <= col_indices[:,None]\n\narray([[0., 0., 0., 0., 0.],\n       [1., 1., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [1., 1., 1., 1., 1.],\n       [1., 1., 0., 0., 0.]])",
            "masked_code": "<line_mask>\n\narray([[0., 0., 0., 0., 0.],\n       [1., 1., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [1., 1., 1., 1., 1.],\n       [1., 1., 0., 0., 0.]])",
            "masked_line": "arr[row_indices] = np.arange(arr.shape[0]) <= col_indices[:,None]",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1162"
        },
        {
            "dependency": "tensorflow",
            "version": ">=1.13",
            "time": "2019-03-09",
            "description": "The code finds the top 3 values in the input tensor 'x', creates a new tensor with ones at the positions indicated by the indices of the top 3 values, and assigns the result to the variable 'result'.",
            "code": "x = tf.convert_to_tensor([0,4,1,2,8,7,0,2])\n_, indices = tf.math.top_k(x, k=3)\nresult = tf.scatter_nd(tf.expand_dims(indices, 1), tf.ones_like(indices), tf.shape(x))",
            "masked_code": "<line_mask>\n_, indices = tf.math.top_k(x, k=3)\nresult = tf.scatter_nd(tf.expand_dims(indices, 1), tf.ones_like(indices), tf.shape(x))",
            "masked_line": "x = tf.convert_to_tensor([0,4,1,2,8,7,0,2])",
            "answer": "convert_to_tensor",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1163"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-02-20",
            "description": "This code assigns the values of the bboxes array to specific locations in the output array based on the values of x_cell and y_cell arrays.",
            "code": "N = len(bboxes)\noutput[x_cell[:N],y_cell[:N],np.arange(N)] = bboxes",
            "masked_code": "N = len(bboxes)\n<line_mask>",
            "masked_line": "output[x_cell[:N],y_cell[:N],np.arange(N)] = bboxes",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1164"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-05-09",
            "description": "The code generates a 3x3 NumPy array containing the power of 2 for each element in the array [0, 1, 2, 3, 4, 5, 6, 7, 8].",
            "code": "2**np.arange(9).reshape(-1, 3)\n\narray([[  1,   2,   4],\n       [  8,  16,  32],\n       [ 64, 128, 256]], dtype=int32)",
            "masked_code": "<line_mask>\n\narray([[  1,   2,   4],\n       [  8,  16,  32],\n       [ 64, 128, 256]], dtype=int32)",
            "masked_line": "2**np.arange(9).reshape(-1, 3)",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1165"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-01",
            "description": "The code creates a new column 'comparison' in dataframe df1, comparing each row's 'Year' and 'Week' with the next row's 'Year' and 'Week'. If they are equal, the value in the 'comparison' column is set to 'Yes', otherwise it is set to 'No'.",
            "code": "df1['comparison'] = np.where((df1['Year'] == df1['Year'].shift(-1)) & \n                             (df1['Week'] == df1['Week'].shift(-1)), 'Yes', 'No')",
            "masked_code": "<line_mask>\n                             (df1['Week'] == df1['Week'].shift(-1)), 'Yes', 'No')",
            "masked_line": "df1['comparison'] = np.where((df1['Year'] == df1['Year'].shift(-1)) &",
            "answer": "shift",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1166"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.1",
            "time": "2019-09-25",
            "description": "This code moves the specified axis of the 'volume' array to the first axis position in a new array 'slices_ar'.",
            "code": "slices_ar = np.moveaxis(volume,axis,0)",
            "masked_code": "<line_mask>",
            "masked_line": "slices_ar = np.moveaxis(volume,axis,0)",
            "answer": "moveaxis",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1167"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-04-14",
            "description": "This code calculates the cumulative sum of the lengths of words in a list.",
            "code": "# remember about importing numpy\nlengths = np.cumsum([0] + list(map(len, words)))\nprint(lengths)",
            "masked_code": "# remember about importing numpy\n<line_mask>\nprint(lengths)",
            "masked_line": "lengths = np.cumsum([0] + list(map(len, words)))",
            "answer": "cumsum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1168"
        },
        {
            "dependency": "numpy",
            "version": "==1.9.2",
            "time": "2019-01-15",
            "description": "This code snippet takes an input array 'a' and extracts the month values from each element, returning an array containing the month values.",
            "code": "np.vectorize(lambda x: x.month)(a)\narray([1, 1, 1])",
            "masked_code": "<line_mask>\narray([1, 1, 1])",
            "masked_line": "np.vectorize(lambda x: x.month)(a)",
            "answer": "vectorize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1169"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-16",
            "description": "The code reshapes a 2D numpy array \"x_tilde_2d\" into a 3D array \"x_tilde_reshaped_3d\" with specified dimensions and swaps the axes.",
            "code": "x_tilde_2d = np.array([[111,112,121,122,131,132],[211,212,221,222,231,232],[311,312,321,322,331,332]])\nx_tilde_reshaped_3d  = x_tilde_2d.reshape(N, x_tilde_2d.T.shape[1], n_ddl).swapaxes(0, 1)\nprint (x_tilde_reshaped_3d)",
            "masked_code": "x_tilde_2d = np.array([[111,112,121,122,131,132],[211,212,221,222,231,232],[311,312,321,322,331,332]])\n<line_mask>\nprint (x_tilde_reshaped_3d)",
            "masked_line": "x_tilde_reshaped_3d  = x_tilde_2d.reshape(N, x_tilde_2d.T.shape[1], n_ddl).swapaxes(0, 1)",
            "answer": "swapaxes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1170"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.0",
            "time": "2019-09-01",
            "description": "This code takes a Pandas Series, expands any lists within the Series into separate rows, and then resets the index of the resulting DataFrame.",
            "code": "pd.Series(links).explode().reset_index()",
            "masked_code": "<line_mask>",
            "masked_line": "pd.Series(links).explode().reset_index()",
            "answer": "reset_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1171"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.5",
            "time": "2019-02-08",
            "description": "Generate an array of 7 random numbers between -3 and 3.",
            "code": "In [11]: np.random.uniform(-3, 3, 7)  # 7 numbers between -3 and 3\nOut[11]: array([ 2.68365104, -0.97817374,  1.92815971, -2.56190434,  2.48954842, -0.16202127, -0.37050593])",
            "masked_code": "<line_mask>\nOut[11]: array([ 2.68365104, -0.97817374,  1.92815971, -2.56190434,  2.48954842, -0.16202127, -0.37050593])",
            "masked_line": "In [11]: np.random.uniform(-3, 3, 7)  # 7 numbers between -3 and 3",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1172"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-13",
            "description": "The code replaces the values in the 2nd, 3rd, and 4th columns of array b with the value 2 where the corresponding value in the 4th column of array a is 0.",
            "code": "rows = np.argwhere(a[:, 3] == 0)    \ncols = [2, 3, 4]        \n\nb[rows, cols] = 2       # Replace the values with 2\nprint(b)",
            "masked_code": "<line_mask>\ncols = [2, 3, 4]        \n\nb[rows, cols] = 2       # Replace the values with 2\nprint(b)",
            "masked_line": "rows = np.argwhere(a[:, 3] == 0)",
            "answer": "argwhere",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1173"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-10",
            "description": "The code calculates the maximum value in the 'Id' column of a dataframe, creates a Boolean series of null values in the 'Id' column, and assigns a range starting from one above the maximum 'Id' value to the null values in the 'Id' column.",
            "code": "# calculate maximum value\nmaxId = int(pd.to_numeric(df['Id'], errors='coerce').max())\n\n# calculate Boolean series of nulls\nnulls = df['Id'].isnull()\n\n# assign range starting from one above maxId\ndf.loc[nulls, 'Id'] = np.arange(maxId + 1, maxId + 1 + nulls.sum())\n\nprint(df)\n\n#      Id\n# 0     3\n# 1    67\n# 2   356\n# 3   679\n# 50   P4\n# 51   P5\n# 52  678\n# 53  680\n# 54    2",
            "masked_code": "# calculate maximum value\nmaxId = int(pd.to_numeric(df['Id'], errors='coerce').max())\n\n# calculate Boolean series of nulls\nnulls = df['Id'].isnull()\n\n# assign range starting from one above maxId\n<line_mask>\n\nprint(df)\n\n#      Id\n# 0     3\n# 1    67\n# 2   356\n# 3   679\n# 50   P4\n# 51   P5\n# 52  678\n# 53  680\n# 54    2",
            "masked_line": "df.loc[nulls, 'Id'] = np.arange(maxId + 1, maxId + 1 + nulls.sum())",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1174"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-06",
            "description": "The code reindexes the dataframe by shifting the index positions, resets the index, renames the columns of the resulting dataframes with different prefixes, and then concatenates the original dataframe with the modified dataframes along the column axis. Finally, it prints the combined dataframe.",
            "code": "df2 = df.reindex(index=np.roll(df.index, -1)).reset_index(drop=True)\ndf2.columns = ['B{}'.format(i) for i in range(1, len(df.columns) + 1)]\n\ndf3 = df.reindex(index=np.roll(df.index, -2)).reset_index(drop=True)\ndf3.columns = ['C{}'.format(i) for i in range(1, len(df.columns) + 1)]\n\nresult = pd.concat([df, df2, df3], axis=1)\n\nprint(result)",
            "masked_code": "<line_mask>\ndf2.columns = ['B{}'.format(i) for i in range(1, len(df.columns) + 1)]\n\ndf3 = df.reindex(index=np.roll(df.index, -2)).reset_index(drop=True)\ndf3.columns = ['C{}'.format(i) for i in range(1, len(df.columns) + 1)]\n\nresult = pd.concat([df, df2, df3], axis=1)\n\nprint(result)",
            "masked_line": "df2 = df.reindex(index=np.roll(df.index, -1)).reset_index(drop=True)",
            "answer": "roll",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1175"
        },
        {
            "dependency": "click",
            "version": "==7.0",
            "time": "2019-11-03",
            "description": "This Python code defines a command-line interface (CLI) using Click library. The CLI has a group command with an option \"--mode\" that only allows the values \"foo\" or \"bar\" as choices. The CLI is used for executing commands based on the selected mode.",
            "code": "@click.group(cls=mode_opts_cmds('mode'))\n@click.option('--mode', type=click.Choice([\"foo\", \"bar\"]))\ndef cli(mode):\n    \"\"\"My wonderful cli\"\"\"",
            "masked_code": "@click.group(cls=mode_opts_cmds('mode'))\n<line_mask>\ndef cli(mode):\n    \"\"\"My wonderful cli\"\"\"",
            "masked_line": "@click.option('--mode', type=click.Choice([\"foo\", \"bar\"]))",
            "answer": "option",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1176"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-10-05",
            "description": "The code converts the 'start_time' and 'end_time' columns in a pandas DataFrame to Timestamp format if they are not already, and adjusts cases where the times cross the day boundary. It then creates a 'time' column that holds a minutely range using the start and end times. The code further explodes the DataFrame to individual minutes, groups them by time, fills any missing values with 0, and formats the index as time.",
            "code": "# Convert `start_time` and `end_time` to Timestamp, if they\n# are not already. This also allows you to adjust cases where\n# the times cross the day boundary, e.g.: 23:00 - 02:00\ndf['start_time'] = pd.to_datetime(df['start_time'])\ndf['end_time'] = pd.to_datetime(df['end_time'])\n\n# Make a `time` column that holds a minutely range. We will\n# later explode it into individual minutes\nf = lambda row: pd.date_range(row['start_time'], row['end_time'], freq='T')\ndf['time'] = df.apply(f, axis=1)\n\n# The reporting range, adjust as needed\nt = pd.date_range('13:23', '13:30', freq='T')\n\nresult = df.explode('time') \\\n            .groupby('time').size() \\\n            .reindex(t).fillna(0) \\\n            .to_frame('active')\nresult.index = result.index.time",
            "masked_code": "# Convert `start_time` and `end_time` to Timestamp, if they\n# are not already. This also allows you to adjust cases where\n# the times cross the day boundary, e.g.: 23:00 - 02:00\ndf['start_time'] = pd.to_datetime(df['start_time'])\ndf['end_time'] = pd.to_datetime(df['end_time'])\n\n# Make a `time` column that holds a minutely range. We will\n# later explode it into individual minutes\nf = lambda row: pd.date_range(row['start_time'], row['end_time'], freq='T')\ndf['time'] = df.apply(f, axis=1)\n\n# The reporting range, adjust as needed\nt = pd.date_range('13:23', '13:30', freq='T')\n\nresult = df.explode('time') \\\n            .groupby('time').size() \\\n            <line_mask>\n            .to_frame('active')\nresult.index = result.index.time",
            "masked_line": ".reindex(t).fillna(0) \\",
            "answer": "reindex",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1177"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.0",
            "time": "2019-10-02",
            "description": "This code counts the number of 'C's in each row of a dataframe, then based on the count, it extracts and manipulates ID values to create a final dataframe with concatenated ID values.",
            "code": "# count the amount of C's in each row\nc_count = df['Merged_ID'].str.count('C')\n\n# if the amount of C's is 1, then we take the last 2 characters, else the last 4 (which is id2) and inser a space between the two id2's\nid2 = pd.Series(np.where(c_count==1, df['Merged_ID'].str[-2:], df['Merged_ID'].str[-4:].apply(lambda x: x[:2]+ ' ' + x[2:])))\n\n# we substract id1 from the string\nid1 = df['Merged_ID'].str.split('C\\d').str[0]\n\n# we explode the concatenated id2's to different rows and join id1 back \nfinal = id1.to_frame().join(id2.str.split().explode().to_frame())\n\n# finally we concatenate the strings back to each other\nfinal.assign(Merged_ID = final['Merged_ID'].str.cat(final[0])).iloc[:, 0].to_frame()",
            "masked_code": "# count the amount of C's in each row\nc_count = df['Merged_ID'].str.count('C')\n\n# if the amount of C's is 1, then we take the last 2 characters, else the last 4 (which is id2) and inser a space between the two id2's\nid2 = pd.Series(np.where(c_count==1, df['Merged_ID'].str[-2:], df['Merged_ID'].str[-4:].apply(lambda x: x[:2]+ ' ' + x[2:])))\n\n# we substract id1 from the string\nid1 = df['Merged_ID'].str.split('C\\d').str[0]\n\n# we explode the concatenated id2's to different rows and join id1 back \n<line_mask>\n\n# finally we concatenate the strings back to each other\nfinal.assign(Merged_ID = final['Merged_ID'].str.cat(final[0])).iloc[:, 0].to_frame()",
            "masked_line": "final = id1.to_frame().join(id2.str.split().explode().to_frame())",
            "answer": "to_frame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1178"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.1",
            "time": "2019-06-26",
            "description": "This code concatenates the 'data' array with 'labels_ext' array along the fourth axis, resulting in a new array with a shape of (100, 81, 121, 8, 3).",
            "code": "In [215]: data = np.random.rand(100,81,121,6,3)\n\nIn [216]: labels = np.random.rand(100,2)\n\nIn [218]: labels_ext = np.broadcast_to(labels[:,None,None,:,None],(100,81,121,2,3))\n\nIn [219]: np.concatenate((data,labels_ext),axis=3).shape\nOut[219]: (100, 81, 121, 8, 3)",
            "masked_code": "In [215]: data = np.random.rand(100,81,121,6,3)\n\nIn [216]: labels = np.random.rand(100,2)\n\n<line_mask>\n\nIn [219]: np.concatenate((data,labels_ext),axis=3).shape\nOut[219]: (100, 81, 121, 8, 3)",
            "masked_line": "In [218]: labels_ext = np.broadcast_to(labels[:,None,None,:,None],(100,81,121,2,3))",
            "answer": "broadcast_to",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1179"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14",
            "time": "2019-07-26",
            "description": "The code calculates the Frechet Inception Distance (FID) between two sets of images using a pre-trained InceptionV3 model. It first resizes the images to the specified input shape, then calculates the FID by comparing the mean and covariance of feature vectors extracted from the images using the model. The final FID score is printed as output.",
            "code": "import numpy as np\nimport scipy.linalg\nimport tensorflow as tf\nimport tensorflow.keras as keras\nfrom tensorflow.keras.applications.inception_v3 import InceptionV3, preprocess_input\nfrom tensorflow.compat.v1 import ConfigProto\nfrom skimage.transform import resize\n\n\ntf.enable_eager_execution()\nconfig = ConfigProto()\nconfig.gpu_options.allow_growth = True\ntf.keras.backend.set_session(tf.Session(config=config))\n\n\ndef scale_images(images, new_shape):\n    return np.asarray([resize(image, new_shape, 0) for image in images])\n\n\ndef calculate_fid(model, images1, images2):\n    f1, f2 = [model.predict(im) for im in (images1, images2)]\n    mean1, sigma1 = f1.mean(axis=0), np.cov(f1, rowvar=False)\n    mean2, sigma2 = f2.mean(axis=0), np.cov(f2, rowvar=False)\n    sum_sq_diff = np.sum((mean1 - mean2)**2)\n    cov_mean = scipy.linalg.sqrtm(sigma1.dot(sigma2))\n    if np.iscomplexobj(cov_mean):\n        cov_mean = cov_mean.real\n    fid = sum_sq_diff + np.trace(sigma1 + sigma2 - 2.0*cov_mean)\n    return fid\n\n\nif __name__ == '__main__':\n    input_shape = (299, 299, 3)\n\n    inception = InceptionV3(include_top=False, pooling='avg', input_shape=input_shape)\n\n    (dataset, _), _ = keras.datasets.cifar10.load_data()\n    dataset = dataset[:100]\n    dataset = scale_images(dataset, input_shape)\n\n    noise = preprocess_input(np.clip(255*np.random.uniform(size=dataset.shape), 0, 255))\n    noise = scale_images(noise, input_shape)\n\n    print('FID:', calculate_fid(inception, dataset, noise))",
            "masked_code": "import numpy as np\nimport scipy.linalg\nimport tensorflow as tf\nimport tensorflow.keras as keras\n<line_mask>\nfrom tensorflow.compat.v1 import ConfigProto\nfrom skimage.transform import resize\n\n\ntf.enable_eager_execution()\nconfig = ConfigProto()\nconfig.gpu_options.allow_growth = True\ntf.keras.backend.set_session(tf.Session(config=config))\n\n\ndef scale_images(images, new_shape):\n    return np.asarray([resize(image, new_shape, 0) for image in images])\n\n\ndef calculate_fid(model, images1, images2):\n    f1, f2 = [model.predict(im) for im in (images1, images2)]\n    mean1, sigma1 = f1.mean(axis=0), np.cov(f1, rowvar=False)\n    mean2, sigma2 = f2.mean(axis=0), np.cov(f2, rowvar=False)\n    sum_sq_diff = np.sum((mean1 - mean2)**2)\n    cov_mean = scipy.linalg.sqrtm(sigma1.dot(sigma2))\n    if np.iscomplexobj(cov_mean):\n        cov_mean = cov_mean.real\n    fid = sum_sq_diff + np.trace(sigma1 + sigma2 - 2.0*cov_mean)\n    return fid\n\n\nif __name__ == '__main__':\n    input_shape = (299, 299, 3)\n\n    inception = InceptionV3(include_top=False, pooling='avg', input_shape=input_shape)\n\n    (dataset, _), _ = keras.datasets.cifar10.load_data()\n    dataset = dataset[:100]\n    dataset = scale_images(dataset, input_shape)\n\n    noise = preprocess_input(np.clip(255*np.random.uniform(size=dataset.shape), 0, 255))\n    noise = scale_images(noise, input_shape)\n\n    print('FID:', calculate_fid(inception, dataset, noise))",
            "masked_line": "from tensorflow.keras.applications.inception_v3 import InceptionV3, preprocess_input",
            "answer": "preprocess_input",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1180"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-03-26",
            "description": "Calculate the midpoint of each range in the array `mx_ranges1` and return an array of these midpoints.",
            "code": "a = np.array(mx_ranges1)\n(a[:,1] - a[:,0]) /2 + a[:,0]\n# array([868., 827., 785., 743., ...",
            "masked_code": "<line_mask>\n(a[:,1] - a[:,0]) /2 + a[:,0]\n# array([868., 827., 785., 743., ...",
            "masked_line": "a = np.array(mx_ranges1)",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1181"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-16",
            "description": "This code performs the contraction of three 2D arrays xy, W, and xy along specified axes and returns a 1D array.",
            "code": "np.einsum('ij,ik,kj->j',xy,W,xy, optimize=True)",
            "masked_code": "<line_mask>",
            "masked_line": "np.einsum('ij,ik,kj->j',xy,W,xy, optimize=True)",
            "answer": "einsum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1182"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-05",
            "description": "The code creates a pandas DataFrame with two columns named 'Start date' and 'End date', each containing values from 0 to 3559. It then prints the shape of the DataFrame which is (3560, 2) and the first 5 rows of the DataFrame.",
            "code": "df = pd.DataFrame(dict.fromkeys(['Start date', 'End date'], np.arange(3560)))\n\nprint(df.shape)\n# (3560, 2)\n\nprint(df.head())\n#    Start date  End date\n# 0           0         0\n# 1           1         1\n# 2           2         2\n# 3           3         3\n# 4           4         4",
            "masked_code": "<line_mask>\n\nprint(df.shape)\n# (3560, 2)\n\nprint(df.head())\n#    Start date  End date\n# 0           0         0\n# 1           1         1\n# 2           2         2\n# 3           3         3\n# 4           4         4",
            "masked_line": "df = pd.DataFrame(dict.fromkeys(['Start date', 'End date'], np.arange(3560)))",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1183"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-12-20",
            "description": "The code randomly selects 3 unique values from the 'Village' column in the DataFrame and then filters the DataFrame to only include rows where the 'Village' column values match the selected values.",
            "code": "vil = np.random.choice(df['Village'].unique(), 3)\ndf = df[df['Village'].isin(vil)]",
            "masked_code": "<line_mask>\ndf = df[df['Village'].isin(vil)]",
            "masked_line": "vil = np.random.choice(df['Village'].unique(), 3)",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1184"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-11-22",
            "description": "The code relabels the nodes in graph G1 by incrementing the node labels by the total number of nodes in the graph.",
            "code": "relabel_dict = {node: node+len(G.nodes) for node in G1.nodes}\nG1 = nx.relabel_nodes(G1, relabel_dict)",
            "masked_code": "relabel_dict = {node: node+len(G.nodes) for node in G1.nodes}\n<line_mask>",
            "masked_line": "G1 = nx.relabel_nodes(G1, relabel_dict)",
            "answer": "relabel_nodes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1185"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.1",
            "time": "2019-10-30",
            "description": "This function converts a list of dictionaries into a sparse dataframe with three columns: 'docid', 'word', and 'n'.",
            "code": "def dicts_to_sparse_dataframe(docs):\n    rows = ((i, k, v)\n            for i, doc in enumerate(docs)\n            for k, v in doc.items())\n    out = pd.DataFrame(rows, columns=['docid', 'word', 'n'])\n    out = out.set_index(['docid', 'word'])['n'].astype(pd.SparseDtype(float))\n    out = out.unstack()\n    return out",
            "masked_code": "def dicts_to_sparse_dataframe(docs):\n    rows = ((i, k, v)\n            for i, doc in enumerate(docs)\n            for k, v in doc.items())\n    out = pd.DataFrame(rows, columns=['docid', 'word', 'n'])\n    out = out.set_index(['docid', 'word'])['n'].astype(pd.SparseDtype(float))\n    <line_mask>\n    return out",
            "masked_line": "out = out.unstack()",
            "answer": "unstack",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1186"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-06-17",
            "description": "Generate a DataFrame by comparing the values in the 'MARKS' column of df2 with the flattened values of df1, placing 'Y' where the value in df2 is less than the corresponding value in df1, and 'FALSE' otherwise. The resulting DataFrame is indexed by the 'class' column of df2.",
            "code": "a = df1.values.ravel()\nb = df2.MARKS.values\n\npd.DataFrame(np.where(np.less.outer(b, a), 'Y', 'FALSE'), index=df2['class'])\n# If you don't really want 'Y' and 'FALSE', replace those values with what you do want",
            "masked_code": "a = df1.values.ravel()\nb = df2.MARKS.values\n\n<line_mask>\n# If you don't really want 'Y' and 'FALSE', replace those values with what you do want",
            "masked_line": "pd.DataFrame(np.where(np.less.outer(b, a), 'Y', 'FALSE'), index=df2['class'])",
            "answer": "outer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1187"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-04-10",
            "description": "The code retrieves elements from array \"a\" based on the corresponding integer values in array \"b\", with the shape of array \"b\" determining the shape of the output array \"out\".",
            "code": "m,n = b.shape\nout = a[np.arange(m)[:,None],np.arange(n),b.astype(int)]",
            "masked_code": "m,n = b.shape\n<line_mask>",
            "masked_line": "out = a[np.arange(m)[:,None],np.arange(n),b.astype(int)]",
            "answer": "arange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1188"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-04",
            "description": "The code assigns a value of 0 to column 'col_B' in the DataFrame 'df' where the corresponding value in column 'col_A' is null. If the value in 'col_A' is not null, it retains the original value in 'col_B'.",
            "code": "df['col_B'] = np.where(df['col_A'].isnull(), 0, df['col_B'])",
            "masked_code": "<line_mask>",
            "masked_line": "df['col_B'] = np.where(df['col_A'].isnull(), 0, df['col_B'])",
            "answer": "isnull",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1189"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-30",
            "description": "The code identifies specific elements in an array that are outside a certain range of the first element, and then extracts those elements into a new array.",
            "code": "BIV = np.array(Brake_index_values) # shortening for convenience\nref_val = BIV[0]\nreq_indicies, = np.where((BIV < ref_val-3e4) | (BIV > ref_val+3e4)) \nreq_array = BIV[req_indicies]",
            "masked_code": "BIV = np.array(Brake_index_values) # shortening for convenience\nref_val = BIV[0]\n<line_mask>\nreq_array = BIV[req_indicies]",
            "masked_line": "req_indicies, = np.where((BIV < ref_val-3e4) | (BIV > ref_val+3e4))",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1190"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-27",
            "description": "The code calculates the dot product of matrices 'a' and 'b' using the np.dot() function and prints the resulting matrix.",
            "code": "a = np.array([[0, 1, 2],\n     [3, 4, 5]])\n\nb = np.array([[0, 1, 2, 3],\n     [4, 5, 6, 7],\n     [8, 9, 10, 11]])\n\nprint (np.dot(a,b))\n\n# array([[20, 23, 26, 29],\n#        [56, 68, 80, 92]])",
            "masked_code": "a = np.array([[0, 1, 2],\n     [3, 4, 5]])\n\n<line_mask>\n     [4, 5, 6, 7],\n     [8, 9, 10, 11]])\n\nprint (np.dot(a,b))\n\n# array([[20, 23, 26, 29],\n#        [56, 68, 80, 92]])",
            "masked_line": "b = np.array([[0, 1, 2, 3],",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1191"
        },
        {
            "dependency": "pyglet",
            "version": "==1.3",
            "time": "2019-06-09",
            "description": "This code returns the frames per second (fps) of the application using pyglet library's clock module.",
            "code": "pyglet.clock.get_fps()",
            "masked_code": "<line_mask>",
            "masked_line": "pyglet.clock.get_fps()",
            "answer": "clock",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1192"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-20",
            "description": "This code creates a new numpy array of the same shape and data type as the input array 'a' with all elements initialized to 0.",
            "code": "np.zeros_like(a)\n# array([0, 0, 0, 0, 0])",
            "masked_code": "<line_mask>\n# array([0, 0, 0, 0, 0])",
            "masked_line": "np.zeros_like(a)",
            "answer": "zeros_like",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1193"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-02-11",
            "description": "The code creates a numpy array with values [1, 2, 3] and then reshapes it to have each element in its own sublist, resulting in a list of lists where each inner list contains a single element.",
            "code": "x = np.array([1,2,3])\n\nx[:, np.newaxis].tolist()\n# [[1], [2], [3]]",
            "masked_code": "<line_mask>\n\nx[:, np.newaxis].tolist()\n# [[1], [2], [3]]",
            "masked_line": "x = np.array([1,2,3])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1194"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-17",
            "description": "The code saves the content of the variable \"mzplist\" to a CSV file named as \"filename\" in the folder specified by \"newfolder\". Each element in \"mzplist\" is separated by a comma in the CSV file.",
            "code": "np.savetxt(newfolder + '\\\\' + filename + '.csv', mzplist, delimiter=',')",
            "masked_code": "<line_mask>",
            "masked_line": "np.savetxt(newfolder + '\\\\' + filename + '.csv', mzplist, delimiter=',')",
            "answer": "savetxt",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1195"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-05",
            "description": "The code randomly selects rows from a DataFrame and replicates them 10 times.",
            "code": "df = df.iloc[np.random.choice(len(df), len(df) * 10)]",
            "masked_code": "<line_mask>",
            "masked_line": "df = df.iloc[np.random.choice(len(df), len(df) * 10)]",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1196"
        },
        {
            "dependency": "pandas",
            "version": ">=0.19",
            "time": "2019-11-27",
            "description": "This code filters the rows in the DataFrame 'df_indices' where the 'date' column is equal to June 22, 2019.",
            "code": "df_indices[df_indices['date'] == pd.Timestamp(year=2019,month=6,day=22).dt.date]",
            "masked_code": "<line_mask>",
            "masked_line": "df_indices[df_indices['date'] == pd.Timestamp(year=2019,month=6,day=22).dt.date]",
            "answer": "Timestamp",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1197"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-11-07",
            "description": "Generate a new vector of random numbers sampled from a normal distribution with a specified mean and variance.",
            "code": "newVect = np.random.normal(meanVect, varVect)",
            "masked_code": "<line_mask>",
            "masked_line": "newVect = np.random.normal(meanVect, varVect)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1198"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2019-07-10",
            "description": "The code takes a list of tuples containing boolean values, and generates a new list where each tuple is expanded to have the same boolean value repeated based on whether any element in the original tuple is True.",
            "code": "lst = [(True,False,True), (False,False,False), (False,False,True)]\nresult = [(np.any(x),) * len(x) for x in lst]\n\n# result is [(True, True, True), (False, False, False), (True, True, True)]",
            "masked_code": "lst = [(True,False,True), (False,False,False), (False,False,True)]\n<line_mask>\n\n# result is [(True, True, True), (False, False, False), (True, True, True)]",
            "masked_line": "result = [(np.any(x),) * len(x) for x in lst]",
            "answer": "any",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1199"
        },
        {
            "dependency": "dash",
            "version": "==2.0",
            "time": "2022-11-03",
            "description": "This code defines a callback function that displays a tooltip on a graph based on the hover data of a specified graph. The tooltip consists of an image and text content.",
            "code": "# Assuming app is your Dash app\n@app.callback(Output(\"graph-tooltip\", \"show\"), Output(\"graph-tooltip\", \"bbox\"),\n              Output(\"graph-tooltip\", \"children\"), Input(\"graph-basic-2\", \"hoverData\"),\n)\ndef display_hover(hoverData):\n    # ...\n    pt = hoverData[\"points\"][0]\n    bbox = pt[\"bbox\"]\n    # ...\n    # img_src is your image, e.g. from URL or b64 encoded\n    children = [\n        html.Div([\n            html.Img(src=img_src, style={\"width\": \"100%\"}),\n            html.P(\"Tooltip text\"),\n        ])\n    ]\n    return True, bbox, children",
            "masked_code": "# Assuming app is your Dash app\n<line_mask>\n              Output(\"graph-tooltip\", \"children\"), Input(\"graph-basic-2\", \"hoverData\"),\n)\ndef display_hover(hoverData):\n    # ...\n    pt = hoverData[\"points\"][0]\n    bbox = pt[\"bbox\"]\n    # ...\n    # img_src is your image, e.g. from URL or b64 encoded\n    children = [\n        html.Div([\n            html.Img(src=img_src, style={\"width\": \"100%\"}),\n            html.P(\"Tooltip text\"),\n        ])\n    ]\n    return True, bbox, children",
            "masked_line": "@app.callback(Output(\"graph-tooltip\", \"show\"), Output(\"graph-tooltip\", \"bbox\"),",
            "answer": "callback",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1200"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.1",
            "time": "2020-05-25",
            "description": "The code generates a pandas Series filled with NaN values, then fills NaN values with False, and finally performs a bitwise OR operation with another pandas Series filled with True values.",
            "code": "pd.Series([np.nan]).fillna(False) | pd.Series([True])",
            "masked_code": "<line_mask>",
            "masked_line": "pd.Series([np.nan]).fillna(False) | pd.Series([True])",
            "answer": "fillna",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1201"
        },
        {
            "dependency": "dash",
            "version": "==1.14.0",
            "time": "2020-08-13",
            "description": "The code initializes a web application using Dash framework and runs a server in debug mode with multi-threading enabled.",
            "code": "app = dash.Dash(__name__)\n# Dash code\nif __name__ == '__main__':\n  app.run_server(debug=True, threaded=True)",
            "masked_code": "app = dash.Dash(__name__)\n# Dash code\nif __name__ == '__main__':\n  <line_mask>",
            "masked_line": "app.run_server(debug=True, threaded=True)",
            "answer": "run_server",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1202"
        },
        {
            "dependency": "Telethon",
            "version": "==1.14.0",
            "time": "2020-06-04",
            "description": "The code establishes a connection to the Telegram API using the Telethon library, reads configuration settings from a file, and searches for contacts with a specific query (in this case, 'linux') on Telegram. It then prints out the search results.",
            "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# Tested with Telethon version 1.14.0\n\nimport configparser\nfrom telethon import TelegramClient\nfrom telethon.errors import SessionPasswordNeededError\nfrom telethon.sync import TelegramClient\nfrom telethon import functions, types\n\n# Reading Configs\nconfig = configparser.ConfigParser()\nconfig.read(\"config.ini\")\n\n# These example values won't work. You must get your own api_id and\n# api_hash from https://my.telegram.org, under API Development.\n# (1) Use your own values here\napi_id = config['Telegram']['api_id']\napi_hash = config['Telegram']['api_hash']\n\n# (2) Create the client and connect\nphone = config['Telegram']['phone']\nusername = config['Telegram']['username']\nclient = TelegramClient(username, api_id, api_hash)\n\nasync def main():\n    await client.start()\n    # Ensure you're authorized\n    if not await client.is_user_authorized():\n        await client.send_code_request(phone)\n        try:\n            await client.sign_in(phone, input('Enter the code: '))\n        except SessionPasswordNeededError:\n            await client.sign_in(password=input('Password: '))\n\n    search = 'linux'\n    result = await client(functions.contacts.SearchRequest(\n        q=search,\n        limit=100\n    ))\n    print(result.stringify())\n\nwith client:\n    client.loop.run_until_complete(main())",
            "masked_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# Tested with Telethon version 1.14.0\n\nimport configparser\nfrom telethon import TelegramClient\nfrom telethon.errors import SessionPasswordNeededError\nfrom telethon.sync import TelegramClient\nfrom telethon import functions, types\n\n# Reading Configs\nconfig = configparser.ConfigParser()\nconfig.read(\"config.ini\")\n\n# These example values won't work. You must get your own api_id and\n# api_hash from https://my.telegram.org, under API Development.\n# (1) Use your own values here\napi_id = config['Telegram']['api_id']\napi_hash = config['Telegram']['api_hash']\n\n# (2) Create the client and connect\nphone = config['Telegram']['phone']\nusername = config['Telegram']['username']\nclient = TelegramClient(username, api_id, api_hash)\n\nasync def main():\n    await client.start()\n    # Ensure you're authorized\n    if not await client.is_user_authorized():\n        await client.send_code_request(phone)\n        try:\n            <line_mask>\n        except SessionPasswordNeededError:\n            await client.sign_in(password=input('Password: '))\n\n    search = 'linux'\n    result = await client(functions.contacts.SearchRequest(\n        q=search,\n        limit=100\n    ))\n    print(result.stringify())\n\nwith client:\n    client.loop.run_until_complete(main())",
            "masked_line": "await client.sign_in(phone, input('Enter the code: '))",
            "answer": "sign_in",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1203"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-04-25",
            "description": "This code combines two graphs G and H into a new graph GH, and then returns the nodes present in the combined graph.",
            "code": "GH = nx.compose(G,H)\nGH.nodes()\n# NodeView(('A', 'C', 'D', 'I', 'F', 'K', 'E', 'B', 'Q', 'J', 'X'))",
            "masked_code": "GH = nx.compose(G,H)\n<line_mask>\n# NodeView(('A', 'C', 'D', 'I', 'F', 'K', 'E', 'B', 'Q', 'J', 'X'))",
            "masked_line": "GH.nodes()",
            "answer": "nodes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1204"
        },
        {
            "dependency": "cartopy",
            "version": "==0.15",
            "time": "2020-03-29",
            "description": "This function takes an xarray DataArray with dimensions (time, lat, lon), adds a cyclic point to the longitude dimension using the cartopy library, and returns a new DataArray with the same structure as the input but with the cyclic point added.",
            "code": "from cartopy.util import add_cyclic_point\nimport xarray as xr \n\ndef xr_add_cyclic_point(da):\n    \"\"\"\n    Inputs\n    da: xr.DataArray with dimensions (time,lat,lon)\n    \"\"\"\n\n    # Use add_cyclic_point to interpolate input data\n    lon_idx = da.dims.index('lon')\n    wrap_data, wrap_lon = add_cyclic_point(da.values, coord=da.lon, axis=lon_idx)\n\n    # Generate output DataArray with new data but same structure as input\n    outp_da = xr.DataArray(data=wrap_data, \n                           coords = {'time': da.time, 'lat': da.lat, 'lon': wrap_lon}, \n                           dims=da.dims, \n                           attrs=da.attrs)\n    \n    return outp_da",
            "masked_code": "<line_mask>\nimport xarray as xr \n\ndef xr_add_cyclic_point(da):\n    \"\"\"\n    Inputs\n    da: xr.DataArray with dimensions (time,lat,lon)\n    \"\"\"\n\n    # Use add_cyclic_point to interpolate input data\n    lon_idx = da.dims.index('lon')\n    wrap_data, wrap_lon = add_cyclic_point(da.values, coord=da.lon, axis=lon_idx)\n\n    # Generate output DataArray with new data but same structure as input\n    outp_da = xr.DataArray(data=wrap_data, \n                           coords = {'time': da.time, 'lat': da.lat, 'lon': wrap_lon}, \n                           dims=da.dims, \n                           attrs=da.attrs)\n    \n    return outp_da",
            "masked_line": "from cartopy.util import add_cyclic_point",
            "answer": "add_cyclic_point",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1205"
        },
        {
            "dependency": "requests-cache",
            "version": "==0.6.3",
            "time": "2020-04-26",
            "description": "This code installs a cache named 'example_cache' using the requests_cache library, which will store HTTP responses with status codes 200 and 404 for future use.",
            "code": "requests_cache.install_cache('example_cache', allowable_codes=(200, 404))",
            "masked_code": "<line_mask>",
            "masked_line": "requests_cache.install_cache('example_cache', allowable_codes=(200, 404))",
            "answer": "install_cache",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1206"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-11-11",
            "description": "The code performs binary erosion operation on a boolean array after checking for finite values, resulting in erosion of the binary image.",
            "code": "from scipy.ndimage.morphology import binary_erosion\n\nm = np.isfinite(a)\nout = binary_erosion(m, np.ones(w, dtype=bool))[w//2:len(a)-w+1+w//2]",
            "masked_code": "<line_mask>\n\nm = np.isfinite(a)\nout = binary_erosion(m, np.ones(w, dtype=bool))[w//2:len(a)-w+1+w//2]",
            "masked_line": "from scipy.ndimage.morphology import binary_erosion",
            "answer": "binary_erosion",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1207"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.22.2",
            "time": "2020-03-11",
            "description": "This function computes Receiver Operating Characteristic (ROC) curve to evaluate the performance of a binary classification model. It returns the false positive rate, true positive rate, and threshold values.",
            "code": "sklearn.metrics.roc_curve(y_true, y_score, pos_label=None, sample_weight=None, drop_intermediate=True)",
            "masked_code": "<line_mask>",
            "masked_line": "sklearn.metrics.roc_curve(y_true, y_score, pos_label=None, sample_weight=None, drop_intermediate=True)",
            "answer": "metrics",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1208"
        },
        {
            "dependency": "scrapy",
            "version": ">=1.7",
            "time": "2020-09-26",
            "description": "This code defines a spider named MySpider that scrapes data from a website. The parse method extracts titles and URLs from list items, sends requests to the detail page, and calls the parse_detail_page method. The parse_detail_page method extracts descriptions from the detail page and yields the title and description as key-value pairs.",
            "code": "class MySpider(scrapy.Spider):\n    name = \"my_spider\"\n\n    start_urls = ['https://example.com',]\n\n    def parse(self, response):\n        for li in response.xpath('//li'):\n            title = li.xpath('text()').get()\n            url_to_detail_page = li.xpath('a/@href').get()\n            yield scrapy.Request(\n                url=url_to_detail_page,\n                callback=self.parse_detail_page,\n                cb_kwargs={\n                    'title': title\n                })\n\n    def parse_detail_page(self, response, title):  # Notice title as a keyword arg\n        description = response.xpath('//div[@class=\"a-descrption\"]//text()').getall()\n        yield {\n            'title': title,\n            'description': description,\n        }",
            "masked_code": "class MySpider(scrapy.Spider):\n    name = \"my_spider\"\n\n    start_urls = ['https://example.com',]\n\n    def parse(self, response):\n        for li in response.xpath('//li'):\n            title = li.xpath('text()').get()\n            url_to_detail_page = li.xpath('a/@href').get()\n            <line_mask>\n                url=url_to_detail_page,\n                callback=self.parse_detail_page,\n                cb_kwargs={\n                    'title': title\n                })\n\n    def parse_detail_page(self, response, title):  # Notice title as a keyword arg\n        description = response.xpath('//div[@class=\"a-descrption\"]//text()').getall()\n        yield {\n            'title': title,\n            'description': description,\n        }",
            "masked_line": "yield scrapy.Request(",
            "answer": "Request",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1209"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-06-28",
            "description": "The code calculates all pairs shortest path lengths in a graph using the Floyd-Warshall algorithm.",
            "code": "nx.floyd_warshall(G_ig)",
            "masked_code": "<line_mask>",
            "masked_line": "nx.floyd_warshall(G_ig)",
            "answer": "floyd_warshall",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1210"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.0",
            "time": "2020-02-03",
            "description": "The code creates a DataFrame with information about different trip categories, start dates, end dates, and fares. It then generates a date range for each trip based on the start and end dates, explodes the date range into individual date rows, and drops the original start and end date columns from the DataFrame. Finally, it prints the updated DataFrame.",
            "code": "# Minimal example setup\ndf = pd.DataFrame({\n    'TRIPNAME': ['HIGHSEASON', 'LOWSEASON', 'MEDSEASON'],\n    'TRIPCAT': ['H', 'L', 'M'],\n    'STARTDATE' : ['01JAN20', '16SEP20', '29JAN20'],\n    'ENDDATE': ['15JAN20', '30NOV20', '19JUL20'],\n    'FARE': [345, 280, 250]\n})\n\n\ndf['DATE'] = [pd.date_range(s, e, freq='d') for s, e in\n              zip(pd.to_datetime(df['STARTDATE']),\n                  pd.to_datetime(df['ENDDATE']))]\n\ndf = df.explode('DATE').drop(['STARTDATE', 'ENDDATE'], axis=1)\n\nprint(df)",
            "masked_code": "# Minimal example setup\ndf = pd.DataFrame({\n    'TRIPNAME': ['HIGHSEASON', 'LOWSEASON', 'MEDSEASON'],\n    'TRIPCAT': ['H', 'L', 'M'],\n    'STARTDATE' : ['01JAN20', '16SEP20', '29JAN20'],\n    'ENDDATE': ['15JAN20', '30NOV20', '19JUL20'],\n    'FARE': [345, 280, 250]\n})\n\n\ndf['DATE'] = [pd.date_range(s, e, freq='d') for s, e in\n              zip(pd.to_datetime(df['STARTDATE']),\n                  pd.to_datetime(df['ENDDATE']))]\n\n<line_mask>\n\nprint(df)",
            "masked_line": "df = df.explode('DATE').drop(['STARTDATE', 'ENDDATE'], axis=1)",
            "answer": "drop",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1211"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-06-18",
            "description": "The code generates unique random numbers based on the total sum of Quota values in the DataFrame, combining them with the Prefix values repeated based on the Quota values and multiplied by 100000.",
            "code": "np.random.seed(2)  \nnumbers = np.random.choice(range(99999), size=df.Quota.sum(), replace=False)\nrandom = df.Prefix.repeat(df.Quota)*100000 + numbers",
            "masked_code": "np.random.seed(2)  \n<line_mask>\nrandom = df.Prefix.repeat(df.Quota)*100000 + numbers",
            "masked_line": "numbers = np.random.choice(range(99999), size=df.Quota.sum(), replace=False)",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1212"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-06-19",
            "description": "The code finds the roots of each weakly connected component in the graph G.",
            "code": "roots = []\nfor component in nx.weakly_connected_components(G):\n    G_sub = G.subgraph(component)\n    roots.extend([n for n,d in G_sub.in_degree() if d==0])",
            "masked_code": "roots = []\n<line_mask>\n    G_sub = G.subgraph(component)\n    roots.extend([n for n,d in G_sub.in_degree() if d==0])",
            "masked_line": "for component in nx.weakly_connected_components(G):",
            "answer": "weakly_connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1213"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-03-07",
            "description": "This code generates random 3D points within a spherical region defined by a center point and radius.",
            "code": "c = np.asarray(center)\nxx,yy,zz = np.random.uniform(c-radius, c+radius, size=(n,3)).T",
            "masked_code": "c = np.asarray(center)\n<line_mask>",
            "masked_line": "xx,yy,zz = np.random.uniform(c-radius, c+radius, size=(n,3)).T",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1214"
        },
        {
            "dependency": "pandas",
            "version": "==1.1",
            "time": "2020-07-13",
            "description": "The code extracts the version of the Pandas library being used and creates a PeriodIndex object based on the values in the 'col' column of a DataFrame, specifying a quarterly frequency starting from October.",
            "code": "pd.__version__\n# '1.1.0.dev0+2004.g8d10bfb6f'\n\npd.PeriodIndex(x['col'], freq='Q-Oct')\n# PeriodIndex(['2019Q1', '2019Q2', '2019Q3', '2019Q4', '2020Q1', '2020Q2'], \n#             dtype='period[Q-OCT]', freq='Q-OCT')",
            "masked_code": "pd.__version__\n# '1.1.0.dev0+2004.g8d10bfb6f'\n\n<line_mask>\n# PeriodIndex(['2019Q1', '2019Q2', '2019Q3', '2019Q4', '2020Q1', '2020Q2'], \n#             dtype='period[Q-OCT]', freq='Q-OCT')",
            "masked_line": "pd.PeriodIndex(x['col'], freq='Q-Oct')",
            "answer": "PeriodIndex",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1215"
        },
        {
            "dependency": "requests",
            "version": "==0.10.2",
            "time": "2020-06-12",
            "description": "The code sends a GET request to the specified URL using a client certificate for authentication and specifying a custom certification authority file for verification.",
            "code": "response = requests.get(url, cert=cert, verify=\"nifi_ca.pem\")",
            "masked_code": "<line_mask>",
            "masked_line": "response = requests.get(url, cert=cert, verify=\"nifi_ca.pem\")",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1216"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.4",
            "time": "2020-08-28",
            "description": "The code generates a pandas DataFrame `df_` by randomly selecting a user associated with each unique class from the original DataFrame `df`. Each row in the new DataFrame contains a user and the corresponding class it belongs to.",
            "code": "df_ = pd.DataFrame([\n    {'users': np.random.choice(df.loc[df['class'].eq(c), 'users']), 'class': c}\n    for c in df['class'].unique()])",
            "masked_code": "df_ = pd.DataFrame([\n    <line_mask>\n    for c in df['class'].unique()])",
            "masked_line": "{'users': np.random.choice(df.loc[df['class'].eq(c), 'users']), 'class': c}",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1217"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-09-15",
            "description": "The code creates a network visualization of a graph using matplotlib and networkx library in Python. It sets the figure size, positions the nodes in a circular layout, draws nodes with specified size, draws edges with different widths and styles, and labels the nodes with specified font size and family. Finally, it hides the axis and displays the graph visualization.",
            "code": "plt.figure(figsize=(10,6))\n\npos = nx.circular_layout(G)  # positions for all nodes\n# nodes\nnx.draw_networkx_nodes(G, pos, node_size=700)\n# edges\nnx.draw_networkx_edges(G, pos, edgelist=elarge, width=6)\nnx.draw_networkx_edges(\n    G, pos, edgelist=esmall, width=6, alpha=0.5, edge_color=\"b\", style=\"dashed\"\n)\n# labels\nnx.draw_networkx_labels(G, pos, font_size=20, font_family=\"sans-serif\")\n\nplt.axis(\"off\")\nplt.show()",
            "masked_code": "plt.figure(figsize=(10,6))\n\npos = nx.circular_layout(G)  # positions for all nodes\n# nodes\nnx.draw_networkx_nodes(G, pos, node_size=700)\n# edges\nnx.draw_networkx_edges(G, pos, edgelist=elarge, width=6)\nnx.draw_networkx_edges(\n    G, pos, edgelist=esmall, width=6, alpha=0.5, edge_color=\"b\", style=\"dashed\"\n)\n# labels\n<line_mask>\n\nplt.axis(\"off\")\nplt.show()",
            "masked_line": "nx.draw_networkx_labels(G, pos, font_size=20, font_family=\"sans-serif\")",
            "answer": "draw_networkx_labels",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1218"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2020-05-18",
            "description": "This code counts the number of elements in the array xx that are equal to None.",
            "code": "np.count_nonzero(xx == None)",
            "masked_code": "<line_mask>",
            "masked_line": "np.count_nonzero(xx == None)",
            "answer": "count_nonzero",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1219"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2020-07-09",
            "description": "The code reorders the elements of a multi-dimensional array 'a' based on sorting the first column of each sub-array along the second axis.",
            "code": "ixs = a[...,0].argsort(1)[...,None]\nnp.take_along_axis(a, ixs, 1)\n\narray([[[ 2,  2, 10,  2],\n        [ 7, 10,  3,  2],\n        [10, 12,  4,  2],\n        [12,  4,  2,  5]],\n\n       [[ 2,  2, 12,  1],\n        [ 7, 10,  3,  2],\n        [10, 12,  4,  2],\n        [13, 23,  4,  5]],\n\n       [[ 2,  2,  3,  2],\n        [ 4,  4,  2,  5],\n        [ 7, 10,  3,  2],\n        [10, 12,  4,  2]]])",
            "masked_code": "ixs = a[...,0].argsort(1)[...,None]\n<line_mask>\n\narray([[[ 2,  2, 10,  2],\n        [ 7, 10,  3,  2],\n        [10, 12,  4,  2],\n        [12,  4,  2,  5]],\n\n       [[ 2,  2, 12,  1],\n        [ 7, 10,  3,  2],\n        [10, 12,  4,  2],\n        [13, 23,  4,  5]],\n\n       [[ 2,  2,  3,  2],\n        [ 4,  4,  2,  5],\n        [ 7, 10,  3,  2],\n        [10, 12,  4,  2]]])",
            "masked_line": "np.take_along_axis(a, ixs, 1)",
            "answer": "take_along_axis",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1220"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24",
            "time": "2020-02-05",
            "description": "The code reads an Excel file and stores the data with specified data types for columns x and y.",
            "code": "df= pd.read_excel(excel_file, dtype={'column_x': 'Int64', 'column_y': 'Int64'})",
            "masked_code": "<line_mask>",
            "masked_line": "df= pd.read_excel(excel_file, dtype={'column_x': 'Int64', 'column_y': 'Int64'})",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1221"
        },
        {
            "dependency": "networkx",
            "version": "==1.7",
            "time": "2020-06-14",
            "description": "This code converts a numpy array into a graph object and retrieves the edges with their associated weights.",
            "code": "df.values\narray([[6, 0, 4, 0],\n       [0, 0, 0, 1],\n       [0, 2, 0, 0],\n       [1, 0, 4, 8]])\n\nG = nx.from_numpy_array(df.values)\n\nG.edges(data=True)\n#EdgeDataView([(0, 0, {'weight': 1}), (0, 2, {'weight': 1})...",
            "masked_code": "df.values\narray([[6, 0, 4, 0],\n       [0, 0, 0, 1],\n       [0, 2, 0, 0],\n       [1, 0, 4, 8]])\n\nG = nx.from_numpy_array(df.values)\n\n<line_mask>\n#EdgeDataView([(0, 0, {'weight': 1}), (0, 2, {'weight': 1})...",
            "masked_line": "G.edges(data=True)",
            "answer": "edges",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1222"
        },
        {
            "dependency": "vaex",
            "version": "==3.0.0",
            "time": "2020-06-04",
            "description": "The code adds a virtual range column to the dataframe and multiplies the values in that column by zero before adding the initial value of 111.",
            "code": "df['test'] = vaex.vrange(0, len(df))  # add a 'virtual range' column, which takes no memory\ndf['test'] = df['test']* 0 + 111  # multiply by zero, and add the initial value",
            "masked_code": "<line_mask>\ndf['test'] = df['test']* 0 + 111  # multiply by zero, and add the initial value",
            "masked_line": "df['test'] = vaex.vrange(0, len(df))  # add a 'virtual range' column, which takes no memory",
            "answer": "vrange",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1223"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-06-02",
            "description": "The code calculates the node connectivity between nodes 4 and 5 in the graph G, which is 2. It also determines that there is no minimum node cut between nodes 4 and 5.",
            "code": "nx.node_connectivity(G,4,5) \n# 2\nnx.minimum_node_cut(G, 4,5)\n#{}",
            "masked_code": "nx.node_connectivity(G,4,5) \n# 2\n<line_mask>\n#{}",
            "masked_line": "nx.minimum_node_cut(G, 4,5)",
            "answer": "minimum_node_cut",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1224"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.0",
            "time": "2020-02-07",
            "description": "This code groups the 'Subset' data by the columns 'Company ID', 'Company Name', 'Platform' and 'Date', and then aggregates the sum and count of 'Units in order' and 'Units delivered' for each group. It then resets the index of the resulting dataframe.",
            "code": "Subset = Subset.groupby(['Company ID', 'Company Name', 'Platform', 'Date']).agg(\n   Units_in_order_sum = pd.NamedAgg(column='Units in order', aggfunc='sum'),\n   Units_in_order_count = pd.NamedAgg(column='Units in order', aggfunc='count'),\n   Units_delivered_sum = pd.NamedAgg(column='Units delivered',aggfunc='sum'),\n   Units_delivered_count = pd.NamedAgg(column='Units delivered',aggfunc='count')).reset_index()",
            "masked_code": "Subset = Subset.groupby(['Company ID', 'Company Name', 'Platform', 'Date']).agg(\n   Units_in_order_sum = pd.NamedAgg(column='Units in order', aggfunc='sum'),\n   Units_in_order_count = pd.NamedAgg(column='Units in order', aggfunc='count'),\n   <line_mask>\n   Units_delivered_count = pd.NamedAgg(column='Units delivered',aggfunc='count')).reset_index()",
            "masked_line": "Units_delivered_sum = pd.NamedAgg(column='Units delivered',aggfunc='sum'),",
            "answer": "NamedAgg",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1225"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2020-01-29",
            "description": "This code generates a frequency count of dates within a range specified in each row of a DataFrame.",
            "code": "df.apply(lambda row: pd.date_range(row['START'], row['END']), axis=1) \\\n    .explode() \\\n    .value_counts() \\\n    .sort_index()",
            "masked_code": "<line_mask>\n    .explode() \\\n    .value_counts() \\\n    .sort_index()",
            "masked_line": "df.apply(lambda row: pd.date_range(row['START'], row['END']), axis=1) \\",
            "answer": "date_range",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1226"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.4",
            "time": "2020-11-05",
            "description": "The code assigns a random choice of 0 or 1 to the values in column 'col1' of a DataFrame where the original values were 'c'.",
            "code": "m = df['col1'].eq('c')\ndf['col1'] = df['col1'].map({'a':1, 'b':0, 'c':0})\n\ndf.loc[m, 'col1'] = np.random.choice([0,1], p=[0.5, 0.5], size=m.sum())",
            "masked_code": "m = df['col1'].eq('c')\ndf['col1'] = df['col1'].map({'a':1, 'b':0, 'c':0})\n\n<line_mask>",
            "masked_line": "df.loc[m, 'col1'] = np.random.choice([0,1], p=[0.5, 0.5], size=m.sum())",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1227"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.0",
            "time": "2020-08-05",
            "description": "The code assigns a boolean value to the 'sortkey' column in dataframe df1 based on whether the 'Country' column contains duplicated values. It then sets the column labels of dataframe df2 to be the same as the columns of df1 excluding the last column. Additionally, it assigns a numeric value to the 'sortkey' column in df1 based on whether the 'Country' column contains duplicated values, replacing True with 2 and False with 0. Finally, it concatenates df1 and df2, sorts the resulting dataframe by 'Country' and 'sortkey', and assigns the 'Id' column of each group in 'Country' the value of the first 'Id' within that group. The code then outputs the sorted dataframe without the 'sortkey' column.",
            "code": "df1['sortkey'] = df1['Country'].duplicated()\ndf2 = df2.set_axis(df1.columns[:-1], axis=1)\n\ndf1['sortkey'] = df1['Country'].duplicated().replace({True:2, False:0})\ndf_sorted = (pd.concat([df1, df2.assign(sortkey=1)])\n               .sort_values(['Country', 'sortkey'], \n                            key=lambda x: x.astype(str).str.split(' ').str[0]))\n\ndf_sorted['Id'] = df_sorted.groupby(df_sorted['Country'].str.split(' ').str[0])['Id'].transform('first')\nprint(df_sorted.drop('sortkey', axis=1))",
            "masked_code": "df1['sortkey'] = df1['Country'].duplicated()\ndf2 = df2.set_axis(df1.columns[:-1], axis=1)\n\ndf1['sortkey'] = df1['Country'].duplicated().replace({True:2, False:0})\ndf_sorted = (pd.concat([df1, df2.assign(sortkey=1)])\n               .sort_values(['Country', 'sortkey'], \n                            key=lambda x: x.astype(str).str.split(' ').str[0]))\n\n<line_mask>\nprint(df_sorted.drop('sortkey', axis=1))",
            "masked_line": "df_sorted['Id'] = df_sorted.groupby(df_sorted['Country'].str.split(' ').str[0])['Id'].transform('first')",
            "answer": "split",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1228"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-07-23",
            "description": "The code generates a lollipop graph with 4 nodes forming a cycle connected to 3 additional nodes in a line, and then converts the graph into an array of adjacency lists.",
            "code": "G = nx.lollipop_graph(4, 3)\nnp.array(list(nx.generate_adjlist(G)))\n# array(['0 1 2 3', '1 2 3', '2 3', '3 4', '4 5', '5 6', '6'], dtype='",
            "masked_code": "<line_mask>\nnp.array(list(nx.generate_adjlist(G)))\n# array(['0 1 2 3', '1 2 3', '2 3', '3 4', '4 5', '5 6', '6'], dtype='",
            "masked_line": "G = nx.lollipop_graph(4, 3)",
            "answer": "lollipop_graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1229"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.1",
            "time": "2020-03-12",
            "description": "The code calculates the time 60 minutes ago in UTC timezone.",
            "code": "time_to_compare = pd.to_datetime(datetime.utcnow()-timedelta(minutes=60), utc=True)",
            "masked_code": "<line_mask>",
            "masked_line": "time_to_compare = pd.to_datetime(datetime.utcnow()-timedelta(minutes=60), utc=True)",
            "answer": "to_datetime",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1230"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1",
            "time": "2020-03-06",
            "description": "This code defines a class called Cutout, which takes the number of holes and side length as parameters. The __call__ method of this class applies a cutout augmentation technique to an image by creating holes in the image and replacing the contents of those holes with zeros. The locations of the holes are randomly chosen within the image dimensions and the size of each hole is determined by the side length parameter. The resulting image with the cutout applied is then returned.",
            "code": "class Cutout:\n\n    def __init__(self, num_holes, side_length):\n        self.n = num_holes\n        self.length = side_length\n\n    def __call__(self, image):\n        tf.cast(image, tf.float32)\n        zeros = tf.zeros_like(image)  # used in last step\n        img_shape = tf.shape(image)\n        rows = img_shape[0]\n        cols = img_shape[1]\n        num_channels = img_shape[-1]\n\n        # We want to build all combinations of indices in any hole.\n        # Here I create `n` tiles of all row/col indices, basically handling\n        # each hole in a different layer of the resulting tensor.\n        row_range = tf.tile(tf.range(rows)[..., tf.newaxis], [1, self.n])\n        col_range = tf.tile(tf.range(cols)[..., tf.newaxis], [1, self.n])\n\n        # Generate all of our starting indices at once.\n        r_idx = tf.random.uniform([self.n], minval=0, maxval=rows-1, dtype=tf.int32)\n        c_idx = tf.random.uniform([self.n], minval=0, maxval=cols-1, dtype=tf.int32)\n\n        # With broadcasting, these operations work for our tensor of\n        # `n` row/column center points.\n        r1 = tf.clip_by_value(r_idx - self.length // 2, 0, rows)\n        r2 = tf.clip_by_value(r_idx + self.length // 2, 0, rows)\n        c1 = tf.clip_by_value(c_idx - self.length // 2, 0, cols)\n        c2 = tf.clip_by_value(c_idx + self.length // 2, 0, cols)\n\n        # By refactoring here, we can take advantage of broadcasting\n        # to build masks for each hole, one per layer in the last\n        # dimension of our resulting masks\n        row_mask = (row_range > r1) & (row_range < r2)\n        col_mask = (col_range > c1) & (col_range < c2)\n\n        mask = row_mask[:, tf.newaxis] & col_mask\n        mask = tf.reduce_any(mask, axis=-1)  # Combine mask layers into one\n        mask = mask[..., tf.newaxis]  # Copy mask across channels\n        mask = tf.tile(mask, [1, 1, num_channels])\n\n        # Finally we apply our mask with `tf.where`.\n        filtered_image = tf.where(mask, zeros, image)\n        return filtered_image",
            "masked_code": "class Cutout:\n\n    def __init__(self, num_holes, side_length):\n        self.n = num_holes\n        self.length = side_length\n\n    def __call__(self, image):\n        <line_mask>\n        zeros = tf.zeros_like(image)  # used in last step\n        img_shape = tf.shape(image)\n        rows = img_shape[0]\n        cols = img_shape[1]\n        num_channels = img_shape[-1]\n\n        # We want to build all combinations of indices in any hole.\n        # Here I create `n` tiles of all row/col indices, basically handling\n        # each hole in a different layer of the resulting tensor.\n        row_range = tf.tile(tf.range(rows)[..., tf.newaxis], [1, self.n])\n        col_range = tf.tile(tf.range(cols)[..., tf.newaxis], [1, self.n])\n\n        # Generate all of our starting indices at once.\n        r_idx = tf.random.uniform([self.n], minval=0, maxval=rows-1, dtype=tf.int32)\n        c_idx = tf.random.uniform([self.n], minval=0, maxval=cols-1, dtype=tf.int32)\n\n        # With broadcasting, these operations work for our tensor of\n        # `n` row/column center points.\n        r1 = tf.clip_by_value(r_idx - self.length // 2, 0, rows)\n        r2 = tf.clip_by_value(r_idx + self.length // 2, 0, rows)\n        c1 = tf.clip_by_value(c_idx - self.length // 2, 0, cols)\n        c2 = tf.clip_by_value(c_idx + self.length // 2, 0, cols)\n\n        # By refactoring here, we can take advantage of broadcasting\n        # to build masks for each hole, one per layer in the last\n        # dimension of our resulting masks\n        row_mask = (row_range > r1) & (row_range < r2)\n        col_mask = (col_range > c1) & (col_range < c2)\n\n        mask = row_mask[:, tf.newaxis] & col_mask\n        mask = tf.reduce_any(mask, axis=-1)  # Combine mask layers into one\n        mask = mask[..., tf.newaxis]  # Copy mask across channels\n        mask = tf.tile(mask, [1, 1, num_channels])\n\n        # Finally we apply our mask with `tf.where`.\n        filtered_image = tf.where(mask, zeros, image)\n        return filtered_image",
            "masked_line": "tf.cast(image, tf.float32)",
            "answer": "cast",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1231"
        },
        {
            "dependency": "Flask",
            "version": "==1.1.1",
            "time": "2020-02-14",
            "description": "This code defines a basic Flask application with a route that returns a greeting message 'Hello World!' when a user accesses the root URL '/'.",
            "code": "# [START gae_python37_app]\nfrom flask import Flask\nimport pyzbar\n\napp = Flask(__name__)\n\n\n@app.route('/')\ndef hello():\n   \"\"\"Return a friendly HTTP greeting.\"\"\"\n   return 'Hello World!'",
            "masked_code": "# [START gae_python37_app]\nfrom flask import Flask\nimport pyzbar\n\napp = Flask(__name__)\n\n\n<line_mask>\ndef hello():\n   \"\"\"Return a friendly HTTP greeting.\"\"\"\n   return 'Hello World!'",
            "masked_line": "@app.route('/')",
            "answer": "route",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1232"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-02-04",
            "description": "This code calculates the squared loss between two constant tensors y and y_hat using TensorFlow.",
            "code": "y_hat = tf.constant(36)\ny = tf.constant(39)\n\nloss = tf.Variable((y-y_hat)**2)\n\nprint(loss.numpy())",
            "masked_code": "y_hat = tf.constant(36)\ny = tf.constant(39)\n\n<line_mask>\n\nprint(loss.numpy())",
            "masked_line": "loss = tf.Variable((y-y_hat)**2)",
            "answer": "Variable",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1233"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2020-05-20",
            "description": "The code takes a dictionary 'd', converts it into a pandas Series, explodes the Series so that each element in the Series becomes a separate row, and then applies pd.Series to each element in order to split them into separate columns.",
            "code": "df=pd.Series(d).explode().apply(pd.Series)",
            "masked_code": "<line_mask>",
            "masked_line": "df=pd.Series(d).explode().apply(pd.Series)",
            "answer": "explode",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1234"
        },
        {
            "dependency": "numpy",
            "version": "==1.17",
            "time": "2020-06-06",
            "description": "This code generates an array of random integers between 1 and the elements of the array [2, 5, 7].",
            "code": "In [22]: rng = np.random.default_rng()                                          \n\nIn [23]: f = np.array([2, 5, 7])                                                \n\nIn [24]: rng.integers(1, f + 1)                                                 \nOut[24]: array([2, 4, 6])",
            "masked_code": "In [22]: rng = np.random.default_rng()                                          \n\n<line_mask>\n\nIn [24]: rng.integers(1, f + 1)                                                 \nOut[24]: array([2, 4, 6])",
            "masked_line": "In [23]: f = np.array([2, 5, 7])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1235"
        },
        {
            "dependency": "httpx",
            "version": ">=0.14.0",
            "time": "2021-10-12",
            "description": "The code instantiates a client that makes ASGI requests with a specified client IP address and port number, and then sends asynchronous requests using this client to a specified base URL.",
            "code": "# Instantiate a client that makes ASGI requests with a client IP of \"1.2.3.4\",\n# on port 123.\ntransport = httpx.ASGITransport(app=app, raise_app_exceptions=False,\n client=(\"1.2.3.4\", 123))\nasync with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n    ...",
            "masked_code": "# Instantiate a client that makes ASGI requests with a client IP of \"1.2.3.4\",\n# on port 123.\n<line_mask>\n client=(\"1.2.3.4\", 123))\nasync with httpx.AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n    ...",
            "masked_line": "transport = httpx.ASGITransport(app=app, raise_app_exceptions=False,",
            "answer": "ASGITransport",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1236"
        },
        {
            "dependency": "django",
            "version": "==3.2",
            "time": "2021-09-26",
            "description": "The code concatenates the fields \"lab_number\", \"patient_name\", and \"specimen_type\" from the queryset into a new field called \"specimen_name\" with \"_\" as a separator.",
            "code": "from django.db.models import Value\nfrom django.db.models.functions import Concat\n\n\nqueryset = queryset.annotate(\n    specimen_name=Concat(\"lab_number\", Value(\"_\"), \"patient_name\", Value(\"_\"), \"specimen_type\")\n)\n# Note: If you use Django version >=3.2 you can use \"alias\" instead of \"annotate\"",
            "masked_code": "from django.db.models import Value\nfrom django.db.models.functions import Concat\n\n\nqueryset = queryset.annotate(\n    <line_mask>\n)\n# Note: If you use Django version >=3.2 you can use \"alias\" instead of \"annotate\"",
            "masked_line": "specimen_name=Concat(\"lab_number\", Value(\"_\"), \"patient_name\", Value(\"_\"), \"specimen_type\")",
            "answer": "Concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1237"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-06-03",
            "description": "The code generates a line plot using seaborn library, with 'date' on the x-axis, 'value' on the y-axis, and different lines colored by 'variable' and styled by 'class'. It also allows for formatting of the x-axis using a Date Formatter (commented out in the code).",
            "code": "# plot with seaborn\np = sns.relplot(data=df, kind='line', x='date', y='value', hue='variable', style='class', height=4, aspect=2, marker='o')\n\n# format the x-axis - use as needed\n# xfmt = mdates.DateFormatter('%Y-%m')\n# p.axes[0, 0].xaxis.set_major_formatter(xfmt)",
            "masked_code": "# plot with seaborn\n<line_mask>\n\n# format the x-axis - use as needed\n# xfmt = mdates.DateFormatter('%Y-%m')\n# p.axes[0, 0].xaxis.set_major_formatter(xfmt)",
            "masked_line": "p = sns.relplot(data=df, kind='line', x='date', y='value', hue='variable', style='class', height=4, aspect=2, marker='o')",
            "answer": "relplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1238"
        },
        {
            "dependency": "pyttsx3",
            "version": "==2.6",
            "time": "2021-10-16",
            "description": "The code generates speech using pyttsx3, iterating through different voices and speaking the sentence \"The quick brown fox jumped over the lazy dog\" with each voice.",
            "code": "engine = pyttsx3.init()\nvoices = engine.getProperty('voices')\nfor voice in voices:\n  engine.setProperty('voice', voice.id)\n  engine.say('The quick brown fox jumped over the lazy dog.')\nengine.runAndWait()",
            "masked_code": "<line_mask>\nvoices = engine.getProperty('voices')\nfor voice in voices:\n  engine.setProperty('voice', voice.id)\n  engine.say('The quick brown fox jumped over the lazy dog.')\nengine.runAndWait()",
            "masked_line": "engine = pyttsx3.init()",
            "answer": "init",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1239"
        },
        {
            "dependency": "boto3",
            "version": "==1.18.18",
            "time": "2021-09-16",
            "description": "This function retrieves the MD5 hash value of a file stored in an S3 bucket by sending a HEAD request to the specified bucket and key, then strips the quotation marks from the etag value and returns it.",
            "code": "def GetMD5(bucket, key):\n        s3_cli = boto3.client('s3')\n        response = s3_cli.head_object(Bucket=bucket, Key=key)\n        return response['ResponseMetadata']['HTTPHeaders']['etag'].strip('\"')",
            "masked_code": "def GetMD5(bucket, key):\n        s3_cli = boto3.client('s3')\n        <line_mask>\n        return response['ResponseMetadata']['HTTPHeaders']['etag'].strip('\"')",
            "masked_line": "response = s3_cli.head_object(Bucket=bucket, Key=key)",
            "answer": "head_object",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1240"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4",
            "time": "2021-11-23",
            "description": "The code creates a staircase plot using a histogram of the data in the variable \"my_list\". The y-axis is set to a log scale and the x-axis is also set to a log scale.",
            "code": "plt.stairs(*np.histogram(my_list))\nplt.yscale('log')\nplt.xscale('log')",
            "masked_code": "plt.stairs(*np.histogram(my_list))\n<line_mask>\nplt.xscale('log')",
            "masked_line": "plt.yscale('log')",
            "answer": "yscale",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1241"
        },
        {
            "dependency": "tensorflow",
            "version": ">=2.2.0",
            "time": "2022-05-18",
            "description": "This code sets the image data format to 'channels_last' in TensorFlow's Keras backend.",
            "code": "tf.keras.backend.set_image_data_format('channels_last')",
            "masked_code": "<line_mask>",
            "masked_line": "tf.keras.backend.set_image_data_format('channels_last')",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1242"
        },
        {
            "dependency": "pyparsing",
            "version": "==2.4.7",
            "time": "2021-04-19",
            "description": "The code constructs a parser using pyparsing to parse a query string that may contain a LIMIT clause followed by an integer number, and then parses the query string \"LIMIT 1\" to extract and display the parsed result containing the LIMIT clause and the integer number.",
            "code": "import pyparsing\n\n# construct parser\nLIMIT = 'LIMIT'\nint_num = pyparsing.pyparsing_common.signed_integer()\nlimit_clause = pyparsing.Optional(pyparsing.Group(LIMIT + int_num), None)\nstatement = limit_clause('limit')\n# parse a string\nquery = 'LIMIT 1'\nresult = statement.parseString(query)\nprint(repr(result))",
            "masked_code": "import pyparsing\n\n# construct parser\nLIMIT = 'LIMIT'\n<line_mask>\nlimit_clause = pyparsing.Optional(pyparsing.Group(LIMIT + int_num), None)\nstatement = limit_clause('limit')\n# parse a string\nquery = 'LIMIT 1'\nresult = statement.parseString(query)\nprint(repr(result))",
            "masked_line": "int_num = pyparsing.pyparsing_common.signed_integer()",
            "answer": "signed_integer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1243"
        },
        {
            "dependency": "numpy",
            "version": ">=1.7.0",
            "time": "2021-02-27",
            "description": "This function calculates the sum of element-wise multiplication of reshaped arrays x, y, and matrix.",
            "code": "def my_func(x, y, matrix):\n    x = np.reshape(x, x.shape + (1,) * (y.ndim + 1))\n    y = np.reshape(y, y.shape + (1,))\n    return (x * y * matrix.ravel()).sum(axis=-1)",
            "masked_code": "def my_func(x, y, matrix):\n    <line_mask>\n    y = np.reshape(y, y.shape + (1,))\n    return (x * y * matrix.ravel()).sum(axis=-1)",
            "masked_line": "x = np.reshape(x, x.shape + (1,) * (y.ndim + 1))",
            "answer": "reshape",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1244"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-17",
            "description": "The code creates a violin plot using Seaborn library, showing the distribution of the 'y' values across different categories of 'x' with the additional grouping by 'z selection'. The size of the plot is set to 9 inches in width and 6 inches in height.",
            "code": "ax = sns.violinplot(x='x', y='y', data=dfnew, hue='z selection')\nax.figure.set_size_inches(9, 6)",
            "masked_code": "<line_mask>\nax.figure.set_size_inches(9, 6)",
            "masked_line": "ax = sns.violinplot(x='x', y='y', data=dfnew, hue='z selection')",
            "answer": "violinplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1245"
        },
        {
            "dependency": "pytest",
            "version": "==6.2.4",
            "time": "2021-06-24",
            "description": "This code defines a test class that contains a test method. The test method takes in username and password as parameters and prints them. The test method is parameterized with multiple sets of username and password values.",
            "code": "@pytest.mark.repeat(2)\nclass Test:\n    @pytest.mark.parametrize(\n        \"username, password\",\n        [(\"abc@abc.com\", \"aaa\"), (\"def@def.com\", \"ddd\"), (\"efg@efg.com\", \"eee\")],\n    )\n    def test(self, username, password):\n        print(username, password)",
            "masked_code": "<line_mask>\nclass Test:\n    @pytest.mark.parametrize(\n        \"username, password\",\n        [(\"abc@abc.com\", \"aaa\"), (\"def@def.com\", \"ddd\"), (\"efg@efg.com\", \"eee\")],\n    )\n    def test(self, username, password):\n        print(username, password)",
            "masked_line": "@pytest.mark.repeat(2)",
            "answer": "mark",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1246"
        },
        {
            "dependency": "pandas",
            "version": ">=1.2.0",
            "time": "2021-02-06",
            "description": "The given code creates a pandas Series from a dictionary and then expands or \"explodes\" the Series by splitting the values into separate rows.",
            "code": "pd.Series(dictionary).explode()",
            "masked_code": "<line_mask>",
            "masked_line": "pd.Series(dictionary).explode()",
            "answer": "Series",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1247"
        },
        {
            "dependency": "numpy",
            "version": ">=1.20",
            "time": "2021-06-28",
            "description": "The code creates a sliding window view of the 'ainput' array with a shape of (3, 100) to allow for moving windows over the array along the specified axes (0 and 1).",
            "code": "aoutput = np.lib.stride_tricks.sliding_window_view(ainput, (3, 100), axis=(0, 1))",
            "masked_code": "<line_mask>",
            "masked_line": "aoutput = np.lib.stride_tricks.sliding_window_view(ainput, (3, 100), axis=(0, 1))",
            "answer": "lib",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1248"
        },
        {
            "dependency": "pytest",
            "version": "==2.5.2",
            "time": "2021-01-28",
            "description": "The code defines two test functions \"test_foo\" and \"test_bar\", where both tests assert True, with \"test_foo\" marked as order2 and \"test_bar\" marked as order1.",
            "code": "import pytest\n\n@pytest.mark.order2\ndef test_foo():\n    assert True\n\n@pytest.mark.order1\ndef test_bar():\n    assert True",
            "masked_code": "import pytest\n\n@pytest.mark.order2\ndef test_foo():\n    assert True\n\n<line_mask>\ndef test_bar():\n    assert True",
            "masked_line": "@pytest.mark.order1",
            "answer": "order1",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1249"
        },
        {
            "dependency": "pandas",
            "version": ">=1.2.0",
            "time": "2021-12-07",
            "description": "The code merges the 'SUBMISSION' and 'CLOSE' columns from a DataFrame using a cross-merge. It then calculates the sum of all 'CLOSE - SUBMISSION' values for each unique 'CLOSE' value, creating a new column named 'ACCUM'. Finally, the result is merged back to the original DataFrame based on the 'CLOSE' column.",
            "code": "m = pd.merge(df.SUBMISSION, df.CLOSE, how='cross') # cross-merge for all SUBMISSION x CLOSE combos\n\naccum = (m.where(m.CLOSE > m.SUBMISSION)           # limit to CLOSE > SUBMISSION\n          .groupby('CLOSE').SUBMISSION             # group by CLOSE\n          .apply(lambda g: (g.name - g).sum())     # sum of all (CLOSE - SUBMISSION)\n          .rename('ACCUM'))\n\ndf.merge(accum, on='CLOSE')                        # merge back to df",
            "masked_code": "m = pd.merge(df.SUBMISSION, df.CLOSE, how='cross') # cross-merge for all SUBMISSION x CLOSE combos\n\naccum = (m.where(m.CLOSE > m.SUBMISSION)           # limit to CLOSE > SUBMISSION\n          .groupby('CLOSE').SUBMISSION             # group by CLOSE\n          .apply(lambda g: (g.name - g).sum())     # sum of all (CLOSE - SUBMISSION)\n          .rename('ACCUM'))\n\n<line_mask>",
            "masked_line": "df.merge(accum, on='CLOSE')                        # merge back to df",
            "answer": "merge",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1250"
        },
        {
            "dependency": "pandas",
            "version": ">=1.3.0",
            "time": "2021-10-13",
            "description": "The code reads a CSV file named 'df1.csv' and warns about any bad lines encountered during the reading process.",
            "code": "df1 = pd.read_csv('df1.csv', on_bad_lines='warn')",
            "masked_code": "<line_mask>",
            "masked_line": "df1 = pd.read_csv('df1.csv', on_bad_lines='warn')",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1251"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-08-29",
            "description": "This code reads an Excel file named \"foo.xls\" using the openpyxl engine.",
            "code": "df = pd.read_excel(\"foo.xls\", engine=\"openpyxl\")\n#                             ^^^^^^^^^^^^^^^^^",
            "masked_code": "<line_mask>\n#                             ^^^^^^^^^^^^^^^^^",
            "masked_line": "df = pd.read_excel(\"foo.xls\", engine=\"openpyxl\")",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1252"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.4.2",
            "time": "2021-08-24",
            "description": "The code sets custom tick labels on the colorbar's y-axis.",
            "code": "cbar = plt.colorbar(ticks = [0,1], values = [0,1])\ncbar.ax.get_yaxis().set_ticks([0, 0.25, 0.5, 0.75, 1]) # pass the array of labels you want",
            "masked_code": "<line_mask>\ncbar.ax.get_yaxis().set_ticks([0, 0.25, 0.5, 0.75, 1]) # pass the array of labels you want",
            "masked_line": "cbar = plt.colorbar(ticks = [0,1], values = [0,1])",
            "answer": "colorbar",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1253"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.5.0",
            "time": "2021-08-04",
            "description": "The code initializes an RMSprop optimizer with a learning rate of 0.0001.",
            "code": "optimizer=tf.keras.optimizers.RMSprop(1e-4)",
            "masked_code": "<line_mask>",
            "masked_line": "optimizer=tf.keras.optimizers.RMSprop(1e-4)",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1254"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-07-27",
            "description": "The code creates a scatter plot using the data in the DataFrame 'd', where the 'x' values are plotted on the x-axis, the 'y' values are plotted on the y-axis, and the different categories of 'type' are represented by different colors on the plot.",
            "code": "d = pd.DataFrame([[\"a\", 1,3], [\"b\", 3,3], [\"b\", 2,3], [\"a\", 5,2]], columns=['type', 'x', 'y'])\nd['type'] = pd.Categorical(d['type'])\nd.plot.scatter(x='x', y='y', c='type', cmap='inferno')\nplt.show()",
            "masked_code": "d = pd.DataFrame([[\"a\", 1,3], [\"b\", 3,3], [\"b\", 2,3], [\"a\", 5,2]], columns=['type', 'x', 'y'])\nd['type'] = pd.Categorical(d['type'])\n<line_mask>\nplt.show()",
            "masked_line": "d.plot.scatter(x='x', y='y', c='type', cmap='inferno')",
            "answer": "scatter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1255"
        },
        {
            "dependency": "PyAutoGUI",
            "version": ">=0.9.41",
            "time": "2021-10-25",
            "description": "The code scrolls the screen until it finds images \"findaname.png\", \"topleft.png\", and \"topright.png\". Once all three images are found, the variable allsat is set to True to stop scrolling.",
            "code": "def scrolluntil():\n    allsat = False\n    fan    = False\n    tl     = False\n    tr     = False\n    while allsat == False:\n        pyautogui.scroll(-100)\n        if fan == False:\n            if locateCenterOnScreen(\"findaname.png\") is not None:\n                fan = True\n        if tl == False:\n            if locateCenterOnScreen(\"topleft.png\") is not None:\n                tl = True\n        if tr == False:\n            if locateCenterOnScreen(\"topright.png\") is not None:\n                tr = True\n        if fan:\n            if tl:\n                if tr:\n                    allsat = True",
            "masked_code": "def scrolluntil():\n    allsat = False\n    fan    = False\n    tl     = False\n    tr     = False\n    while allsat == False:\n        <line_mask>\n        if fan == False:\n            if locateCenterOnScreen(\"findaname.png\") is not None:\n                fan = True\n        if tl == False:\n            if locateCenterOnScreen(\"topleft.png\") is not None:\n                tl = True\n        if tr == False:\n            if locateCenterOnScreen(\"topright.png\") is not None:\n                tr = True\n        if fan:\n            if tl:\n                if tr:\n                    allsat = True",
            "masked_line": "pyautogui.scroll(-100)",
            "answer": "scroll",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1256"
        },
        {
            "dependency": "discord.py",
            "version": "==2.0",
            "time": "2022-08-25",
            "description": "The code initializes and configures Discord intents for a Python program.",
            "code": "intents = discord.Intents.all()",
            "masked_code": "<line_mask>",
            "masked_line": "intents = discord.Intents.all()",
            "answer": "all",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1257"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2022-03-08",
            "description": "The code calculates a probability distribution 'p' by setting the last element of 'p' to be 1 minus the sum of all elements except the last one. It then uses numpy random.choice function to select a random element from array 'x' based on the calculated probabilities 'p'.",
            "code": "p[-1] = 1 - np.sum(p[0:-1])\nnp.random.choice(x, p = p)",
            "masked_code": "<line_mask>\nnp.random.choice(x, p = p)",
            "masked_line": "p[-1] = 1 - np.sum(p[0:-1])",
            "answer": "sum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1258"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.0",
            "time": "2022-01-19",
            "description": "This code defines a function called TestModel that creates a model using two sets of input data (in_1 and in_2). Each input data set goes through a convolutional layer with LeakyReLU activation and global average pooling. The outputs of these two branches are then concatenated, followed by spatial dropout and a dense layer with 1000 units. Finally, it creates a Keras model with the specified inputs and output, and returns the model. The model summary and visualization are then generated using tf.keras utilities.",
            "code": "def TestModel():\n  # specify the input shape\n  in_1 = tf.keras.layers.Input(shape = (256,256,3))\n  in_2 = tf.keras.layers.Input(shape = (256,256,3))\n\n  x1 = tf.keras.layers.Conv2D(64, (3,3))(in_1)\n  x1 = tf.keras.layers.LeakyReLU()(x1)\n  x1 = tf.keras.layers.GlobalAveragePooling2D(keepdims = True)(x1)\n\n  x2 = tf.keras.layers.Conv2D(64, (3,3))(in_2)\n  x2 = tf.keras.layers.LeakyReLU()(x2)\n  x2 = tf.keras.layers.GlobalAveragePooling2D(keepdims = True)(x2)\n \n  x = tf.keras.layers.concatenate([x1,x2])\n  x = tf.keras.layers.SpatialDropout2D(0.2)(x)\n  x = tf.keras.layers.Dense(1000)(x)\n\n  # create the model\n  model = tf.keras.Model(inputs=(in_1,in_2), outputs=x)\n\n  return model\n\n#Testcode\nmodel = TestModel()\nmodel.summary()\ntf.keras.utils.plot_model(model, show_shapes=True, expand_nested=False, show_dtype=True, to_file=\"model.png\")",
            "masked_code": "def TestModel():\n  # specify the input shape\n  in_1 = tf.keras.layers.Input(shape = (256,256,3))\n  in_2 = tf.keras.layers.Input(shape = (256,256,3))\n\n  x1 = tf.keras.layers.Conv2D(64, (3,3))(in_1)\n  x1 = tf.keras.layers.LeakyReLU()(x1)\n  x1 = tf.keras.layers.GlobalAveragePooling2D(keepdims = True)(x1)\n\n  x2 = tf.keras.layers.Conv2D(64, (3,3))(in_2)\n  x2 = tf.keras.layers.LeakyReLU()(x2)\n  x2 = tf.keras.layers.GlobalAveragePooling2D(keepdims = True)(x2)\n \n  <line_mask>\n  x = tf.keras.layers.SpatialDropout2D(0.2)(x)\n  x = tf.keras.layers.Dense(1000)(x)\n\n  # create the model\n  model = tf.keras.Model(inputs=(in_1,in_2), outputs=x)\n\n  return model\n\n#Testcode\nmodel = TestModel()\nmodel.summary()\ntf.keras.utils.plot_model(model, show_shapes=True, expand_nested=False, show_dtype=True, to_file=\"model.png\")",
            "masked_line": "x = tf.keras.layers.concatenate([x1,x2])",
            "answer": "concatenate",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1259"
        },
        {
            "dependency": "pandas",
            "version": ">1.4.0",
            "time": "2022-03-17",
            "description": "This code creates an ExcelWriter object in append mode for writing data to an Excel file with the specified path, using the openpyxl engine, and overlaying sheets if they already exist.",
            "code": "pd.ExcelWriter(path, engine='openpyxl', mode='a', if_sheet_exists='overlay')",
            "masked_code": "<line_mask>",
            "masked_line": "pd.ExcelWriter(path, engine='openpyxl', mode='a', if_sheet_exists='overlay')",
            "answer": "ExcelWriter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1260"
        },
        {
            "dependency": "discord.py",
            "version": ">=2.0",
            "time": "2022-09-23",
            "description": "The function sets up a Discord bot using the discord library with specified intents. It prints a message when the bot is running and responds to messages by printing the username, message content, and channel only if the message is not sent by the bot itself.",
            "code": "def run_discord_bot():\n    intents = discord.Intents.default()  \n    intents.message_content = True\n    client = discord.Client(intents = intents)\n\n    @client.event\n    async def on_ready():\n        print(f'{client.user} is now running!')\n        \n    \n\n    @client.event\n    async def on_message(message):\n        if message.author == client.user:\n            return \n\n\n        username = str(message.author)\n        user_message = str(message.content)\n        channel = str(message.channel)",
            "masked_code": "def run_discord_bot():\n    <line_mask>\n    intents.message_content = True\n    client = discord.Client(intents = intents)\n\n    @client.event\n    async def on_ready():\n        print(f'{client.user} is now running!')\n        \n    \n\n    @client.event\n    async def on_message(message):\n        if message.author == client.user:\n            return \n\n\n        username = str(message.author)\n        user_message = str(message.content)\n        channel = str(message.channel)",
            "masked_line": "intents = discord.Intents.default()",
            "answer": "default",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1261"
        },
        {
            "dependency": "numpy",
            "version": "==1.20.0",
            "time": "2022-03-26",
            "description": "The code creates a sliding window view of a flattened array 'a' with size 4, then applies a function 'create_array' along the rows of the sliding window view, which creates a new array containing the first 3 elements of each row and the last element of each row as separate arrays. Finally, it prints the result 'c'.",
            "code": "a = np.array([[1, 3, 5, 7, 8, 7, 1],[11, 13, 51, 17, 18, 17, 10]])\nb = np.lib.stride_tricks.sliding_window_view(a.ravel(),4)\n\ndef create_array(row):\n    return np.array([row[:3],np.array(row[-1])], dtype=object)\n\nc = np.apply_along_axis(create_array, 1, b)\nprint(c)",
            "masked_code": "a = np.array([[1, 3, 5, 7, 8, 7, 1],[11, 13, 51, 17, 18, 17, 10]])\nb = np.lib.stride_tricks.sliding_window_view(a.ravel(),4)\n\ndef create_array(row):\n    return np.array([row[:3],np.array(row[-1])], dtype=object)\n\n<line_mask>\nprint(c)",
            "masked_line": "c = np.apply_along_axis(create_array, 1, b)",
            "answer": "apply_along_axis",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1262"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4.0",
            "time": "2022-04-06",
            "description": "The code creates a figure with 3 subfigures arranged horizontally, each containing a scatter plot of different sets of data. Each subfigure has a suptitle associated with it. The axes of each subfigure have an equal aspect ratio, and each scatter plot is generated using different sets of data.",
            "code": "fig = plt.figure(constrained_layout=True, figsize=(10, 4))\n\n# create 3 subfigs (width padding=30%)\nsf1, sf2, sf3 = fig.subfigures(1, 3, wspace=0.3)\n\n# add an axes to each subfig (left=0%, bottom=0%, width=100%, height=90%)\nax1 = sf1.add_axes([0, 0, 1, 0.9])\nax2 = sf2.add_axes([0, 0, 1, 0.9])\nax3 = sf3.add_axes([0, 0, 1, 0.9])\n\nax1.scatter(data1[:, 0], data1[:, 1])\nax2.scatter(data2[:, 0], data2[:, 1])\nax3.scatter(data3[:, 0], data3[:, 1])\n\nax1.set_aspect('equal')\nax2.set_aspect('equal')\nax3.set_aspect('equal')\n\n# plot suptitle per subfig\nsf1.suptitle('suptitle 1')\nsf2.suptitle('suptitle 2')\nsf3.suptitle('suptitle 3')\n\nplt.show()",
            "masked_code": "<line_mask>\n\n# create 3 subfigs (width padding=30%)\nsf1, sf2, sf3 = fig.subfigures(1, 3, wspace=0.3)\n\n# add an axes to each subfig (left=0%, bottom=0%, width=100%, height=90%)\nax1 = sf1.add_axes([0, 0, 1, 0.9])\nax2 = sf2.add_axes([0, 0, 1, 0.9])\nax3 = sf3.add_axes([0, 0, 1, 0.9])\n\nax1.scatter(data1[:, 0], data1[:, 1])\nax2.scatter(data2[:, 0], data2[:, 1])\nax3.scatter(data3[:, 0], data3[:, 1])\n\nax1.set_aspect('equal')\nax2.set_aspect('equal')\nax3.set_aspect('equal')\n\n# plot suptitle per subfig\nsf1.suptitle('suptitle 1')\nsf2.suptitle('suptitle 2')\nsf3.suptitle('suptitle 3')\n\nplt.show()",
            "masked_line": "fig = plt.figure(constrained_layout=True, figsize=(10, 4))",
            "answer": "figure",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1263"
        },
        {
            "dependency": "pandas",
            "version": ">=1.4",
            "time": "2022-02-02",
            "description": "This code defines a function named `badlines_collect` that takes a list of strings as input and appends the input list to the `badlines_list`. The code then reads a CSV file using pandas, where if there are any bad lines encountered during reading, the `badlines_collect` function is called to collect and store those bad lines in the `badlines_list`.",
            "code": "badlines_list = []\ndef badlines_collect (bad_line: list[str]) -> None:\n        badlines_list.append(bad_line)\n        return None\n\ndf = pd.read_csv(csv_file, engine=\"python\",on_bad_lines=badlines_collect)",
            "masked_code": "badlines_list = []\ndef badlines_collect (bad_line: list[str]) -> None:\n        badlines_list.append(bad_line)\n        return None\n\n<line_mask>",
            "masked_line": "df = pd.read_csv(csv_file, engine=\"python\",on_bad_lines=badlines_collect)",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1264"
        },
        {
            "dependency": "scikit-learn",
            "version": "==1.2.0",
            "time": "2022-12-18",
            "description": "The code generates synthetic multilabel classification data with 1000 samples, 50 features, and 14 classes using sklearn's make_multilabel_classification function. It then calculates the balanced accuracy score between the true labels y and the predicted labels y, and prints the result.",
            "code": "from sklearn.datasets import make_multilabel_classification\nfrom sklearn.metrics import balanced_accuracy_score\n\nX, y = make_multilabel_classification(n_samples=1000, n_features=50, n_classes=14)\nprint(balanced_accuracy_score(y, y))",
            "masked_code": "<line_mask>\nfrom sklearn.metrics import balanced_accuracy_score\n\nX, y = make_multilabel_classification(n_samples=1000, n_features=50, n_classes=14)\nprint(balanced_accuracy_score(y, y))",
            "masked_line": "from sklearn.datasets import make_multilabel_classification",
            "answer": "make_multilabel_classification",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1265"
        },
        {
            "dependency": "pandas",
            "version": ">1.3.0",
            "time": "2022-12-09",
            "description": "The code creates a DataFrame from a Series 's' by converting it to a list, setting the index to match 's', and setting the columns to 'col1', 'col2', and 'col3'. It then explodes the DataFrame, expanding the 'cols' columns into multiple rows.",
            "code": "cols = ['col1', 'col2', 'col3']\npd.DataFrame(s.tolist(), index=s.index, columns=cols).explode(cols)",
            "masked_code": "cols = ['col1', 'col2', 'col3']\n<line_mask>",
            "masked_line": "pd.DataFrame(s.tolist(), index=s.index, columns=cols).explode(cols)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1266"
        },
        {
            "dependency": "scipy",
            "version": "==0.17",
            "time": "2022-11-25",
            "description": "The code fits a Gaussian curve to the data points in arr[0] by optimizing the parameters (amplitude, mean, standard deviation) to minimize the residual between the curve and the actual data points. It uses bounds to restrict the parameter values within certain ranges during the optimization process.",
            "code": "fit = scipy.optimize.curve_fit(gaussian_only, arr[0], curve_residual, [amp,mean,std], bounds=([0, -inf, 1e-15],[inf, inf, inf]))",
            "masked_code": "<line_mask>",
            "masked_line": "fit = scipy.optimize.curve_fit(gaussian_only, arr[0], curve_residual, [amp,mean,std], bounds=([0, -inf, 1e-15],[inf, inf, inf]))",
            "answer": "optimize",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1267"
        },
        {
            "dependency": "pandas",
            "version": ">=1.2",
            "time": "2022-11-04",
            "description": "This code reads a CSV file (\"myFile.csv\") in chunks of size 1000 rows and writes each chunk to a new Excel file (\"new_file.xlsx\") without including the index or header, starting each chunk at a new row in the Excel file.",
            "code": "n = 1000  # chunksize\nwith pd.read_csv(\"myFile.csv\", chunksize=n) as reader, \\\n     pd.ExcelWriter('new_file.xlsx') as writer:\n    for i, df in enumerate(reader):\n        df.to_excel(writer, index=False, header=False, startrow=i * n)",
            "masked_code": "n = 1000  # chunksize\n<line_mask>\n     pd.ExcelWriter('new_file.xlsx') as writer:\n    for i, df in enumerate(reader):\n        df.to_excel(writer, index=False, header=False, startrow=i * n)",
            "masked_line": "with pd.read_csv(\"myFile.csv\", chunksize=n) as reader, \\",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1268"
        },
        {
            "dependency": "folium",
            "version": "==0.12.1",
            "time": "2022-11-17",
            "description": "The code creates a map using Folium with a specific location and zoom level, then adds the map to a container using Branca. Finally, it renders the map in a web page template along with other context data.",
            "code": "current_map = folium.Map(location=(48.51, 32.25), zoom_start=6)\nmap_container = branca.element.Figure(height=\"100%\")\nmap_container.add_child(current_map)\n...\ncontext = {\"current_map\": map_container.render(), \"form\": form}\nreturn render(request, template_name=\"hub/index.html\", context=context)",
            "masked_code": "<line_mask>\nmap_container = branca.element.Figure(height=\"100%\")\nmap_container.add_child(current_map)\n...\ncontext = {\"current_map\": map_container.render(), \"form\": form}\nreturn render(request, template_name=\"hub/index.html\", context=context)",
            "masked_line": "current_map = folium.Map(location=(48.51, 32.25), zoom_start=6)",
            "answer": "Map",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1269"
        },
        {
            "dependency": "pandas",
            "version": ">=2.0",
            "time": "2023-04-07",
            "description": "The code concatenates a new row (stored in a DataFrame) to an existing DataFrame 'df' and ensures that the resulting DataFrame has its index reset.",
            "code": "df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)",
            "masked_code": "<line_mask>",
            "masked_line": "df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1270"
        },
        {
            "dependency": "pydantic",
            "version": "==1.10.9",
            "time": "2023-06-13",
            "description": "This code defines a Python class called Model with attributes a, b, c, d, e, f, and g. The attributes can have values of string type or None, and some of them have default values specified. An instance of the Model class is created and its attributes are converted to JSON format with an indentation of 4 spaces before being printed.",
            "code": "from typing import Optional, Union\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    a: str | None\n    b: Union[str, None]\n    c: Optional[str]\n    d: Optional[str] = None\n    e: Optional[str] = Field(default=None)\n    f: Optional[str] = Field(default_factory=lambda: None)\n    g: str = None\n\n\nobj = Model()\nprint(obj.json(indent=4))",
            "masked_code": "from typing import Optional, Union\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    a: str | None\n    b: Union[str, None]\n    c: Optional[str]\n    d: Optional[str] = None\n    <line_mask>\n    f: Optional[str] = Field(default_factory=lambda: None)\n    g: str = None\n\n\nobj = Model()\nprint(obj.json(indent=4))",
            "masked_line": "e: Optional[str] = Field(default=None)",
            "answer": "Field",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1271"
        },
        {
            "dependency": "pandas",
            "version": ">=2.0",
            "time": "2023-04-15",
            "description": "The code concatenates multiple DataFrames created from directories specified in `arg_list` into a single large DataFrame named `big_df`.",
            "code": "accumulator = []\nfor args in arg_list:\n    accumulator.append(dataFrameFromDirectory(*args))\n\nbig_df = pd.concat(accumulator)",
            "masked_code": "accumulator = []\nfor args in arg_list:\n    accumulator.append(dataFrameFromDirectory(*args))\n\n<line_mask>",
            "masked_line": "big_df = pd.concat(accumulator)",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1272"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.13.3",
            "time": "2023-03-22",
            "description": "This code retrieves a list of models for automatic speech recognition from the Hugging Face model hub, then prints the total number of models in the list and the model ID of the first model in the list.",
            "code": "from huggingface_hub import HfApi, ModelFilter\napi = HfApi()\nmodels = api.list_models(\n    filter=ModelFilter(\n        task=\"automatic-speech-recognition\"\n    )\n)\nmodels = list(models)\nprint(len(models))\nprint(models[0].modelId)",
            "masked_code": "<line_mask>\napi = HfApi()\nmodels = api.list_models(\n    filter=ModelFilter(\n        task=\"automatic-speech-recognition\"\n    )\n)\nmodels = list(models)\nprint(len(models))\nprint(models[0].modelId)",
            "masked_line": "from huggingface_hub import HfApi, ModelFilter",
            "answer": "HfApi",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1273"
        },
        {
            "dependency": "pandas",
            "version": "==1.5",
            "time": "2023-01-21",
            "description": "The code combines the 'salary' column from the dataframe with the dummy variables created from dropping the 'salary' column, and renames the resulting dataframe column as 'type'.",
            "code": "df[['salary']].join(pd.from_dummies(df.drop(columns='salary'))[''].rename('type'))\n\n# or\npd.DataFrame({'salary': df['salary'],\n              'type': pd.from_dummies(df.drop(columns='salary'))['']})",
            "masked_code": "<line_mask>\n\n# or\npd.DataFrame({'salary': df['salary'],\n              'type': pd.from_dummies(df.drop(columns='salary'))['']})",
            "masked_line": "df[['salary']].join(pd.from_dummies(df.drop(columns='salary'))[''].rename('type'))",
            "answer": "from_dummies",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1274"
        },
        {
            "dependency": "opencv-python",
            "version": ">=4.7",
            "time": "2023-03-28",
            "description": "This function estimates the rotation and translation vectors (rvec and tvec) for each detected marker corner in an image using the camera matrix and distortion matrix provided.",
            "code": "def my_estimatePoseSingleMarkers(corners, marker_size, mtx, distortion):\n    '''\n    This will estimate the rvec and tvec for each of the marker corners detected by:\n       corners, ids, rejectedImgPoints = detector.detectMarkers(image)\n    corners - is an array of detected corners for each detected marker in the image\n    marker_size - is the size of the detected markers\n    mtx - is the camera matrix\n    distortion - is the camera distortion matrix\n    RETURN list of rvecs, tvecs, and trash (so that it corresponds to the old estimatePoseSingleMarkers())\n    '''\n    marker_points = np.array([[-marker_size / 2, marker_size / 2, 0],\n                              [marker_size / 2, marker_size / 2, 0],\n                              [marker_size / 2, -marker_size / 2, 0],\n                              [-marker_size / 2, -marker_size / 2, 0]], dtype=np.float32)\n    trash = []\n    rvecs = []\n    tvecs = []\n    \n    for c in corners:\n        nada, R, t = cv2.solvePnP(marker_points, c, mtx, distortion, False, cv2.SOLVEPNP_IPPE_SQUARE)\n        rvecs.append(R)\n        tvecs.append(t)\n        trash.append(nada)\n    return rvecs, tvecs, trash",
            "masked_code": "def my_estimatePoseSingleMarkers(corners, marker_size, mtx, distortion):\n    '''\n    This will estimate the rvec and tvec for each of the marker corners detected by:\n       corners, ids, rejectedImgPoints = detector.detectMarkers(image)\n    corners - is an array of detected corners for each detected marker in the image\n    marker_size - is the size of the detected markers\n    mtx - is the camera matrix\n    distortion - is the camera distortion matrix\n    RETURN list of rvecs, tvecs, and trash (so that it corresponds to the old estimatePoseSingleMarkers())\n    '''\n    marker_points = np.array([[-marker_size / 2, marker_size / 2, 0],\n                              [marker_size / 2, marker_size / 2, 0],\n                              [marker_size / 2, -marker_size / 2, 0],\n                              [-marker_size / 2, -marker_size / 2, 0]], dtype=np.float32)\n    trash = []\n    rvecs = []\n    tvecs = []\n    \n    for c in corners:\n        <line_mask>\n        rvecs.append(R)\n        tvecs.append(t)\n        trash.append(nada)\n    return rvecs, tvecs, trash",
            "masked_line": "nada, R, t = cv2.solvePnP(marker_points, c, mtx, distortion, False, cv2.SOLVEPNP_IPPE_SQUARE)",
            "answer": "solvePnP",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1275"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.0",
            "time": "2023-02-10",
            "description": "This code selects specific elements from a 2D array 'arr' at row indices 0, 2, and 4, and column indices 1 and 2, returning a new 2D array with these selected elements.",
            "code": "arr[np.ix_([0,2,4],[1,2])]\n\narray([[1, 0],\n       [0, 0],\n       [1, 0]])",
            "masked_code": "<line_mask>\n\narray([[1, 0],\n       [0, 0],\n       [1, 0]])",
            "masked_line": "arr[np.ix_([0,2,4],[1,2])]",
            "answer": "ix_",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1276"
        },
        {
            "dependency": "polars",
            "version": ">=0.18.7",
            "time": "2023-07-07",
            "description": "The code creates a DataFrame with a \"date\" column containing three date values. It then converts the \"date\" column to date type. Finally, it adds a new column \"busday\" to the DataFrame, where each date in the \"date\" column is offset by 0 business days, rolled forward.",
            "code": "df = pl.DataFrame({\"date\": [\"2011-03-20\", \"2011-03-22\", \"2011-03-24\"]})\ndf = df.with_columns(pl.col(\"date\").str.to_date())\n\ndf.with_columns(busday = \n   pl.col(\"date\").map(lambda date: \n      pl.Series(np.busday_offset(date, 0, roll=\"forward\"))\n   )\n)",
            "masked_code": "df = pl.DataFrame({\"date\": [\"2011-03-20\", \"2011-03-22\", \"2011-03-24\"]})\ndf = df.with_columns(pl.col(\"date\").str.to_date())\n\ndf.with_columns(busday = \n   <line_mask>\n      pl.Series(np.busday_offset(date, 0, roll=\"forward\"))\n   )\n)",
            "masked_line": "pl.col(\"date\").map(lambda date:",
            "answer": "map",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1277"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2023-04-10",
            "description": "This code creates a pandas DataFrame with latitude and longitude values, and then uses a geolocator to get the place name for each location. The place names are added as a new column in the DataFrame.",
            "code": "df = pd.DataFrame({'lat': [34.053691, 40.712728],\n                   'lon': [-118.242766, -74.006015]})\n\ngeolocator = Nominatim(user_agent='MyApp')\n\ndf['place_name'] = df.apply(lambda x: get_place_name(x['lat'], x['lon']), axis=1)\nprint(df)",
            "masked_code": "<line_mask>\n                   'lon': [-118.242766, -74.006015]})\n\ngeolocator = Nominatim(user_agent='MyApp')\n\ndf['place_name'] = df.apply(lambda x: get_place_name(x['lat'], x['lon']), axis=1)\nprint(df)",
            "masked_line": "df = pd.DataFrame({'lat': [34.053691, 40.712728],",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1278"
        },
        {
            "dependency": "pandas",
            "version": ">=1.3",
            "time": "2023-12-21",
            "description": "Reads a CSV file named 'male_playersK.csv' into a pandas DataFrame object named 'dk'.",
            "code": "dk = pd.read_csv('male_playersK.csv', encoding_errors='ignore')",
            "masked_code": "<line_mask>",
            "masked_line": "dk = pd.read_csv('male_playersK.csv', encoding_errors='ignore')",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1279"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.1",
            "time": "2023-04-06",
            "description": "This code generates a contour plot of the data represented by the arrays x, y, and T. The plot uses the 'turbo' colormap and shows contour levels from 0 to 100 in increments of 5. The plot is displayed with a color bar and the text \"StackOverflow\" is centered at coordinates (0.5, 0.5) on the plot. The aspect ratio of the plot is set to be equal. Finally, the plot is shown.",
            "code": "fig, ax = plt.subplots(figsize=(10, 8))\n\nCS = ax.tricontourf(x, y, T, cmap=cm.turbo, extend='neither', levels=np.arange(0, 101, 5))\n\nfig.colorbar(CS), ax.set_aspect('equal')\n\nax.text(0.5, 0.5, # X & Y coordinates\n        s='StackOverflow', # <-- put your text here\n        fontsize=12, # adjust the fontsize\n        ha='center', transform=ax.transAxes)\n\nplt.show()",
            "masked_code": "<line_mask>\n\nCS = ax.tricontourf(x, y, T, cmap=cm.turbo, extend='neither', levels=np.arange(0, 101, 5))\n\nfig.colorbar(CS), ax.set_aspect('equal')\n\nax.text(0.5, 0.5, # X & Y coordinates\n        s='StackOverflow', # <-- put your text here\n        fontsize=12, # adjust the fontsize\n        ha='center', transform=ax.transAxes)\n\nplt.show()",
            "masked_line": "fig, ax = plt.subplots(figsize=(10, 8))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1280"
        },
        {
            "dependency": "pandas",
            "version": ">=1.4",
            "time": "2023-01-30",
            "description": "The code concatenates two DataFrames (df and df_o) along the rows and creates a new DataFrame with the combined data while ignoring the original index values.",
            "code": "df = pd.concat([df, df_o],ignore_index=True)",
            "masked_code": "<line_mask>",
            "masked_line": "df = pd.concat([df, df_o],ignore_index=True)",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1281"
        },
        {
            "dependency": "torch",
            "version": "==1.0.1",
            "time": "2019-03-21",
            "description": "This code segment calculates the accuracy of a model by predicting labels for images using a trained neural network model.",
            "code": "with torch.no_grad():\n    correct = 0\n    total = 0\n    for images, labels in test_loader:\n        images = images.to(device)  # missing line from original code\n        labels = labels.to(device)  # missing line from original code\n        images = images.reshape(-1, 28 * 28)\n        out = model(images)\n        _, predicted = torch.max(out.data, 1)\n        total += labels.size(0)\n        correct += (predicted == labels).sum().item()",
            "masked_code": "with torch.no_grad():\n    correct = 0\n    total = 0\n    for images, labels in test_loader:\n        images = images.to(device)  # missing line from original code\n        labels = labels.to(device)  # missing line from original code\n        images = images.reshape(-1, 28 * 28)\n        out = model(images)\n        <line_mask>\n        total += labels.size(0)\n        correct += (predicted == labels).sum().item()",
            "masked_line": "_, predicted = torch.max(out.data, 1)",
            "answer": "max",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1282"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-10-04",
            "description": "This code takes a TensorFlow dataset containing byte string tensors, transforms each byte string tensor into a byte numpy string, decodes it into a Python string, and converts it to uppercase using a custom Python function. The transformation is applied to the dataset in graph mode.",
            "code": "d = tf.data.Dataset.from_tensor_slices(['hello', 'world'])\n\n#  transform a byte string tensor to a byte numpy string and decode to python str\n#  upper case string using a Python function\ndef upper_case_fn(t):\n    return t.numpy().decode('utf-8').upper()\n\n#  use the python code in graph mode\nd.map(lambda x: tf.py_function(func=upper_case_fn,\n      inp=[x], Tout=tf.string))  # ==> [ \"HELLO\", \"WORLD\" ]",
            "masked_code": "<line_mask>\n\n#  transform a byte string tensor to a byte numpy string and decode to python str\n#  upper case string using a Python function\ndef upper_case_fn(t):\n    return t.numpy().decode('utf-8').upper()\n\n#  use the python code in graph mode\nd.map(lambda x: tf.py_function(func=upper_case_fn,\n      inp=[x], Tout=tf.string))  # ==> [ \"HELLO\", \"WORLD\" ]",
            "masked_line": "d = tf.data.Dataset.from_tensor_slices(['hello', 'world'])",
            "answer": "data",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1283"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-04-09",
            "description": "This Python code defines a command line interface using the Click library. It specifies required and optional options for the command, such as generator_string, number_of_sample_points, and number_of_center_points. The main function parses the input arguments and prints out the values of these options along with the input file and doe value. The script also provides a list of example commands and their output for demonstration purposes.",
            "code": "import click\n\nrequired_options = {\n    1: 'generator_string',\n    2: 'number_of_sample_points',\n    3: 'number_of_center_points',\n}\n\n@click.command(context_settings=dict(max_content_width=800),\n               cls=command_required_option_from_option('doe', required_options))\n@click.option('--input', required=True,\n              type=click.Path(exists=True))\n@click.option('--doe', required=True, type=int)\n@click.option('--generator_string', required=False, type=str, is_eager=True)\n@click.option('--number_of_sample_points', required=False, type=int,\n              is_eager=True)\n@click.option('--number_of_center_points', required=False, type=int,\n              is_eager=True)\ndef main(input, doe, generator_string, number_of_sample_points,\n         number_of_center_points):\n    click.echo('input: {}'.format(input))\n    click.echo('doe: {}'.format(doe))\n    click.echo('generator_string: {}'.format(generator_string))\n    click.echo('Num of sample_points: {}'.format(number_of_sample_points))\n    click.echo('Num of center_points: {}'.format(number_of_center_points))\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '--input ./input.txt --doe 0',\n        '--input ./input.txt --doe 1',\n        '--input ./input.txt --doe 2',\n        '--input ./input.txt --doe 3',\n        '--input ./input.txt --doe 1 --generator_string 1234',\n        '--input ./input.txt --doe 2 --number_of_sample_points 3',\n        '--input ./input.txt --doe 3 --number_of_center_points 2',\n        '',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            main(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_code": "import click\n\nrequired_options = {\n    1: 'generator_string',\n    2: 'number_of_sample_points',\n    3: 'number_of_center_points',\n}\n\n<line_mask>\n               cls=command_required_option_from_option('doe', required_options))\n@click.option('--input', required=True,\n              type=click.Path(exists=True))\n@click.option('--doe', required=True, type=int)\n@click.option('--generator_string', required=False, type=str, is_eager=True)\n@click.option('--number_of_sample_points', required=False, type=int,\n              is_eager=True)\n@click.option('--number_of_center_points', required=False, type=int,\n              is_eager=True)\ndef main(input, doe, generator_string, number_of_sample_points,\n         number_of_center_points):\n    click.echo('input: {}'.format(input))\n    click.echo('doe: {}'.format(doe))\n    click.echo('generator_string: {}'.format(generator_string))\n    click.echo('Num of sample_points: {}'.format(number_of_sample_points))\n    click.echo('Num of center_points: {}'.format(number_of_center_points))\n\n\nif __name__ == \"__main__\":\n    commands = (\n        '--input ./input.txt --doe 0',\n        '--input ./input.txt --doe 1',\n        '--input ./input.txt --doe 2',\n        '--input ./input.txt --doe 3',\n        '--input ./input.txt --doe 1 --generator_string 1234',\n        '--input ./input.txt --doe 2 --number_of_sample_points 3',\n        '--input ./input.txt --doe 3 --number_of_center_points 2',\n        '',\n        '--help',\n    )\n\n    import sys, time\n\n    time.sleep(1)\n    print('Click Version: {}'.format(click.__version__))\n    print('Python Version: {}'.format(sys.version))\n    for cmd in commands:\n        try:\n            time.sleep(0.1)\n            print('-----------')\n            print('> ' + cmd)\n            time.sleep(0.1)\n            main(cmd.split())\n\n        except BaseException as exc:\n            if str(exc) != '0' and \\\n                    not isinstance(exc, (click.ClickException, SystemExit)):\n                raise",
            "masked_line": "@click.command(context_settings=dict(max_content_width=800),",
            "answer": "command",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1284"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-03-28",
            "description": "This code creates a Bokeh visualization showing sea surface temperature data at a specific location. It includes a line plot of temperature over time and a table displaying alpha and num values. The code also includes a callback function that adjusts the data displayed based on user-selected rows in the table.",
            "code": "from bokeh.layouts import column\nfrom bokeh.models import ColumnDataSource, DataTable, TableColumn\nfrom bokeh.plotting import figure, curdoc\nfrom bokeh.io import show, output_notebook\nfrom bokeh.sampledata.sea_surface_temperature import sea_surface_temperature\n\n# output_notebook()\ndef modify_doc(doc):\n    df = sea_surface_temperature.copy()\n    source = ColumnDataSource(data = df)\n    source_table = ColumnDataSource(data = {\"alpha\": [s for s in \"abcdefgh\"],\n                                            \"num\": list(range(8))})\n\n    plot = figure(x_axis_type = 'datetime', y_range = (0, 25),\n                  y_axis_label = 'Temperature (Celsius)',\n                  title = \"Sea Surface Temperature at 43.18, -70.43\")\n    plot.line('time', 'temperature', source = source)\n\n    def callback(attr, old, new):  # here new is an array containing selected rows\n        if new == 0:\n            data = df\n        else:\n            data = df.rolling('{0}D'.format(new[0])).mean()  # asuming one row is selected\n\n        source.data = ColumnDataSource(data = data).data\n\n    table = DataTable(source = source_table,\n                      columns = [TableColumn(field = \"alpha\", title = \"Alpha\"),\n                                 TableColumn(field = \"num\", title = \"Num\")])\n    source_table.selected.on_change('indices', callback)\n\n    doc().add_root(column(table, plot))\n\nmodify_doc(curdoc)\n# show(modify_doc)",
            "masked_code": "from bokeh.layouts import column\nfrom bokeh.models import ColumnDataSource, DataTable, TableColumn\nfrom bokeh.plotting import figure, curdoc\nfrom bokeh.io import show, output_notebook\nfrom bokeh.sampledata.sea_surface_temperature import sea_surface_temperature\n\n# output_notebook()\ndef modify_doc(doc):\n    df = sea_surface_temperature.copy()\n    source = ColumnDataSource(data = df)\n    source_table = ColumnDataSource(data = {\"alpha\": [s for s in \"abcdefgh\"],\n                                            \"num\": list(range(8))})\n\n    plot = figure(x_axis_type = 'datetime', y_range = (0, 25),\n                  y_axis_label = 'Temperature (Celsius)',\n                  title = \"Sea Surface Temperature at 43.18, -70.43\")\n    <line_mask>\n\n    def callback(attr, old, new):  # here new is an array containing selected rows\n        if new == 0:\n            data = df\n        else:\n            data = df.rolling('{0}D'.format(new[0])).mean()  # asuming one row is selected\n\n        source.data = ColumnDataSource(data = data).data\n\n    table = DataTable(source = source_table,\n                      columns = [TableColumn(field = \"alpha\", title = \"Alpha\"),\n                                 TableColumn(field = \"num\", title = \"Num\")])\n    source_table.selected.on_change('indices', callback)\n\n    doc().add_root(column(table, plot))\n\nmodify_doc(curdoc)\n# show(modify_doc)",
            "masked_line": "plot.line('time', 'temperature', source = source)",
            "answer": "line",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1285"
        },
        {
            "dependency": "numpy",
            "version": "==1.17",
            "time": "2019-08-14",
            "description": "The code defines a custom data type \"np_resource\" in numpy with a single field named \"resource\" of type unsigned byte.",
            "code": "np_resource = np.dtype([(\"resource\", np.ubyte, (1,))])",
            "masked_code": "<line_mask>",
            "masked_line": "np_resource = np.dtype([(\"resource\", np.ubyte, (1,))])",
            "answer": "dtype",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1286"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-04-27",
            "description": "This code calculates the ceiling of the result of subtracting 0.5 from 10.4 and dividing the result by 0.8, resulting in 13.0.",
            "code": "In [33]: np.ceil((10.4-0.5)/0.8)                                                \nOut[33]: 13.0",
            "masked_code": "<line_mask>\nOut[33]: 13.0",
            "masked_line": "In [33]: np.ceil((10.4-0.5)/0.8)",
            "answer": "ceil",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1287"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-01-25",
            "description": "The code extracts numbers from a string and creates a NumPy array with those numbers.",
            "code": "a = \"[0.01 0.01 0.01 0.01 0.01 0.01]\"\nnum_arr = np.fromstring(a.strip('[]'), count = 6, sep = ' ')\n\narray([0.01, 0.01, 0.01, 0.01, 0.01, 0.01])",
            "masked_code": "a = \"[0.01 0.01 0.01 0.01 0.01 0.01]\"\n<line_mask>\n\narray([0.01, 0.01, 0.01, 0.01, 0.01, 0.01])",
            "masked_line": "num_arr = np.fromstring(a.strip('[]'), count = 6, sep = ' ')",
            "answer": "fromstring",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1288"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.x",
            "time": "2019-01-19",
            "description": "The code generates a dataframe from a list of lists, filters out rows based on a condition, creates manually and arbitrarily length color maps, and plots pie and bar charts using the filtered data with different color schemes.",
            "code": "# a dataframe from a list of lists \nel = [['RED', 50, 1], \n      ['GREEN', 30, 2], \n      ['BLUE', 7, 3], \n      ['YELLOW', 3, 4], \n      ['ORANGE', 9, 5], \n      ['BLACK', 1, 6]]\ndf = pd.DataFrame(el)\n\n# since you are not using the entire dataframe\ndf_thres = df[df[1] > 1]\n\n# make a fixed length color map manually\nc = ['red', 'green', 'blue', 'yellow', 'orange']\nclist1 = {i:j for i, j in zip(df_thres[0].values, c)}\n\n# make an arbitrary-length colormap\ncm = plt.get_cmap('rainbow')\nc = [cm(1.0 * i/len(df_thres)) for i in range(len(df_thres))]\nclist2 = {i:j for i, j in zip(df_thres[0].values, c)}\n\n\nfig, ax = plt.subplots(nrows=2, ncols=2, figsize=(11, 8))\n\n# manual colors\n\n# PIE PLOT: sort on the third column\nnewdf = df_thres.sort_values(2, ascending=False)\nax[0, 0].pie(newdf[2], labels=newdf[0], colors=[clist1[i] for i in newdf[0].values])\nax[0, 0].axis('square') # matplotlib 2.x only\n\n# BAR PLOT: sort on the second column    \nnewdf = df_thres.sort_values(1, ascending=False)\nax[0, 1].bar(newdf[0], newdf[1], color=[clist1[i] for i in newdf[0].values])\n\n#----------------\n\n# arbitrary-length generated colorlist\nnewdf = df_thres.sort_values(2, ascending=False)\nax[1, 0].pie(newdf[1], labels=newdf[0], colors=[clist2[i] for i in newdf[0].values])\nax[1, 0].axis('square') # matplotlib 2.x only\n\nnewdf = df_thres.sort_values(1, ascending=False)\nax[1, 1].bar(newdf[0], newdf[1], color=[clist2[i] for i in newdf[0].values])",
            "masked_code": "# a dataframe from a list of lists \nel = [['RED', 50, 1], \n      ['GREEN', 30, 2], \n      ['BLUE', 7, 3], \n      ['YELLOW', 3, 4], \n      ['ORANGE', 9, 5], \n      ['BLACK', 1, 6]]\ndf = pd.DataFrame(el)\n\n# since you are not using the entire dataframe\ndf_thres = df[df[1] > 1]\n\n# make a fixed length color map manually\nc = ['red', 'green', 'blue', 'yellow', 'orange']\nclist1 = {i:j for i, j in zip(df_thres[0].values, c)}\n\n# make an arbitrary-length colormap\ncm = plt.get_cmap('rainbow')\n<line_mask>\nclist2 = {i:j for i, j in zip(df_thres[0].values, c)}\n\n\nfig, ax = plt.subplots(nrows=2, ncols=2, figsize=(11, 8))\n\n# manual colors\n\n# PIE PLOT: sort on the third column\nnewdf = df_thres.sort_values(2, ascending=False)\nax[0, 0].pie(newdf[2], labels=newdf[0], colors=[clist1[i] for i in newdf[0].values])\nax[0, 0].axis('square') # matplotlib 2.x only\n\n# BAR PLOT: sort on the second column    \nnewdf = df_thres.sort_values(1, ascending=False)\nax[0, 1].bar(newdf[0], newdf[1], color=[clist1[i] for i in newdf[0].values])\n\n#----------------\n\n# arbitrary-length generated colorlist\nnewdf = df_thres.sort_values(2, ascending=False)\nax[1, 0].pie(newdf[1], labels=newdf[0], colors=[clist2[i] for i in newdf[0].values])\nax[1, 0].axis('square') # matplotlib 2.x only\n\nnewdf = df_thres.sort_values(1, ascending=False)\nax[1, 1].bar(newdf[0], newdf[1], color=[clist2[i] for i in newdf[0].values])",
            "masked_line": "c = [cm(1.0 * i/len(df_thres)) for i in range(len(df_thres))]",
            "answer": "cm",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1289"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.0",
            "time": "2019-02-12",
            "description": "This function calculates the triplet semihard loss for metric learning using the labels y and embeddings.",
            "code": "def func(y, embeddings): \n    return tf.contrib.losses.metric_learning.triplet_semihard_loss(labels=y, embeddings=embeddings)",
            "masked_code": "def func(y, embeddings): \n    <line_mask>",
            "masked_line": "return tf.contrib.losses.metric_learning.triplet_semihard_loss(labels=y, embeddings=embeddings)",
            "answer": "contrib",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1290"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.4",
            "time": "2019-05-03",
            "description": "The code creates sample data with date ranges, target values, and close values. It then calculates the difference in days between the current day's \"close\" value and all \"target\" values that are lower than 0.25 or where the \"target\" value is greater than the \"close\" value. The result is stored in a new column \"date_diff\" in the dataframe.",
            "code": "### Create sample data\ndate_range = pd.date_range(start=\"1/1/2018\", end=\"20/1/2018\", freq=\"6H\", closed=\"right\")\n\ntarget1 = np.random.uniform(10, 30, len(date_range))\n\nclose = [[i]*4 for i in np.random.uniform(10,30, len(date_range)//4)]\nclose_flat = np.array([item for sublist in close for item in sublist])\n\ndf = pd.DataFrame(np.array([np.array(date_range.date), target1,\n    close_flat]).transpose(), columns=[\"date\", \"target\", \"close\"])\n\n\n### Create the column you need\n# iterating over the days and finding days when the difference between\n# \"close\" of current day and all \"target\" is lower than 0.25 OR the \"target\"\n# value is greater than \"close\" value.\nthresh = 0.25\ndate_diff_arr = np.zeros(len(df))\nfor i in range(0,len(df),4):\n    diff_lt_thresh = df[(abs(df.target-df.close.iloc[i]) < thresh) | (df.target > df.close.iloc[i])]\n    # only keep the findings from the next day onwards\n    diff_lt_thresh = diff_lt_thresh.loc[i+4:]\n    if not diff_lt_thresh.empty:\n        # find day difference only if something under thresh is found\n        days_diff = (diff_lt_thresh.iloc[0].date - df.iloc[i].date).days\n    else:\n        # otherwise write it as nan\n        days_diff = np.nan\n    # fill in the np.array which will be used to write to the df\n    date_diff_arr[i:i+4] = days_diff\n\ndf[\"date_diff\"] = date_diff_arr",
            "masked_code": "### Create sample data\ndate_range = pd.date_range(start=\"1/1/2018\", end=\"20/1/2018\", freq=\"6H\", closed=\"right\")\n\ntarget1 = np.random.uniform(10, 30, len(date_range))\n\nclose = [[i]*4 for i in np.random.uniform(10,30, len(date_range)//4)]\nclose_flat = np.array([item for sublist in close for item in sublist])\n\n<line_mask>\n    close_flat]).transpose(), columns=[\"date\", \"target\", \"close\"])\n\n\n### Create the column you need\n# iterating over the days and finding days when the difference between\n# \"close\" of current day and all \"target\" is lower than 0.25 OR the \"target\"\n# value is greater than \"close\" value.\nthresh = 0.25\ndate_diff_arr = np.zeros(len(df))\nfor i in range(0,len(df),4):\n    diff_lt_thresh = df[(abs(df.target-df.close.iloc[i]) < thresh) | (df.target > df.close.iloc[i])]\n    # only keep the findings from the next day onwards\n    diff_lt_thresh = diff_lt_thresh.loc[i+4:]\n    if not diff_lt_thresh.empty:\n        # find day difference only if something under thresh is found\n        days_diff = (diff_lt_thresh.iloc[0].date - df.iloc[i].date).days\n    else:\n        # otherwise write it as nan\n        days_diff = np.nan\n    # fill in the np.array which will be used to write to the df\n    date_diff_arr[i:i+4] = days_diff\n\ndf[\"date_diff\"] = date_diff_arr",
            "masked_line": "df = pd.DataFrame(np.array([np.array(date_range.date), target1,",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1291"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0.0",
            "time": "2019-12-30",
            "description": "The code retrieves and sets the visible physical and logical devices associated with the GPU for TensorFlow operations.",
            "code": "physical_devices = tf.config.experimental.list_physical_devices('GPU')\n\ntf.config.experimental.set_visible_devices(physical_devices[0], 'GPU')\n\nlogical_devices = tf.config.experimental.list_logical_devices('GPU')",
            "masked_code": "physical_devices = tf.config.experimental.list_physical_devices('GPU')\n\n<line_mask>\n\nlogical_devices = tf.config.experimental.list_logical_devices('GPU')",
            "masked_line": "tf.config.experimental.set_visible_devices(physical_devices[0], 'GPU')",
            "answer": "set_visible_devices",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1292"
        },
        {
            "dependency": "numpy",
            "version": "==1.17.3",
            "time": "2019-11-19",
            "description": "The code creates a numpy array with the shape specified by the input parameter \"shape\", and fills the array with values from the given \"vector_value\".",
            "code": "np.full((*shape, len(vector_value)), vector_value)",
            "masked_code": "<line_mask>",
            "masked_line": "np.full((*shape, len(vector_value)), vector_value)",
            "answer": "full",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1293"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-11",
            "description": "The code initializes a NumPy array \"Out\" with zeros, where the dimensions of the array are specified by \"dimN\".",
            "code": "Out=np.zeros(dimN)",
            "masked_code": "<line_mask>",
            "masked_line": "Out=np.zeros(dimN)",
            "answer": "zeros",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1294"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-11",
            "description": "This function calculates the tensor dot product of two input tensors A and B based on the specified axes iA and iB. It validates the dimensions of the input tensors and constructs the output tensor with the appropriate dimensions before performing the tensor dot product operation.",
            "code": "@nb.jit()  # We can't use nopython mode here...\ndef mytensordot(A, B, iA, iB):\n    iA, iB = np.array(iA, dtype=np.int32), np.array(iB, dtype=np.int32)\n    dimA, dimB = A.shape, B.shape\n    NdimA, NdimB = len(dimA), len(dimB)\n\n    if len(iA) != NdimA:\n        raise ValueError(\"iA must be same size as dim A\")\n    if len(iB) != NdimB:\n        raise ValueError(\"iB must be same size as dim B\")\n\n    NdimN = NdimA + NdimB\n    dimN = np.zeros(NdimN, dtype=np.int32)\n    dimN[iA] = dimA\n    dimN[iB] = dimB\n    Out = np.zeros(dimN)\n    return mytensordot_jit(A, B, iA, iB, dimN, Out)",
            "masked_code": "@nb.jit()  # We can't use nopython mode here...\ndef mytensordot(A, B, iA, iB):\n    iA, iB = np.array(iA, dtype=np.int32), np.array(iB, dtype=np.int32)\n    dimA, dimB = A.shape, B.shape\n    NdimA, NdimB = len(dimA), len(dimB)\n\n    if len(iA) != NdimA:\n        raise ValueError(\"iA must be same size as dim A\")\n    if len(iB) != NdimB:\n        raise ValueError(\"iB must be same size as dim B\")\n\n    NdimN = NdimA + NdimB\n    <line_mask>\n    dimN[iA] = dimA\n    dimN[iB] = dimB\n    Out = np.zeros(dimN)\n    return mytensordot_jit(A, B, iA, iB, dimN, Out)",
            "masked_line": "dimN = np.zeros(NdimN, dtype=np.int32)",
            "answer": "zeros",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1295"
        },
        {
            "dependency": "tensorflow",
            "version": "==0.7",
            "time": "2019-11-25",
            "description": "This code generates samples from a Student's t-distribution with degrees of freedom of 3 using both NumPy and TensorFlow. It then plots histograms of the samples using matplotlib, comparing the distributions generated by NumPy and TensorFlow.",
            "code": "import numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nnp.random.seed(0)\nt_np = np.random.standard_t(df=3, size=10000)\nwith tf.Graph().as_default(), tf.Session() as sess:\n    tf.random.set_random_seed(0)\n    t_dist = tf.distributions.StudentT(df=3.0, loc=0.0, scale=1.0)\n    t_tf = sess.run(t_dist.sample(10000))\nplt.hist((t_np, t_tf), np.linspace(-10, 10, 20), label=['NumPy', 'TensorFlow'])\nplt.legend()\nplt.tight_layout()\nplt.show()",
            "masked_code": "import numpy as np\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nnp.random.seed(0)\nt_np = np.random.standard_t(df=3, size=10000)\n<line_mask>\n    tf.random.set_random_seed(0)\n    t_dist = tf.distributions.StudentT(df=3.0, loc=0.0, scale=1.0)\n    t_tf = sess.run(t_dist.sample(10000))\nplt.hist((t_np, t_tf), np.linspace(-10, 10, 20), label=['NumPy', 'TensorFlow'])\nplt.legend()\nplt.tight_layout()\nplt.show()",
            "masked_line": "with tf.Graph().as_default(), tf.Session() as sess:",
            "answer": "Graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1296"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.2.2",
            "time": "2019-01-29",
            "description": "This code sorts a list of features and their corresponding importance values, then creates a horizontal bar plot to visualize the importance of each feature.",
            "code": "features_sorted = []\nimportance_sorted = []\n\nfor i in sorted_list:\n    features_sorted += [i[1]]\n    importance_sorted += [i[0]]\n\nplt.title(\"Feature importance\", fontsize=15)\nplt.xlabel(\"Importance\", fontsize=13)\n\nplt.barh(range(len(importance_sorted)), importance_sorted, color=\"green\", edgecolor='green')\nplt.yticks(range(len(importance_sorted)), features_sorted);",
            "masked_code": "features_sorted = []\nimportance_sorted = []\n\nfor i in sorted_list:\n    features_sorted += [i[1]]\n    importance_sorted += [i[0]]\n\nplt.title(\"Feature importance\", fontsize=15)\nplt.xlabel(\"Importance\", fontsize=13)\n\n<line_mask>\nplt.yticks(range(len(importance_sorted)), features_sorted);",
            "masked_line": "plt.barh(range(len(importance_sorted)), importance_sorted, color=\"green\", edgecolor='green')",
            "answer": "barh",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1297"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-05-28",
            "description": "The code creates a list of dictionaries where each dictionary contains the index and the value from a Pandas Series. If the value is an integer, the value is converted to an integer before being added to the dictionary. The final list of dictionaries is then printed.",
            "code": "test_series = pd.Series([int(1),1.3])\nresults = [{index:int(value)} if value.is_integer() else {index:value} for index,value in test_series.iteritems()]\nprint (results)",
            "masked_code": "<line_mask>\nresults = [{index:int(value)} if value.is_integer() else {index:value} for index,value in test_series.iteritems()]\nprint (results)",
            "masked_line": "test_series = pd.Series([int(1),1.3])",
            "answer": "Series",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1298"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-18",
            "description": "This code performs an einsum operation on two input arrays v1 and v2 and returns the resulting array with dimensions 'ik'.",
            "code": "np.einsum('ij,jki->ik',v1,v2)",
            "masked_code": "<line_mask>",
            "masked_line": "np.einsum('ij,jki->ik',v1,v2)",
            "answer": "einsum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1299"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14",
            "time": "2019-07-28",
            "description": "The code calculates the mean squared error (MSE) loss between the true values (y_true) and the predicted values (y_pred) for two different classes (0 and 1) in a classification task. It first identifies the indices where 0 and 1 are present in y_true, then retrieves the corresponding values from y_pred using these indices. Finally, it calculates the MSE loss for each class and prints the predicted values along with the corresponding losses.",
            "code": "y_true = tf.constant([[0,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,0]], dtype=tf.float32)\ny_pred = tf.random.uniform([4, 4], minval=0, maxval=1)\n\n# find indices where 0 is present in y_true\nindices0 = tf.where(tf.equal(y_true, tf.zeros([1.]))) \n# find indices where 1 is present in y_true\nindices1 = tf.where(tf.equal(y_true, tf.ones([1.]))) \n\n# find all values in y_pred which are present at indices0\ny_pred_indices0 = tf.gather_nd(y_pred, indices0)\n# find all values in y_pred which are present at indices1\ny_pred_indices1 = tf.gather_nd(y_pred, indices1)\n\n# mse loss calculations \nmse0 = tf.losses.mean_squared_error(labels=tf.gather_nd(y_true, indices0), predictions=y_pred_indices0)\nmse1 = tf.losses.mean_squared_error(labels=tf.gather_nd(y_true, indices1), predictions=y_pred_indices1)\n\n# mse0 = tf.reduce_sum(tf.squared_difference(tf.gather_nd(y_true, indices0), y_pred_indices0))\n# mse1 = tf.reduce_sum(tf.squared_difference(tf.gather_nd(y_true, indices1), y_pred_indices1))\n\nwith tf.Session() as sess:\n    y_, loss0, loss1 = sess.run([y_pred, mse0, mse1])\n    print(y_)\n    print(loss0, loss1)",
            "masked_code": "y_true = tf.constant([[0,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,0]], dtype=tf.float32)\n<line_mask>\n\n# find indices where 0 is present in y_true\nindices0 = tf.where(tf.equal(y_true, tf.zeros([1.]))) \n# find indices where 1 is present in y_true\nindices1 = tf.where(tf.equal(y_true, tf.ones([1.]))) \n\n# find all values in y_pred which are present at indices0\ny_pred_indices0 = tf.gather_nd(y_pred, indices0)\n# find all values in y_pred which are present at indices1\ny_pred_indices1 = tf.gather_nd(y_pred, indices1)\n\n# mse loss calculations \nmse0 = tf.losses.mean_squared_error(labels=tf.gather_nd(y_true, indices0), predictions=y_pred_indices0)\nmse1 = tf.losses.mean_squared_error(labels=tf.gather_nd(y_true, indices1), predictions=y_pred_indices1)\n\n# mse0 = tf.reduce_sum(tf.squared_difference(tf.gather_nd(y_true, indices0), y_pred_indices0))\n# mse1 = tf.reduce_sum(tf.squared_difference(tf.gather_nd(y_true, indices1), y_pred_indices1))\n\nwith tf.Session() as sess:\n    y_, loss0, loss1 = sess.run([y_pred, mse0, mse1])\n    print(y_)\n    print(loss0, loss1)",
            "masked_line": "y_pred = tf.random.uniform([4, 4], minval=0, maxval=1)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1300"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.13",
            "time": "2019-05-11",
            "description": "The code defines a neural network model consisting of two dense layers with relu and softmax activation functions, respectively. The model is compiled with Adam optimizer, categorical crossentropy loss function, and accuracy metrics. It then trains the model on the provided data and labels for 10 epochs with 2 steps per epoch.",
            "code": "model = tf.keras.Sequential([\ntf.keras.layers.Dense(3, activation='relu'),\ntf.keras.layers.Dense(3, activation='softmax')])\n\nmodel.compile(optimizer=tf.train.AdamOptimizer(0.001),\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\n\n\ndata = tf.constant([[0,0,1],[0,1,0],[1,0,0]], dtype=tf.float32)\nlabel = tf.constant([[0,0,1],[0,1,0],[1,0,0]], dtype=tf.float32)\nmodel.fit(data, label, epochs=10, steps_per_epoch=2)",
            "masked_code": "model = tf.keras.Sequential([\ntf.keras.layers.Dense(3, activation='relu'),\ntf.keras.layers.Dense(3, activation='softmax')])\n\nmodel.compile(optimizer=tf.train.AdamOptimizer(0.001),\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\n\n\ndata = tf.constant([[0,0,1],[0,1,0],[1,0,0]], dtype=tf.float32)\nlabel = tf.constant([[0,0,1],[0,1,0],[1,0,0]], dtype=tf.float32)\n<line_mask>",
            "masked_line": "model.fit(data, label, epochs=10, steps_per_epoch=2)",
            "answer": "fit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1301"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.0",
            "time": "2019-08-14",
            "description": "The code takes a DataFrame, sets the 'speaker' column as the index, applies ast.literal_eval to the 'ratings' column, explodes the resulting Series, converts it to a DataFrame, resets the index, and finally creates a pivot table with 'speaker' as the index, 'name' as the columns, and 'count' as the values.",
            "code": "ii = df.set_index('speaker')['ratings'].apply(ast.literal_eval).explode()\n\nu = pd.DataFrame(ii.tolist(), index=ii.index).reset_index()\n\nu.pivot('speaker', 'name', 'count')",
            "masked_code": "ii = df.set_index('speaker')['ratings'].apply(ast.literal_eval).explode()\n\nu = pd.DataFrame(ii.tolist(), index=ii.index).reset_index()\n\n<line_mask>",
            "masked_line": "u.pivot('speaker', 'name', 'count')",
            "answer": "pivot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1302"
        },
        {
            "dependency": "numpy",
            "version": "==1.17.0",
            "time": "2019-11-27",
            "description": "The code assigns the values of column 'B' to column 'D' in the DataFrame 'df' when the corresponding value in column 'C' is equal to ' Description'; otherwise, it assigns the values of column 'C' to column 'D'.",
            "code": "df['D'] = np.where(df['C'] == ' Description', df['B'], df['C'])",
            "masked_code": "<line_mask>",
            "masked_line": "df['D'] = np.where(df['C'] == ' Description', df['B'], df['C'])",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1303"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-14",
            "description": "The code calculates the 75th, 100th, and 99th percentiles of the values in array 'a', and then uses linear interpolation to find the approximate 99th percentile value.",
            "code": "a = np.array([0,0.2,0.4,0.7,1])\n\nnp.sort(a)  # array([ 0. ,  0.2,  0.4,  0.7,  1. ])\n\nnp.percentile(a, 75)   # 0.70\nnp.percentile(a, 100)  # 1.0\nnp.percentile(a, 99)   # 0.988\n\n0.70 + (1.0 - 0.70) * (99 - 75) / (100 - 75)  # 0.988",
            "masked_code": "<line_mask>\n\nnp.sort(a)  # array([ 0. ,  0.2,  0.4,  0.7,  1. ])\n\nnp.percentile(a, 75)   # 0.70\nnp.percentile(a, 100)  # 1.0\nnp.percentile(a, 99)   # 0.988\n\n0.70 + (1.0 - 0.70) * (99 - 75) / (100 - 75)  # 0.988",
            "masked_line": "a = np.array([0,0.2,0.4,0.7,1])",
            "answer": "array",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1304"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2019-11-06",
            "description": "This function performs mutation on the input array by randomly changing the sign of elements based on the probability value provided.",
            "code": "def mutation(arr, p_val):\n    m = np.random.choice([True,False],size=arr.shape,p=[p_val,1-p_val])\n    return np.where(m,-np.sign(arr),arr)",
            "masked_code": "def mutation(arr, p_val):\n    <line_mask>\n    return np.where(m,-np.sign(arr),arr)",
            "masked_line": "m = np.random.choice([True,False],size=arr.shape,p=[p_val,1-p_val])",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1305"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-07-27",
            "description": "The code checks if there is a GPU available in the system and if so, sets up memory growth and virtual device configuration for the GPU with a memory limit of 4000.",
            "code": "if tf.config.list_physical_devices('GPU'):\n    physical_devices = tf.config.list_physical_devices('GPU')\n    tf.config.experimental.set_memory_growth(physical_devices[0], enable=True)\n    tf.config.experimental.set_virtual_device_configuration(physical_devices[0], [tf.config.experimental.VirtualDeviceConfiguration(memory_limit=4000)])",
            "masked_code": "if tf.config.list_physical_devices('GPU'):\n    physical_devices = tf.config.list_physical_devices('GPU')\n    <line_mask>\n    tf.config.experimental.set_virtual_device_configuration(physical_devices[0], [tf.config.experimental.VirtualDeviceConfiguration(memory_limit=4000)])",
            "masked_line": "tf.config.experimental.set_memory_growth(physical_devices[0], enable=True)",
            "answer": "set_memory_growth",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1306"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-08",
            "description": "Check if any element in each row of the given array is greater than 0.9, return the index of the maximum element in each row if True, otherwise return -1.",
            "code": "m = arr > 0.9\nnp.where(m.any(axis=1), m.argmax(axis=1), -1)\narray([-1,  0,  1])",
            "masked_code": "m = arr > 0.9\n<line_mask>\narray([-1,  0,  1])",
            "masked_line": "np.where(m.any(axis=1), m.argmax(axis=1), -1)",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1307"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2019-11-27",
            "description": "This code snippet creates a ProximalAdagrad optimizer with a learning rate of 0.001, compiles a model with this optimizer using sparse categorical crossentropy as the loss function and accuracy as the metric.",
            "code": "# This works both in recent 1.x and 2.0\noptimizer = tf.compat.v1.train.ProximalAdagradOptimizer(0.001)\nmodel.compile(optimizer=optimizer,\n              loss=\"sparse_categorical_crossentropy\",\n              metrics=[\"accuracy\"])",
            "masked_code": "# This works both in recent 1.x and 2.0\n<line_mask>\nmodel.compile(optimizer=optimizer,\n              loss=\"sparse_categorical_crossentropy\",\n              metrics=[\"accuracy\"])",
            "masked_line": "optimizer = tf.compat.v1.train.ProximalAdagradOptimizer(0.001)",
            "answer": "ProximalAdagradOptimizer",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1308"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2020-01-03",
            "description": "This code saves the trained model variables to disk in a file named \"model.ckpt\" located in the \"/tmp\" directory.",
            "code": "saver = tf.train.Saver()\nwith tf.Session() as sess:\n  sess.run(init_op)\n  # Do some work with the model.\n\n  # Save the variables to disk.\n  save_path = saver.save(sess, \"/tmp/model.ckpt\")",
            "masked_code": "<line_mask>\nwith tf.Session() as sess:\n  sess.run(init_op)\n  # Do some work with the model.\n\n  # Save the variables to disk.\n  save_path = saver.save(sess, \"/tmp/model.ckpt\")",
            "masked_line": "saver = tf.train.Saver()",
            "answer": "Saver",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1309"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-08-12",
            "description": "The function takes an array as input, rounds the elements to the nearest integer, and returns a new array with the rounded values.",
            "code": "nb.jit(nopython=True)\ndef func(x):\n    out = np.empty_like(x)\n    np.round(x, 0, out)\n    return out",
            "masked_code": "nb.jit(nopython=True)\ndef func(x):\n    out = np.empty_like(x)\n    <line_mask>\n    return out",
            "masked_line": "np.round(x, 0, out)",
            "answer": "round",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1310"
        },
        {
            "dependency": "pandas",
            "version": "==0.24",
            "time": "2019-02-08",
            "description": "This code generates a test dataframe with randomly generated values for columns 'a' and 'b' at intervals of 1 second. It then sets an interval of 10 minutes and start time of the buckets based on the indexes of the dataframe. Finally, it groups the data by intervals of 10 minutes and prints out the size of each group.",
            "code": "\"Generate test dataframe\"\ncase = 1\nif case == 1:\n    start = '2018-11-26 16:17:43.510000'\nelse:\n    start = '2018-11-26 16:17:43.500000'\n\nrng = pd.date_range(start, periods=10, freq='1S')\ndf = pd.DataFrame({'a':np.random.randn(len(rng)),'b':np.random.randn(len(rng))}, index=rng)\n\n\"Set interval and start time of the buckets\"\ninterval = dt.timedelta(minutes=10)\nt0 = df.index[0]\nbase = t0.minute + (t0.second +t0.microsecond/1e6)/60\ngroups = df.groupby(pd.Grouper(freq=interval, base=base))\n\nprint(groups.size())",
            "masked_code": "\"Generate test dataframe\"\ncase = 1\nif case == 1:\n    start = '2018-11-26 16:17:43.510000'\nelse:\n    start = '2018-11-26 16:17:43.500000'\n\nrng = pd.date_range(start, periods=10, freq='1S')\n<line_mask>\n\n\"Set interval and start time of the buckets\"\ninterval = dt.timedelta(minutes=10)\nt0 = df.index[0]\nbase = t0.minute + (t0.second +t0.microsecond/1e6)/60\ngroups = df.groupby(pd.Grouper(freq=interval, base=base))\n\nprint(groups.size())",
            "masked_line": "df = pd.DataFrame({'a':np.random.randn(len(rng)),'b':np.random.randn(len(rng))}, index=rng)",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1311"
        },
        {
            "dependency": "pyglet",
            "version": "==1.3",
            "time": "2019-02-20",
            "description": "This code snippet loads an image file named 'kitten.png' using the pyglet library from a byte stream created from the variable 'some_bytes'.",
            "code": "kitten_stream = io.BytesIO(some_bytes)\nkitten = pyglet.image.load('kitten.png', file=kitten_stream)",
            "masked_code": "kitten_stream = io.BytesIO(some_bytes)\n<line_mask>",
            "masked_line": "kitten = pyglet.image.load('kitten.png', file=kitten_stream)",
            "answer": "image",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1312"
        },
        {
            "dependency": "psycopg2",
            "version": ">=2.5",
            "time": "2019-11-24",
            "description": "This Python code establishes a connection to a PostgreSQL database using psycopg2, creates a cursor object, and executes a SQL query.",
            "code": "with psycopg2.connect(DSN) as conn:\n    with conn.cursor() as curs:\n        curs.execute(SQL)",
            "masked_code": "<line_mask>\n    with conn.cursor() as curs:\n        curs.execute(SQL)",
            "masked_line": "with psycopg2.connect(DSN) as conn:",
            "answer": "connect",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1313"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-01-25",
            "description": "This code converts an RGB image array to YUV color space.",
            "code": "images_yuv = np.apply_along_axis( yuv, -1, images_rgb)",
            "masked_code": "<line_mask>",
            "masked_line": "images_yuv = np.apply_along_axis( yuv, -1, images_rgb)",
            "answer": "apply_along_axis",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1314"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.1",
            "time": "2019-12-28",
            "description": "This code sorts the DataFrame 'dataFrame' by the values in the column 'a' in descending order and then resets the index of the DataFrame.",
            "code": "dictionary = {\"a\":[2,3,1,4],\"b\":[\"a\",\"f\",\"g\",\"z\"]}\ndataFrame = pd.DataFrame.from_dict(dictionary)\ndataFrame.sort_values('a',ascending=False,inplace = True)\ndataFrame.reset_index(drop=True)",
            "masked_code": "dictionary = {\"a\":[2,3,1,4],\"b\":[\"a\",\"f\",\"g\",\"z\"]}\ndataFrame = pd.DataFrame.from_dict(dictionary)\n<line_mask>\ndataFrame.reset_index(drop=True)",
            "masked_line": "dataFrame.sort_values('a',ascending=False,inplace = True)",
            "answer": "sort_values",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1315"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-10-03",
            "description": "This code shuffles unique values of 'GT' and 'PRED' columns in a DataFrame, creates pairs of shuffled values, and then selects rows in the DataFrame where either 'GT' or 'PRED' matches the shuffled pairs.",
            "code": "gt_u = df2['GT'].unique()\npred_u = df2['PRED'].unique()\n\nnp.random.shuffle(gt_u)\nnp.random.shuffle(pred_u)\n\npairs = pd.DataFrame({'GT':gt_u, 'PRED':pred_u})    \n#pairs = pd.DataFrame([[x, y] for x, y in zip(gt_u, pred_u)], columns=['GT', 'PRED'])\n\nsel = df2.apply(lambda x : (x[['GT', 'PRED']] == pairs).all(axis=1).any(axis=0), axis=1)\nout = df2.loc[sel]",
            "masked_code": "gt_u = df2['GT'].unique()\npred_u = df2['PRED'].unique()\n\nnp.random.shuffle(gt_u)\n<line_mask>\n\npairs = pd.DataFrame({'GT':gt_u, 'PRED':pred_u})    \n#pairs = pd.DataFrame([[x, y] for x, y in zip(gt_u, pred_u)], columns=['GT', 'PRED'])\n\nsel = df2.apply(lambda x : (x[['GT', 'PRED']] == pairs).all(axis=1).any(axis=0), axis=1)\nout = df2.loc[sel]",
            "masked_line": "np.random.shuffle(pred_u)",
            "answer": "random",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1316"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.2.2",
            "time": "2019-07-08",
            "description": "The code iterates through each element in list K, then plots scatter points with specific colors and markers at the coordinates specified by centers. Finally, it prints the values of centers[0] and displays the plot.",
            "code": "for i, k in enumerate(K):\n    # rest of your code\n\n    plt.scatter(centers[0], centers[1], c=color_palette[0:i+1], marker = \"x\")\n    print (centers[0].values)\n    plt.show()",
            "masked_code": "for i, k in enumerate(K):\n    # rest of your code\n\n    plt.scatter(centers[0], centers[1], c=color_palette[0:i+1], marker = \"x\")\n    print (centers[0].values)\n    <line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1317"
        },
        {
            "dependency": "fitsio",
            "version": "==0.9.11",
            "time": "2019-04-19",
            "description": "This code opens a FITS file named 'test.fits' in read-write mode and writes a key named 'KEY' with a value of 'key value' and a comment of 'my comment' to the last HDU (Header Data Unit) of the file.",
            "code": "with fitsio.FITS('test.fits', 'rw') as ff:\n    ff[-1].write_key('KEY', 'key value', 'my comment')",
            "masked_code": "<line_mask>\n    ff[-1].write_key('KEY', 'key value', 'my comment')",
            "masked_line": "with fitsio.FITS('test.fits', 'rw') as ff:",
            "answer": "FITS",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1318"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-14",
            "description": "The code creates an embedding layer with fixed weights initialized from a pre-trained embedding matrix. The embedding layer maps input integers to dense vectors of fixed size. The weights are not trainable during model training.",
            "code": "x = tf.keras.layers.Embedding(vocabulary_size, embedding_dim, embeddings_initializer=tf.keras.initializers.Constant(embedding_matrix), trainable=False)",
            "masked_code": "<line_mask>",
            "masked_line": "x = tf.keras.layers.Embedding(vocabulary_size, embedding_dim, embeddings_initializer=tf.keras.initializers.Constant(embedding_matrix), trainable=False)",
            "answer": "initializers",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1319"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2019-06-22",
            "description": "The code performs an operation to set values in tf_ent to 0 where corresponding values in tf_ent_var are True, and set values in tf_ent to the minimum value in tf_ent where tf_ent_var is False.",
            "code": "val = tf.math.reduce_min(tf_ent)\ntf.where(tf_ent_var, tf_ent, tf.zeros_like(tf_ent) + val)",
            "masked_code": "<line_mask>\ntf.where(tf_ent_var, tf_ent, tf.zeros_like(tf_ent) + val)",
            "masked_line": "val = tf.math.reduce_min(tf_ent)",
            "answer": "reduce_min",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1320"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.0",
            "time": "2019-10-06",
            "description": "The code restructures the DataFrame `df` from wide format to long format, by stacking multiple columns with prefix 'BQ_', 'BP_', 'BO_' into a single column, with corresponding 'Number' values indicating the source column. The 'timestamp' column is used as the identifier for each row in the long format.",
            "code": "result = pd.wide_to_long(df, stubnames=['BQ_','BP_','BO_'], i=['timestamp'],j=\"Number\")",
            "masked_code": "<line_mask>",
            "masked_line": "result = pd.wide_to_long(df, stubnames=['BQ_','BP_','BO_'], i=['timestamp'],j=\"Number\")",
            "answer": "wide_to_long",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1321"
        },
        {
            "dependency": "trio",
            "version": "==0.12.0",
            "time": "2019-08-01",
            "description": "This code runs a subprocess using the 'sudo' command with specific arguments and sends a password as stdin for authentication.",
            "code": "await trio.run_process(['sudo', '-S', 'apt-get', cmd, '-y'], stdin=password_bytes)",
            "masked_code": "<line_mask>",
            "masked_line": "await trio.run_process(['sudo', '-S', 'apt-get', cmd, '-y'], stdin=password_bytes)",
            "answer": "run_process",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1322"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-06-29",
            "description": "This code returns the number of bytes occupied by each element of a single-precision floating-point number (float32) in numpy.",
            "code": "np.dtype('float32').itemsize",
            "masked_code": "<line_mask>",
            "masked_line": "np.dtype('float32').itemsize",
            "answer": "dtype",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1323"
        },
        {
            "dependency": "numba",
            "version": "==0.49.1",
            "time": "2020-05-20",
            "description": "The code creates a typed list of numbers using the numba library in Python.",
            "code": "py_list = [2,3,5]    \nnumber_list = numba.typed.List(py_list)",
            "masked_code": "py_list = [2,3,5]    \n<line_mask>",
            "masked_line": "number_list = numba.typed.List(py_list)",
            "answer": "typed",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1324"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.0",
            "time": "2020-03-10",
            "description": "This code defines a function called \"print_window\" that prints the input window and a line of equal signs below it. It then defines a function called \"example\" which reads data from a CSV file and applies the \"print_window\" function to a rolling window of size 5.",
            "code": "def print_window(window):\n  print(window)\n  print('==================')\n  return 0\n\n\ndef example():\n\n  df = pd.read_csv('window_example.csv')\n\n  df.rolling(5).apply(print_window)",
            "masked_code": "def print_window(window):\n  print(window)\n  print('==================')\n  return 0\n\n\ndef example():\n\n  <line_mask>\n\n  df.rolling(5).apply(print_window)",
            "masked_line": "df = pd.read_csv('window_example.csv')",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1325"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1",
            "time": "2020-03-08",
            "description": "The function of the given code is to load MRI images from files, preprocess them, create a TensorFlow dataset, build a Convolutional Neural Network (CNN) model using Keras, train the model on the dataset, and evaluate its performance. The code includes loading and preprocessing MRI image data, setting up a TensorFlow dataset, defining a CNN model architecture with Conv3D layers, compiling the model with loss function and optimizer, training the model on the dataset with specified batch size and number of epochs.",
            "code": "def load_image(file, label):\n    nifti = np.asarray(nibabel.load(file.numpy().decode('utf-8')).get_fdata()).astype(np.float32)\n\n    xs, ys, zs = np.where(nifti != 0)\n    nifti = nifti[min(xs):max(xs) + 1, min(ys):max(ys) + 1, min(zs):max(zs) + 1]\n    nifti = nifti[0:100, 0:100, 0:100]\n    nifti = np.reshape(nifti, (100, 100, 100, 1))\n    return nifti, label\n\n\n@tf.autograph.experimental.do_not_convert\ndef load_image_wrapper(file, label):\n    return tf.py_function(load_image, [file, label], [tf.float64, tf.float64])\n\n\ndataset = tf.data.Dataset.from_tensor_slices((train, labels))\ndataset = dataset.map(load_image_wrapper, num_parallel_calls=32)\ndataset = dataset.prefetch(buffer_size=1)\ndataset = dataset.apply(tf.data.experimental.prefetch_to_device('/device:GPU:0', 1))\n\n# So, my dataset size is 522, i.e. 522 MRI images.\n# I need to load the entire dataset as a batch.\n# This should exceed 60GiBs of RAM, but it doesn't go over 12GiB of RAM.\n# I'm not sure how tf.data batch() stores the data, maybe a custom file?\n# And also add a repeat parameter to iterate with each epoch.\ndataset = dataset.batch(522, drop_remainder=True).repeat()\n\n# Now initialise an iterator\niterator = iter(dataset)\n\n# Create two objects, x & y, from batch\nbatch_image, batch_label = iterator.get_next()\n\n##################################################################################\nwith tf.device(\"/cpu:0\"):\n    with tf.device(\"/gpu:0\"):\n        model = tf.keras.Sequential()\n\n        model.add(Conv3D(64,\n                         input_shape=(100, 100, 100, 1),\n                         data_format='channels_last',\n                         kernel_size=(7, 7, 7),\n                         strides=(2, 2, 2),\n                         padding='valid',\n                         activation='relu'))\n\n    with tf.device(\"/gpu:1\"):\n        model.add(Conv3D(64,\n                         kernel_size=(3, 3, 3),\n                         padding='valid',\n                         activation='relu'))\n\n    with tf.device(\"/gpu:2\"):\n        model.add(Conv3D(128,\n                         kernel_size=(3, 3, 3),\n                         padding='valid',\n                         activation='relu'))\n\n        model.add(MaxPooling3D(pool_size=(2, 2, 2),\n                               padding='valid'))\n\n        model.add(Flatten())\n\n        model.add(Dense(256, activation='relu'))\n        model.add(Dropout(0.7))\n        model.add(Dense(1, activation='sigmoid'))\n\nmodel.compile(loss=tf.keras.losses.binary_crossentropy,\n              optimizer=tf.keras.optimizers.Adagrad(0.01),\n              metrics=['accuracy'])\n##################################################################################\n\n# Now supply x=batch_image, y= batch_label to Keras' model.fit()\n# And finally, supply your batchs_size here!\nmodel.fit(batch_image, batch_label, epochs=100, batch_size=12)\n\n##################################################################################",
            "masked_code": "def load_image(file, label):\n    nifti = np.asarray(nibabel.load(file.numpy().decode('utf-8')).get_fdata()).astype(np.float32)\n\n    xs, ys, zs = np.where(nifti != 0)\n    nifti = nifti[min(xs):max(xs) + 1, min(ys):max(ys) + 1, min(zs):max(zs) + 1]\n    nifti = nifti[0:100, 0:100, 0:100]\n    nifti = np.reshape(nifti, (100, 100, 100, 1))\n    return nifti, label\n\n\n@tf.autograph.experimental.do_not_convert\ndef load_image_wrapper(file, label):\n    <line_mask>\n\n\ndataset = tf.data.Dataset.from_tensor_slices((train, labels))\ndataset = dataset.map(load_image_wrapper, num_parallel_calls=32)\ndataset = dataset.prefetch(buffer_size=1)\ndataset = dataset.apply(tf.data.experimental.prefetch_to_device('/device:GPU:0', 1))\n\n# So, my dataset size is 522, i.e. 522 MRI images.\n# I need to load the entire dataset as a batch.\n# This should exceed 60GiBs of RAM, but it doesn't go over 12GiB of RAM.\n# I'm not sure how tf.data batch() stores the data, maybe a custom file?\n# And also add a repeat parameter to iterate with each epoch.\ndataset = dataset.batch(522, drop_remainder=True).repeat()\n\n# Now initialise an iterator\niterator = iter(dataset)\n\n# Create two objects, x & y, from batch\nbatch_image, batch_label = iterator.get_next()\n\n##################################################################################\nwith tf.device(\"/cpu:0\"):\n    with tf.device(\"/gpu:0\"):\n        model = tf.keras.Sequential()\n\n        model.add(Conv3D(64,\n                         input_shape=(100, 100, 100, 1),\n                         data_format='channels_last',\n                         kernel_size=(7, 7, 7),\n                         strides=(2, 2, 2),\n                         padding='valid',\n                         activation='relu'))\n\n    with tf.device(\"/gpu:1\"):\n        model.add(Conv3D(64,\n                         kernel_size=(3, 3, 3),\n                         padding='valid',\n                         activation='relu'))\n\n    with tf.device(\"/gpu:2\"):\n        model.add(Conv3D(128,\n                         kernel_size=(3, 3, 3),\n                         padding='valid',\n                         activation='relu'))\n\n        model.add(MaxPooling3D(pool_size=(2, 2, 2),\n                               padding='valid'))\n\n        model.add(Flatten())\n\n        model.add(Dense(256, activation='relu'))\n        model.add(Dropout(0.7))\n        model.add(Dense(1, activation='sigmoid'))\n\nmodel.compile(loss=tf.keras.losses.binary_crossentropy,\n              optimizer=tf.keras.optimizers.Adagrad(0.01),\n              metrics=['accuracy'])\n##################################################################################\n\n# Now supply x=batch_image, y= batch_label to Keras' model.fit()\n# And finally, supply your batchs_size here!\nmodel.fit(batch_image, batch_label, epochs=100, batch_size=12)\n\n##################################################################################",
            "masked_line": "return tf.py_function(load_image, [file, label], [tf.float64, tf.float64])",
            "answer": "py_function",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1326"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-05-24",
            "description": "This code generates a visualization of a network graph using the spring layout algorithm in NetworkX library, where the nodes are positioned based on their connections and the edges are drawn to connect the nodes. Labels are added to the nodes slightly above their original positions.",
            "code": "pos = nx.spring_layout(G, scale=0.2)\nnx.draw_networkx_nodes(G,pos)\nnx.draw_networkx_edges(G,pos)\ny_off = 0.02\nnx.draw_networkx_labels(G, pos = {k:([v[0], v[1]+y_off]) for k,v in pos.items()})",
            "masked_code": "pos = nx.spring_layout(G, scale=0.2)\n<line_mask>\nnx.draw_networkx_edges(G,pos)\ny_off = 0.02\nnx.draw_networkx_labels(G, pos = {k:([v[0], v[1]+y_off]) for k,v in pos.items()})",
            "masked_line": "nx.draw_networkx_nodes(G,pos)",
            "answer": "draw_networkx_nodes",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1327"
        },
        {
            "dependency": "numba",
            "version": "==0.47.0",
            "time": "2020-02-17",
            "description": "This function calculates the number of steps needed to reach the value 1 from the input value 'b' following the Collatz conjecture algorithm.",
            "code": "@numba.njit\ndef numb_steps(b, steps):\n\n    e = b    \n    d = 0\n\n    while True:\n\n        if e == 1:\n            return d + steps[e]\n\n        if e % 2 == 0:\n            e //= 2\n        else:\n            e = 3*e + 1\n\n        d += 1",
            "masked_code": "<line_mask>\ndef numb_steps(b, steps):\n\n    e = b    \n    d = 0\n\n    while True:\n\n        if e == 1:\n            return d + steps[e]\n\n        if e % 2 == 0:\n            e //= 2\n        else:\n            e = 3*e + 1\n\n        d += 1",
            "masked_line": "@numba.njit",
            "answer": "njit",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1328"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2020-05-04",
            "description": "The code snippet compares numpy int32 values with standard integers and checks if the comparisons return True.",
            "code": "np.int32(3) == 3   # True\n[np.int32(1), 4] == [1, np.int32(4)]    # True",
            "masked_code": "np.int32(3) == 3   # True\n<line_mask>",
            "masked_line": "[np.int32(1), 4] == [1, np.int32(4)]    # True",
            "answer": "int32",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1329"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2020-09-09",
            "description": "The code rounds the values in column 'A' and 'B' of a dataframe to 2 decimal places.",
            "code": "df['A'] = df['A'].apply(lambda x: np.round(x, 2))\ndf['B'] = df['B'].apply(lambda x: np.round(x, 2))",
            "masked_code": "<line_mask>\ndf['B'] = df['B'].apply(lambda x: np.round(x, 2))",
            "masked_line": "df['A'] = df['A'].apply(lambda x: np.round(x, 2))",
            "answer": "round",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1330"
        },
        {
            "dependency": "scipy",
            "version": "==1.4.1",
            "time": "2020-06-14",
            "description": "This code creates a sparse COO matrix containing the value 1, and then multiplies it by a scalar value of 2, returning a new sparse CSR matrix.",
            "code": "In [11]: x = scipy.sparse.coo_matrix([[1]])\n\nIn [12]: type(x.multiply(2))\nOut[12]: scipy.sparse.csr.csr_matrix",
            "masked_code": "<line_mask>\n\nIn [12]: type(x.multiply(2))\nOut[12]: scipy.sparse.csr.csr_matrix",
            "masked_line": "In [11]: x = scipy.sparse.coo_matrix([[1]])",
            "answer": "coo_matrix",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1331"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-11-06",
            "description": "This code converts the integer variable num to a float data type using the tf.cast method with a data type of tf.float32.",
            "code": "num=5\n#as_float = tf.to_float(num)\n#Change the above code line and use cast method instead\nas_float=tf.cast(num, tf.float32)\nas_float",
            "masked_code": "num=5\n#as_float = tf.to_float(num)\n#Change the above code line and use cast method instead\n<line_mask>\nas_float",
            "masked_line": "as_float=tf.cast(num, tf.float32)",
            "answer": "cast",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1332"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.0",
            "time": "2020-02-04",
            "description": "This code assigns a new column 'ReportingTime' to the DataFrame 'df'. The 'ReportingTime' column is generated by applying a lambda function to each row of the DataFrame, which creates a date range starting from the value in the 'CycleOfRepricingAnchorTime' column to the end of 2019 with a frequency specified in the 'CycleOfRepricing' column. Finally, the 'ReportingTime' column is exploded to expand the date ranges into separate rows.",
            "code": "df.assign(ReportingTime=df.apply(lambda x: \\\n        pd.date_range(start = x.CycleOfRepricingAnchorTime, \\\n                         end = pd.to_datetime('31.12.2019'),\n                         freq = x.CycleOfRepricing), axis = 1)).explode('ReportingTime')",
            "masked_code": "df.assign(ReportingTime=df.apply(lambda x: \\\n        <line_mask>\n                         end = pd.to_datetime('31.12.2019'),\n                         freq = x.CycleOfRepricing), axis = 1)).explode('ReportingTime')",
            "masked_line": "pd.date_range(start = x.CycleOfRepricingAnchorTime, \\",
            "answer": "date_range",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1333"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-09-04",
            "description": "The code trains a TensorFlow variable 'w' using the gradient descent optimizer to minimize the cost function, which is a quadratic function of 'w' with coefficients provided in the 'coefficients' constant tensor. After 100 iterations, it prints the final value of 'w' that minimizes the cost function.",
            "code": "coefficients = tf.constant([[1.], [-10.], [25.]])\nw = tf.Variable(0.0)\n\n@tf.function\ndef train(x):\n  cost = (x[0][0] * (w**2)) + (x[1][0]*w) + (x[2][0])\n  tf.compat.v1.train.GradientDescentOptimizer(0.05).minimize(cost, var_list=[w])\n\nfor i in range(100):\n    train(coefficients)\n\nprint(w)",
            "masked_code": "<line_mask>\nw = tf.Variable(0.0)\n\n@tf.function\ndef train(x):\n  cost = (x[0][0] * (w**2)) + (x[1][0]*w) + (x[2][0])\n  tf.compat.v1.train.GradientDescentOptimizer(0.05).minimize(cost, var_list=[w])\n\nfor i in range(100):\n    train(coefficients)\n\nprint(w)",
            "masked_line": "coefficients = tf.constant([[1.], [-10.], [25.]])",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1334"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.0",
            "time": "2020-08-03",
            "description": "The code creates a sparse DataFrame from a sparse matrix and then selects rows with index 0 and 1.",
            "code": "df = pd.DataFrame.sparse.from_spmatrix(\n    scipy.sparse.csr_matrix([[0, 0, 0, 1],\n                             [1, 0, 0, 0],\n                             [0, 1, 0, 0]])\n)\ndf.loc[[0, 1]]",
            "masked_code": "<line_mask>\n    scipy.sparse.csr_matrix([[0, 0, 0, 1],\n                             [1, 0, 0, 0],\n                             [0, 1, 0, 0]])\n)\ndf.loc[[0, 1]]",
            "masked_line": "df = pd.DataFrame.sparse.from_spmatrix(",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1335"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.2.0",
            "time": "2020-11-14",
            "description": "The code stitches two images together to create a panoramic image.",
            "code": "stitcher = cv2.Stitcher.create(cv2.Stitcher_PANORAMA)\nstitcher.setPanoConfidenceThresh(0.0) # might be too aggressive for real examples\nfoo = cv2.imread(\"/path/to/image1.jpg\")\nbar = cv2.imread(\"/path/to/image2.jpg\")\nstatus, result = stitcher.stitch((foo,bar))\nassert status == 0 # Verify returned status is 'success'\ncv2.imshow(\"result\", result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
            "masked_code": "stitcher = cv2.Stitcher.create(cv2.Stitcher_PANORAMA)\n<line_mask>\nfoo = cv2.imread(\"/path/to/image1.jpg\")\nbar = cv2.imread(\"/path/to/image2.jpg\")\nstatus, result = stitcher.stitch((foo,bar))\nassert status == 0 # Verify returned status is 'success'\ncv2.imshow(\"result\", result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
            "masked_line": "stitcher.setPanoConfidenceThresh(0.0) # might be too aggressive for real examples",
            "answer": "setPanoConfidenceThresh",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1336"
        },
        {
            "dependency": "networkx",
            "version": "==2.5",
            "time": "2020-09-23",
            "description": "The code generates subgraphs of strongly connected components in a directed graph G.",
            "code": "(G.subgraph(c) for c in nx.strongly_connected_components(G))",
            "masked_code": "<line_mask>",
            "masked_line": "(G.subgraph(c) for c in nx.strongly_connected_components(G))",
            "answer": "strongly_connected_components",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1337"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-05-11",
            "description": "Generate a random sample of size n from a normal distribution with mean f and standard deviation 1.0.",
            "code": "y = f + np.random.normal(scale=1.0, size=n)",
            "masked_code": "<line_mask>",
            "masked_line": "y = f + np.random.normal(scale=1.0, size=n)",
            "answer": "normal",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1338"
        },
        {
            "dependency": "altair",
            "version": "==4.0",
            "time": "2020-03-07",
            "description": "The code creates a visualization with error bars and bars, where the bars represent the mean value of a dataset categorized by weight, and the error bars show the confidence interval of the data. The visualization is then faceted by the size of the data.",
            "code": "error_bars = alt.Chart().mark_errorbar(extent='ci').encode(\n    x=alt.X('weight:O',  title=None, axis=None, sort=['10 kg', '10 g', '10 mg']),\n    y='value:Q'\n)\n\nbars = alt.Chart().mark_bar().encode(\n    x = alt.X('weight:O', title=None, axis=None, sort=['10 kg', '10 g', '10 mg']),\n    y = alt.Y('mean(value)', title='Value'),\n    color = alt.Color('weight:O', sort=['10 kg', '10 g', '10 mg'])\n)\n\nalt.layer(bars, error_bars, data=df).facet(\n    column = alt.Column('size', sort=['huge', 'big', 'small'])\n)",
            "masked_code": "<line_mask>\n    x=alt.X('weight:O',  title=None, axis=None, sort=['10 kg', '10 g', '10 mg']),\n    y='value:Q'\n)\n\nbars = alt.Chart().mark_bar().encode(\n    x = alt.X('weight:O', title=None, axis=None, sort=['10 kg', '10 g', '10 mg']),\n    y = alt.Y('mean(value)', title='Value'),\n    color = alt.Color('weight:O', sort=['10 kg', '10 g', '10 mg'])\n)\n\nalt.layer(bars, error_bars, data=df).facet(\n    column = alt.Column('size', sort=['huge', 'big', 'small'])\n)",
            "masked_line": "error_bars = alt.Chart().mark_errorbar(extent='ci').encode(",
            "answer": "encode",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1339"
        },
        {
            "dependency": "altair",
            "version": "<4.0",
            "time": "2020-03-21",
            "description": "The code enables the 'notebook' renderer for Altair plots.",
            "code": "alt.renderers.enable('notebook')",
            "masked_code": "<line_mask>",
            "masked_line": "alt.renderers.enable('notebook')",
            "answer": "renderers",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1340"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.4",
            "time": "2020-02-20",
            "description": "The code extracts rows from a DataFrame where the datetime index values fall between 11:00 and 13:00.",
            "code": "indexer = (pd.DatetimeIndex(df.index.get_level_values('datetime'))\n           .indexer_between_time('11:00', '13:00'))\ndf.loc[pd.IndexSlice[:, df.index.get_level_values('datetime')[indexer]], :]",
            "masked_code": "<line_mask>\n           .indexer_between_time('11:00', '13:00'))\ndf.loc[pd.IndexSlice[:, df.index.get_level_values('datetime')[indexer]], :]",
            "masked_line": "indexer = (pd.DatetimeIndex(df.index.get_level_values('datetime'))",
            "answer": "DatetimeIndex",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1341"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2021-10-07",
            "description": "The code adds a flattening layer to a neural network model.",
            "code": "model.add(tf.keras.layers.Flatten())",
            "masked_code": "<line_mask>",
            "masked_line": "model.add(tf.keras.layers.Flatten())",
            "answer": "Flatten",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1342"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x.x",
            "time": "2020-09-03",
            "description": "The code converts a Keras model to a ConcreteFunction, then freezes the ConcreteFunction to get a frozen graph. It prints the layers of the frozen model, as well as its inputs and outputs. Finally, it saves the frozen graph to the hard drive as a protobuf file.",
            "code": "# Convert Keras model to ConcreteFunction\nfull_model = tf.function(lambda x: model(x))\nfull_model = full_model.get_concrete_function(\n    x=tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))\n\n# Get frozen ConcreteFunction\nfrozen_func = convert_variables_to_constants_v2(full_model)\nfrozen_func.graph.as_graph_def()\n\nlayers = [op.name for op in frozen_func.graph.get_operations()]\nprint(\"-\" * 50)\nprint(\"Frozen model layers: \")\nfor layer in layers:\n    print(layer)\n\nprint(\"-\" * 50)\nprint(\"Frozen model inputs: \")\nprint(frozen_func.inputs)\nprint(\"Frozen model outputs: \")\nprint(frozen_func.outputs)\n\n# Save frozen graph from frozen ConcreteFunction to hard drive\ntf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n                  logdir=\"./frozen_models\",\n                  name=\"simple_frozen_graph.pb\",\n                  as_text=False)",
            "masked_code": "# Convert Keras model to ConcreteFunction\nfull_model = tf.function(lambda x: model(x))\nfull_model = full_model.get_concrete_function(\n    <line_mask>\n\n# Get frozen ConcreteFunction\nfrozen_func = convert_variables_to_constants_v2(full_model)\nfrozen_func.graph.as_graph_def()\n\nlayers = [op.name for op in frozen_func.graph.get_operations()]\nprint(\"-\" * 50)\nprint(\"Frozen model layers: \")\nfor layer in layers:\n    print(layer)\n\nprint(\"-\" * 50)\nprint(\"Frozen model inputs: \")\nprint(frozen_func.inputs)\nprint(\"Frozen model outputs: \")\nprint(frozen_func.outputs)\n\n# Save frozen graph from frozen ConcreteFunction to hard drive\ntf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n                  logdir=\"./frozen_models\",\n                  name=\"simple_frozen_graph.pb\",\n                  as_text=False)",
            "masked_line": "x=tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))",
            "answer": "TensorSpec",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1343"
        },
        {
            "dependency": "Flask",
            "version": "==1.1.2",
            "time": "2020-04-13",
            "description": "This code defines a Flask web application with two routes. The '/custom.html' route renders a custom HTML template, while the '/trigger-python' route prints a success message to the console and returns 'OK'. When the application is run, it starts a development server on localhost at port 8080.",
            "code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n\n@app.route('/custom.html')\ndef custom():\n    return render_template('custom.html')\n\n@app.route(\"/trigger-python\")\ndef print_something():\n    print(\"Successful line print\")\n    return 'OK'\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=8080, debug=True)",
            "masked_code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n\n@app.route('/custom.html')\ndef custom():\n    return render_template('custom.html')\n\n@app.route(\"/trigger-python\")\ndef print_something():\n    print(\"Successful line print\")\n    return 'OK'\n\nif __name__ == '__main__':\n    <line_mask>",
            "masked_line": "app.run(host='127.0.0.1', port=8080, debug=True)",
            "answer": "run",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1344"
        },
        {
            "dependency": "tensorflow",
            "version": ">=2.2",
            "time": "2020-08-24",
            "description": "This code generates a 3-dimensional array with shape (32, 100, 10) filled with random float values between 0 and 1. It then compares the sum of the elements along the second axis using two different methods (one from TensorFlow backend and one directly from TensorFlow) and checks if the results are the same for all elements, returning True if they are all equal.",
            "code": "X = np.random.uniform(0,1, (32,100,10)).astype('float32')\n\n(tf.keras.backend.sum(X, axis=-2) == tf.reduce_sum(X, axis=-2)).numpy().all() # TRUE",
            "masked_code": "X = np.random.uniform(0,1, (32,100,10)).astype('float32')\n\n<line_mask>",
            "masked_line": "(tf.keras.backend.sum(X, axis=-2) == tf.reduce_sum(X, axis=-2)).numpy().all() # TRUE",
            "answer": "keras",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1345"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.1.0",
            "time": "2020-08-01",
            "description": "The code sets the x-axis scale of the plot to be symlog with a linear threshold at 1e-7.",
            "code": "plt.xscale('symlog', linthresh=1e-7)",
            "masked_code": "<line_mask>",
            "masked_line": "plt.xscale('symlog', linthresh=1e-7)",
            "answer": "xscale",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1346"
        },
        {
            "dependency": "networkx",
            "version": "==1.9.1",
            "time": "2020-06-26",
            "description": "The code creates a MultiGraph object and adds nodes representing different lands (A, B, C, D) with connected edges indicating bridges between the lands. The bridges have attributes such as color and weight. The code also relabels the nodes with the corresponding land names.",
            "code": "G=nx.MultiGraph()\n\nG.add_node(1)  ## Land A\nG.add_node(2)  ## Land B\nG.add_node(3)  ## Land C\nG.add_node(4)  ## Land D\n\n## Connected Edges\nG.add_edge(1,3,color='r',weight=1)  ## Bridge 1\nG.add_edge(1,3,color='r',weight=1)  ## Bridge 2\nG.add_edge(1,4,color='r',weight=1)  ## Bridge 3\nG.add_edge(3,4,color='r',weight=1)  ## Bridge 4\nG.add_edge(1,2,color='r',weight=1)  ## Bridge 5\nG.add_edge(1,2,color='r',weight=1)  ## Bridge 6\nG.add_edge(2,4,color='r',weight=1)  ## Bridge 7\n\ncolors = nx.get_edge_attributes(G,'color').values()\nweights = nx.get_edge_attributes(G,'weight').values()\n\nnames = {1:\"Land A\",2:\"Land B\",3:\"Land C\",4:\"Land D\"}\nH=nx.relabel_nodes(G,names)",
            "masked_code": "G=nx.MultiGraph()\n\nG.add_node(1)  ## Land A\nG.add_node(2)  ## Land B\nG.add_node(3)  ## Land C\nG.add_node(4)  ## Land D\n\n## Connected Edges\nG.add_edge(1,3,color='r',weight=1)  ## Bridge 1\nG.add_edge(1,3,color='r',weight=1)  ## Bridge 2\nG.add_edge(1,4,color='r',weight=1)  ## Bridge 3\nG.add_edge(3,4,color='r',weight=1)  ## Bridge 4\nG.add_edge(1,2,color='r',weight=1)  ## Bridge 5\nG.add_edge(1,2,color='r',weight=1)  ## Bridge 6\nG.add_edge(2,4,color='r',weight=1)  ## Bridge 7\n\n<line_mask>\nweights = nx.get_edge_attributes(G,'weight').values()\n\nnames = {1:\"Land A\",2:\"Land B\",3:\"Land C\",4:\"Land D\"}\nH=nx.relabel_nodes(G,names)",
            "masked_line": "colors = nx.get_edge_attributes(G,'color').values()",
            "answer": "values",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1347"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-06-15",
            "description": "The code reads data from a file, creates a weighted graph, adds weighted edges to the graph, and returns a view of the edges with their weights.",
            "code": "weight = 1\nedges = [[*map(int,line.split()), weight] for line in open(\"file.txt\")]\nG = nx.Graph()\nG.add_weighted_edges_from(edges)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 1}), (1, 3, {'weight': 1}), (2, 4, {'weight': 1})])",
            "masked_code": "weight = 1\nedges = [[*map(int,line.split()), weight] for line in open(\"file.txt\")]\n<line_mask>\nG.add_weighted_edges_from(edges)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 1}), (1, 3, {'weight': 1}), (2, 4, {'weight': 1})])",
            "masked_line": "G = nx.Graph()",
            "answer": "Graph",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1348"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.3",
            "time": "2020-03-31",
            "description": "The code converts the 'Id' column in the DataFrame 'df' to an Integer datatype and then prints the data types of all columns in the DataFrame along with the entire DataFrame.",
            "code": "df['Id'] = df['Id'].astype(pd.Int64Dtype())\n\nprint(df.dtypes)\nprint(df)",
            "masked_code": "<line_mask>\n\nprint(df.dtypes)\nprint(df)",
            "masked_line": "df['Id'] = df['Id'].astype(pd.Int64Dtype())",
            "answer": "Int64Dtype",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1349"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-01-19",
            "description": "This code solves a system of non-linear equations using the fsolve function from the scipy.optimize library. The equations are defined in the equations function, and the initial values are set for the variables x0, x1, and x2. The solution is then calculated for the given initial vector (0.0, 0.0, 0.0) and the parameters a, b, and c. Finally, the solution values x0, x1, and x2 are printed.",
            "code": "from scipy.optimize import fsolve\nfrom numpy import cos, sin, exp\n\n# Define the non-linear equations\ndef equations(X, a,b,c):\n    x0, x1, x2 = X\n    return [3*x0-cos(x1*x2)+ a, x0*x0-81*(x1+0.1)**2+ sin(x2)+b, exp(-x0*x1)+20*x2+c]\n\na = 1.0\nb = 0.5\nc = 2.5\n\n# Using (0.0, 0.0, 0.0) as an initial vector\nx0, x1, x2 = fsolve(equations, x0=(0.,0.,0.), args=(a,b,c)) \nprint(x0, x1, x2)",
            "masked_code": "<line_mask>\nfrom numpy import cos, sin, exp\n\n# Define the non-linear equations\ndef equations(X, a,b,c):\n    x0, x1, x2 = X\n    return [3*x0-cos(x1*x2)+ a, x0*x0-81*(x1+0.1)**2+ sin(x2)+b, exp(-x0*x1)+20*x2+c]\n\na = 1.0\nb = 0.5\nc = 2.5\n\n# Using (0.0, 0.0, 0.0) as an initial vector\nx0, x1, x2 = fsolve(equations, x0=(0.,0.,0.), args=(a,b,c)) \nprint(x0, x1, x2)",
            "masked_line": "from scipy.optimize import fsolve",
            "answer": "fsolve",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1350"
        },
        {
            "dependency": "pandas",
            "version": "==0.24",
            "time": "2020-01-15",
            "description": "The code creates a DataFrame with a column named \"error_code\" containing integer and NaN values, and then changes the data type of the \"error_code\" column to Int8.",
            "code": "df = pd.DataFrame({\"error_code\":[1,2,5,np.nan]}) \nprint(df.dtypes)\n\n# error_code    float64\n# dtype: object\n\ndf[\"error_code\"] = df[\"error_code\"].astype(\"Int8\") \nprint(df.dtypes)",
            "masked_code": "<line_mask>\nprint(df.dtypes)\n\n# error_code    float64\n# dtype: object\n\ndf[\"error_code\"] = df[\"error_code\"].astype(\"Int8\") \nprint(df.dtypes)",
            "masked_line": "df = pd.DataFrame({\"error_code\":[1,2,5,np.nan]})",
            "answer": "DataFrame",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1351"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2020-08-17",
            "description": "This code generates a random binary array with a specified size where 80% of the elements are zeros.",
            "code": "size = (960, 200, 200, 1)\nproba_0 = 0.8                 # resulting array will have 80% of zeros\nnp.random.choice([0, 1], size=size, p=[proba_0, 1-proba_0])",
            "masked_code": "size = (960, 200, 200, 1)\nproba_0 = 0.8                 # resulting array will have 80% of zeros\n<line_mask>",
            "masked_line": "np.random.choice([0, 1], size=size, p=[proba_0, 1-proba_0])",
            "answer": "choice",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1352"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.5.2.52",
            "time": "2021-10-15",
            "description": "This code snippet reads a video file frame by frame using OpenCV in Python and prints out the timestamp and frame number for each frame. It calculates and prints out the timestamp based on the frame number and frames per second (fps) of the video.",
            "code": "index = 0\ncap = cv2.VideoCapture(video_path)\nfps = cap.get(cv2.CAP_PROP_FPS)\nwhile True:\n    offset = cap.get(cv2.CAP_PROP_POS_MSEC)\n\n    ok, frame = cap.read()\n    if not ok:\n        break\n    \n    # CAP_PROP_POS_MSEC\n    print(\"CAP_PROP_POS_MSEC: \", index, offset)\n    \n    # Devide fps by frame number\n    offset = cap.get(cv2.CAP_PROP_POS_FRAMES) / fps * 1000\n    print(\"cv2.CAP_PROP_POS_FRAMES\", index, offset)\n     \n    index += 1",
            "masked_code": "index = 0\n<line_mask>\nfps = cap.get(cv2.CAP_PROP_FPS)\nwhile True:\n    offset = cap.get(cv2.CAP_PROP_POS_MSEC)\n\n    ok, frame = cap.read()\n    if not ok:\n        break\n    \n    # CAP_PROP_POS_MSEC\n    print(\"CAP_PROP_POS_MSEC: \", index, offset)\n    \n    # Devide fps by frame number\n    offset = cap.get(cv2.CAP_PROP_POS_FRAMES) / fps * 1000\n    print(\"cv2.CAP_PROP_POS_FRAMES\", index, offset)\n     \n    index += 1",
            "masked_line": "cap = cv2.VideoCapture(video_path)",
            "answer": "VideoCapture",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1353"
        },
        {
            "dependency": "tensorflow",
            "version": ">2.4",
            "time": "2021-12-01",
            "description": "This Python code defines a TensorFlow model class called TimingModelTF. The call method of this class takes an input tensor x, converts it to a float32 data type, and returns the element at the 0th row and 0th column of the tensor.",
            "code": "class TimingModelTF(tf.keras.Model):\n    def __init__(self, ):\n        super(TimingModelTF, self).__init__()\n\n    @tf.function(jit_compile=True)\n    def call(self, x):\n        return tf.cast(x, dtype=tf.float32)[0, 0]",
            "masked_code": "class TimingModelTF(tf.keras.Model):\n    def __init__(self, ):\n        super(TimingModelTF, self).__init__()\n\n    @tf.function(jit_compile=True)\n    def call(self, x):\n        <line_mask>",
            "masked_line": "return tf.cast(x, dtype=tf.float32)[0, 0]",
            "answer": "cast",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1354"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2021-09-22",
            "description": "The code disables eager execution in TensorFlow.",
            "code": "tf.compat.v1.disable_eager_execution()",
            "masked_code": "<line_mask>",
            "masked_line": "tf.compat.v1.disable_eager_execution()",
            "answer": "v1",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1355"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-05-06",
            "description": "The code generates a horizontal bar plot using seaborn library to visualize the new data with predictions for different variables. The plot displays the values for each variable with different colors representing different predictions.",
            "code": "import pandas as pd\nimport seaborn as sns\n\n# new data; note there are different values for prediction\n{'prediction': {5: 'c1', 4: 'c3', 3: 'c3', 2: 'c1', 0: 'c1', 1: 'c2', 7: 'c2', 6: 'c2'}, 'variable': {5: 'ft1', 4: 'ft2', 3: 'ft3', 2: 'ft4', 0: 'ft5', 1: 'ft6', 7: 'ft7', 6: 'ft8'}, 'value': {5: 0.020915912763961077, 4: 0.020388363414781133, 3: 0.007204373035913109, 2: 0.0035298765062560817, 0: -0.002049702058734183, 1: -0.004283512505036808, 7: -0.01882610282871816, 6: -0.022324439779323434}}\n\ndf = pd.DataFrame(x)\n\nsns.barplot(data=df, x='value', y='variable', hue='prediction', orient=\"h\", color='red', ec='k', dodge=False)",
            "masked_code": "import pandas as pd\nimport seaborn as sns\n\n# new data; note there are different values for prediction\n{'prediction': {5: 'c1', 4: 'c3', 3: 'c3', 2: 'c1', 0: 'c1', 1: 'c2', 7: 'c2', 6: 'c2'}, 'variable': {5: 'ft1', 4: 'ft2', 3: 'ft3', 2: 'ft4', 0: 'ft5', 1: 'ft6', 7: 'ft7', 6: 'ft8'}, 'value': {5: 0.020915912763961077, 4: 0.020388363414781133, 3: 0.007204373035913109, 2: 0.0035298765062560817, 0: -0.002049702058734183, 1: -0.004283512505036808, 7: -0.01882610282871816, 6: -0.022324439779323434}}\n\ndf = pd.DataFrame(x)\n\n<line_mask>",
            "masked_line": "sns.barplot(data=df, x='value', y='variable', hue='prediction', orient=\"h\", color='red', ec='k', dodge=False)",
            "answer": "barplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1356"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-05-09",
            "description": "The code sorts the 'Company' column alphabetically and creates a boxplot of 'Price_euros' against 'Company' using the sorted order.",
            "code": "# to sort alphabetically by company\ndftrain.Company = pd.Categorical(dftrain.Company, categories=sorted(dftrain.Company.unique()), ordered=True)\n\n# plot\nplt.figure(figsize=(8, 6))\nsns.boxplot(data=dftrain, x='Price_euros', y='Company')",
            "masked_code": "# to sort alphabetically by company\ndftrain.Company = pd.Categorical(dftrain.Company, categories=sorted(dftrain.Company.unique()), ordered=True)\n\n# plot\nplt.figure(figsize=(8, 6))\n<line_mask>",
            "masked_line": "sns.boxplot(data=dftrain, x='Price_euros', y='Company')",
            "answer": "boxplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1357"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-05-09",
            "description": "This code calculates the mean price of each company from the 'dftrain' DataFrame, sorts the companies based on these mean prices, and then plots a boxplot of the 'Price_euros' column against the 'Company' column in the DataFrame 'dftrain' with the companies ordered based on their mean prices.",
            "code": "# get the index for the mean of each company\nmean_index = dftrain.groupby('Company').Price_euros.mean().sort_values().index\n\n# plot using order\nplt.figure(figsize=(8, 6))\nsns.boxplot(data=dftrain, x='Price_euros', y='Company', order=mean_index)",
            "masked_code": "# get the index for the mean of each company\nmean_index = dftrain.groupby('Company').Price_euros.mean().sort_values().index\n\n# plot using order\nplt.figure(figsize=(8, 6))\n<line_mask>",
            "masked_line": "sns.boxplot(data=dftrain, x='Price_euros', y='Company', order=mean_index)",
            "answer": "boxplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1358"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4.0",
            "time": "2021-07-11",
            "description": "This code generates a bar plot showing the relationship between two variables. The x-axis represents the index of the data group, the y-axis represents the values of the group. The plot displays the average of the second variable for each group. The plot also includes labels for the bars and a title describing the relationship between the two variables.",
            "code": "def barplot_groups(group_, my_labels, var_names):\n    fig, ax = plt.subplots(figsize=(15, 7))\n    sns.barplot(x=group_.index, y=group_.values, ax=ax)\n    ax.set(xlabel=f'{var_names[0]}',\n           ylabel=f'Average of {var_names[1]}',\n           title=f'Relationship between {var_names[0]} and {var_names[1]}')\n\n    ax.bar_label(ax.containers[0], labels=my_labels, label_type='center',\n                 rotation=90)\n    plt.show()",
            "masked_code": "def barplot_groups(group_, my_labels, var_names):\n    <line_mask>\n    sns.barplot(x=group_.index, y=group_.values, ax=ax)\n    ax.set(xlabel=f'{var_names[0]}',\n           ylabel=f'Average of {var_names[1]}',\n           title=f'Relationship between {var_names[0]} and {var_names[1]}')\n\n    ax.bar_label(ax.containers[0], labels=my_labels, label_type='center',\n                 rotation=90)\n    plt.show()",
            "masked_line": "fig, ax = plt.subplots(figsize=(15, 7))",
            "answer": "subplots",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1359"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.5.1.48",
            "time": "2021-11-16",
            "description": "The code creates a SIFT (Scale-Invariant Feature Transform) object using the OpenCV library.",
            "code": "sift = cv2.SIFT_create() # it's in main, no more xfeatures2d",
            "masked_code": "<line_mask>",
            "masked_line": "sift = cv2.SIFT_create() # it's in main, no more xfeatures2d",
            "answer": "SIFT_create",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1360"
        },
        {
            "dependency": "numpy",
            "version": "==1.20.0",
            "time": "2022-01-29",
            "description": "This function generates Insightface embeddings for a set of grayscale images converted to RGB format. It loops through a list of image file paths, reads the image, converts it to RGB, and then generates the embedding using the Insightface model. The function then appends the embeddings to one list and the corresponding labels to another list before returning both lists.",
            "code": "def generate_embs(img_fpaths: List[str]):\n  embs_set = list()\n  embs_label = list()\n\n  for img_fpath in img_fpaths:  \n    print('tratamento: ',img_fpath)                    \n    # read grayscale img\n    img = Image.open(os.path.join(YALE_DIR, img_fpath)) \n    img_arr = np.asarray(img)  \n    \n    # convert grayscale to rgb\n    im = Image.fromarray((img_arr * 255).astype(np.uint8))\n    rgb_arr = np.asarray(im.convert('RGB'))       \n   \n    # generate Insightface embedding\n    emb_res = app.get(rgb_arr)\n    try:\n     res = emb_res[0].embedding\n     # append emb to the eval set\n     embs_set.append(res)          \n     # append label to eval_label set\n     embs_label.append(img_fpath.split(\"_\")[0])\n    except:\n     print('no embedding found for this image')\n  return embs_set, embs_label",
            "masked_code": "def generate_embs(img_fpaths: List[str]):\n  embs_set = list()\n  embs_label = list()\n\n  for img_fpath in img_fpaths:  \n    print('tratamento: ',img_fpath)                    \n    # read grayscale img\n    img = Image.open(os.path.join(YALE_DIR, img_fpath)) \n    <line_mask>\n    \n    # convert grayscale to rgb\n    im = Image.fromarray((img_arr * 255).astype(np.uint8))\n    rgb_arr = np.asarray(im.convert('RGB'))       \n   \n    # generate Insightface embedding\n    emb_res = app.get(rgb_arr)\n    try:\n     res = emb_res[0].embedding\n     # append emb to the eval set\n     embs_set.append(res)          \n     # append label to eval_label set\n     embs_label.append(img_fpath.split(\"_\")[0])\n    except:\n     print('no embedding found for this image')\n  return embs_set, embs_label",
            "masked_line": "img_arr = np.asarray(img)",
            "answer": "asarray",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1361"
        },
        {
            "dependency": "spacy",
            "version": "==3.0",
            "time": "2021-02-05",
            "description": "This code loads the English language model from the spaCy library.",
            "code": "spacy.load('en_core_web_sm')",
            "masked_code": "<line_mask>",
            "masked_line": "spacy.load('en_core_web_sm')",
            "answer": "load",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1362"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.3",
            "time": "2021-12-15",
            "description": "The code identifies and visualizes the data points where the power values are considered as unusual (outside a predefined list of unusual power values). It plots a line chart for normal power values and scatter plot for unusual power values.",
            "code": "df = pd.DataFrame({'datetime': {0: '2021-12-01 00:00:00', 5: '2021-12-01 01:00:00', 10: '2021-12-01 02:00:00', 15: '2021-12-01 03:00:00', 20: '2021-12-01 04:00:00', 1129: '2021-12-10 09:00:00', 1134: '2021-12-10 10:00:00', 1149: '2021-12-10 13:00:00', 1154: '2021-12-10 14:00:00', 1159: '2021-12-10 15:00:00', 1164: '2021-12-10 16:00:00', 1169: '2021-12-10 17:00:00'}, 'invno': {0: 1, 5: 1, 10: 1, 15: 1, 20: 1, 1129: 5, 1134: 5, 1149: 5, 1154: 5, 1159: 5, 1164: 5, 1169: 5}, 'power': {0: 0.0, 5: 0.0, 10: 0.0, 15: 0.0, 20: 0.0, 1129: 2.914, 1134: 10.318, 1149: 2.756, 1154: 1.297, 1159: 1.503, 1164: 1.417, 1169: 0.084}})\nonly_unusual = [13.266, 4.213291, 2.756, 3.6722, 12.356, 12.193, 10.318, 12.203, 8.7549, 9.536, 9.10677, 1.417]\n\nmatches = df[np.isclose(df['power'].values[:, None], only_unusual).any(axis=1)]\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(pd.to_datetime(df['datetime']), df['power'], color='b', label='Normal')\nax.scatter(pd.to_datetime(matches['datetime']), matches['power'], color='r', label='Unusual', marker='o')\nax.xaxis_date()\nplt.xlabel('Date Time')\nplt.ylabel('Power')\nplt.legend()\nfig.autofmt_xdate()",
            "masked_code": "df = pd.DataFrame({'datetime': {0: '2021-12-01 00:00:00', 5: '2021-12-01 01:00:00', 10: '2021-12-01 02:00:00', 15: '2021-12-01 03:00:00', 20: '2021-12-01 04:00:00', 1129: '2021-12-10 09:00:00', 1134: '2021-12-10 10:00:00', 1149: '2021-12-10 13:00:00', 1154: '2021-12-10 14:00:00', 1159: '2021-12-10 15:00:00', 1164: '2021-12-10 16:00:00', 1169: '2021-12-10 17:00:00'}, 'invno': {0: 1, 5: 1, 10: 1, 15: 1, 20: 1, 1129: 5, 1134: 5, 1149: 5, 1154: 5, 1159: 5, 1164: 5, 1169: 5}, 'power': {0: 0.0, 5: 0.0, 10: 0.0, 15: 0.0, 20: 0.0, 1129: 2.914, 1134: 10.318, 1149: 2.756, 1154: 1.297, 1159: 1.503, 1164: 1.417, 1169: 0.084}})\nonly_unusual = [13.266, 4.213291, 2.756, 3.6722, 12.356, 12.193, 10.318, 12.203, 8.7549, 9.536, 9.10677, 1.417]\n\nmatches = df[np.isclose(df['power'].values[:, None], only_unusual).any(axis=1)]\n\nfig, ax = plt.subplots(figsize=(8, 6))\n<line_mask>\nax.scatter(pd.to_datetime(matches['datetime']), matches['power'], color='r', label='Unusual', marker='o')\nax.xaxis_date()\nplt.xlabel('Date Time')\nplt.ylabel('Power')\nplt.legend()\nfig.autofmt_xdate()",
            "masked_line": "ax.plot(pd.to_datetime(df['datetime']), df['power'], color='b', label='Normal')",
            "answer": "to_datetime",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1363"
        },
        {
            "dependency": "numpy",
            "version": "==1.20.3",
            "time": "2021-12-15",
            "description": "The code identifies and plots unusual power values from a DataFrame. It compares the 'power' column values in the DataFrame with a predefined list of unusual values, and then creates a plot showing normal and unusual power values based on the comparison.",
            "code": "df = pd.DataFrame({'datetime': {0: '2021-12-01 00:00:00', 5: '2021-12-01 01:00:00', 10: '2021-12-01 02:00:00', 15: '2021-12-01 03:00:00', 20: '2021-12-01 04:00:00', 1129: '2021-12-10 09:00:00', 1134: '2021-12-10 10:00:00', 1149: '2021-12-10 13:00:00', 1154: '2021-12-10 14:00:00', 1159: '2021-12-10 15:00:00', 1164: '2021-12-10 16:00:00', 1169: '2021-12-10 17:00:00'}, 'invno': {0: 1, 5: 1, 10: 1, 15: 1, 20: 1, 1129: 5, 1134: 5, 1149: 5, 1154: 5, 1159: 5, 1164: 5, 1169: 5}, 'power': {0: 0.0, 5: 0.0, 10: 0.0, 15: 0.0, 20: 0.0, 1129: 2.914, 1134: 10.318, 1149: 2.756, 1154: 1.297, 1159: 1.503, 1164: 1.417, 1169: 0.084}})\nonly_unusual = [13.266, 4.213291, 2.756, 3.6722, 12.356, 12.193, 10.318, 12.203, 8.7549, 9.536, 9.10677, 1.417]\n\nmatches = df[np.isclose(df['power'].values[:, None], only_unusual).any(axis=1)]\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(pd.to_datetime(df['datetime']), df['power'], color='b', label='Normal')\nax.scatter(pd.to_datetime(matches['datetime']), matches['power'], color='r', label='Unusual', marker='o')\nax.xaxis_date()\nplt.xlabel('Date Time')\nplt.ylabel('Power')\nplt.legend()\nfig.autofmt_xdate()",
            "masked_code": "df = pd.DataFrame({'datetime': {0: '2021-12-01 00:00:00', 5: '2021-12-01 01:00:00', 10: '2021-12-01 02:00:00', 15: '2021-12-01 03:00:00', 20: '2021-12-01 04:00:00', 1129: '2021-12-10 09:00:00', 1134: '2021-12-10 10:00:00', 1149: '2021-12-10 13:00:00', 1154: '2021-12-10 14:00:00', 1159: '2021-12-10 15:00:00', 1164: '2021-12-10 16:00:00', 1169: '2021-12-10 17:00:00'}, 'invno': {0: 1, 5: 1, 10: 1, 15: 1, 20: 1, 1129: 5, 1134: 5, 1149: 5, 1154: 5, 1159: 5, 1164: 5, 1169: 5}, 'power': {0: 0.0, 5: 0.0, 10: 0.0, 15: 0.0, 20: 0.0, 1129: 2.914, 1134: 10.318, 1149: 2.756, 1154: 1.297, 1159: 1.503, 1164: 1.417, 1169: 0.084}})\nonly_unusual = [13.266, 4.213291, 2.756, 3.6722, 12.356, 12.193, 10.318, 12.203, 8.7549, 9.536, 9.10677, 1.417]\n\n<line_mask>\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(pd.to_datetime(df['datetime']), df['power'], color='b', label='Normal')\nax.scatter(pd.to_datetime(matches['datetime']), matches['power'], color='r', label='Unusual', marker='o')\nax.xaxis_date()\nplt.xlabel('Date Time')\nplt.ylabel('Power')\nplt.legend()\nfig.autofmt_xdate()",
            "masked_line": "matches = df[np.isclose(df['power'].values[:, None], only_unusual).any(axis=1)]",
            "answer": "any",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1364"
        },
        {
            "dependency": "matplotlib",
            "version": "==1.3.5",
            "time": "2021-12-15",
            "description": "The code identifies and visualizes unusual power consumption data points by comparing them with a predefined list of unusual power values. It plots normal power consumption data in blue and unusual data in red, showing the date and time along with the corresponding power values.",
            "code": "df = pd.DataFrame({'datetime': {0: '2021-12-01 00:00:00', 5: '2021-12-01 01:00:00', 10: '2021-12-01 02:00:00', 15: '2021-12-01 03:00:00', 20: '2021-12-01 04:00:00', 1129: '2021-12-10 09:00:00', 1134: '2021-12-10 10:00:00', 1149: '2021-12-10 13:00:00', 1154: '2021-12-10 14:00:00', 1159: '2021-12-10 15:00:00', 1164: '2021-12-10 16:00:00', 1169: '2021-12-10 17:00:00'}, 'invno': {0: 1, 5: 1, 10: 1, 15: 1, 20: 1, 1129: 5, 1134: 5, 1149: 5, 1154: 5, 1159: 5, 1164: 5, 1169: 5}, 'power': {0: 0.0, 5: 0.0, 10: 0.0, 15: 0.0, 20: 0.0, 1129: 2.914, 1134: 10.318, 1149: 2.756, 1154: 1.297, 1159: 1.503, 1164: 1.417, 1169: 0.084}})\nonly_unusual = [13.266, 4.213291, 2.756, 3.6722, 12.356, 12.193, 10.318, 12.203, 8.7549, 9.536, 9.10677, 1.417]\n\nmatches = df[np.isclose(df['power'].values[:, None], only_unusual).any(axis=1)]\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(pd.to_datetime(df['datetime']), df['power'], color='b', label='Normal')\nax.scatter(pd.to_datetime(matches['datetime']), matches['power'], color='r', label='Unusual', marker='o')\nax.xaxis_date()\nplt.xlabel('Date Time')\nplt.ylabel('Power')\nplt.legend()\nfig.autofmt_xdate()",
            "masked_code": "df = pd.DataFrame({'datetime': {0: '2021-12-01 00:00:00', 5: '2021-12-01 01:00:00', 10: '2021-12-01 02:00:00', 15: '2021-12-01 03:00:00', 20: '2021-12-01 04:00:00', 1129: '2021-12-10 09:00:00', 1134: '2021-12-10 10:00:00', 1149: '2021-12-10 13:00:00', 1154: '2021-12-10 14:00:00', 1159: '2021-12-10 15:00:00', 1164: '2021-12-10 16:00:00', 1169: '2021-12-10 17:00:00'}, 'invno': {0: 1, 5: 1, 10: 1, 15: 1, 20: 1, 1129: 5, 1134: 5, 1149: 5, 1154: 5, 1159: 5, 1164: 5, 1169: 5}, 'power': {0: 0.0, 5: 0.0, 10: 0.0, 15: 0.0, 20: 0.0, 1129: 2.914, 1134: 10.318, 1149: 2.756, 1154: 1.297, 1159: 1.503, 1164: 1.417, 1169: 0.084}})\nonly_unusual = [13.266, 4.213291, 2.756, 3.6722, 12.356, 12.193, 10.318, 12.203, 8.7549, 9.536, 9.10677, 1.417]\n\nmatches = df[np.isclose(df['power'].values[:, None], only_unusual).any(axis=1)]\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(pd.to_datetime(df['datetime']), df['power'], color='b', label='Normal')\nax.scatter(pd.to_datetime(matches['datetime']), matches['power'], color='r', label='Unusual', marker='o')\nax.xaxis_date()\nplt.xlabel('Date Time')\nplt.ylabel('Power')\nplt.legend()\n<line_mask>",
            "masked_line": "fig.autofmt_xdate()",
            "answer": "autofmt_xdate",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1365"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.0.3",
            "time": "2021-10-28",
            "description": "The code creates a polar plot with data points from the lists data1 and data2.",
            "code": "data1 = [-2, -5,  2, 2]\ndata2 = [-2, 2, -2, 2]\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection=\"polar\")\nax.scatter(\n        data2,\n        data1,\n        s=30)\n\nplt.show()",
            "masked_code": "data1 = [-2, -5,  2, 2]\ndata2 = [-2, 2, -2, 2]\n\nfig = plt.figure()\n<line_mask>\nax.scatter(\n        data2,\n        data1,\n        s=30)\n\nplt.show()",
            "masked_line": "ax = fig.add_subplot(111, projection=\"polar\")",
            "answer": "add_subplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1366"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2021-10-18",
            "description": "Calculate the sum of the elements in the 'predictions' tensor along axis 0.",
            "code": "tf.reduce_sum(predictions, axis= 0)",
            "masked_code": "<line_mask>",
            "masked_line": "tf.reduce_sum(predictions, axis= 0)",
            "answer": "reduce_sum",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1367"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.3",
            "time": "2021-10-08",
            "description": "The code finds the maximum values of each column in a pandas DataFrame for each date in the index, and creates a new DataFrame with these maximum values for the columns specified in the 'ozone' list.",
            "code": "ozone = ['MDA8_3135', 'MDA8_2551', 'MDA8_3186', 'MDA8_2878', 'MDA8_2199', 'MDA8_3168'] \ndf = pd.read_csv('IV_hourly_dataframe_Clim_Anom.csv', parse_dates=['date'], index_col=['date'])\nout = {col: df.loc[df[col].groupby(df.index.date).idxmax().dropna()] for col in ozone}",
            "masked_code": "ozone = ['MDA8_3135', 'MDA8_2551', 'MDA8_3186', 'MDA8_2878', 'MDA8_2199', 'MDA8_3168'] \n<line_mask>\nout = {col: df.loc[df[col].groupby(df.index.date).idxmax().dropna()] for col in ozone}",
            "masked_line": "df = pd.read_csv('IV_hourly_dataframe_Clim_Anom.csv', parse_dates=['date'], index_col=['date'])",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1368"
        },
        {
            "dependency": "requests",
            "version": ">=2.4.0",
            "time": "2021-05-07",
            "description": "The code tries to download content from a given link with a timeout of 10 seconds. If a connection error or read timeout occurs, an error message is printed. If any other exception occurs, an error message is also printed.",
            "code": "try : \n    timeout = 10\n    r = requests.get(\"download_link\", timeout=10)\n    data = r.content\nexcept requests.exceptions.ConnectionError as ex:\n    print('Issue file download...'+str(ex))\nexcept requests.exceptions.ReadTimeout as ex:\n    print('Issue file download...'+str(ex))\nexcept Exception as ex:\n    print('Issue file download...'+str(ex))",
            "masked_code": "try : \n    timeout = 10\n    <line_mask>\n    data = r.content\nexcept requests.exceptions.ConnectionError as ex:\n    print('Issue file download...'+str(ex))\nexcept requests.exceptions.ReadTimeout as ex:\n    print('Issue file download...'+str(ex))\nexcept Exception as ex:\n    print('Issue file download...'+str(ex))",
            "masked_line": "r = requests.get(\"download_link\", timeout=10)",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1369"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-04-22",
            "description": "This code generates a scatter plot with data points from two arrays (data1 and data2) that have been reshaped and split into sub-arrays. Each sub-array is colored according to the corresponding month, with a colorbar indicating the mapping of months to colors. The scatter plot is displayed using matplotlib.",
            "code": "from datetime import datetime as dt\nimport numpy as np                   # v 1.19.2\nimport matplotlib.pyplot as plt      # v 3.3.4\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndata1 = rng.random(360)\ndata2 = rng.random(360)\n\n# Reshape data\nsplit_data1 = np.stack(np.split(data1, 30)).transpose()\nsplit_data2 = np.stack(np.split(data2, 30)).transpose()\n\n# Generate lists of months and colors\nmonths = [dt.strptime(str(m), '%m').strftime('%B') for m in range(1, 13)]\ncmap = plt.cm.get_cmap('viridis')  # no need to preselect number of colors in this case\ncolors = cmap(np.linspace(0, 1, len(months)))\n\n# Draw scatter plot by looping over zipped sub-arrays, colors and months\nfor x, y, c, month in zip(split_data1, split_data2, colors, months):\n    plt.scatter(x, y, color=c, label=month)\n\n# Add colorbar\nbounds = np.arange(len(months)+1)\nnorm = plt.matplotlib.colors.BoundaryNorm(bounds, cmap.N)\ncbar = plt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap=cmap), ticks=bounds+0.5)\ncbar.set_ticklabels(months)\n\n# Optional extra formatting\ncbar.ax.tick_params(length=0, pad=7)\ncbar.ax.invert_yaxis()\n\nplt.show()",
            "masked_code": "from datetime import datetime as dt\nimport numpy as np                   # v 1.19.2\nimport matplotlib.pyplot as plt      # v 3.3.4\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndata1 = rng.random(360)\ndata2 = rng.random(360)\n\n# Reshape data\n<line_mask>\nsplit_data2 = np.stack(np.split(data2, 30)).transpose()\n\n# Generate lists of months and colors\nmonths = [dt.strptime(str(m), '%m').strftime('%B') for m in range(1, 13)]\ncmap = plt.cm.get_cmap('viridis')  # no need to preselect number of colors in this case\ncolors = cmap(np.linspace(0, 1, len(months)))\n\n# Draw scatter plot by looping over zipped sub-arrays, colors and months\nfor x, y, c, month in zip(split_data1, split_data2, colors, months):\n    plt.scatter(x, y, color=c, label=month)\n\n# Add colorbar\nbounds = np.arange(len(months)+1)\nnorm = plt.matplotlib.colors.BoundaryNorm(bounds, cmap.N)\ncbar = plt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap=cmap), ticks=bounds+0.5)\ncbar.set_ticklabels(months)\n\n# Optional extra formatting\ncbar.ax.tick_params(length=0, pad=7)\ncbar.ax.invert_yaxis()\n\nplt.show()",
            "masked_line": "split_data1 = np.stack(np.split(data1, 30)).transpose()",
            "answer": "transpose",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1370"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.4",
            "time": "2021-04-22",
            "description": "This code generates a scatter plot with multiple colored markers representing different months. It creates two random datasets, splits and transposes them, generates a list of months and colors, and then plots the scatter plot with each point representing a month and colored accordingly. It also adds a colorbar to the plot for reference.",
            "code": "from datetime import datetime as dt\nimport numpy as np                   # v 1.19.2\nimport matplotlib.pyplot as plt      # v 3.3.4\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndata1 = rng.random(360)\ndata2 = rng.random(360)\n\n# Reshape data\nsplit_data1 = np.stack(np.split(data1, 30)).transpose()\nsplit_data2 = np.stack(np.split(data2, 30)).transpose()\n\n# Generate lists of months and colors\nmonths = [dt.strptime(str(m), '%m').strftime('%B') for m in range(1, 13)]\ncmap = plt.cm.get_cmap('viridis')  # no need to preselect number of colors in this case\ncolors = cmap(np.linspace(0, 1, len(months)))\n\n# Draw scatter plot by looping over zipped sub-arrays, colors and months\nfor x, y, c, month in zip(split_data1, split_data2, colors, months):\n    plt.scatter(x, y, color=c, label=month)\n\n# Add colorbar\nbounds = np.arange(len(months)+1)\nnorm = plt.matplotlib.colors.BoundaryNorm(bounds, cmap.N)\ncbar = plt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap=cmap), ticks=bounds+0.5)\ncbar.set_ticklabels(months)\n\n# Optional extra formatting\ncbar.ax.tick_params(length=0, pad=7)\ncbar.ax.invert_yaxis()\n\nplt.show()",
            "masked_code": "from datetime import datetime as dt\nimport numpy as np                   # v 1.19.2\nimport matplotlib.pyplot as plt      # v 3.3.4\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndata1 = rng.random(360)\ndata2 = rng.random(360)\n\n# Reshape data\nsplit_data1 = np.stack(np.split(data1, 30)).transpose()\nsplit_data2 = np.stack(np.split(data2, 30)).transpose()\n\n# Generate lists of months and colors\nmonths = [dt.strptime(str(m), '%m').strftime('%B') for m in range(1, 13)]\ncmap = plt.cm.get_cmap('viridis')  # no need to preselect number of colors in this case\ncolors = cmap(np.linspace(0, 1, len(months)))\n\n# Draw scatter plot by looping over zipped sub-arrays, colors and months\nfor x, y, c, month in zip(split_data1, split_data2, colors, months):\n    plt.scatter(x, y, color=c, label=month)\n\n# Add colorbar\nbounds = np.arange(len(months)+1)\nnorm = plt.matplotlib.colors.BoundaryNorm(bounds, cmap.N)\n<line_mask>\ncbar.set_ticklabels(months)\n\n# Optional extra formatting\ncbar.ax.tick_params(length=0, pad=7)\ncbar.ax.invert_yaxis()\n\nplt.show()",
            "masked_line": "cbar = plt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap=cmap), ticks=bounds+0.5)",
            "answer": "cmap",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1371"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2022-07-29",
            "description": "The code writes a pandas DataFrame to an Excel sheet named 'Sheet1' with a specific cell 'A2' formatted to display duration format in the format [hh]:mm:ss, and then saves the changes to the Excel file on disk.",
            "code": "writer = pd.ExcelWriter(file = './sheet.xlsx', engine='openpyxl')\n\n\n# Writes dataFrame to Writer Sheet, including column header\n\ndf.to_excel(writer, sheet_name='Sheet1', index=False)\n\n\n# Selects which Sheet in Writer to manipulate\n\nsheet = writer.sheets['Sheet1']\n\n\n# Formats specific cell with desired duration format\n\ncell = 'A2'\nsheet[cell].number_format = '[hh]:mm:ss'\n\n\n# Writes to file on disk\n\nwriter.save()\nwriter.close()",
            "masked_code": "writer = pd.ExcelWriter(file = './sheet.xlsx', engine='openpyxl')\n\n\n# Writes dataFrame to Writer Sheet, including column header\n\ndf.to_excel(writer, sheet_name='Sheet1', index=False)\n\n\n# Selects which Sheet in Writer to manipulate\n\nsheet = writer.sheets['Sheet1']\n\n\n# Formats specific cell with desired duration format\n\ncell = 'A2'\nsheet[cell].number_format = '[hh]:mm:ss'\n\n\n# Writes to file on disk\n\nwriter.save()\n<line_mask>",
            "masked_line": "writer.close()",
            "answer": "close",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1372"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2022-07-29",
            "description": "The code reads data from an existing Excel file, appends a DataFrame to the file's Sheet1, updates the row count, and formats a specific cell with a desired duration format before saving the changes to the file on disk.",
            "code": "file = './sheet.xlsx'\n\nwriter = pd.ExcelWriter(file = file, engine='openpyxl')\n\n\n# Loads content from existing Sheet in file\n\nworkbook = load_workbook(file)\nwriter.book = workbook  #writer.book potentially needs to be explicitly stated like this\nwriter.sheets = {sheet.title: sheet for sheet in workbook.worksheets}\n\nsheet = writer.sheets['Sheet1']\n\n\n# Writes dataFrame to Writer Sheet, below the last existing row, excluding column header\n\ndf.to_excel(writer, sheet_name='Sheet1', startrow=sheet.max_row, index=False, header=False)\n\n\n# Updates the row count again, and formats specific cell with desired duration format\n# (the last cell in column A)\n\ncell = 'A' + str(sheet.max_row)\n\nsheet[cell].number_format = '[hh]:mm:ss'\n\n\n# Writes to file on disk\n\nwriter.save()\nwriter.close()",
            "masked_code": "file = './sheet.xlsx'\n\n<line_mask>\n\n\n# Loads content from existing Sheet in file\n\nworkbook = load_workbook(file)\nwriter.book = workbook  #writer.book potentially needs to be explicitly stated like this\nwriter.sheets = {sheet.title: sheet for sheet in workbook.worksheets}\n\nsheet = writer.sheets['Sheet1']\n\n\n# Writes dataFrame to Writer Sheet, below the last existing row, excluding column header\n\ndf.to_excel(writer, sheet_name='Sheet1', startrow=sheet.max_row, index=False, header=False)\n\n\n# Updates the row count again, and formats specific cell with desired duration format\n# (the last cell in column A)\n\ncell = 'A' + str(sheet.max_row)\n\nsheet[cell].number_format = '[hh]:mm:ss'\n\n\n# Writes to file on disk\n\nwriter.save()\nwriter.close()",
            "masked_line": "writer = pd.ExcelWriter(file = file, engine='openpyxl')",
            "answer": "ExcelWriter",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1373"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4.1",
            "time": "2021-03-30",
            "description": "The code uses a Tensorflow model called \"embedder\" with the default signature to embed the input with the text \"test\".",
            "code": "USE_embedder.signatures['default'](tf.constant(['test']))",
            "masked_code": "<line_mask>",
            "masked_line": "USE_embedder.signatures['default'](tf.constant(['test']))",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1374"
        },
        {
            "dependency": "trackpy",
            "version": "==0.5.0",
            "time": "2021-07-14",
            "description": "This code is creating a batch of frames from index 100 to 300 with specified mask size and minimum mass, while also inverting the frames and using only 1 process.",
            "code": "f = tp.batch(frames[100:300], masksize, minmass=minmass, invert=True, processes=1);",
            "masked_code": "<line_mask>",
            "masked_line": "f = tp.batch(frames[100:300], masksize, minmass=minmass, invert=True, processes=1);",
            "answer": "batch",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1375"
        },
        {
            "dependency": "tensorflow",
            "version": ">2.0",
            "time": "2021-02-12",
            "description": "This code creates a TensorFlow session with GPU memory growth enabled, allowing the session to allocate only as much GPU memory as needed by the process.",
            "code": "config = tf.compat.v1.ConfigProto()\n\nconfig.gpu_options.allow_growth=True\n\nsess = tf.compat.v1.Session(config=config)",
            "masked_code": "config = tf.compat.v1.ConfigProto()\n\nconfig.gpu_options.allow_growth=True\n\n<line_mask>",
            "masked_line": "sess = tf.compat.v1.Session(config=config)",
            "answer": "Session",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1376"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7",
            "time": "2021-12-17",
            "description": "This code defines the shape of the input data for a particular layer in TensorFlow's Keras API.",
            "code": "tf.keras.layers.InputSpec(shape=input_shape)",
            "masked_code": "<line_mask>",
            "masked_line": "tf.keras.layers.InputSpec(shape=input_shape)",
            "answer": "InputSpec",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1377"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2022-12-13",
            "description": "The code reads a CSV file into a pandas DataFrame from a string variable 'data', where columns 'b' and 'c' are converted to integer type after replacing any occurrence of '.' in the values.",
            "code": "df = pd.read_csv(io.StringIO(data), sep=';', dtype=str, engine='python')\nint_columns = ['b', 'c']\ndf[int_columns] = df[int_columns].apply(lambda x: x.str.replace('.', '')).astype(int)",
            "masked_code": "df = pd.read_csv(io.StringIO(data), sep=';', dtype=str, engine='python')\nint_columns = ['b', 'c']\n<line_mask>",
            "masked_line": "df[int_columns] = df[int_columns].apply(lambda x: x.str.replace('.', '')).astype(int)",
            "answer": "apply",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1378"
        },
        {
            "dependency": "torch",
            "version": "==1.12.1",
            "time": "2022-10-25",
            "description": "This code establishes a WebSocket connection for audio streaming. It receives audio data in chunks of 1000 bytes, converts the data to a byte stream, processes the audio stream using TorchAudio library, concatenates the processed audio chunks, and closes the WebSocket connection after processing.",
            "code": "@app.websocket(\"/listen\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        chunk_size = 1000\n        while True:\n            data = await websocket.receive_bytes()\n            f = BytesIO(data)\n            s = torchaudio.io.StreamReader(f)\n            s.add_basic_audio_stream(chunk_size)\n            array = torch.concat([chunk[0] for chunk in s.stream()])\n    except Exception as e:\n        raise Exception(f'Could not process audio: {e}')\n    finally:\n        await websocket.close()",
            "masked_code": "@app.websocket(\"/listen\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        chunk_size = 1000\n        while True:\n            data = await websocket.receive_bytes()\n            f = BytesIO(data)\n            s = torchaudio.io.StreamReader(f)\n            s.add_basic_audio_stream(chunk_size)\n            <line_mask>\n    except Exception as e:\n        raise Exception(f'Could not process audio: {e}')\n    finally:\n        await websocket.close()",
            "masked_line": "array = torch.concat([chunk[0] for chunk in s.stream()])",
            "answer": "concat",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1379"
        },
        {
            "dependency": "torchaudio",
            "version": "==0.12.1",
            "time": "2022-10-25",
            "description": "This code sets up a websocket endpoint to listen for incoming audio data chunks, processes them using torchaudio library, and sends back the processed audio data. If there is an exception during processing, it raises an exception and closes the websocket connection.",
            "code": "@app.websocket(\"/listen\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        chunk_size = 1000\n        while True:\n            data = await websocket.receive_bytes()\n            f = BytesIO(data)\n            s = torchaudio.io.StreamReader(f)\n            s.add_basic_audio_stream(chunk_size)\n            array = torch.concat([chunk[0] for chunk in s.stream()])\n    except Exception as e:\n        raise Exception(f'Could not process audio: {e}')\n    finally:\n        await websocket.close()",
            "masked_code": "@app.websocket(\"/listen\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        chunk_size = 1000\n        while True:\n            data = await websocket.receive_bytes()\n            f = BytesIO(data)\n            <line_mask>\n            s.add_basic_audio_stream(chunk_size)\n            array = torch.concat([chunk[0] for chunk in s.stream()])\n    except Exception as e:\n        raise Exception(f'Could not process audio: {e}')\n    finally:\n        await websocket.close()",
            "masked_line": "s = torchaudio.io.StreamReader(f)",
            "answer": "StreamReader",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1380"
        },
        {
            "dependency": "pytest",
            "version": "==7.0.1",
            "time": "2022-07-11",
            "description": "The code defines a MockResponse class with an init method to initialize status code and raise for status attributes, as well as a json method that returns a dictionary containing fake access token, token type, and expiration time. The code also includes a fixture to mock the Requests.post() method to return the MockResponse object, and a test case to check if the access token returned by a function matches the fake access token in the MockResponse object.",
            "code": "class MockResponse:\n    def __init__(self, status_code, raise_for_status):\n        self.status_code = status_code\n        self.raise_for_status = raise_for_status\n\n    @staticmethod\n    def json() -> Dict[str, Union[str, int]]:\n        return {\n            'access_token': 'fake-access-token',\n            'token_type': 'fake-token-type',\n            'expires_in': 10800,\n        }\n\n@pytest.fixture\ndef mock_response(monkeypatch):\n    \"\"\"Requests.post() mocked to return json.\"\"\"\n    def wrapper(status_code, raise_for_status=None):\n        def mock_post(*args, **kwargs):\n            return MockResponse(status_code, raise_for_status)\n\n        monkeypatch.setattr(requests, \"post\", mock_post)\n\n    return wrapper\n\n\ndef test_some_random_status_code(mock_response) -> None:\n    mock_response(301)\n\n    result = get_access_token(\n        url=\"https://fakeurl\",\n        client_id=\"fake-client-id\",\n        client_secret=\"fake-client-secret\",\n        grant_type=\"fake-grant-type\",\n    )\n\n    assert result['access_token'] == \"fake-access-token\"",
            "masked_code": "class MockResponse:\n    def __init__(self, status_code, raise_for_status):\n        self.status_code = status_code\n        self.raise_for_status = raise_for_status\n\n    @staticmethod\n    def json() -> Dict[str, Union[str, int]]:\n        return {\n            'access_token': 'fake-access-token',\n            'token_type': 'fake-token-type',\n            'expires_in': 10800,\n        }\n\n<line_mask>\ndef mock_response(monkeypatch):\n    \"\"\"Requests.post() mocked to return json.\"\"\"\n    def wrapper(status_code, raise_for_status=None):\n        def mock_post(*args, **kwargs):\n            return MockResponse(status_code, raise_for_status)\n\n        monkeypatch.setattr(requests, \"post\", mock_post)\n\n    return wrapper\n\n\ndef test_some_random_status_code(mock_response) -> None:\n    mock_response(301)\n\n    result = get_access_token(\n        url=\"https://fakeurl\",\n        client_id=\"fake-client-id\",\n        client_secret=\"fake-client-secret\",\n        grant_type=\"fake-grant-type\",\n    )\n\n    assert result['access_token'] == \"fake-access-token\"",
            "masked_line": "@pytest.fixture",
            "answer": "fixture",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1381"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4.0",
            "time": "2022-11-16",
            "description": "The code creates a bar graph with multiple bars for each category in the x-axis using the data provided in the \"values\" dictionary. Each bar represents a different value (eu, man, min3, min4, che) corresponding to the x-axis categories (ENN, CNN, ENN-CNN). The resulting bar graph is displayed in a 2x3 subplot layout with the specified figure size.",
            "code": "values = {\"x_values\" : [\"ENN\", \"CNN\", \"ENN-CNN\"],\n\"eu\" : [11, 79.97, 91],\n\"man\" : [11, 80, 90],\n\"min3\" : [11, 79.70, 90],\n\"min4\" : [11, 79.50, 90],\n\"che\" : [12, 78, 89]}\n\ndf = pd.DataFrame(data=values)\n\nfig, axs = plt.subplots(2, 3, figsize=(10,6))\n\neu = axs[0, 0].bar(df[\"x_values\"], df[\"eu\"])\naxs[0,0].bar_label(eu)\nman = axs[0, 1].bar(df[\"x_values\"], df[\"man\"])\naxs[0,1].bar_label(man)\nmin3 = axs[0, 2].bar(df[\"x_values\"], df[\"min3\"])\naxs[0,2].bar_label(min3)\nmin4 = axs[1, 0].bar(df[\"x_values\"], df[\"min4\"])\naxs[1,0].bar_label(min4)\nche = axs[1, 1].bar(df[\"x_values\"], df[\"che\"])\naxs[1,1].bar_label(che)\nfig.delaxes(axs[1, 2])",
            "masked_code": "values = {\"x_values\" : [\"ENN\", \"CNN\", \"ENN-CNN\"],\n\"eu\" : [11, 79.97, 91],\n\"man\" : [11, 80, 90],\n\"min3\" : [11, 79.70, 90],\n\"min4\" : [11, 79.50, 90],\n\"che\" : [12, 78, 89]}\n\ndf = pd.DataFrame(data=values)\n\nfig, axs = plt.subplots(2, 3, figsize=(10,6))\n\n<line_mask>\naxs[0,0].bar_label(eu)\nman = axs[0, 1].bar(df[\"x_values\"], df[\"man\"])\naxs[0,1].bar_label(man)\nmin3 = axs[0, 2].bar(df[\"x_values\"], df[\"min3\"])\naxs[0,2].bar_label(min3)\nmin4 = axs[1, 0].bar(df[\"x_values\"], df[\"min4\"])\naxs[1,0].bar_label(min4)\nche = axs[1, 1].bar(df[\"x_values\"], df[\"che\"])\naxs[1,1].bar_label(che)\nfig.delaxes(axs[1, 2])",
            "masked_line": "eu = axs[0, 0].bar(df[\"x_values\"], df[\"eu\"])",
            "answer": "bar",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1382"
        },
        {
            "dependency": "datasets",
            "version": "==1.7.0",
            "time": "2022-12-06",
            "description": "This code initializes a dataset, sets a transformation function for the dataset, sets the format of the dataset to \"torch\", and creates a data loader for the dataset with a batch size of 32.",
            "code": "...\ndataset.set_transform(annot)\ndataset.set_format(\"torch\")\ndataloader = torch.utils.data.DataLoader(dataset, batch_size=32)",
            "masked_code": "...\n<line_mask>\ndataset.set_format(\"torch\")\ndataloader = torch.utils.data.DataLoader(dataset, batch_size=32)",
            "masked_line": "dataset.set_transform(annot)",
            "answer": "set_transform",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1383"
        },
        {
            "dependency": "PyAutoGUI",
            "version": ">=0.9.41",
            "time": "2022-11-21",
            "description": "The code detects the center coordinates of an image on the screen with 80% confidence. If the image is not found, it prints \"Not Detected\" and clicks at a specific coordinate. If the image is found, it prints \"Detected\" and clicks at the center coordinates of the image.",
            "code": "pt = pyautogui.locateCenterOnScreen('yellow.png', confidence=0.8)\nif not pt:\n    print(\"Not Detected\")\n    pyautogui.click(1280,720)\nelse:\n    x, y = pt\n    print(\"Detected\")\n    pyautogui.click(x, y)",
            "masked_code": "<line_mask>\nif not pt:\n    print(\"Not Detected\")\n    pyautogui.click(1280,720)\nelse:\n    x, y = pt\n    print(\"Detected\")\n    pyautogui.click(x, y)",
            "masked_line": "pt = pyautogui.locateCenterOnScreen('yellow.png', confidence=0.8)",
            "answer": "locateCenterOnScreen",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1384"
        },
        {
            "dependency": "transformers",
            "version": "==4.16.2",
            "time": "2022-02-11",
            "description": "This code sets up a text classification pipeline using a pre-trained model and tokenizer to predict the category of a given input text with all the prediction scores returned.",
            "code": "from transformers import TextClassificationPipeline, AutoTokenizer, AutoModelForSequenceClassification\n\nMODEL_NAME = \"...\"\ntokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)\nmodel = AutoModelForSequenceClassification.from_pretrained(MODEL_NAME)\n\npipe = TextClassificationPipeline(model=model, tokenizer=tokenizer)\nprediction = pipe(\"The text to predict\", return_all_scores=True)",
            "masked_code": "from transformers import TextClassificationPipeline, AutoTokenizer, AutoModelForSequenceClassification\n\nMODEL_NAME = \"...\"\ntokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)\nmodel = AutoModelForSequenceClassification.from_pretrained(MODEL_NAME)\n\npipe = TextClassificationPipeline(model=model, tokenizer=tokenizer)\n<line_mask>",
            "masked_line": "prediction = pipe(\"The text to predict\", return_all_scores=True)",
            "answer": "pipe",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1385"
        },
        {
            "dependency": "streamlit",
            "version": ">=1.18.0",
            "time": "2023-05-31",
            "description": "The code clears the cached data and resources used in the current program.",
            "code": "st.cache_data.clear()\nst.cache_resource.clear()",
            "masked_code": "<line_mask>\nst.cache_resource.clear()",
            "masked_line": "st.cache_data.clear()",
            "answer": "clear",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1386"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.8.2",
            "time": "2022-07-31",
            "description": "This code defines a custom log_huber function that calculates the Huber loss for a given input x with a threshold value m. It then creates tensor constants x and m, sets up a TensorFlow session, uses a GradientTape to compute the gradient of y with respect to x, asserts that the gradient is equal to 2.0, and prints the result. Finally, it closes the TensorFlow session.",
            "code": "tf.compat.v1.disable_eager_execution()\n\ndef log_huber(x, m):\n  if tf.abs(x) <= m:\n    return x**2\n  else:\n    return m**2 * (1 - 2 * tf.math.log(m) + tf.math.log(x**2))\n\nx = tf.constant(1.0)\nm = tf.constant(2.0)\n\n# Launch the graph in a session.\nsess = tf.compat.v1.Session()\n\nwith tf.GradientTape() as t:\n  t.watch([x, m])\n  y = tf.py_function(func=log_huber, inp=[x, m], Tout=tf.float32)\n\nwith sess.as_default():\n  dy_dx = t.gradient(y, x)\n  assert dy_dx.eval() == 2.0\n  print(dy_dx.eval())\n\nsess.close()",
            "masked_code": "<line_mask>\n\ndef log_huber(x, m):\n  if tf.abs(x) <= m:\n    return x**2\n  else:\n    return m**2 * (1 - 2 * tf.math.log(m) + tf.math.log(x**2))\n\nx = tf.constant(1.0)\nm = tf.constant(2.0)\n\n# Launch the graph in a session.\nsess = tf.compat.v1.Session()\n\nwith tf.GradientTape() as t:\n  t.watch([x, m])\n  y = tf.py_function(func=log_huber, inp=[x, m], Tout=tf.float32)\n\nwith sess.as_default():\n  dy_dx = t.gradient(y, x)\n  assert dy_dx.eval() == 2.0\n  print(dy_dx.eval())\n\nsess.close()",
            "masked_line": "tf.compat.v1.disable_eager_execution()",
            "answer": "v1",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1387"
        },
        {
            "dependency": "numpy",
            "version": ">=1.22.0",
            "time": "2022-07-06",
            "description": "This function calculates the quartiles (Q1, Q2, Q3) of a list of numbers.",
            "code": "intList = [5, 10, 14, 15, 26, 30, 31, 33, 34, 47, 64,]\n\ndef quartiles(numbers):\n    Q1, Q2, Q3 = np.quantile(numbers, [0.25, 0.5, 0.75], axis=0, method='nearest')\n    return {\n        'Q1': Q1,\n        'Q2': Q2,\n        'Q3': Q3\n    }",
            "masked_code": "intList = [5, 10, 14, 15, 26, 30, 31, 33, 34, 47, 64,]\n\ndef quartiles(numbers):\n    <line_mask>\n    return {\n        'Q1': Q1,\n        'Q2': Q2,\n        'Q3': Q3\n    }",
            "masked_line": "Q1, Q2, Q3 = np.quantile(numbers, [0.25, 0.5, 0.75], axis=0, method='nearest')",
            "answer": "quantile",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1388"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.5",
            "time": "2022-02-25",
            "description": "Returns the shape of the result of element-wise multiplication between an array filled with two elements of 20.0 each and the values of the third row in the input dataframe.",
            "code": "(np.full(2, 20.0) * df.values[2]).shape",
            "masked_code": "<line_mask>",
            "masked_line": "(np.full(2, 20.0) * df.values[2]).shape",
            "answer": "full",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1389"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.5",
            "time": "2022-01-15",
            "description": "The code creates a pandas Series mapping integers to letters, then creates a DataFrame with a column of random integers between 10 and 20, and finally adds a new column 'C2' to the DataFrame by mapping the values in 'C1' using the Series previously created. It then prints the first few rows of the DataFrame.",
            "code": "sr = pd.Series({10:\"A\", 13:\"B\", 16:\"C\", 18:\"D\"})\ndf = pd.DataFrame({\"C1\":np.random.randint(10, 20, size=3000000)})\ndf['C2'] = df['C1'].map(sr)\nprint(df.head())",
            "masked_code": "sr = pd.Series({10:\"A\", 13:\"B\", 16:\"C\", 18:\"D\"})\ndf = pd.DataFrame({\"C1\":np.random.randint(10, 20, size=3000000)})\ndf['C2'] = df['C1'].map(sr)\n<line_mask>",
            "masked_line": "print(df.head())",
            "answer": "head",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1390"
        },
        {
            "dependency": "scipy",
            "version": ">=1.7.0",
            "time": "2022-05-28",
            "description": "The code generates a plot of the probability mass function (pmf) of a binomial distribution with parameters n=14 and p=0.4. It visualizes the pmf values for different values of k (the number of successful trials) and includes a dashed line representing the pmf value for k=2. The plot also includes grid lines and labels for clarity.",
            "code": "import numpy as np\nfrom scipy.stats import binom\nimport matplotlib.pyplot as plt\n\n\nn = 14\np = 0.4\n\nk = np.arange(0, n+1)\n\nplt.plot(k, binom.pmf(k, n, p), 'o')\nplt.xlabel('k')\nplt.ylabel('pmf(k, n, p)')\nplt.title(f'Binomial distribution with {n=}, {p=}')\nax = plt.gca()\nax.set_xticks(k[::2])\n\npmf2 = binom.pmf(2, n, p)\nplt.axhline(pmf2, linestyle='--', color='k', alpha=0.5)\n\nplt.grid(True)\nplt.show()",
            "masked_code": "import numpy as np\nfrom scipy.stats import binom\nimport matplotlib.pyplot as plt\n\n\nn = 14\np = 0.4\n\nk = np.arange(0, n+1)\n\n<line_mask>\nplt.xlabel('k')\nplt.ylabel('pmf(k, n, p)')\nplt.title(f'Binomial distribution with {n=}, {p=}')\nax = plt.gca()\nax.set_xticks(k[::2])\n\npmf2 = binom.pmf(2, n, p)\nplt.axhline(pmf2, linestyle='--', color='k', alpha=0.5)\n\nplt.grid(True)\nplt.show()",
            "masked_line": "plt.plot(k, binom.pmf(k, n, p), 'o')",
            "answer": "pmf",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1391"
        },
        {
            "dependency": "pandas",
            "version": ">=1.3.0",
            "time": "2022-05-07",
            "description": "The code reads a CSV file named 'your.csv' into a DataFrame, skipping any bad lines encountered during the reading process.",
            "code": "df = pd.read_csv('your.csv', on_bad_lines='skip')",
            "masked_code": "<line_mask>",
            "masked_line": "df = pd.read_csv('your.csv', on_bad_lines='skip')",
            "answer": "read_csv",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1392"
        },
        {
            "dependency": "pendulum",
            "version": "==3.0.0",
            "time": "2023-12-22",
            "description": "The code sets the timezone to UTC using the Pendulum library.",
            "code": "pendulum.timezone(\"UTC\")",
            "masked_code": "<line_mask>",
            "masked_line": "pendulum.timezone(\"UTC\")",
            "answer": "timezone",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1393"
        },
        {
            "dependency": "polars",
            "version": "==0.16.15",
            "time": "2023-01-23",
            "description": "The code segments the data into quantiles based on the specified quantile thresholds and assigns labels to each quantile. Maintains the order of elements in the original data.",
            "code": "data = pl.Series([11, 1, 2, 2, 3, 4, 5, 1, 2, 3, 4, 5])\n \ndata.qcut([0.2, 0.4, 0.6, 0.8], labels=['q1', 'q2', 'q3', 'q4', 'q5'], maintain_order=True)",
            "masked_code": "<line_mask>\n \ndata.qcut([0.2, 0.4, 0.6, 0.8], labels=['q1', 'q2', 'q3', 'q4', 'q5'], maintain_order=True)",
            "masked_line": "data = pl.Series([11, 1, 2, 2, 3, 4, 5, 1, 2, 3, 4, 5])",
            "answer": "Series",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1394"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.1",
            "time": "2023-05-02",
            "description": "The code creates an index object with integer values 1, 2, and 3 of data type int64.",
            "code": "pd.Index([1, 2, 3], dtype=np.int64)",
            "masked_code": "<line_mask>",
            "masked_line": "pd.Index([1, 2, 3], dtype=np.int64)",
            "answer": "Index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1395"
        },
        {
            "dependency": "pypdfium2",
            "version": "==4.9.0",
            "time": "2023-05-05",
            "description": "This code snippet loads a PDF file using pdfium, extracts the first page of the PDF, renders the page into a PIL image with a specified scale, and saves the PIL image as a JPEG file in a specified directory.",
            "code": "pdf = pdfium.PdfDocument(pdf_path)\npage = pdf.get_page(0)\npil_image = page.render(scale = 300/72).to_pil()\nimage_name =f\"Images/{image_name}.jpg\"\npil_image.save(image_name)",
            "masked_code": "pdf = pdfium.PdfDocument(pdf_path)\npage = pdf.get_page(0)\n<line_mask>\nimage_name =f\"Images/{image_name}.jpg\"\npil_image.save(image_name)",
            "masked_line": "pil_image = page.render(scale = 300/72).to_pil()",
            "answer": "to_pil",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1396"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4",
            "time": "2023-09-29",
            "description": "The code performs the following tasks:\n- Inverts the order of rows in the DataFrame 'df' and assigns it to 'df2'.\n- Computes meshgrid using the range of row and column indices of the DataFrame.\n- Plots a scatter plot with markers colored in orange, outlined in black with dashed lines, sized based on values from 'df2', and transparency set based on normalized values.\n- Annotates each point on the scatter plot with its corresponding value from 'df2'.\n- Turns off axis lines, sets margins, and displays the plot.",
            "code": "# inverting df to have the same row order\ndf2 = df[::-1]\n\n# computing meshgrid\nx, y = np.meshgrid(range(df.shape[0]), range(df.shape[1]))\n\n# plotting\nplt.scatter(x, y, marker='o', color='tab:orange', ec='k', ls='--',\n            s=df2, alpha=df2.div(np.max(df2)))\n\nfor ix,iy,v in zip(x.ravel(), y.ravel(), df2.to_numpy().ravel()):\n    plt.annotate(str(v), (ix,iy), textcoords='offset points',\n                 xytext=(0,10), ha='center')\n        \nplt.axis(\"off\")\nplt.margins(y=0.2)\nplt.show()",
            "masked_code": "# inverting df to have the same row order\ndf2 = df[::-1]\n\n# computing meshgrid\nx, y = np.meshgrid(range(df.shape[0]), range(df.shape[1]))\n\n# plotting\nplt.scatter(x, y, marker='o', color='tab:orange', ec='k', ls='--',\n            s=df2, alpha=df2.div(np.max(df2)))\n\nfor ix,iy,v in zip(x.ravel(), y.ravel(), df2.to_numpy().ravel()):\n    plt.annotate(str(v), (ix,iy), textcoords='offset points',\n                 xytext=(0,10), ha='center')\n        \nplt.axis(\"off\")\n<line_mask>\nplt.show()",
            "masked_line": "plt.margins(y=0.2)",
            "answer": "margins",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1397"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.15",
            "time": "2024-01-02",
            "description": "This function preprocesses input images by reversing the image arrays along the last axis and subtracting a constant array from each image.",
            "code": "def preprocess_input(imgs):\n    return tf.reverse(imgs, axis=[-1]) - tf.constant([103.939, 116.779, 123.68], dtype=tf.float32)",
            "masked_code": "def preprocess_input(imgs):\n    <line_mask>",
            "masked_line": "return tf.reverse(imgs, axis=[-1]) - tf.constant([103.939, 116.779, 123.68], dtype=tf.float32)",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1398"
        },
        {
            "dependency": "matplotlib",
            "version": "<=3.2",
            "time": "2023-06-05",
            "description": "The code creates a horizontal bar chart showing the duration of each person's period, with the x-axis representing the years, the y-axis representing each person, and different colors representing different people.",
            "code": "result = pd.DataFrame([['Bill', 1972, 1974],\n                       ['Bill', 1976, 1978],\n                       ['Bill', 1967, 1971],\n                       ['Danny', 1969, 1975],\n                       ['Danny', 1976, 1977],\n                       ['James', 1971, 1972],\n                       ['Marshall', 1967, 1975]],\n                      columns=['Person', 'Year_start', 'Year_left'])\n\nfig, ax = plt.subplots()\n\nnames = sorted(result['Person'].unique())\n\ncolormap = plt.get_cmap('plasma')\nslicedColorMap = colormap(np.linspace(0, 1, len(names)))\n\nheight = 0.5\n\n## NEW ADDED CODE ##\n## This is your code.. get the sorted_result\nsorted_result = result.groupby('Person').agg({'Year_start': min, 'Year_left': max})\nsorted_result = sorted_result.sort_values(['Year_start', 'Year_left'], ascending=[True, True]).reset_index()\n\n## Change Person to categorical, so that, when you sort it, it will be in the order you need\n## Notice that I am using sorted_result.Person.to_list(), basically sort order as you need\nresult['Person'] = pd.Categorical(\n    result['Person'], \n    categories=sorted_result.Person.to_list(), \n    ordered=True\n)\n\n## Here, added sort_values('Person') before grouping...\nfor y, (name, g) in enumerate(result.sort_values('Person').groupby('Person')):\n    ax.broken_barh(list(zip(g['Year_start'],\n                            g['Year_left']-g['Year_start'])),\n                   (y-height/2, height),\n                   facecolors=slicedColorMap[y]\n                   )\n\nax.set_ylim(0-height, len(names)-1+height)\nax.set_xlim(result['Year_start'].min()-1, result['Year_left'].max()+1)\nax.set_yticks(range(len(sorted_result.Person.to_list())))  ##Changed name\nax.set_yticklabels(sorted_result.Person.to_list())  ## Changed name\n\nax.grid(True)\nplt.show()",
            "masked_code": "result = pd.DataFrame([['Bill', 1972, 1974],\n                       ['Bill', 1976, 1978],\n                       ['Bill', 1967, 1971],\n                       ['Danny', 1969, 1975],\n                       ['Danny', 1976, 1977],\n                       ['James', 1971, 1972],\n                       ['Marshall', 1967, 1975]],\n                      columns=['Person', 'Year_start', 'Year_left'])\n\nfig, ax = plt.subplots()\n\nnames = sorted(result['Person'].unique())\n\ncolormap = plt.get_cmap('plasma')\n<line_mask>\n\nheight = 0.5\n\n## NEW ADDED CODE ##\n## This is your code.. get the sorted_result\nsorted_result = result.groupby('Person').agg({'Year_start': min, 'Year_left': max})\nsorted_result = sorted_result.sort_values(['Year_start', 'Year_left'], ascending=[True, True]).reset_index()\n\n## Change Person to categorical, so that, when you sort it, it will be in the order you need\n## Notice that I am using sorted_result.Person.to_list(), basically sort order as you need\nresult['Person'] = pd.Categorical(\n    result['Person'], \n    categories=sorted_result.Person.to_list(), \n    ordered=True\n)\n\n## Here, added sort_values('Person') before grouping...\nfor y, (name, g) in enumerate(result.sort_values('Person').groupby('Person')):\n    ax.broken_barh(list(zip(g['Year_start'],\n                            g['Year_left']-g['Year_start'])),\n                   (y-height/2, height),\n                   facecolors=slicedColorMap[y]\n                   )\n\nax.set_ylim(0-height, len(names)-1+height)\nax.set_xlim(result['Year_start'].min()-1, result['Year_left'].max()+1)\nax.set_yticks(range(len(sorted_result.Person.to_list())))  ##Changed name\nax.set_yticklabels(sorted_result.Person.to_list())  ## Changed name\n\nax.grid(True)\nplt.show()",
            "masked_line": "slicedColorMap = colormap(np.linspace(0, 1, len(names)))",
            "answer": "colormap",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1399"
        },
        {
            "dependency": "numpy",
            "version": ">=1.26.0",
            "time": "2023-04-16",
            "description": "The code reads data from a CSV file, extracts two columns, normalizes one of the columns, shifts the normalized values by a specified amount, and then plots the original and shifted data points in a graph. Finally, it saves the graph as a PDF file.",
            "code": "data = np.genfromtxt('radio.csv', delimiter=',', skip_header=1)\n\nrad_ph = data[:, 0]  \nrad_pp = data[:, 1]\n\nbin_normalized = rad_ph / max(rad_ph)\n\nshift = 0.85 \nshift_idx = int(shift / np.diff(bin_normalized)[0])\nbin_shifted = np.concatenate((bin_normalized[shift_idx:], bin_normalized[:shift_idx]))\nrad_pp_shifted = np.concatenate((rad_pp[shift_idx:], rad_pp[:shift_idx]))\n\nplt.figure(figsize=(14,8)) \nax = plt.subplot()\n\nax.plot(bin_normalized, (rad_pp*50), linestyle='-', color='b', label='Normal', linewidth=2) \nax.plot(bin_shifted, (rad_pp_shifted*50), linestyle='-', color='#9a2462', label='shifted', linewidth=2)\n\nplt.legend(prop={'size': 16}) \nplt.savefig('PP_overplot_radio.pdf' , dpi=300)",
            "masked_code": "data = np.genfromtxt('radio.csv', delimiter=',', skip_header=1)\n\nrad_ph = data[:, 0]  \nrad_pp = data[:, 1]\n\nbin_normalized = rad_ph / max(rad_ph)\n\nshift = 0.85 \n<line_mask>\nbin_shifted = np.concatenate((bin_normalized[shift_idx:], bin_normalized[:shift_idx]))\nrad_pp_shifted = np.concatenate((rad_pp[shift_idx:], rad_pp[:shift_idx]))\n\nplt.figure(figsize=(14,8)) \nax = plt.subplot()\n\nax.plot(bin_normalized, (rad_pp*50), linestyle='-', color='b', label='Normal', linewidth=2) \nax.plot(bin_shifted, (rad_pp_shifted*50), linestyle='-', color='#9a2462', label='shifted', linewidth=2)\n\nplt.legend(prop={'size': 16}) \nplt.savefig('PP_overplot_radio.pdf' , dpi=300)",
            "masked_line": "shift_idx = int(shift / np.diff(bin_normalized)[0])",
            "answer": "diff",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1400"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.1",
            "time": "2023-01-19",
            "description": "The code creates a palette dictionary with unique values in the hue column, then plots a filtered dataframe using seaborn relplot with different facets. It iterates through each facet and plots error bars for each hue group with correct color.",
            "code": "# create a palette dictionary for the unique values in the hue column\npalette = dict(zip(filtered['Mineral content (g/g fibre)'].unique(), [\"#fdae61\", \"#abd9e9\"]))\n\n# plot the filtered dataframe\ng = sns.relplot(data=filtered, x=\"Impeller speed (rpm)\", y=\"Result\", col=\"Media size\", row='Material', hue=\"Mineral content (g/g fibre)\", size=\"Media size\", sizes=(50, 200), palette=palette)\n\n# iterate through each facet of the facetgrid\nfor (material, media), ax in g.axes_dict.items():\n    # select the data for the facet\n    data = filtered[filtered['Material'].eq(material) & filtered['Media size'].eq(media)]\n    # select the data for each hue group\n    for group, selected in data.groupby('Mineral content (g/g fibre)'):\n        # plot the errorbar with the correct color for each group \n        ax.errorbar(data=selected, x=\"Impeller speed (rpm)\", y=\"Result\", yerr=\"ster\", marker=\"none\", color=palette[group], ls='none')",
            "masked_code": "# create a palette dictionary for the unique values in the hue column\npalette = dict(zip(filtered['Mineral content (g/g fibre)'].unique(), [\"#fdae61\", \"#abd9e9\"]))\n\n# plot the filtered dataframe\n<line_mask>\n\n# iterate through each facet of the facetgrid\nfor (material, media), ax in g.axes_dict.items():\n    # select the data for the facet\n    data = filtered[filtered['Material'].eq(material) & filtered['Media size'].eq(media)]\n    # select the data for each hue group\n    for group, selected in data.groupby('Mineral content (g/g fibre)'):\n        # plot the errorbar with the correct color for each group \n        ax.errorbar(data=selected, x=\"Impeller speed (rpm)\", y=\"Result\", yerr=\"ster\", marker=\"none\", color=palette[group], ls='none')",
            "masked_line": "g = sns.relplot(data=filtered, x=\"Impeller speed (rpm)\", y=\"Result\", col=\"Media size\", row='Material', hue=\"Mineral content (g/g fibre)\", size=\"Media size\", sizes=(50, 200), palette=palette)",
            "answer": "relplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1401"
        },
        {
            "dependency": "numpy",
            "version": "==1.24.0",
            "time": "2023-01-28",
            "description": "This code calculates the gradient of a given temperature matrix T in the x and y directions.",
            "code": "def hc_grad(T):\n    dTdx = np.zeros_like(T)\n    dTdy = np.zeros_like(T)\n\n    dTdx[1:-1, 1:-1] = (T[1:-1, 2:] - T[1:-1, :-2]) / 2\n    dTdy[1:-1, 1:-1] = (T[2:, 1:-1] - T[:-2, 1:-1]) / 2",
            "masked_code": "def hc_grad(T):\n    <line_mask>\n    dTdy = np.zeros_like(T)\n\n    dTdx[1:-1, 1:-1] = (T[1:-1, 2:] - T[1:-1, :-2]) / 2\n    dTdy[1:-1, 1:-1] = (T[2:, 1:-1] - T[:-2, 1:-1]) / 2",
            "masked_line": "dTdx = np.zeros_like(T)",
            "answer": "zeros_like",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1402"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.0",
            "time": "2023-12-06",
            "description": "The code generates a strip plot visualization using the data from a DataFrame (df) with x and y values. The plot is displayed on the second subplot (axarr[1]) with a native scale for the y-axis.",
            "code": "sns.stripplot(data=df, x='x', y='y', native_scale=True, ax=axarr[1])",
            "masked_code": "<line_mask>",
            "masked_line": "sns.stripplot(data=df, x='x', y='y', native_scale=True, ax=axarr[1])",
            "answer": "stripplot",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1403"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.2",
            "time": "2023-10-29",
            "description": "The code removes emojis from a given HTML string, then it reads the HTML table within the string and converts it into a pandas DataFrame. Finally, it prints the DataFrame.",
            "code": "import re\nfrom bs4 import BeautifulSoup\nimport pandas as pd\n\ndef remove_emojis(html):\n    soup = BeautifulSoup(html, 'html.parser')\n    emoji_pattern = re.compile(\"[\"\n                               \"\\U0001F600-\\U0001F64F\" \n                               \"\\U0001F300-\\U0001F5FF\"\n                               \"\\U0001F680-\\U0001F6FF\"  \n                               \"\\U0001F700-\\U0001F77F\"\n                               \"\\U0001F780-\\U0001F7FF\"\n                               \"\\U0001F800-\\U0001F8FF\"\n                               \"\\U0001F900-\\U0001F9FF\"\n                               \"\\U0001FA00-\\U0001FA6F\"\n                               \"\\U0001FA70-\\U0001FAFF\"\n                               \"\\U0001F004-\\U0001F0CF\"\n                               \"\\U0001F0D0-\\U0001F0FF\"\n                               \"\\U0001F10D-\\U0001F10F\"\n                               \"\\U0001F004-\\U0001F251\"\n                               \"]+\", flags=re.UNICODE)\n\n    return emoji_pattern.sub('', html)\n\ntable_tag = \"\"\"\n  \n    Company\n    Contact\n    Country\n  \n  \n    Notfall Software \n    Mario Mller\n    Germany\n  \n  \n    Centro comercial Plican\n    Francisco Villa \n    Mexico\n  \n\"\"\"\n\ntables = pd.read_html(remove_emojis(table_tag), encoding='utf-8')\ndf = tables[0]\nprint(df)",
            "masked_code": "import re\nfrom bs4 import BeautifulSoup\nimport pandas as pd\n\ndef remove_emojis(html):\n    soup = BeautifulSoup(html, 'html.parser')\n    emoji_pattern = re.compile(\"[\"\n                               \"\\U0001F600-\\U0001F64F\" \n                               \"\\U0001F300-\\U0001F5FF\"\n                               \"\\U0001F680-\\U0001F6FF\"  \n                               \"\\U0001F700-\\U0001F77F\"\n                               \"\\U0001F780-\\U0001F7FF\"\n                               \"\\U0001F800-\\U0001F8FF\"\n                               \"\\U0001F900-\\U0001F9FF\"\n                               \"\\U0001FA00-\\U0001FA6F\"\n                               \"\\U0001FA70-\\U0001FAFF\"\n                               \"\\U0001F004-\\U0001F0CF\"\n                               \"\\U0001F0D0-\\U0001F0FF\"\n                               \"\\U0001F10D-\\U0001F10F\"\n                               \"\\U0001F004-\\U0001F251\"\n                               \"]+\", flags=re.UNICODE)\n\n    return emoji_pattern.sub('', html)\n\ntable_tag = \"\"\"\n  \n    Company\n    Contact\n    Country\n  \n  \n    Notfall Software \n    Mario Mller\n    Germany\n  \n  \n    Centro comercial Plican\n    Francisco Villa \n    Mexico\n  \n\"\"\"\n\n<line_mask>\ndf = tables[0]\nprint(df)",
            "masked_line": "tables = pd.read_html(remove_emojis(table_tag), encoding='utf-8')",
            "answer": "read_html",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1404"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.1",
            "time": "2023-05-12",
            "description": "The code compares two DataFrames, df1 and df2, with different index types (idx1 and idx2) and then asserts that they are equal, which passes without any errors.",
            "code": "print(pd.__version__)\n# 2.0.1\n\nidx1 = pd.Index([0, 3, 6, 9, 12, 15, 18, 1, 4, 7, 10, 13, 16, 19, 2, 5, 8, 11, 14, 17], dtype='int64')\nidx2 = pd.RangeIndex(start=0, stop=20, step=1)\n\ndf1 = pd.DataFrame(index=idx1).sort_index()\ndf2 = pd.DataFrame(index=idx2)\n\nprint(df1.index)\n# Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], dtype='int64')\nprint(df2.index)\n# RangeIndex(start=0, stop=20, step=1)\n\npd.testing.assert_frame_equal(df1, df2) # no error",
            "masked_code": "print(pd.__version__)\n# 2.0.1\n\nidx1 = pd.Index([0, 3, 6, 9, 12, 15, 18, 1, 4, 7, 10, 13, 16, 19, 2, 5, 8, 11, 14, 17], dtype='int64')\nidx2 = pd.RangeIndex(start=0, stop=20, step=1)\n\n<line_mask>\ndf2 = pd.DataFrame(index=idx2)\n\nprint(df1.index)\n# Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], dtype='int64')\nprint(df2.index)\n# RangeIndex(start=0, stop=20, step=1)\n\npd.testing.assert_frame_equal(df1, df2) # no error",
            "masked_line": "df1 = pd.DataFrame(index=idx1).sort_index()",
            "answer": "sort_index",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1405"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2023-03-11",
            "description": "The code updates the weight of a layer in a neural network model during each epoch based on the current epoch number and a specified number of steps.",
            "code": "class update_callback(tf.keras.callbacks.Callback):\n    def on_epoch_begin(self, epoch, logs=None, steps=50):\n        update_value = tf.clip_by_value(\n            tf.cast((epoch + 1) / steps, dtype=tf.float32),\n            clip_value_min=tf.constant(0.0, dtype=tf.float32),\n            clip_value_max=tf.constant(1.0, dtype=tf.float32),\n        ) # change this to what you want\n        weighted_add_layer.weight.assign(update_value) #assign the update",
            "masked_code": "class update_callback(tf.keras.callbacks.Callback):\n    def on_epoch_begin(self, epoch, logs=None, steps=50):\n        update_value = tf.clip_by_value(\n            tf.cast((epoch + 1) / steps, dtype=tf.float32),\n            clip_value_min=tf.constant(0.0, dtype=tf.float32),\n            <line_mask>\n        ) # change this to what you want\n        weighted_add_layer.weight.assign(update_value) #assign the update",
            "masked_line": "clip_value_max=tf.constant(1.0, dtype=tf.float32),",
            "answer": "constant",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1406"
        },
        {
            "dependency": "PyAutoGUI",
            "version": "==0.9.41",
            "time": "2023-11-18",
            "description": "The code continuously searches for an image of an orange shape with a confidence level of 80%, and if found, prints \"I can see it\". If the image is not found, it prints \"I am unable to see it\" and then waits for 0.5 seconds before continuing the search.",
            "code": "while 1:\n    try:\n        pyautogui.locateOnScreen('orange shape.png', confidence=0.8)\n        print (\"I can see it\")\n    except pyautogui.ImageNotFoundException:\n        print(\"I am unable to see it\")\n    time.sleep(0.5)",
            "masked_code": "while 1:\n    try:\n        <line_mask>\n        print (\"I can see it\")\n    except pyautogui.ImageNotFoundException:\n        print(\"I am unable to see it\")\n    time.sleep(0.5)",
            "masked_line": "pyautogui.locateOnScreen('orange shape.png', confidence=0.8)",
            "answer": "locateOnScreen",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1407"
        },
        {
            "dependency": "discord.py",
            "version": ">=1.0.0",
            "time": "2020-06-08",
            "description": "This code retrieves the server object that the member belongs to and then finds a specific text channel named 'Channel name' within that server.",
            "code": "server = bot.get_server(member.server)\nchannel = discord.utils.get(server.text_channels, name='Channel name')",
            "masked_code": "server = bot.get_server(member.server)\n<line_mask>",
            "masked_line": "channel = discord.utils.get(server.text_channels, name='Channel name')",
            "answer": "get",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1408"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2022-08-26",
            "description": "The code reads data from an Excel file, groups the data by two columns ('result_by' and 'variable'), counts the occurrences of 'variable' within each group, and renames the column containing the count to 'count_col'.",
            "code": "df = pd.read_excel('testingfile.xlsx')\ndf_grouped = df.groupby(['result_by', 'variable']).agg({'variable':\"count\"}).rename(column={'variable':'count_col'})",
            "masked_code": "<line_mask>\ndf_grouped = df.groupby(['result_by', 'variable']).agg({'variable':\"count\"}).rename(column={'variable':'count_col'})",
            "masked_line": "df = pd.read_excel('testingfile.xlsx')",
            "answer": "read_excel",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1409"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.8.0",
            "time": "2023-07-31",
            "description": "This function estimates the rotation vectors (rvecs) and translation vectors (tvecs) for each detected marker corner based on the input detected corners, marker size, camera matrix, and camera distortion matrix. The function returns a list of rvecs, tvecs, and a corresponding list of \"trash\" values.",
            "code": "def my_estimatePoseSingleMarkers(corners, marker_size, mtx, distortion):\n    '''\n    This will estimate the rvec and tvec for each of the marker corners detected by:\n       corners, ids, rejectedImgPoints = detector.detectMarkers(image)\n    corners - is an array of detected corners for each detected marker in the image\n    marker_size - is the size of the detected markers\n    mtx - is the camera matrix\n    distortion - is the camera distortion matrix\n    RETURN list of rvecs, tvecs, and trash (so that it corresponds to the old estimatePoseSingleMarkers())\n    '''\n    marker_points = np.array([[-marker_size / 2, marker_size / 2, 0],\n                              [marker_size / 2, marker_size / 2, 0],\n                              [marker_size / 2, -marker_size / 2, 0],\n                              [-marker_size / 2, -marker_size / 2, 0]], dtype=np.float32)\n    trash = []\n    rvecs = []\n    tvecs = []\n    for c in corners:\n        nada, R, t = cv2.solvePnP(marker_points, c, mtx, distortion, False, cv2.SOLVEPNP_IPPE_SQUARE)\n        rvecs.append(R)\n        tvecs.append(t)\n        trash.append(nada)\n    return rvecs, tvecs, trash",
            "masked_code": "def my_estimatePoseSingleMarkers(corners, marker_size, mtx, distortion):\n    '''\n    This will estimate the rvec and tvec for each of the marker corners detected by:\n       corners, ids, rejectedImgPoints = detector.detectMarkers(image)\n    corners - is an array of detected corners for each detected marker in the image\n    marker_size - is the size of the detected markers\n    mtx - is the camera matrix\n    distortion - is the camera distortion matrix\n    RETURN list of rvecs, tvecs, and trash (so that it corresponds to the old estimatePoseSingleMarkers())\n    '''\n    marker_points = np.array([[-marker_size / 2, marker_size / 2, 0],\n                              [marker_size / 2, marker_size / 2, 0],\n                              [marker_size / 2, -marker_size / 2, 0],\n                              [-marker_size / 2, -marker_size / 2, 0]], dtype=np.float32)\n    trash = []\n    rvecs = []\n    tvecs = []\n    for c in corners:\n        <line_mask>\n        rvecs.append(R)\n        tvecs.append(t)\n        trash.append(nada)\n    return rvecs, tvecs, trash",
            "masked_line": "nada, R, t = cv2.solvePnP(marker_points, c, mtx, distortion, False, cv2.SOLVEPNP_IPPE_SQUARE)",
            "answer": "solvePnP",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1410"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-23",
            "description": "This code replaces any zeros in the tensor x_std with ones.",
            "code": "x_std = tf.where(tf.equal(x_std, 0), tf.ones_like(x_std), x_std)",
            "masked_code": "<line_mask>",
            "masked_line": "x_std = tf.where(tf.equal(x_std, 0), tf.ones_like(x_std), x_std)",
            "answer": "where",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1411"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-06-18",
            "description": "The code defines a Batch Normalization layer in a neural network model, with options to scale, center, and make the layer trainable.",
            "code": "tf.keras.layers.BatchNormalization(\n    name=\"BatchNorm\",\n    scale=True,\n    center=True,\n    trainable=True,\n)(tensor)",
            "masked_code": "<line_mask>\n    name=\"BatchNorm\",\n    scale=True,\n    center=True,\n    trainable=True,\n)(tensor)",
            "masked_line": "tf.keras.layers.BatchNormalization(",
            "answer": "layers",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1412"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3",
            "time": "2020-08-25",
            "description": "The code preprocesses an image dataset by converting the pixel values of the images to floating point numbers between 0 and 1.",
            "code": "def process(image,label):\n    image = tf.cast(image/255. ,tf.float32)\n    return image,label\n\nds = tf.keras.preprocessing.image_dataset_from_directory(IMAGE_DIR)\nds = ds.map(process)",
            "masked_code": "def process(image,label):\n    <line_mask>\n    return image,label\n\nds = tf.keras.preprocessing.image_dataset_from_directory(IMAGE_DIR)\nds = ds.map(process)",
            "masked_line": "image = tf.cast(image/255. ,tf.float32)",
            "answer": "cast",
            "granularity": "line",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_line_1413"
        }
    ]
}